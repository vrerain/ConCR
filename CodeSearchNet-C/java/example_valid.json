{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/CharSource.java", "func_name": "CharSource.copyTo", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Copies the contents of this source to the given sink.\n\n@return the number of characters copied\n@throws IOException if an I/O error occurs while reading from this source or writing to {@code\nsink}", "docstring_tokens": ["Copies", "the", "contents", "of", "this", "source", "to", "the", "given", "sink", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/CharSource.java#L208-L222", "partition": "valid", "up_fun_num": 8, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.Ascii;", "import com.google.common.base.Optional;", "import com.google.common.base.Splitter;", "import com.google.common.collect.AbstractIterator;", "import com.google.common.collect.ImmutableList;", "import com.google.common.collect.Lists;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.io.BufferedReader;", "import java.io.IOException;", "import java.io.InputStream;", "import java.io.Reader;", "import java.io.StringReader;", "import java.io.Writer;", "import java.nio.charset.Charset;", "import java.util.Iterator;", "import java.util.List;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public abstract class CharSource\n", "    public ByteSource asByteSource(Charset charset)\n", "    public abstract Reader openStream() throws IOException;\n", "    public BufferedReader openBufferedStream() throws IOException\n", "    public Optional<Long> lengthIfKnown()\n", "    public long length() throws IOException\n", "    private long countBySkipping(Reader reader) throws IOException\n", "    public long copyTo(Appendable appendable) throws IOException\n", "    public String read() throws IOException\n", "    public String readFirstLine() throws IOException\n", "    public ImmutableList<String> readLines() throws IOException\n", "    public <T> T readLines(LineProcessor<T> processor) throws IOException\n", "    public boolean isEmpty() throws IOException\n", "    public static CharSource concat(Iterable<? extends CharSource> sources)\n", "    public static CharSource concat(Iterator<? extends CharSource> sources)\n", "    public static CharSource concat(CharSource... sources)\n", "    public static CharSource wrap(CharSequence charSequence)\n", "    public static CharSource empty()\n"], "context": "/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Ascii;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.AbstractIterator;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A readable source of characters, such as a text file. Unlike a {@link Reader}, a {@code\n * CharSource} is not an open, stateful stream of characters that can be read and closed. Instead,\n * it is an immutable <i>supplier</i> of {@code Reader} instances.\n *\n * <p>{@code CharSource} provides two kinds of methods:\n *\n * <ul>\n *   <li><b>Methods that return a reader:</b> These methods should return a <i>new</i>, independent\n *       instance each time they are called. The caller is responsible for ensuring that the\n *       returned reader is closed.\n *   <li><b>Convenience methods:</b> These are implementations of common operations that are\n *       typically implemented by opening a reader using one of the methods in the first category,\n *       doing something and finally closing the reader that was opened.\n * </ul>\n *\n * <p>Several methods in this class, such as {@link #readLines()}, break the contents of the source\n * into lines. Like {@link BufferedReader}, these methods break lines on any of {@code \\n}, {@code\n * \\r} or {@code \\r\\n}, do not include the line separator in each line and do not consider there to\n * be an empty line at the end if the contents are terminated with a line separator.\n *\n * <p>Any {@link ByteSource} containing text encoded with a specific {@linkplain Charset character\n * encoding} may be viewed as a {@code CharSource} using {@link ByteSource#asCharSource(Charset)}.\n *\n * @since 14.0\n * @author Colin Decker\n */\n@GwtIncompatible\npublic abstract class CharSource\n{\n\n    /** Constructor for use by subclasses. */\n    protected CharSource() {}\n\n    /**\n     * Returns a {@link ByteSource} view of this char source that encodes chars read from this source\n     * as bytes using the given {@link Charset}.\n     *\n     * <p>If {@link ByteSource#asCharSource} is called on the returned source with the same charset,\n     * the default implementation of this method will ensure that the original {@code CharSource} is\n     * returned, rather than round-trip encoding. Subclasses that override this method should behave\n     * the same way.\n     *\n     * @since 20.0\n     */\n    @Beta\n    public ByteSource asByteSource(Charset charset)\n    {\n        return new AsByteSource(charset);\n    }\n\n    /**\n     * Opens a new {@link Reader} for reading from this source. This method returns a new, independent\n     * reader each time it is called.\n     *\n     * <p>The caller is responsible for ensuring that the returned reader is closed.\n     *\n     * @throws IOException if an I/O error occurs while opening the reader\n     */\n    public abstract Reader openStream() throws IOException;\n\n    /**\n     * Opens a new {@link BufferedReader} for reading from this source. This method returns a new,\n     * independent reader each time it is called.\n     *\n     * <p>The caller is responsible for ensuring that the returned reader is closed.\n     *\n     * @throws IOException if an I/O error occurs while of opening the reader\n     */\n    public BufferedReader openBufferedStream() throws IOException\n    {\n        Reader reader = openStream();\n        return (reader instanceof BufferedReader)\n               ? (BufferedReader) reader\n               : new BufferedReader(reader);\n    }\n\n    /**\n     * Returns the size of this source in chars, if the size can be easily determined without actually\n     * opening the data stream.\n     *\n     * <p>The default implementation returns {@link Optional#absent}. Some sources, such as a {@code\n     * CharSequence}, may return a non-absent value. Note that in such cases, it is <i>possible</i>\n     * that this method will return a different number of chars than would be returned by reading all\n     * of the chars.\n     *\n     * <p>Additionally, for mutable sources such as {@code StringBuilder}s, a subsequent read may\n     * return a different number of chars if the contents are changed.\n     *\n     * @since 19.0\n     */\n    @Beta\n    public Optional<Long> lengthIfKnown()\n    {\n        return Optional.absent();\n    }\n\n    /**\n     * Returns the length of this source in chars, even if doing so requires opening and traversing an\n     * entire stream. To avoid a potentially expensive operation, see {@link #lengthIfKnown}.\n     *\n     * <p>The default implementation calls {@link #lengthIfKnown} and returns the value if present. If\n     * absent, it will fall back to a heavyweight operation that will open a stream, {@link\n     * Reader#skip(long) skip} to the end of the stream, and return the total number of chars that\n     * were skipped.\n     *\n     * <p>Note that for sources that implement {@link #lengthIfKnown} to provide a more efficient\n     * implementation, it is <i>possible</i> that this method will return a different number of chars\n     * than would be returned by reading all of the chars.\n     *\n     * <p>In either case, for mutable sources such as files, a subsequent read may return a different\n     * number of chars if the contents are changed.\n     *\n     * @throws IOException if an I/O error occurs while reading the length of this source\n     * @since 19.0\n     */\n    @Beta\n    public long length() throws IOException\n    {\n        Optional<Long> lengthIfKnown = lengthIfKnown();\n        if (lengthIfKnown.isPresent())\n        {\n            return lengthIfKnown.get();\n        }\n\n        Closer closer = Closer.create();\n        try\n        {\n            Reader reader = closer.register(openStream());\n            return countBySkipping(reader);\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    private long countBySkipping(Reader reader) throws IOException\n    {\n        long count = 0;\n        long read;\n        while ((read = reader.skip(Long.MAX_VALUE)) != 0)\n        {\n            count += read;\n        }\n        return count;\n    }\n\n    /**\n     * Appends the contents of this source to the given {@link Appendable} (such as a {@link Writer}).\n     * Does not close {@code appendable} if it is {@code Closeable}.\n     *\n     * @return the number of characters copied\n     * @throws IOException if an I/O error occurs while reading from this source or writing to {@code\n     *     appendable}\n     */\n    @CanIgnoreReturnValue\n    public long copyTo(Appendable appendable) throws IOException\n    {\n        checkNotNull(appendable);\n\n        Closer closer = Closer.create();\n        try\n        {\n            Reader reader = closer.register(openStream());\n            return CharStreams.copy(reader, appendable);\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Copies the contents of this source to the given sink.\n     *\n     * @return the number of characters copied\n     * @throws IOException if an I/O error occurs while reading from this source or writing to {@code\n     *     sink}\n     */\n\n    /**\n     * Reads the contents of this source as a string.\n     *\n     * @throws IOException if an I/O error occurs while reading from this source\n     */\n    public String read() throws IOException\n    {\n        Closer closer = Closer.create();\n        try\n        {\n            Reader reader = closer.register(openStream());\n            return CharStreams.toString(reader);\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Reads the first line of this source as a string. Returns {@code null} if this source is empty.\n     *\n     * <p>Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of\n     * text that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code\n     * \\n}. If the source's content does not end in a line termination sequence, it is treated as if\n     * it does.\n     *\n     * @throws IOException if an I/O error occurs while reading from this source\n     */\n    @NullableDecl\n    public String readFirstLine() throws IOException\n    {\n        Closer closer = Closer.create();\n        try\n        {\n            BufferedReader reader = closer.register(openBufferedStream());\n            return reader.readLine();\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Reads all the lines of this source as a list of strings. The returned list will be empty if\n     * this source is empty.\n     *\n     * <p>Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of\n     * text that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code\n     * \\n}. If the source's content does not end in a line termination sequence, it is treated as if\n     * it does.\n     *\n     * @throws IOException if an I/O error occurs while reading from this source\n     */\n    public ImmutableList<String> readLines() throws IOException\n    {\n        Closer closer = Closer.create();\n        try\n        {\n            BufferedReader reader = closer.register(openBufferedStream());\n            List<String> result = Lists.newArrayList();\n            String line;\n            while ((line = reader.readLine()) != null)\n            {\n                result.add(line);\n            }\n            return ImmutableList.copyOf(result);\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Reads lines of text from this source, processing each line as it is read using the given {@link\n     * LineProcessor processor}. Stops when all lines have been processed or the processor returns\n     * {@code false} and returns the result produced by the processor.\n     *\n     * <p>Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of\n     * text that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code\n     * \\n}. If the source's content does not end in a line termination sequence, it is treated as if\n     * it does.\n     *\n     * @throws IOException if an I/O error occurs while reading from this source or if {@code\n     *     processor} throws an {@code IOException}\n     * @since 16.0\n     */\n    @Beta\n    @CanIgnoreReturnValue // some processors won't return a useful result\n    public <T> T readLines(LineProcessor<T> processor) throws IOException\n    {\n        checkNotNull(processor);\n\n        Closer closer = Closer.create();\n        try\n        {\n            Reader reader = closer.register(openStream());\n            return CharStreams.readLines(reader, processor);\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Returns whether the source has zero chars. The default implementation first checks {@link\n     * #lengthIfKnown}, returning true if it's known to be zero and false if it's known to be\n     * non-zero. If the length is not known, it falls back to opening a stream and checking for EOF.\n     *\n     * <p>Note that, in cases where {@code lengthIfKnown} returns zero, it is <i>possible</i> that\n     * chars are actually available for reading. This means that a source may return {@code true} from\n     * {@code isEmpty()} despite having readable content.\n     *\n     * @throws IOException if an I/O error occurs\n     * @since 15.0\n     */\n    public boolean isEmpty() throws IOException\n    {\n        Optional<Long> lengthIfKnown = lengthIfKnown();\n        if (lengthIfKnown.isPresent())\n        {\n            return lengthIfKnown.get() == 0L;\n        }\n        Closer closer = Closer.create();\n        try\n        {\n            Reader reader = closer.register(openStream());\n            return reader.read() == -1;\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Concatenates multiple {@link CharSource} instances into a single source. Streams returned from\n     * the source will contain the concatenated data from the streams of the underlying sources.\n     *\n     * <p>Only one underlying stream will be open at a time. Closing the concatenated stream will\n     * close the open underlying stream.\n     *\n     * @param sources the sources to concatenate\n     * @return a {@code CharSource} containing the concatenated data\n     * @since 15.0\n     */\n    public static CharSource concat(Iterable<? extends CharSource> sources)\n    {\n        return new ConcatenatedCharSource(sources);\n    }\n\n    /**\n     * Concatenates multiple {@link CharSource} instances into a single source. Streams returned from\n     * the source will contain the concatenated data from the streams of the underlying sources.\n     *\n     * <p>Only one underlying stream will be open at a time. Closing the concatenated stream will\n     * close the open underlying stream.\n     *\n     * <p>Note: The input {@code Iterator} will be copied to an {@code ImmutableList} when this method\n     * is called. This will fail if the iterator is infinite and may cause problems if the iterator\n     * eagerly fetches data for each source when iterated (rather than producing sources that only\n     * load data through their streams). Prefer using the {@link #concat(Iterable)} overload if\n     * possible.\n     *\n     * @param sources the sources to concatenate\n     * @return a {@code CharSource} containing the concatenated data\n     * @throws NullPointerException if any of {@code sources} is {@code null}\n     * @since 15.0\n     */\n    public static CharSource concat(Iterator<? extends CharSource> sources)\n    {\n        return concat(ImmutableList.copyOf(sources));\n    }\n\n    /**\n     * Concatenates multiple {@link CharSource} instances into a single source. Streams returned from\n     * the source will contain the concatenated data from the streams of the underlying sources.\n     *\n     * <p>Only one underlying stream will be open at a time. Closing the concatenated stream will\n     * close the open underlying stream.\n     *\n     * @param sources the sources to concatenate\n     * @return a {@code CharSource} containing the concatenated data\n     * @throws NullPointerException if any of {@code sources} is {@code null}\n     * @since 15.0\n     */\n    public static CharSource concat(CharSource... sources)\n    {\n        return concat(ImmutableList.copyOf(sources));\n    }\n\n    /**\n     * Returns a view of the given character sequence as a {@link CharSource}. The behavior of the\n     * returned {@code CharSource} and any {@code Reader} instances created by it is unspecified if\n     * the {@code charSequence} is mutated while it is being read, so don't do that.\n     *\n     * @since 15.0 (since 14.0 as {@code CharStreams.asCharSource(String)})\n     */\n    public static CharSource wrap(CharSequence charSequence)\n    {\n        return charSequence instanceof String\n               ? new StringCharSource((String) charSequence)\n               : new CharSequenceCharSource(charSequence);\n    }\n\n    /**\n     * Returns an immutable {@link CharSource} that contains no characters.\n     *\n     * @since 15.0\n     */\n    public static CharSource empty()\n    {\n        return EmptyCharSource.INSTANCE;\n    }\n\n    /** A byte source that reads chars from this source and encodes them as bytes using a charset. */\n    private final class AsByteSource extends ByteSource\n    {\n\n        final Charset charset;\n\n        AsByteSource(Charset charset)\n        {\n            this.charset = checkNotNull(charset);\n        }\n\n        @Override\n        public CharSource asCharSource(Charset charset)\n        {\n            if (charset.equals(this.charset))\n            {\n                return CharSource.this;\n            }\n            return super.asCharSource(charset);\n        }\n\n        @Override\n        public InputStream openStream() throws IOException\n        {\n            return new ReaderInputStream(CharSource.this.openStream(), charset, 8192);\n        }\n\n        @Override\n        public String toString()\n        {\n            return CharSource.this.toString() + \".asByteSource(\" + charset + \")\";\n        }\n    }\n\n    private static class CharSequenceCharSource extends CharSource\n    {\n\n        private static final Splitter LINE_SPLITTER = Splitter.onPattern(\"\\r\\n|\\n|\\r\");\n\n        protected final CharSequence seq;\n\n        protected CharSequenceCharSource(CharSequence seq)\n        {\n            this.seq = checkNotNull(seq);\n        }\n\n        @Override\n        public Reader openStream()\n        {\n            return new CharSequenceReader(seq);\n        }\n\n        @Override\n        public String read()\n        {\n            return seq.toString();\n        }\n\n        @Override\n        public boolean isEmpty()\n        {\n            return seq.length() == 0;\n        }\n\n        @Override\n        public long length()\n        {\n            return seq.length();\n        }\n\n        @Override\n        public Optional<Long> lengthIfKnown()\n        {\n            return Optional.of((long) seq.length());\n        }\n\n        /**\n         * Returns an iterator over the lines in the string. If the string ends in a newline, a final\n         * empty string is not included, to match the behavior of BufferedReader/LineReader.readLine().\n         */\n        private Iterator<String> linesIterator()\n        {\n            return new AbstractIterator<String>()\n            {\n                Iterator<String> lines = LINE_SPLITTER.split(seq).iterator();\n\n                @Override\n                protected String computeNext()\n                {\n                    if (lines.hasNext())\n                    {\n                        String next = lines.next();\n                        // skip last line if it's empty\n                        if (lines.hasNext() || !next.isEmpty())\n                        {\n                            return next;\n                        }\n                    }\n                    return endOfData();\n                }\n            };\n        }\n\n        @Override\n        public String readFirstLine()\n        {\n            Iterator<String> lines = linesIterator();\n            return lines.hasNext() ? lines.next() : null;\n        }\n\n        @Override\n        public ImmutableList<String> readLines()\n        {\n            return ImmutableList.copyOf(linesIterator());\n        }\n\n        @Override\n        public <T> T readLines(LineProcessor<T> processor) throws IOException\n        {\n            Iterator<String> lines = linesIterator();\n            while (lines.hasNext())\n            {\n                if (!processor.processLine(lines.next()))\n                {\n                    break;\n                }\n            }\n            return processor.getResult();\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"CharSource.wrap(\" + Ascii.truncate(seq, 30, \"...\") + \")\";\n        }\n    }\n\n    /**\n     * Subclass specialized for string instances.\n     *\n     * <p>Since Strings are immutable and built into the jdk we can optimize some operations\n     *\n     * <ul>\n     *   <li>use {@link StringReader} instead of {@link CharSequenceReader}. It is faster since it can\n     *       use {@link String#getChars(int, int, char[], int)} instead of copying characters one by\n     *       one with {@link CharSequence#charAt(int)}.\n     *   <li>use {@link Appendable#append(CharSequence)} in {@link #copyTo(Appendable)} and {@link\n     *       #copyTo(CharSink)}. We know this is correct since strings are immutable and so the length\n     *       can't change, and it is faster because many writers and appendables are optimized for\n     *       appending string instances.\n     * </ul>\n     */\n    private static class StringCharSource extends CharSequenceCharSource\n    {\n        protected StringCharSource(String seq)\n        {\n            super(seq);\n        }\n\n        @Override\n        public Reader openStream()\n        {\n            return new StringReader((String) seq);\n        }\n\n        @Override\n        public long copyTo(Appendable appendable) throws IOException\n        {\n            appendable.append(seq);\n            return seq.length();\n        }\n\n        @Override\n        public long copyTo(CharSink sink) throws IOException\n        {\n            checkNotNull(sink);\n            Closer closer = Closer.create();\n            try\n            {\n                Writer writer = closer.register(sink.openStream());\n                writer.write((String) seq);\n                return seq.length();\n            }\n            catch (Throwable e)\n            {\n                throw closer.rethrow(e);\n            }\n            finally\n            {\n                closer.close();\n            }\n        }\n    }\n\n    private static final class EmptyCharSource extends StringCharSource\n    {\n\n        private static final EmptyCharSource INSTANCE = new EmptyCharSource();\n\n        private EmptyCharSource()\n        {\n            super(\"\");\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"CharSource.empty()\";\n        }\n    }\n\n    private static final class ConcatenatedCharSource extends CharSource\n    {\n\n        private final Iterable<? extends CharSource> sources;\n\n        ConcatenatedCharSource(Iterable<? extends CharSource> sources)\n        {\n            this.sources = checkNotNull(sources);\n        }\n\n        @Override\n        public Reader openStream() throws IOException\n        {\n            return new MultiReader(sources.iterator());\n        }\n\n        @Override\n        public boolean isEmpty() throws IOException\n        {\n            for (CharSource source : sources)\n            {\n                if (!source.isEmpty())\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        @Override\n        public Optional<Long> lengthIfKnown()\n        {\n            long result = 0L;\n            for (CharSource source : sources)\n            {\n                Optional<Long> lengthIfKnown = source.lengthIfKnown();\n                if (!lengthIfKnown.isPresent())\n                {\n                    return Optional.absent();\n                }\n                result += lengthIfKnown.get();\n            }\n            return Optional.of(result);\n        }\n\n        @Override\n        public long length() throws IOException\n        {\n            long result = 0L;\n            for (CharSource source : sources)\n            {\n                result += source.length();\n            }\n            return result;\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"CharSource.concat(\" + sources + \")\";\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/CharSource.java", "func_name": "CharSource.read", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Reads the contents of this source as a string.\n\n@throws IOException if an I/O error occurs while reading from this source", "docstring_tokens": ["Reads", "the", "contents", "of", "this", "source", "as", "a", "string", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/CharSource.java#L229-L239", "partition": "valid", "up_fun_num": 10, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.Ascii;", "import com.google.common.base.Optional;", "import com.google.common.base.Splitter;", "import com.google.common.collect.AbstractIterator;", "import com.google.common.collect.ImmutableList;", "import com.google.common.collect.Lists;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.io.BufferedReader;", "import java.io.IOException;", "import java.io.InputStream;", "import java.io.Reader;", "import java.io.StringReader;", "import java.io.Writer;", "import java.nio.charset.Charset;", "import java.util.Iterator;", "import java.util.List;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public abstract class CharSource\n", "    public ByteSource asByteSource(Charset charset)\n", "    public abstract Reader openStream() throws IOException;\n", "    public BufferedReader openBufferedStream() throws IOException\n", "    public Optional<Long> lengthIfKnown()\n", "    public long length() throws IOException\n", "    private long countBySkipping(Reader reader) throws IOException\n", "    public long copyTo(Appendable appendable) throws IOException\n", "    public long copyTo(CharSink sink) throws IOException\n", "    public String readFirstLine() throws IOException\n", "    public ImmutableList<String> readLines() throws IOException\n", "    public <T> T readLines(LineProcessor<T> processor) throws IOException\n", "    public boolean isEmpty() throws IOException\n", "    public static CharSource concat(Iterable<? extends CharSource> sources)\n", "    public static CharSource concat(Iterator<? extends CharSource> sources)\n", "    public static CharSource concat(CharSource... sources)\n", "    public static CharSource wrap(CharSequence charSequence)\n", "    public static CharSource empty()\n"], "context": "/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Ascii;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.AbstractIterator;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A readable source of characters, such as a text file. Unlike a {@link Reader}, a {@code\n * CharSource} is not an open, stateful stream of characters that can be read and closed. Instead,\n * it is an immutable <i>supplier</i> of {@code Reader} instances.\n *\n * <p>{@code CharSource} provides two kinds of methods:\n *\n * <ul>\n *   <li><b>Methods that return a reader:</b> These methods should return a <i>new</i>, independent\n *       instance each time they are called. The caller is responsible for ensuring that the\n *       returned reader is closed.\n *   <li><b>Convenience methods:</b> These are implementations of common operations that are\n *       typically implemented by opening a reader using one of the methods in the first category,\n *       doing something and finally closing the reader that was opened.\n * </ul>\n *\n * <p>Several methods in this class, such as {@link #readLines()}, break the contents of the source\n * into lines. Like {@link BufferedReader}, these methods break lines on any of {@code \\n}, {@code\n * \\r} or {@code \\r\\n}, do not include the line separator in each line and do not consider there to\n * be an empty line at the end if the contents are terminated with a line separator.\n *\n * <p>Any {@link ByteSource} containing text encoded with a specific {@linkplain Charset character\n * encoding} may be viewed as a {@code CharSource} using {@link ByteSource#asCharSource(Charset)}.\n *\n * @since 14.0\n * @author Colin Decker\n */\n@GwtIncompatible\npublic abstract class CharSource\n{\n\n    /** Constructor for use by subclasses. */\n    protected CharSource() {}\n\n    /**\n     * Returns a {@link ByteSource} view of this char source that encodes chars read from this source\n     * as bytes using the given {@link Charset}.\n     *\n     * <p>If {@link ByteSource#asCharSource} is called on the returned source with the same charset,\n     * the default implementation of this method will ensure that the original {@code CharSource} is\n     * returned, rather than round-trip encoding. Subclasses that override this method should behave\n     * the same way.\n     *\n     * @since 20.0\n     */\n    @Beta\n    public ByteSource asByteSource(Charset charset)\n    {\n        return new AsByteSource(charset);\n    }\n\n    /**\n     * Opens a new {@link Reader} for reading from this source. This method returns a new, independent\n     * reader each time it is called.\n     *\n     * <p>The caller is responsible for ensuring that the returned reader is closed.\n     *\n     * @throws IOException if an I/O error occurs while opening the reader\n     */\n    public abstract Reader openStream() throws IOException;\n\n    /**\n     * Opens a new {@link BufferedReader} for reading from this source. This method returns a new,\n     * independent reader each time it is called.\n     *\n     * <p>The caller is responsible for ensuring that the returned reader is closed.\n     *\n     * @throws IOException if an I/O error occurs while of opening the reader\n     */\n    public BufferedReader openBufferedStream() throws IOException\n    {\n        Reader reader = openStream();\n        return (reader instanceof BufferedReader)\n               ? (BufferedReader) reader\n               : new BufferedReader(reader);\n    }\n\n    /**\n     * Returns the size of this source in chars, if the size can be easily determined without actually\n     * opening the data stream.\n     *\n     * <p>The default implementation returns {@link Optional#absent}. Some sources, such as a {@code\n     * CharSequence}, may return a non-absent value. Note that in such cases, it is <i>possible</i>\n     * that this method will return a different number of chars than would be returned by reading all\n     * of the chars.\n     *\n     * <p>Additionally, for mutable sources such as {@code StringBuilder}s, a subsequent read may\n     * return a different number of chars if the contents are changed.\n     *\n     * @since 19.0\n     */\n    @Beta\n    public Optional<Long> lengthIfKnown()\n    {\n        return Optional.absent();\n    }\n\n    /**\n     * Returns the length of this source in chars, even if doing so requires opening and traversing an\n     * entire stream. To avoid a potentially expensive operation, see {@link #lengthIfKnown}.\n     *\n     * <p>The default implementation calls {@link #lengthIfKnown} and returns the value if present. If\n     * absent, it will fall back to a heavyweight operation that will open a stream, {@link\n     * Reader#skip(long) skip} to the end of the stream, and return the total number of chars that\n     * were skipped.\n     *\n     * <p>Note that for sources that implement {@link #lengthIfKnown} to provide a more efficient\n     * implementation, it is <i>possible</i> that this method will return a different number of chars\n     * than would be returned by reading all of the chars.\n     *\n     * <p>In either case, for mutable sources such as files, a subsequent read may return a different\n     * number of chars if the contents are changed.\n     *\n     * @throws IOException if an I/O error occurs while reading the length of this source\n     * @since 19.0\n     */\n    @Beta\n    public long length() throws IOException\n    {\n        Optional<Long> lengthIfKnown = lengthIfKnown();\n        if (lengthIfKnown.isPresent())\n        {\n            return lengthIfKnown.get();\n        }\n\n        Closer closer = Closer.create();\n        try\n        {\n            Reader reader = closer.register(openStream());\n            return countBySkipping(reader);\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    private long countBySkipping(Reader reader) throws IOException\n    {\n        long count = 0;\n        long read;\n        while ((read = reader.skip(Long.MAX_VALUE)) != 0)\n        {\n            count += read;\n        }\n        return count;\n    }\n\n    /**\n     * Appends the contents of this source to the given {@link Appendable} (such as a {@link Writer}).\n     * Does not close {@code appendable} if it is {@code Closeable}.\n     *\n     * @return the number of characters copied\n     * @throws IOException if an I/O error occurs while reading from this source or writing to {@code\n     *     appendable}\n     */\n    @CanIgnoreReturnValue\n    public long copyTo(Appendable appendable) throws IOException\n    {\n        checkNotNull(appendable);\n\n        Closer closer = Closer.create();\n        try\n        {\n            Reader reader = closer.register(openStream());\n            return CharStreams.copy(reader, appendable);\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Copies the contents of this source to the given sink.\n     *\n     * @return the number of characters copied\n     * @throws IOException if an I/O error occurs while reading from this source or writing to {@code\n     *     sink}\n     */\n    @CanIgnoreReturnValue\n    public long copyTo(CharSink sink) throws IOException\n    {\n        checkNotNull(sink);\n\n        Closer closer = Closer.create();\n        try\n        {\n            Reader reader = closer.register(openStream());\n            Writer writer = closer.register(sink.openStream());\n            return CharStreams.copy(reader, writer);\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Reads the contents of this source as a string.\n     *\n     * @throws IOException if an I/O error occurs while reading from this source\n     */\n\n    /**\n     * Reads the first line of this source as a string. Returns {@code null} if this source is empty.\n     *\n     * <p>Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of\n     * text that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code\n     * \\n}. If the source's content does not end in a line termination sequence, it is treated as if\n     * it does.\n     *\n     * @throws IOException if an I/O error occurs while reading from this source\n     */\n    @NullableDecl\n    public String readFirstLine() throws IOException\n    {\n        Closer closer = Closer.create();\n        try\n        {\n            BufferedReader reader = closer.register(openBufferedStream());\n            return reader.readLine();\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Reads all the lines of this source as a list of strings. The returned list will be empty if\n     * this source is empty.\n     *\n     * <p>Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of\n     * text that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code\n     * \\n}. If the source's content does not end in a line termination sequence, it is treated as if\n     * it does.\n     *\n     * @throws IOException if an I/O error occurs while reading from this source\n     */\n    public ImmutableList<String> readLines() throws IOException\n    {\n        Closer closer = Closer.create();\n        try\n        {\n            BufferedReader reader = closer.register(openBufferedStream());\n            List<String> result = Lists.newArrayList();\n            String line;\n            while ((line = reader.readLine()) != null)\n            {\n                result.add(line);\n            }\n            return ImmutableList.copyOf(result);\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Reads lines of text from this source, processing each line as it is read using the given {@link\n     * LineProcessor processor}. Stops when all lines have been processed or the processor returns\n     * {@code false} and returns the result produced by the processor.\n     *\n     * <p>Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of\n     * text that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code\n     * \\n}. If the source's content does not end in a line termination sequence, it is treated as if\n     * it does.\n     *\n     * @throws IOException if an I/O error occurs while reading from this source or if {@code\n     *     processor} throws an {@code IOException}\n     * @since 16.0\n     */\n    @Beta\n    @CanIgnoreReturnValue // some processors won't return a useful result\n    public <T> T readLines(LineProcessor<T> processor) throws IOException\n    {\n        checkNotNull(processor);\n\n        Closer closer = Closer.create();\n        try\n        {\n            Reader reader = closer.register(openStream());\n            return CharStreams.readLines(reader, processor);\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Returns whether the source has zero chars. The default implementation first checks {@link\n     * #lengthIfKnown}, returning true if it's known to be zero and false if it's known to be\n     * non-zero. If the length is not known, it falls back to opening a stream and checking for EOF.\n     *\n     * <p>Note that, in cases where {@code lengthIfKnown} returns zero, it is <i>possible</i> that\n     * chars are actually available for reading. This means that a source may return {@code true} from\n     * {@code isEmpty()} despite having readable content.\n     *\n     * @throws IOException if an I/O error occurs\n     * @since 15.0\n     */\n    public boolean isEmpty() throws IOException\n    {\n        Optional<Long> lengthIfKnown = lengthIfKnown();\n        if (lengthIfKnown.isPresent())\n        {\n            return lengthIfKnown.get() == 0L;\n        }\n        Closer closer = Closer.create();\n        try\n        {\n            Reader reader = closer.register(openStream());\n            return reader.read() == -1;\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Concatenates multiple {@link CharSource} instances into a single source. Streams returned from\n     * the source will contain the concatenated data from the streams of the underlying sources.\n     *\n     * <p>Only one underlying stream will be open at a time. Closing the concatenated stream will\n     * close the open underlying stream.\n     *\n     * @param sources the sources to concatenate\n     * @return a {@code CharSource} containing the concatenated data\n     * @since 15.0\n     */\n    public static CharSource concat(Iterable<? extends CharSource> sources)\n    {\n        return new ConcatenatedCharSource(sources);\n    }\n\n    /**\n     * Concatenates multiple {@link CharSource} instances into a single source. Streams returned from\n     * the source will contain the concatenated data from the streams of the underlying sources.\n     *\n     * <p>Only one underlying stream will be open at a time. Closing the concatenated stream will\n     * close the open underlying stream.\n     *\n     * <p>Note: The input {@code Iterator} will be copied to an {@code ImmutableList} when this method\n     * is called. This will fail if the iterator is infinite and may cause problems if the iterator\n     * eagerly fetches data for each source when iterated (rather than producing sources that only\n     * load data through their streams). Prefer using the {@link #concat(Iterable)} overload if\n     * possible.\n     *\n     * @param sources the sources to concatenate\n     * @return a {@code CharSource} containing the concatenated data\n     * @throws NullPointerException if any of {@code sources} is {@code null}\n     * @since 15.0\n     */\n    public static CharSource concat(Iterator<? extends CharSource> sources)\n    {\n        return concat(ImmutableList.copyOf(sources));\n    }\n\n    /**\n     * Concatenates multiple {@link CharSource} instances into a single source. Streams returned from\n     * the source will contain the concatenated data from the streams of the underlying sources.\n     *\n     * <p>Only one underlying stream will be open at a time. Closing the concatenated stream will\n     * close the open underlying stream.\n     *\n     * @param sources the sources to concatenate\n     * @return a {@code CharSource} containing the concatenated data\n     * @throws NullPointerException if any of {@code sources} is {@code null}\n     * @since 15.0\n     */\n    public static CharSource concat(CharSource... sources)\n    {\n        return concat(ImmutableList.copyOf(sources));\n    }\n\n    /**\n     * Returns a view of the given character sequence as a {@link CharSource}. The behavior of the\n     * returned {@code CharSource} and any {@code Reader} instances created by it is unspecified if\n     * the {@code charSequence} is mutated while it is being read, so don't do that.\n     *\n     * @since 15.0 (since 14.0 as {@code CharStreams.asCharSource(String)})\n     */\n    public static CharSource wrap(CharSequence charSequence)\n    {\n        return charSequence instanceof String\n               ? new StringCharSource((String) charSequence)\n               : new CharSequenceCharSource(charSequence);\n    }\n\n    /**\n     * Returns an immutable {@link CharSource} that contains no characters.\n     *\n     * @since 15.0\n     */\n    public static CharSource empty()\n    {\n        return EmptyCharSource.INSTANCE;\n    }\n\n    /** A byte source that reads chars from this source and encodes them as bytes using a charset. */\n    private final class AsByteSource extends ByteSource\n    {\n\n        final Charset charset;\n\n        AsByteSource(Charset charset)\n        {\n            this.charset = checkNotNull(charset);\n        }\n\n        @Override\n        public CharSource asCharSource(Charset charset)\n        {\n            if (charset.equals(this.charset))\n            {\n                return CharSource.this;\n            }\n            return super.asCharSource(charset);\n        }\n\n        @Override\n        public InputStream openStream() throws IOException\n        {\n            return new ReaderInputStream(CharSource.this.openStream(), charset, 8192);\n        }\n\n        @Override\n        public String toString()\n        {\n            return CharSource.this.toString() + \".asByteSource(\" + charset + \")\";\n        }\n    }\n\n    private static class CharSequenceCharSource extends CharSource\n    {\n\n        private static final Splitter LINE_SPLITTER = Splitter.onPattern(\"\\r\\n|\\n|\\r\");\n\n        protected final CharSequence seq;\n\n        protected CharSequenceCharSource(CharSequence seq)\n        {\n            this.seq = checkNotNull(seq);\n        }\n\n        @Override\n        public Reader openStream()\n        {\n            return new CharSequenceReader(seq);\n        }\n\n        @Override\n        public String read()\n        {\n            return seq.toString();\n        }\n\n        @Override\n        public boolean isEmpty()\n        {\n            return seq.length() == 0;\n        }\n\n        @Override\n        public long length()\n        {\n            return seq.length();\n        }\n\n        @Override\n        public Optional<Long> lengthIfKnown()\n        {\n            return Optional.of((long) seq.length());\n        }\n\n        /**\n         * Returns an iterator over the lines in the string. If the string ends in a newline, a final\n         * empty string is not included, to match the behavior of BufferedReader/LineReader.readLine().\n         */\n        private Iterator<String> linesIterator()\n        {\n            return new AbstractIterator<String>()\n            {\n                Iterator<String> lines = LINE_SPLITTER.split(seq).iterator();\n\n                @Override\n                protected String computeNext()\n                {\n                    if (lines.hasNext())\n                    {\n                        String next = lines.next();\n                        // skip last line if it's empty\n                        if (lines.hasNext() || !next.isEmpty())\n                        {\n                            return next;\n                        }\n                    }\n                    return endOfData();\n                }\n            };\n        }\n\n        @Override\n        public String readFirstLine()\n        {\n            Iterator<String> lines = linesIterator();\n            return lines.hasNext() ? lines.next() : null;\n        }\n\n        @Override\n        public ImmutableList<String> readLines()\n        {\n            return ImmutableList.copyOf(linesIterator());\n        }\n\n        @Override\n        public <T> T readLines(LineProcessor<T> processor) throws IOException\n        {\n            Iterator<String> lines = linesIterator();\n            while (lines.hasNext())\n            {\n                if (!processor.processLine(lines.next()))\n                {\n                    break;\n                }\n            }\n            return processor.getResult();\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"CharSource.wrap(\" + Ascii.truncate(seq, 30, \"...\") + \")\";\n        }\n    }\n\n    /**\n     * Subclass specialized for string instances.\n     *\n     * <p>Since Strings are immutable and built into the jdk we can optimize some operations\n     *\n     * <ul>\n     *   <li>use {@link StringReader} instead of {@link CharSequenceReader}. It is faster since it can\n     *       use {@link String#getChars(int, int, char[], int)} instead of copying characters one by\n     *       one with {@link CharSequence#charAt(int)}.\n     *   <li>use {@link Appendable#append(CharSequence)} in {@link #copyTo(Appendable)} and {@link\n     *       #copyTo(CharSink)}. We know this is correct since strings are immutable and so the length\n     *       can't change, and it is faster because many writers and appendables are optimized for\n     *       appending string instances.\n     * </ul>\n     */\n    private static class StringCharSource extends CharSequenceCharSource\n    {\n        protected StringCharSource(String seq)\n        {\n            super(seq);\n        }\n\n        @Override\n        public Reader openStream()\n        {\n            return new StringReader((String) seq);\n        }\n\n        @Override\n        public long copyTo(Appendable appendable) throws IOException\n        {\n            appendable.append(seq);\n            return seq.length();\n        }\n\n        @Override\n        public long copyTo(CharSink sink) throws IOException\n        {\n            checkNotNull(sink);\n            Closer closer = Closer.create();\n            try\n            {\n                Writer writer = closer.register(sink.openStream());\n                writer.write((String) seq);\n                return seq.length();\n            }\n            catch (Throwable e)\n            {\n                throw closer.rethrow(e);\n            }\n            finally\n            {\n                closer.close();\n            }\n        }\n    }\n\n    private static final class EmptyCharSource extends StringCharSource\n    {\n\n        private static final EmptyCharSource INSTANCE = new EmptyCharSource();\n\n        private EmptyCharSource()\n        {\n            super(\"\");\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"CharSource.empty()\";\n        }\n    }\n\n    private static final class ConcatenatedCharSource extends CharSource\n    {\n\n        private final Iterable<? extends CharSource> sources;\n\n        ConcatenatedCharSource(Iterable<? extends CharSource> sources)\n        {\n            this.sources = checkNotNull(sources);\n        }\n\n        @Override\n        public Reader openStream() throws IOException\n        {\n            return new MultiReader(sources.iterator());\n        }\n\n        @Override\n        public boolean isEmpty() throws IOException\n        {\n            for (CharSource source : sources)\n            {\n                if (!source.isEmpty())\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        @Override\n        public Optional<Long> lengthIfKnown()\n        {\n            long result = 0L;\n            for (CharSource source : sources)\n            {\n                Optional<Long> lengthIfKnown = source.lengthIfKnown();\n                if (!lengthIfKnown.isPresent())\n                {\n                    return Optional.absent();\n                }\n                result += lengthIfKnown.get();\n            }\n            return Optional.of(result);\n        }\n\n        @Override\n        public long length() throws IOException\n        {\n            long result = 0L;\n            for (CharSource source : sources)\n            {\n                result += source.length();\n            }\n            return result;\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"CharSource.concat(\" + sources + \")\";\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/CharSource.java", "func_name": "CharSource.readLines", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Reads all the lines of this source as a list of strings. The returned list will be empty if\nthis source is empty.\n\n<p>Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of\ntext that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code\n\\n}. If the source's content does not end in a line termination sequence, it is treated as if\nit does.\n\n@throws IOException if an I/O error occurs while reading from this source", "docstring_tokens": ["Reads", "all", "the", "lines", "of", "this", "source", "as", "a", "list", "of", "strings", ".", "The", "returned", "list", "will", "be", "empty", "if", "this", "source", "is", "empty", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/CharSource.java#L275-L290", "partition": "valid", "up_fun_num": 12, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.Ascii;", "import com.google.common.base.Optional;", "import com.google.common.base.Splitter;", "import com.google.common.collect.AbstractIterator;", "import com.google.common.collect.ImmutableList;", "import com.google.common.collect.Lists;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.io.BufferedReader;", "import java.io.IOException;", "import java.io.InputStream;", "import java.io.Reader;", "import java.io.StringReader;", "import java.io.Writer;", "import java.nio.charset.Charset;", "import java.util.Iterator;", "import java.util.List;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public abstract class CharSource\n", "    public ByteSource asByteSource(Charset charset)\n", "    public abstract Reader openStream() throws IOException;\n", "    public BufferedReader openBufferedStream() throws IOException\n", "    public Optional<Long> lengthIfKnown()\n", "    public long length() throws IOException\n", "    private long countBySkipping(Reader reader) throws IOException\n", "    public long copyTo(Appendable appendable) throws IOException\n", "    public long copyTo(CharSink sink) throws IOException\n", "    public String read() throws IOException\n", "    public String readFirstLine() throws IOException\n", "    public <T> T readLines(LineProcessor<T> processor) throws IOException\n", "    public boolean isEmpty() throws IOException\n", "    public static CharSource concat(Iterable<? extends CharSource> sources)\n", "    public static CharSource concat(Iterator<? extends CharSource> sources)\n", "    public static CharSource concat(CharSource... sources)\n", "    public static CharSource wrap(CharSequence charSequence)\n", "    public static CharSource empty()\n"], "context": "/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Ascii;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.AbstractIterator;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A readable source of characters, such as a text file. Unlike a {@link Reader}, a {@code\n * CharSource} is not an open, stateful stream of characters that can be read and closed. Instead,\n * it is an immutable <i>supplier</i> of {@code Reader} instances.\n *\n * <p>{@code CharSource} provides two kinds of methods:\n *\n * <ul>\n *   <li><b>Methods that return a reader:</b> These methods should return a <i>new</i>, independent\n *       instance each time they are called. The caller is responsible for ensuring that the\n *       returned reader is closed.\n *   <li><b>Convenience methods:</b> These are implementations of common operations that are\n *       typically implemented by opening a reader using one of the methods in the first category,\n *       doing something and finally closing the reader that was opened.\n * </ul>\n *\n * <p>Several methods in this class, such as {@link #readLines()}, break the contents of the source\n * into lines. Like {@link BufferedReader}, these methods break lines on any of {@code \\n}, {@code\n * \\r} or {@code \\r\\n}, do not include the line separator in each line and do not consider there to\n * be an empty line at the end if the contents are terminated with a line separator.\n *\n * <p>Any {@link ByteSource} containing text encoded with a specific {@linkplain Charset character\n * encoding} may be viewed as a {@code CharSource} using {@link ByteSource#asCharSource(Charset)}.\n *\n * @since 14.0\n * @author Colin Decker\n */\n@GwtIncompatible\npublic abstract class CharSource\n{\n\n    /** Constructor for use by subclasses. */\n    protected CharSource() {}\n\n    /**\n     * Returns a {@link ByteSource} view of this char source that encodes chars read from this source\n     * as bytes using the given {@link Charset}.\n     *\n     * <p>If {@link ByteSource#asCharSource} is called on the returned source with the same charset,\n     * the default implementation of this method will ensure that the original {@code CharSource} is\n     * returned, rather than round-trip encoding. Subclasses that override this method should behave\n     * the same way.\n     *\n     * @since 20.0\n     */\n    @Beta\n    public ByteSource asByteSource(Charset charset)\n    {\n        return new AsByteSource(charset);\n    }\n\n    /**\n     * Opens a new {@link Reader} for reading from this source. This method returns a new, independent\n     * reader each time it is called.\n     *\n     * <p>The caller is responsible for ensuring that the returned reader is closed.\n     *\n     * @throws IOException if an I/O error occurs while opening the reader\n     */\n    public abstract Reader openStream() throws IOException;\n\n    /**\n     * Opens a new {@link BufferedReader} for reading from this source. This method returns a new,\n     * independent reader each time it is called.\n     *\n     * <p>The caller is responsible for ensuring that the returned reader is closed.\n     *\n     * @throws IOException if an I/O error occurs while of opening the reader\n     */\n    public BufferedReader openBufferedStream() throws IOException\n    {\n        Reader reader = openStream();\n        return (reader instanceof BufferedReader)\n               ? (BufferedReader) reader\n               : new BufferedReader(reader);\n    }\n\n    /**\n     * Returns the size of this source in chars, if the size can be easily determined without actually\n     * opening the data stream.\n     *\n     * <p>The default implementation returns {@link Optional#absent}. Some sources, such as a {@code\n     * CharSequence}, may return a non-absent value. Note that in such cases, it is <i>possible</i>\n     * that this method will return a different number of chars than would be returned by reading all\n     * of the chars.\n     *\n     * <p>Additionally, for mutable sources such as {@code StringBuilder}s, a subsequent read may\n     * return a different number of chars if the contents are changed.\n     *\n     * @since 19.0\n     */\n    @Beta\n    public Optional<Long> lengthIfKnown()\n    {\n        return Optional.absent();\n    }\n\n    /**\n     * Returns the length of this source in chars, even if doing so requires opening and traversing an\n     * entire stream. To avoid a potentially expensive operation, see {@link #lengthIfKnown}.\n     *\n     * <p>The default implementation calls {@link #lengthIfKnown} and returns the value if present. If\n     * absent, it will fall back to a heavyweight operation that will open a stream, {@link\n     * Reader#skip(long) skip} to the end of the stream, and return the total number of chars that\n     * were skipped.\n     *\n     * <p>Note that for sources that implement {@link #lengthIfKnown} to provide a more efficient\n     * implementation, it is <i>possible</i> that this method will return a different number of chars\n     * than would be returned by reading all of the chars.\n     *\n     * <p>In either case, for mutable sources such as files, a subsequent read may return a different\n     * number of chars if the contents are changed.\n     *\n     * @throws IOException if an I/O error occurs while reading the length of this source\n     * @since 19.0\n     */\n    @Beta\n    public long length() throws IOException\n    {\n        Optional<Long> lengthIfKnown = lengthIfKnown();\n        if (lengthIfKnown.isPresent())\n        {\n            return lengthIfKnown.get();\n        }\n\n        Closer closer = Closer.create();\n        try\n        {\n            Reader reader = closer.register(openStream());\n            return countBySkipping(reader);\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    private long countBySkipping(Reader reader) throws IOException\n    {\n        long count = 0;\n        long read;\n        while ((read = reader.skip(Long.MAX_VALUE)) != 0)\n        {\n            count += read;\n        }\n        return count;\n    }\n\n    /**\n     * Appends the contents of this source to the given {@link Appendable} (such as a {@link Writer}).\n     * Does not close {@code appendable} if it is {@code Closeable}.\n     *\n     * @return the number of characters copied\n     * @throws IOException if an I/O error occurs while reading from this source or writing to {@code\n     *     appendable}\n     */\n    @CanIgnoreReturnValue\n    public long copyTo(Appendable appendable) throws IOException\n    {\n        checkNotNull(appendable);\n\n        Closer closer = Closer.create();\n        try\n        {\n            Reader reader = closer.register(openStream());\n            return CharStreams.copy(reader, appendable);\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Copies the contents of this source to the given sink.\n     *\n     * @return the number of characters copied\n     * @throws IOException if an I/O error occurs while reading from this source or writing to {@code\n     *     sink}\n     */\n    @CanIgnoreReturnValue\n    public long copyTo(CharSink sink) throws IOException\n    {\n        checkNotNull(sink);\n\n        Closer closer = Closer.create();\n        try\n        {\n            Reader reader = closer.register(openStream());\n            Writer writer = closer.register(sink.openStream());\n            return CharStreams.copy(reader, writer);\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Reads the contents of this source as a string.\n     *\n     * @throws IOException if an I/O error occurs while reading from this source\n     */\n    public String read() throws IOException\n    {\n        Closer closer = Closer.create();\n        try\n        {\n            Reader reader = closer.register(openStream());\n            return CharStreams.toString(reader);\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Reads the first line of this source as a string. Returns {@code null} if this source is empty.\n     *\n     * <p>Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of\n     * text that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code\n     * \\n}. If the source's content does not end in a line termination sequence, it is treated as if\n     * it does.\n     *\n     * @throws IOException if an I/O error occurs while reading from this source\n     */\n    @NullableDecl\n    public String readFirstLine() throws IOException\n    {\n        Closer closer = Closer.create();\n        try\n        {\n            BufferedReader reader = closer.register(openBufferedStream());\n            return reader.readLine();\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Reads all the lines of this source as a list of strings. The returned list will be empty if\n     * this source is empty.\n     *\n     * <p>Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of\n     * text that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code\n     * \\n}. If the source's content does not end in a line termination sequence, it is treated as if\n     * it does.\n     *\n     * @throws IOException if an I/O error occurs while reading from this source\n     */\n\n    /**\n     * Reads lines of text from this source, processing each line as it is read using the given {@link\n     * LineProcessor processor}. Stops when all lines have been processed or the processor returns\n     * {@code false} and returns the result produced by the processor.\n     *\n     * <p>Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of\n     * text that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code\n     * \\n}. If the source's content does not end in a line termination sequence, it is treated as if\n     * it does.\n     *\n     * @throws IOException if an I/O error occurs while reading from this source or if {@code\n     *     processor} throws an {@code IOException}\n     * @since 16.0\n     */\n    @Beta\n    @CanIgnoreReturnValue // some processors won't return a useful result\n    public <T> T readLines(LineProcessor<T> processor) throws IOException\n    {\n        checkNotNull(processor);\n\n        Closer closer = Closer.create();\n        try\n        {\n            Reader reader = closer.register(openStream());\n            return CharStreams.readLines(reader, processor);\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Returns whether the source has zero chars. The default implementation first checks {@link\n     * #lengthIfKnown}, returning true if it's known to be zero and false if it's known to be\n     * non-zero. If the length is not known, it falls back to opening a stream and checking for EOF.\n     *\n     * <p>Note that, in cases where {@code lengthIfKnown} returns zero, it is <i>possible</i> that\n     * chars are actually available for reading. This means that a source may return {@code true} from\n     * {@code isEmpty()} despite having readable content.\n     *\n     * @throws IOException if an I/O error occurs\n     * @since 15.0\n     */\n    public boolean isEmpty() throws IOException\n    {\n        Optional<Long> lengthIfKnown = lengthIfKnown();\n        if (lengthIfKnown.isPresent())\n        {\n            return lengthIfKnown.get() == 0L;\n        }\n        Closer closer = Closer.create();\n        try\n        {\n            Reader reader = closer.register(openStream());\n            return reader.read() == -1;\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Concatenates multiple {@link CharSource} instances into a single source. Streams returned from\n     * the source will contain the concatenated data from the streams of the underlying sources.\n     *\n     * <p>Only one underlying stream will be open at a time. Closing the concatenated stream will\n     * close the open underlying stream.\n     *\n     * @param sources the sources to concatenate\n     * @return a {@code CharSource} containing the concatenated data\n     * @since 15.0\n     */\n    public static CharSource concat(Iterable<? extends CharSource> sources)\n    {\n        return new ConcatenatedCharSource(sources);\n    }\n\n    /**\n     * Concatenates multiple {@link CharSource} instances into a single source. Streams returned from\n     * the source will contain the concatenated data from the streams of the underlying sources.\n     *\n     * <p>Only one underlying stream will be open at a time. Closing the concatenated stream will\n     * close the open underlying stream.\n     *\n     * <p>Note: The input {@code Iterator} will be copied to an {@code ImmutableList} when this method\n     * is called. This will fail if the iterator is infinite and may cause problems if the iterator\n     * eagerly fetches data for each source when iterated (rather than producing sources that only\n     * load data through their streams). Prefer using the {@link #concat(Iterable)} overload if\n     * possible.\n     *\n     * @param sources the sources to concatenate\n     * @return a {@code CharSource} containing the concatenated data\n     * @throws NullPointerException if any of {@code sources} is {@code null}\n     * @since 15.0\n     */\n    public static CharSource concat(Iterator<? extends CharSource> sources)\n    {\n        return concat(ImmutableList.copyOf(sources));\n    }\n\n    /**\n     * Concatenates multiple {@link CharSource} instances into a single source. Streams returned from\n     * the source will contain the concatenated data from the streams of the underlying sources.\n     *\n     * <p>Only one underlying stream will be open at a time. Closing the concatenated stream will\n     * close the open underlying stream.\n     *\n     * @param sources the sources to concatenate\n     * @return a {@code CharSource} containing the concatenated data\n     * @throws NullPointerException if any of {@code sources} is {@code null}\n     * @since 15.0\n     */\n    public static CharSource concat(CharSource... sources)\n    {\n        return concat(ImmutableList.copyOf(sources));\n    }\n\n    /**\n     * Returns a view of the given character sequence as a {@link CharSource}. The behavior of the\n     * returned {@code CharSource} and any {@code Reader} instances created by it is unspecified if\n     * the {@code charSequence} is mutated while it is being read, so don't do that.\n     *\n     * @since 15.0 (since 14.0 as {@code CharStreams.asCharSource(String)})\n     */\n    public static CharSource wrap(CharSequence charSequence)\n    {\n        return charSequence instanceof String\n               ? new StringCharSource((String) charSequence)\n               : new CharSequenceCharSource(charSequence);\n    }\n\n    /**\n     * Returns an immutable {@link CharSource} that contains no characters.\n     *\n     * @since 15.0\n     */\n    public static CharSource empty()\n    {\n        return EmptyCharSource.INSTANCE;\n    }\n\n    /** A byte source that reads chars from this source and encodes them as bytes using a charset. */\n    private final class AsByteSource extends ByteSource\n    {\n\n        final Charset charset;\n\n        AsByteSource(Charset charset)\n        {\n            this.charset = checkNotNull(charset);\n        }\n\n        @Override\n        public CharSource asCharSource(Charset charset)\n        {\n            if (charset.equals(this.charset))\n            {\n                return CharSource.this;\n            }\n            return super.asCharSource(charset);\n        }\n\n        @Override\n        public InputStream openStream() throws IOException\n        {\n            return new ReaderInputStream(CharSource.this.openStream(), charset, 8192);\n        }\n\n        @Override\n        public String toString()\n        {\n            return CharSource.this.toString() + \".asByteSource(\" + charset + \")\";\n        }\n    }\n\n    private static class CharSequenceCharSource extends CharSource\n    {\n\n        private static final Splitter LINE_SPLITTER = Splitter.onPattern(\"\\r\\n|\\n|\\r\");\n\n        protected final CharSequence seq;\n\n        protected CharSequenceCharSource(CharSequence seq)\n        {\n            this.seq = checkNotNull(seq);\n        }\n\n        @Override\n        public Reader openStream()\n        {\n            return new CharSequenceReader(seq);\n        }\n\n        @Override\n        public String read()\n        {\n            return seq.toString();\n        }\n\n        @Override\n        public boolean isEmpty()\n        {\n            return seq.length() == 0;\n        }\n\n        @Override\n        public long length()\n        {\n            return seq.length();\n        }\n\n        @Override\n        public Optional<Long> lengthIfKnown()\n        {\n            return Optional.of((long) seq.length());\n        }\n\n        /**\n         * Returns an iterator over the lines in the string. If the string ends in a newline, a final\n         * empty string is not included, to match the behavior of BufferedReader/LineReader.readLine().\n         */\n        private Iterator<String> linesIterator()\n        {\n            return new AbstractIterator<String>()\n            {\n                Iterator<String> lines = LINE_SPLITTER.split(seq).iterator();\n\n                @Override\n                protected String computeNext()\n                {\n                    if (lines.hasNext())\n                    {\n                        String next = lines.next();\n                        // skip last line if it's empty\n                        if (lines.hasNext() || !next.isEmpty())\n                        {\n                            return next;\n                        }\n                    }\n                    return endOfData();\n                }\n            };\n        }\n\n        @Override\n        public String readFirstLine()\n        {\n            Iterator<String> lines = linesIterator();\n            return lines.hasNext() ? lines.next() : null;\n        }\n\n        @Override\n        public ImmutableList<String> readLines()\n        {\n            return ImmutableList.copyOf(linesIterator());\n        }\n\n        @Override\n        public <T> T readLines(LineProcessor<T> processor) throws IOException\n        {\n            Iterator<String> lines = linesIterator();\n            while (lines.hasNext())\n            {\n                if (!processor.processLine(lines.next()))\n                {\n                    break;\n                }\n            }\n            return processor.getResult();\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"CharSource.wrap(\" + Ascii.truncate(seq, 30, \"...\") + \")\";\n        }\n    }\n\n    /**\n     * Subclass specialized for string instances.\n     *\n     * <p>Since Strings are immutable and built into the jdk we can optimize some operations\n     *\n     * <ul>\n     *   <li>use {@link StringReader} instead of {@link CharSequenceReader}. It is faster since it can\n     *       use {@link String#getChars(int, int, char[], int)} instead of copying characters one by\n     *       one with {@link CharSequence#charAt(int)}.\n     *   <li>use {@link Appendable#append(CharSequence)} in {@link #copyTo(Appendable)} and {@link\n     *       #copyTo(CharSink)}. We know this is correct since strings are immutable and so the length\n     *       can't change, and it is faster because many writers and appendables are optimized for\n     *       appending string instances.\n     * </ul>\n     */\n    private static class StringCharSource extends CharSequenceCharSource\n    {\n        protected StringCharSource(String seq)\n        {\n            super(seq);\n        }\n\n        @Override\n        public Reader openStream()\n        {\n            return new StringReader((String) seq);\n        }\n\n        @Override\n        public long copyTo(Appendable appendable) throws IOException\n        {\n            appendable.append(seq);\n            return seq.length();\n        }\n\n        @Override\n        public long copyTo(CharSink sink) throws IOException\n        {\n            checkNotNull(sink);\n            Closer closer = Closer.create();\n            try\n            {\n                Writer writer = closer.register(sink.openStream());\n                writer.write((String) seq);\n                return seq.length();\n            }\n            catch (Throwable e)\n            {\n                throw closer.rethrow(e);\n            }\n            finally\n            {\n                closer.close();\n            }\n        }\n    }\n\n    private static final class EmptyCharSource extends StringCharSource\n    {\n\n        private static final EmptyCharSource INSTANCE = new EmptyCharSource();\n\n        private EmptyCharSource()\n        {\n            super(\"\");\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"CharSource.empty()\";\n        }\n    }\n\n    private static final class ConcatenatedCharSource extends CharSource\n    {\n\n        private final Iterable<? extends CharSource> sources;\n\n        ConcatenatedCharSource(Iterable<? extends CharSource> sources)\n        {\n            this.sources = checkNotNull(sources);\n        }\n\n        @Override\n        public Reader openStream() throws IOException\n        {\n            return new MultiReader(sources.iterator());\n        }\n\n        @Override\n        public boolean isEmpty() throws IOException\n        {\n            for (CharSource source : sources)\n            {\n                if (!source.isEmpty())\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        @Override\n        public Optional<Long> lengthIfKnown()\n        {\n            long result = 0L;\n            for (CharSource source : sources)\n            {\n                Optional<Long> lengthIfKnown = source.lengthIfKnown();\n                if (!lengthIfKnown.isPresent())\n                {\n                    return Optional.absent();\n                }\n                result += lengthIfKnown.get();\n            }\n            return Optional.of(result);\n        }\n\n        @Override\n        public long length() throws IOException\n        {\n            long result = 0L;\n            for (CharSource source : sources)\n            {\n                result += source.length();\n            }\n            return result;\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"CharSource.concat(\" + sources + \")\";\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/ReaderInputStream.java", "func_name": "ReaderInputStream.read", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "buffer when possible.", "docstring_tokens": ["buffer", "when", "possible", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/ReaderInputStream.java#L124-L186", "partition": "valid", "up_fun_num": 3, "levels": [0, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.base.Preconditions.checkPositionIndexes;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.primitives.UnsignedBytes;", "import java.io.IOException;", "import java.io.InputStream;", "import java.io.Reader;", "import java.nio.Buffer;", "import java.nio.ByteBuffer;", "import java.nio.CharBuffer;", "import java.nio.charset.Charset;", "import java.nio.charset.CharsetEncoder;", "import java.nio.charset.CoderResult;", "import java.nio.charset.CodingErrorAction;", "import java.util.Arrays;"], "function": ["final class ReaderInputStream extends InputStream\n", "    public void close() throws IOException\n", "    public int read() throws IOException\n", "    private static CharBuffer grow(CharBuffer buf)\n", "    private void readMoreChars() throws IOException\n", "    private static int availableCapacity(Buffer buffer)\n", "    private void startDraining(boolean overflow)\n", "    private int drain(byte[] b, int off, int len)\n"], "context": "/*\n * Copyright (C) 2015 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkPositionIndexes;\n\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.primitives.UnsignedBytes;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.nio.Buffer;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.CoderResult;\nimport java.nio.charset.CodingErrorAction;\nimport java.util.Arrays;\n\n/**\n * An {@link InputStream} that converts characters from a {@link Reader} into bytes using an\n * arbitrary Charset.\n *\n * <p>This is an alternative to copying the data to an {@code OutputStream} via a {@code Writer},\n * which is necessarily blocking. By implementing an {@code InputStream} it allows consumers to\n * \"pull\" as much data as they can handle, which is more convenient when dealing with flow\n * controlled, async APIs.\n *\n * @author Chris Nokleberg\n */\n@GwtIncompatible\nfinal class ReaderInputStream extends InputStream\n{\n    private final Reader reader;\n    private final CharsetEncoder encoder;\n    private final byte[] singleByte = new byte[1];\n\n    /**\n     * charBuffer holds characters that have been read from the Reader but not encoded yet. The buffer\n     * is perpetually \"flipped\" (unencoded characters between position and limit).\n     */\n    private CharBuffer charBuffer;\n\n    /**\n     * byteBuffer holds encoded characters that have not yet been sent to the caller of the input\n     * stream. When encoding it is \"unflipped\" (encoded bytes between 0 and position) and when\n     * draining it is flipped (undrained bytes between position and limit).\n     */\n    private ByteBuffer byteBuffer;\n\n    /** Whether we've finished reading the reader. */\n    private boolean endOfInput;\n    /** Whether we're copying encoded bytes to the caller's buffer. */\n    private boolean draining;\n    /** Whether we've successfully flushed the encoder. */\n    private boolean doneFlushing;\n\n    /**\n     * Creates a new input stream that will encode the characters from {@code reader} into bytes using\n     * the given character set. Malformed input and unmappable characters will be replaced.\n     *\n     * @param reader input source\n     * @param charset character set used for encoding chars to bytes\n     * @param bufferSize size of internal input and output buffers\n     * @throws IllegalArgumentException if bufferSize is non-positive\n     */\n    ReaderInputStream(Reader reader, Charset charset, int bufferSize)\n    {\n        this(\n            reader,\n            charset\n            .newEncoder()\n            .onMalformedInput(CodingErrorAction.REPLACE)\n            .onUnmappableCharacter(CodingErrorAction.REPLACE),\n            bufferSize);\n    }\n\n    /**\n     * Creates a new input stream that will encode the characters from {@code reader} into bytes using\n     * the given character set encoder.\n     *\n     * @param reader input source\n     * @param encoder character set encoder used for encoding chars to bytes\n     * @param bufferSize size of internal input and output buffers\n     * @throws IllegalArgumentException if bufferSize is non-positive\n     */\n    ReaderInputStream(Reader reader, CharsetEncoder encoder, int bufferSize)\n    {\n        this.reader = checkNotNull(reader);\n        this.encoder = checkNotNull(encoder);\n        checkArgument(bufferSize > 0, \"bufferSize must be positive: %s\", bufferSize);\n        encoder.reset();\n\n        charBuffer = CharBuffer.allocate(bufferSize);\n        charBuffer.flip();\n\n        byteBuffer = ByteBuffer.allocate(bufferSize);\n    }\n\n    @Override\n    public void close() throws IOException\n    {\n        reader.close();\n    }\n\n    @Override\n    public int read() throws IOException\n    {\n        return (read(singleByte) == 1) ? UnsignedBytes.toInt(singleByte[0]) : -1;\n    }\n\n    // TODO(chrisn): Consider trying to encode/flush directly to the argument byte\n    // buffer when possible.\n\n    /** Returns a new CharBuffer identical to buf, except twice the capacity. */\n    private static CharBuffer grow(CharBuffer buf)\n    {\n        char[] copy = Arrays.copyOf(buf.array(), buf.capacity() * 2);\n        CharBuffer bigger = CharBuffer.wrap(copy);\n        bigger.position(buf.position());\n        bigger.limit(buf.limit());\n        return bigger;\n    }\n\n    /** Handle the case of underflow caused by needing more input characters. */\n    private void readMoreChars() throws IOException\n    {\n        // Possibilities:\n        // 1) array has space available on right hand side (between limit and capacity)\n        // 2) array has space available on left hand side (before position)\n        // 3) array has no space available\n        //\n        // In case 2 we shift the existing chars to the left, and in case 3 we create a bigger\n        // array, then they both become case 1.\n\n        if (availableCapacity(charBuffer) == 0)\n        {\n            if (charBuffer.position() > 0)\n            {\n                // (2) There is room in the buffer. Move existing bytes to the beginning.\n                charBuffer.compact().flip();\n            }\n            else\n            {\n                // (3) Entire buffer is full, need bigger buffer.\n                charBuffer = grow(charBuffer);\n            }\n        }\n\n        // (1) Read more characters into free space at end of array.\n        int limit = charBuffer.limit();\n        int numChars = reader.read(charBuffer.array(), limit, availableCapacity(charBuffer));\n        if (numChars == -1)\n        {\n            endOfInput = true;\n        }\n        else\n        {\n            charBuffer.limit(limit + numChars);\n        }\n    }\n\n    /** Returns the number of elements between the limit and capacity. */\n    private static int availableCapacity(Buffer buffer)\n    {\n        return buffer.capacity() - buffer.limit();\n    }\n\n    /**\n     * Flips the buffer output buffer so we can start reading bytes from it. If we are starting to\n     * drain because there was overflow, and there aren't actually any characters to drain, then the\n     * overflow must be due to a small output buffer.\n     */\n    private void startDraining(boolean overflow)\n    {\n        byteBuffer.flip();\n        if (overflow && byteBuffer.remaining() == 0)\n        {\n            byteBuffer = ByteBuffer.allocate(byteBuffer.capacity() * 2);\n        }\n        else\n        {\n            draining = true;\n        }\n    }\n\n    /**\n     * Copy as much of the byte buffer into the output array as possible, returning the (positive)\n     * number of characters copied.\n     */\n    private int drain(byte[] b, int off, int len)\n    {\n        int remaining = Math.min(len, byteBuffer.remaining());\n        byteBuffer.get(b, off, remaining);\n        return remaining;\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/ReaderInputStream.java", "func_name": "ReaderInputStream.grow", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns a new CharBuffer identical to buf, except twice the capacity.", "docstring_tokens": ["Returns", "a", "new", "CharBuffer", "identical", "to", "buf", "except", "twice", "the", "capacity", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/ReaderInputStream.java#L189-L195", "partition": "valid", "up_fun_num": 5, "levels": [0, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.base.Preconditions.checkPositionIndexes;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.primitives.UnsignedBytes;", "import java.io.IOException;", "import java.io.InputStream;", "import java.io.Reader;", "import java.nio.Buffer;", "import java.nio.ByteBuffer;", "import java.nio.CharBuffer;", "import java.nio.charset.Charset;", "import java.nio.charset.CharsetEncoder;", "import java.nio.charset.CoderResult;", "import java.nio.charset.CodingErrorAction;", "import java.util.Arrays;"], "function": ["final class ReaderInputStream extends InputStream\n", "    public void close() throws IOException\n", "    public int read() throws IOException\n", "    public int read(byte[] b, int off, int len) throws IOException\n", "    private void readMoreChars() throws IOException\n", "    private static int availableCapacity(Buffer buffer)\n", "    private void startDraining(boolean overflow)\n", "    private int drain(byte[] b, int off, int len)\n"], "context": "/*\n * Copyright (C) 2015 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkPositionIndexes;\n\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.primitives.UnsignedBytes;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.nio.Buffer;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.CoderResult;\nimport java.nio.charset.CodingErrorAction;\nimport java.util.Arrays;\n\n/**\n * An {@link InputStream} that converts characters from a {@link Reader} into bytes using an\n * arbitrary Charset.\n *\n * <p>This is an alternative to copying the data to an {@code OutputStream} via a {@code Writer},\n * which is necessarily blocking. By implementing an {@code InputStream} it allows consumers to\n * \"pull\" as much data as they can handle, which is more convenient when dealing with flow\n * controlled, async APIs.\n *\n * @author Chris Nokleberg\n */\n@GwtIncompatible\nfinal class ReaderInputStream extends InputStream\n{\n    private final Reader reader;\n    private final CharsetEncoder encoder;\n    private final byte[] singleByte = new byte[1];\n\n    /**\n     * charBuffer holds characters that have been read from the Reader but not encoded yet. The buffer\n     * is perpetually \"flipped\" (unencoded characters between position and limit).\n     */\n    private CharBuffer charBuffer;\n\n    /**\n     * byteBuffer holds encoded characters that have not yet been sent to the caller of the input\n     * stream. When encoding it is \"unflipped\" (encoded bytes between 0 and position) and when\n     * draining it is flipped (undrained bytes between position and limit).\n     */\n    private ByteBuffer byteBuffer;\n\n    /** Whether we've finished reading the reader. */\n    private boolean endOfInput;\n    /** Whether we're copying encoded bytes to the caller's buffer. */\n    private boolean draining;\n    /** Whether we've successfully flushed the encoder. */\n    private boolean doneFlushing;\n\n    /**\n     * Creates a new input stream that will encode the characters from {@code reader} into bytes using\n     * the given character set. Malformed input and unmappable characters will be replaced.\n     *\n     * @param reader input source\n     * @param charset character set used for encoding chars to bytes\n     * @param bufferSize size of internal input and output buffers\n     * @throws IllegalArgumentException if bufferSize is non-positive\n     */\n    ReaderInputStream(Reader reader, Charset charset, int bufferSize)\n    {\n        this(\n            reader,\n            charset\n            .newEncoder()\n            .onMalformedInput(CodingErrorAction.REPLACE)\n            .onUnmappableCharacter(CodingErrorAction.REPLACE),\n            bufferSize);\n    }\n\n    /**\n     * Creates a new input stream that will encode the characters from {@code reader} into bytes using\n     * the given character set encoder.\n     *\n     * @param reader input source\n     * @param encoder character set encoder used for encoding chars to bytes\n     * @param bufferSize size of internal input and output buffers\n     * @throws IllegalArgumentException if bufferSize is non-positive\n     */\n    ReaderInputStream(Reader reader, CharsetEncoder encoder, int bufferSize)\n    {\n        this.reader = checkNotNull(reader);\n        this.encoder = checkNotNull(encoder);\n        checkArgument(bufferSize > 0, \"bufferSize must be positive: %s\", bufferSize);\n        encoder.reset();\n\n        charBuffer = CharBuffer.allocate(bufferSize);\n        charBuffer.flip();\n\n        byteBuffer = ByteBuffer.allocate(bufferSize);\n    }\n\n    @Override\n    public void close() throws IOException\n    {\n        reader.close();\n    }\n\n    @Override\n    public int read() throws IOException\n    {\n        return (read(singleByte) == 1) ? UnsignedBytes.toInt(singleByte[0]) : -1;\n    }\n\n    // TODO(chrisn): Consider trying to encode/flush directly to the argument byte\n    // buffer when possible.\n    @Override\n    public int read(byte[] b, int off, int len) throws IOException\n    {\n        // Obey InputStream contract.\n        checkPositionIndexes(off, off + len, b.length);\n        if (len == 0)\n        {\n            return 0;\n        }\n\n        // The rest of this method implements the process described by the CharsetEncoder javadoc.\n        int totalBytesRead = 0;\n        boolean doneEncoding = endOfInput;\n\n        DRAINING:\n        while (true)\n        {\n            // We stay in draining mode until there are no bytes left in the output buffer. Then we go\n            // back to encoding/flushing.\n            if (draining)\n            {\n                totalBytesRead += drain(b, off + totalBytesRead, len - totalBytesRead);\n                if (totalBytesRead == len || doneFlushing)\n                {\n                    return (totalBytesRead > 0) ? totalBytesRead : -1;\n                }\n                draining = false;\n                byteBuffer.clear();\n            }\n\n            while (true)\n            {\n                // We call encode until there is no more input. The last call to encode will have endOfInput\n                // == true. Then there is a final call to flush.\n                CoderResult result;\n                if (doneFlushing)\n                {\n                    result = CoderResult.UNDERFLOW;\n                }\n                else if (doneEncoding)\n                {\n                    result = encoder.flush(byteBuffer);\n                }\n                else\n                {\n                    result = encoder.encode(charBuffer, byteBuffer, endOfInput);\n                }\n\n                if (result.isOverflow())\n                {\n                    // Not enough room in output buffer--drain it, creating a bigger buffer if necessary.\n                    startDraining(true);\n                    continue DRAINING;\n                }\n                else if (result.isUnderflow())\n                {\n                    // If encoder underflows, it means either:\n                    // a) the final flush() succeeded; next drain (then done)\n                    // b) we encoded all of the input; next flush\n                    // c) we ran of out input to encode; next read more input\n                    if (doneEncoding)   // (a)\n                    {\n                        doneFlushing = true;\n                        startDraining(false);\n                        continue DRAINING;\n                    }\n                    else if (endOfInput)     // (b)\n                    {\n                        doneEncoding = true;\n                    }\n                    else     // (c)\n                    {\n                        readMoreChars();\n                    }\n                }\n                else if (result.isError())\n                {\n                    // Only reach here if a CharsetEncoder with non-REPLACE settings is used.\n                    result.throwException();\n                    return 0; // Not called.\n                }\n            }\n        }\n    }\n\n    /** Returns a new CharBuffer identical to buf, except twice the capacity. */\n\n    /** Handle the case of underflow caused by needing more input characters. */\n    private void readMoreChars() throws IOException\n    {\n        // Possibilities:\n        // 1) array has space available on right hand side (between limit and capacity)\n        // 2) array has space available on left hand side (before position)\n        // 3) array has no space available\n        //\n        // In case 2 we shift the existing chars to the left, and in case 3 we create a bigger\n        // array, then they both become case 1.\n\n        if (availableCapacity(charBuffer) == 0)\n        {\n            if (charBuffer.position() > 0)\n            {\n                // (2) There is room in the buffer. Move existing bytes to the beginning.\n                charBuffer.compact().flip();\n            }\n            else\n            {\n                // (3) Entire buffer is full, need bigger buffer.\n                charBuffer = grow(charBuffer);\n            }\n        }\n\n        // (1) Read more characters into free space at end of array.\n        int limit = charBuffer.limit();\n        int numChars = reader.read(charBuffer.array(), limit, availableCapacity(charBuffer));\n        if (numChars == -1)\n        {\n            endOfInput = true;\n        }\n        else\n        {\n            charBuffer.limit(limit + numChars);\n        }\n    }\n\n    /** Returns the number of elements between the limit and capacity. */\n    private static int availableCapacity(Buffer buffer)\n    {\n        return buffer.capacity() - buffer.limit();\n    }\n\n    /**\n     * Flips the buffer output buffer so we can start reading bytes from it. If we are starting to\n     * drain because there was overflow, and there aren't actually any characters to drain, then the\n     * overflow must be due to a small output buffer.\n     */\n    private void startDraining(boolean overflow)\n    {\n        byteBuffer.flip();\n        if (overflow && byteBuffer.remaining() == 0)\n        {\n            byteBuffer = ByteBuffer.allocate(byteBuffer.capacity() * 2);\n        }\n        else\n        {\n            draining = true;\n        }\n    }\n\n    /**\n     * Copy as much of the byte buffer into the output array as possible, returning the (positive)\n     * number of characters copied.\n     */\n    private int drain(byte[] b, int off, int len)\n    {\n        int remaining = Math.min(len, byteBuffer.remaining());\n        byteBuffer.get(b, off, remaining);\n        return remaining;\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/ReaderInputStream.java", "func_name": "ReaderInputStream.readMoreChars", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Handle the case of underflow caused by needing more input characters.", "docstring_tokens": ["Handle", "the", "case", "of", "underflow", "caused", "by", "needing", "more", "input", "characters", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/ReaderInputStream.java#L198-L225", "partition": "valid", "up_fun_num": 6, "levels": [0, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.base.Preconditions.checkPositionIndexes;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.primitives.UnsignedBytes;", "import java.io.IOException;", "import java.io.InputStream;", "import java.io.Reader;", "import java.nio.Buffer;", "import java.nio.ByteBuffer;", "import java.nio.CharBuffer;", "import java.nio.charset.Charset;", "import java.nio.charset.CharsetEncoder;", "import java.nio.charset.CoderResult;", "import java.nio.charset.CodingErrorAction;", "import java.util.Arrays;"], "function": ["final class ReaderInputStream extends InputStream\n", "    public void close() throws IOException\n", "    public int read() throws IOException\n", "    public int read(byte[] b, int off, int len) throws IOException\n", "    private static CharBuffer grow(CharBuffer buf)\n", "    private static int availableCapacity(Buffer buffer)\n", "    private void startDraining(boolean overflow)\n", "    private int drain(byte[] b, int off, int len)\n"], "context": "/*\n * Copyright (C) 2015 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkPositionIndexes;\n\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.primitives.UnsignedBytes;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.nio.Buffer;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.CoderResult;\nimport java.nio.charset.CodingErrorAction;\nimport java.util.Arrays;\n\n/**\n * An {@link InputStream} that converts characters from a {@link Reader} into bytes using an\n * arbitrary Charset.\n *\n * <p>This is an alternative to copying the data to an {@code OutputStream} via a {@code Writer},\n * which is necessarily blocking. By implementing an {@code InputStream} it allows consumers to\n * \"pull\" as much data as they can handle, which is more convenient when dealing with flow\n * controlled, async APIs.\n *\n * @author Chris Nokleberg\n */\n@GwtIncompatible\nfinal class ReaderInputStream extends InputStream\n{\n    private final Reader reader;\n    private final CharsetEncoder encoder;\n    private final byte[] singleByte = new byte[1];\n\n    /**\n     * charBuffer holds characters that have been read from the Reader but not encoded yet. The buffer\n     * is perpetually \"flipped\" (unencoded characters between position and limit).\n     */\n    private CharBuffer charBuffer;\n\n    /**\n     * byteBuffer holds encoded characters that have not yet been sent to the caller of the input\n     * stream. When encoding it is \"unflipped\" (encoded bytes between 0 and position) and when\n     * draining it is flipped (undrained bytes between position and limit).\n     */\n    private ByteBuffer byteBuffer;\n\n    /** Whether we've finished reading the reader. */\n    private boolean endOfInput;\n    /** Whether we're copying encoded bytes to the caller's buffer. */\n    private boolean draining;\n    /** Whether we've successfully flushed the encoder. */\n    private boolean doneFlushing;\n\n    /**\n     * Creates a new input stream that will encode the characters from {@code reader} into bytes using\n     * the given character set. Malformed input and unmappable characters will be replaced.\n     *\n     * @param reader input source\n     * @param charset character set used for encoding chars to bytes\n     * @param bufferSize size of internal input and output buffers\n     * @throws IllegalArgumentException if bufferSize is non-positive\n     */\n    ReaderInputStream(Reader reader, Charset charset, int bufferSize)\n    {\n        this(\n            reader,\n            charset\n            .newEncoder()\n            .onMalformedInput(CodingErrorAction.REPLACE)\n            .onUnmappableCharacter(CodingErrorAction.REPLACE),\n            bufferSize);\n    }\n\n    /**\n     * Creates a new input stream that will encode the characters from {@code reader} into bytes using\n     * the given character set encoder.\n     *\n     * @param reader input source\n     * @param encoder character set encoder used for encoding chars to bytes\n     * @param bufferSize size of internal input and output buffers\n     * @throws IllegalArgumentException if bufferSize is non-positive\n     */\n    ReaderInputStream(Reader reader, CharsetEncoder encoder, int bufferSize)\n    {\n        this.reader = checkNotNull(reader);\n        this.encoder = checkNotNull(encoder);\n        checkArgument(bufferSize > 0, \"bufferSize must be positive: %s\", bufferSize);\n        encoder.reset();\n\n        charBuffer = CharBuffer.allocate(bufferSize);\n        charBuffer.flip();\n\n        byteBuffer = ByteBuffer.allocate(bufferSize);\n    }\n\n    @Override\n    public void close() throws IOException\n    {\n        reader.close();\n    }\n\n    @Override\n    public int read() throws IOException\n    {\n        return (read(singleByte) == 1) ? UnsignedBytes.toInt(singleByte[0]) : -1;\n    }\n\n    // TODO(chrisn): Consider trying to encode/flush directly to the argument byte\n    // buffer when possible.\n    @Override\n    public int read(byte[] b, int off, int len) throws IOException\n    {\n        // Obey InputStream contract.\n        checkPositionIndexes(off, off + len, b.length);\n        if (len == 0)\n        {\n            return 0;\n        }\n\n        // The rest of this method implements the process described by the CharsetEncoder javadoc.\n        int totalBytesRead = 0;\n        boolean doneEncoding = endOfInput;\n\n        DRAINING:\n        while (true)\n        {\n            // We stay in draining mode until there are no bytes left in the output buffer. Then we go\n            // back to encoding/flushing.\n            if (draining)\n            {\n                totalBytesRead += drain(b, off + totalBytesRead, len - totalBytesRead);\n                if (totalBytesRead == len || doneFlushing)\n                {\n                    return (totalBytesRead > 0) ? totalBytesRead : -1;\n                }\n                draining = false;\n                byteBuffer.clear();\n            }\n\n            while (true)\n            {\n                // We call encode until there is no more input. The last call to encode will have endOfInput\n                // == true. Then there is a final call to flush.\n                CoderResult result;\n                if (doneFlushing)\n                {\n                    result = CoderResult.UNDERFLOW;\n                }\n                else if (doneEncoding)\n                {\n                    result = encoder.flush(byteBuffer);\n                }\n                else\n                {\n                    result = encoder.encode(charBuffer, byteBuffer, endOfInput);\n                }\n\n                if (result.isOverflow())\n                {\n                    // Not enough room in output buffer--drain it, creating a bigger buffer if necessary.\n                    startDraining(true);\n                    continue DRAINING;\n                }\n                else if (result.isUnderflow())\n                {\n                    // If encoder underflows, it means either:\n                    // a) the final flush() succeeded; next drain (then done)\n                    // b) we encoded all of the input; next flush\n                    // c) we ran of out input to encode; next read more input\n                    if (doneEncoding)   // (a)\n                    {\n                        doneFlushing = true;\n                        startDraining(false);\n                        continue DRAINING;\n                    }\n                    else if (endOfInput)     // (b)\n                    {\n                        doneEncoding = true;\n                    }\n                    else     // (c)\n                    {\n                        readMoreChars();\n                    }\n                }\n                else if (result.isError())\n                {\n                    // Only reach here if a CharsetEncoder with non-REPLACE settings is used.\n                    result.throwException();\n                    return 0; // Not called.\n                }\n            }\n        }\n    }\n\n    /** Returns a new CharBuffer identical to buf, except twice the capacity. */\n    private static CharBuffer grow(CharBuffer buf)\n    {\n        char[] copy = Arrays.copyOf(buf.array(), buf.capacity() * 2);\n        CharBuffer bigger = CharBuffer.wrap(copy);\n        bigger.position(buf.position());\n        bigger.limit(buf.limit());\n        return bigger;\n    }\n\n    /** Handle the case of underflow caused by needing more input characters. */\n\n    /** Returns the number of elements between the limit and capacity. */\n    private static int availableCapacity(Buffer buffer)\n    {\n        return buffer.capacity() - buffer.limit();\n    }\n\n    /**\n     * Flips the buffer output buffer so we can start reading bytes from it. If we are starting to\n     * drain because there was overflow, and there aren't actually any characters to drain, then the\n     * overflow must be due to a small output buffer.\n     */\n    private void startDraining(boolean overflow)\n    {\n        byteBuffer.flip();\n        if (overflow && byteBuffer.remaining() == 0)\n        {\n            byteBuffer = ByteBuffer.allocate(byteBuffer.capacity() * 2);\n        }\n        else\n        {\n            draining = true;\n        }\n    }\n\n    /**\n     * Copy as much of the byte buffer into the output array as possible, returning the (positive)\n     * number of characters copied.\n     */\n    private int drain(byte[] b, int off, int len)\n    {\n        int remaining = Math.min(len, byteBuffer.remaining());\n        byteBuffer.get(b, off, remaining);\n        return remaining;\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/ReaderInputStream.java", "func_name": "ReaderInputStream.startDraining", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Flips the buffer output buffer so we can start reading bytes from it. If we are starting to\ndrain because there was overflow, and there aren't actually any characters to drain, then the\noverflow must be due to a small output buffer.", "docstring_tokens": ["Flips", "the", "buffer", "output", "buffer", "so", "we", "can", "start", "reading", "bytes", "from", "it", ".", "If", "we", "are", "starting", "to", "drain", "because", "there", "was", "overflow", "and", "there", "aren", "t", "actually", "any", "characters", "to", "drain", "then", "the", "overflow", "must", "be", "due", "to", "a", "small", "output", "buffer", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/ReaderInputStream.java#L237-L244", "partition": "valid", "up_fun_num": 8, "levels": [0, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.base.Preconditions.checkPositionIndexes;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.primitives.UnsignedBytes;", "import java.io.IOException;", "import java.io.InputStream;", "import java.io.Reader;", "import java.nio.Buffer;", "import java.nio.ByteBuffer;", "import java.nio.CharBuffer;", "import java.nio.charset.Charset;", "import java.nio.charset.CharsetEncoder;", "import java.nio.charset.CoderResult;", "import java.nio.charset.CodingErrorAction;", "import java.util.Arrays;"], "function": ["final class ReaderInputStream extends InputStream\n", "    public void close() throws IOException\n", "    public int read() throws IOException\n", "    public int read(byte[] b, int off, int len) throws IOException\n", "    private static CharBuffer grow(CharBuffer buf)\n", "    private void readMoreChars() throws IOException\n", "    private static int availableCapacity(Buffer buffer)\n", "    private int drain(byte[] b, int off, int len)\n"], "context": "/*\n * Copyright (C) 2015 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkPositionIndexes;\n\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.primitives.UnsignedBytes;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.nio.Buffer;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.CoderResult;\nimport java.nio.charset.CodingErrorAction;\nimport java.util.Arrays;\n\n/**\n * An {@link InputStream} that converts characters from a {@link Reader} into bytes using an\n * arbitrary Charset.\n *\n * <p>This is an alternative to copying the data to an {@code OutputStream} via a {@code Writer},\n * which is necessarily blocking. By implementing an {@code InputStream} it allows consumers to\n * \"pull\" as much data as they can handle, which is more convenient when dealing with flow\n * controlled, async APIs.\n *\n * @author Chris Nokleberg\n */\n@GwtIncompatible\nfinal class ReaderInputStream extends InputStream\n{\n    private final Reader reader;\n    private final CharsetEncoder encoder;\n    private final byte[] singleByte = new byte[1];\n\n    /**\n     * charBuffer holds characters that have been read from the Reader but not encoded yet. The buffer\n     * is perpetually \"flipped\" (unencoded characters between position and limit).\n     */\n    private CharBuffer charBuffer;\n\n    /**\n     * byteBuffer holds encoded characters that have not yet been sent to the caller of the input\n     * stream. When encoding it is \"unflipped\" (encoded bytes between 0 and position) and when\n     * draining it is flipped (undrained bytes between position and limit).\n     */\n    private ByteBuffer byteBuffer;\n\n    /** Whether we've finished reading the reader. */\n    private boolean endOfInput;\n    /** Whether we're copying encoded bytes to the caller's buffer. */\n    private boolean draining;\n    /** Whether we've successfully flushed the encoder. */\n    private boolean doneFlushing;\n\n    /**\n     * Creates a new input stream that will encode the characters from {@code reader} into bytes using\n     * the given character set. Malformed input and unmappable characters will be replaced.\n     *\n     * @param reader input source\n     * @param charset character set used for encoding chars to bytes\n     * @param bufferSize size of internal input and output buffers\n     * @throws IllegalArgumentException if bufferSize is non-positive\n     */\n    ReaderInputStream(Reader reader, Charset charset, int bufferSize)\n    {\n        this(\n            reader,\n            charset\n            .newEncoder()\n            .onMalformedInput(CodingErrorAction.REPLACE)\n            .onUnmappableCharacter(CodingErrorAction.REPLACE),\n            bufferSize);\n    }\n\n    /**\n     * Creates a new input stream that will encode the characters from {@code reader} into bytes using\n     * the given character set encoder.\n     *\n     * @param reader input source\n     * @param encoder character set encoder used for encoding chars to bytes\n     * @param bufferSize size of internal input and output buffers\n     * @throws IllegalArgumentException if bufferSize is non-positive\n     */\n    ReaderInputStream(Reader reader, CharsetEncoder encoder, int bufferSize)\n    {\n        this.reader = checkNotNull(reader);\n        this.encoder = checkNotNull(encoder);\n        checkArgument(bufferSize > 0, \"bufferSize must be positive: %s\", bufferSize);\n        encoder.reset();\n\n        charBuffer = CharBuffer.allocate(bufferSize);\n        charBuffer.flip();\n\n        byteBuffer = ByteBuffer.allocate(bufferSize);\n    }\n\n    @Override\n    public void close() throws IOException\n    {\n        reader.close();\n    }\n\n    @Override\n    public int read() throws IOException\n    {\n        return (read(singleByte) == 1) ? UnsignedBytes.toInt(singleByte[0]) : -1;\n    }\n\n    // TODO(chrisn): Consider trying to encode/flush directly to the argument byte\n    // buffer when possible.\n    @Override\n    public int read(byte[] b, int off, int len) throws IOException\n    {\n        // Obey InputStream contract.\n        checkPositionIndexes(off, off + len, b.length);\n        if (len == 0)\n        {\n            return 0;\n        }\n\n        // The rest of this method implements the process described by the CharsetEncoder javadoc.\n        int totalBytesRead = 0;\n        boolean doneEncoding = endOfInput;\n\n        DRAINING:\n        while (true)\n        {\n            // We stay in draining mode until there are no bytes left in the output buffer. Then we go\n            // back to encoding/flushing.\n            if (draining)\n            {\n                totalBytesRead += drain(b, off + totalBytesRead, len - totalBytesRead);\n                if (totalBytesRead == len || doneFlushing)\n                {\n                    return (totalBytesRead > 0) ? totalBytesRead : -1;\n                }\n                draining = false;\n                byteBuffer.clear();\n            }\n\n            while (true)\n            {\n                // We call encode until there is no more input. The last call to encode will have endOfInput\n                // == true. Then there is a final call to flush.\n                CoderResult result;\n                if (doneFlushing)\n                {\n                    result = CoderResult.UNDERFLOW;\n                }\n                else if (doneEncoding)\n                {\n                    result = encoder.flush(byteBuffer);\n                }\n                else\n                {\n                    result = encoder.encode(charBuffer, byteBuffer, endOfInput);\n                }\n\n                if (result.isOverflow())\n                {\n                    // Not enough room in output buffer--drain it, creating a bigger buffer if necessary.\n                    startDraining(true);\n                    continue DRAINING;\n                }\n                else if (result.isUnderflow())\n                {\n                    // If encoder underflows, it means either:\n                    // a) the final flush() succeeded; next drain (then done)\n                    // b) we encoded all of the input; next flush\n                    // c) we ran of out input to encode; next read more input\n                    if (doneEncoding)   // (a)\n                    {\n                        doneFlushing = true;\n                        startDraining(false);\n                        continue DRAINING;\n                    }\n                    else if (endOfInput)     // (b)\n                    {\n                        doneEncoding = true;\n                    }\n                    else     // (c)\n                    {\n                        readMoreChars();\n                    }\n                }\n                else if (result.isError())\n                {\n                    // Only reach here if a CharsetEncoder with non-REPLACE settings is used.\n                    result.throwException();\n                    return 0; // Not called.\n                }\n            }\n        }\n    }\n\n    /** Returns a new CharBuffer identical to buf, except twice the capacity. */\n    private static CharBuffer grow(CharBuffer buf)\n    {\n        char[] copy = Arrays.copyOf(buf.array(), buf.capacity() * 2);\n        CharBuffer bigger = CharBuffer.wrap(copy);\n        bigger.position(buf.position());\n        bigger.limit(buf.limit());\n        return bigger;\n    }\n\n    /** Handle the case of underflow caused by needing more input characters. */\n    private void readMoreChars() throws IOException\n    {\n        // Possibilities:\n        // 1) array has space available on right hand side (between limit and capacity)\n        // 2) array has space available on left hand side (before position)\n        // 3) array has no space available\n        //\n        // In case 2 we shift the existing chars to the left, and in case 3 we create a bigger\n        // array, then they both become case 1.\n\n        if (availableCapacity(charBuffer) == 0)\n        {\n            if (charBuffer.position() > 0)\n            {\n                // (2) There is room in the buffer. Move existing bytes to the beginning.\n                charBuffer.compact().flip();\n            }\n            else\n            {\n                // (3) Entire buffer is full, need bigger buffer.\n                charBuffer = grow(charBuffer);\n            }\n        }\n\n        // (1) Read more characters into free space at end of array.\n        int limit = charBuffer.limit();\n        int numChars = reader.read(charBuffer.array(), limit, availableCapacity(charBuffer));\n        if (numChars == -1)\n        {\n            endOfInput = true;\n        }\n        else\n        {\n            charBuffer.limit(limit + numChars);\n        }\n    }\n\n    /** Returns the number of elements between the limit and capacity. */\n    private static int availableCapacity(Buffer buffer)\n    {\n        return buffer.capacity() - buffer.limit();\n    }\n\n    /**\n     * Flips the buffer output buffer so we can start reading bytes from it. If we are starting to\n     * drain because there was overflow, and there aren't actually any characters to drain, then the\n     * overflow must be due to a small output buffer.\n     */\n\n    /**\n     * Copy as much of the byte buffer into the output array as possible, returning the (positive)\n     * number of characters copied.\n     */\n    private int drain(byte[] b, int off, int len)\n    {\n        int remaining = Math.min(len, byteBuffer.remaining());\n        byteBuffer.get(b, off, remaining);\n        return remaining;\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/Iterables.java", "func_name": "Iterables.toArray", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Copies an iterable's elements into an array.\n\n@param iterable the iterable to copy\n@param type the type of the elements\n@return a newly-allocated array into which all the elements of the iterable have been copied", "docstring_tokens": ["Copies", "an", "iterable", "s", "elements", "into", "an", "array", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/Iterables.java#L316-L319", "partition": "valid", "up_fun_num": 15, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.collect.CollectPreconditions.checkRemove;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.Function;", "import com.google.common.base.Optional;", "import com.google.common.base.Predicate;", "import com.google.common.base.Predicates;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.util.Collection;", "import java.util.Comparator;", "import java.util.Iterator;", "import java.util.List;", "import java.util.NoSuchElementException;", "import java.util.Queue;", "import java.util.RandomAccess;", "import java.util.Set;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Iterables\n", "    public static <T> Iterable<T> unmodifiableIterable(final Iterable<? extends T> iterable)\n", "    public static <E> Iterable<E> unmodifiableIterable(ImmutableCollection<E> iterable)\n", "    public static int size(Iterable<?> iterable)\n", "    public static boolean contains(Iterable<?> iterable, @NullableDecl Object element)\n", "    public static boolean removeAll(Iterable<?> removeFrom, Collection<?> elementsToRemove)\n", "    public static boolean retainAll(Iterable<?> removeFrom, Collection<?> elementsToRetain)\n", "    public static <T> boolean removeIf(Iterable<T> removeFrom, Predicate<? super T> predicate)\n", "    private static <T> boolean removeIfFromRandomAccessList(\n", "    private static <T> void slowRemoveIfForRemainingElements(\n", "    static <T> T removeFirstMatching(Iterable<T> removeFrom, Predicate<? super T> predicate)\n", "    public static boolean elementsEqual(Iterable<?> iterable1, Iterable<?> iterable2)\n", "    public static String toString(Iterable<?> iterable)\n", "    public static <T> T getOnlyElement(Iterable<T> iterable)\n", "    public static <T> T getOnlyElement(Iterable<? extends T> iterable, @NullableDecl T defaultValue)\n", "    static <T> T[] toArray(Iterable<? extends T> iterable, T[] array)\n", "    static Object[] toArray(Iterable<?> iterable)\n", "    private static <E> Collection<E> castOrCopyToCollection(Iterable<E> iterable)\n", "    public static <T> boolean addAll(Collection<T> addTo, Iterable<? extends T> elementsToAdd)\n", "    public static int frequency(Iterable<?> iterable, @NullableDecl Object element)\n", "    public static <T> Iterable<T> cycle(final Iterable<T> iterable)\n", "    public static <T> Iterable<T> cycle(T... elements)\n", "    public static <T> Iterable<T> concat(Iterable<? extends T> a, Iterable<? extends T> b)\n", "    public static <T> Iterable<T> concat(\n", "    public static <T> Iterable<T> concat(\n", "    public static <T> Iterable<T> concat(Iterable<? extends T>... inputs)\n", "    public static <T> Iterable<T> concat(Iterable<? extends Iterable<? extends T>> inputs)\n", "    public static <T> Iterable<List<T>> partition(final Iterable<T> iterable, final int size)\n", "    public static <T> Iterable<List<T>> paddedPartition(final Iterable<T> iterable, final int size)\n", "    public static <T> Iterable<T> filter(\n", "    public static <T> Iterable<T> filter(final Iterable<?> unfiltered, final Class<T> desiredType)\n", "    public static <T> boolean any(Iterable<T> iterable, Predicate<? super T> predicate)\n", "    public static <T> boolean all(Iterable<T> iterable, Predicate<? super T> predicate)\n", "    public static <T> T find(Iterable<T> iterable, Predicate<? super T> predicate)\n", "    public static <T> T find(\n", "    public static <T> Optional<T> tryFind(Iterable<T> iterable, Predicate<? super T> predicate)\n", "    public static <T> int indexOf(Iterable<T> iterable, Predicate<? super T> predicate)\n", "    public static <F, T> Iterable<T> transform(\n", "    public static <T> T get(Iterable<T> iterable, int position)\n", "    public static <T> T get(\n", "    public static <T> T getFirst(Iterable<? extends T> iterable, @NullableDecl T defaultValue)\n", "    public static <T> T getLast(Iterable<T> iterable)\n", "    public static <T> T getLast(Iterable<? extends T> iterable, @NullableDecl T defaultValue)\n", "    private static <T> T getLastInNonemptyList(List<T> list)\n", "    public static <T> Iterable<T> skip(final Iterable<T> iterable, final int numberToSkip)\n", "    public static <T> Iterable<T> limit(final Iterable<T> iterable, final int limitSize)\n", "    public static <T> Iterable<T> consumingIterable(final Iterable<T> iterable)\n", "    public static boolean isEmpty(Iterable<?> iterable)\n", "    public static <T> Iterable<T> mergeSorted(\n", "    static <T> Function<Iterable<? extends T>, Iterator<? extends T>> toIterator()\n"], "context": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.collect.CollectPreconditions.checkRemove;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Function;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Queue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * An assortment of mainly legacy static utility methods that operate on or return objects of type\n * {@code Iterable}. Except as noted, each method has a corresponding {@link Iterator}-based method\n * in the {@link Iterators} class.\n *\n * <p><b>Java 8 users:</b> several common uses for this class are now more comprehensively addressed\n * by the new {@link java.util.stream.Stream} library. Read the method documentation below for\n * comparisons. This class is not being deprecated, but we gently encourage you to migrate to\n * streams.\n *\n * <p><i>Performance notes:</i> Unless otherwise noted, all of the iterables produced in this class\n * are <i>lazy</i>, which means that their iterators only advance the backing iteration when\n * absolutely necessary.\n *\n * <p>See the Guava User Guide article on <a href=\n * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#iterables\"> {@code\n * Iterables}</a>.\n *\n * @author Kevin Bourrillion\n * @author Jared Levy\n * @since 2.0\n */\n@GwtCompatible(emulated = true)\npublic final class Iterables\n{\n    private Iterables() {}\n\n    /** Returns an unmodifiable view of {@code iterable}. */\n    public static <T> Iterable<T> unmodifiableIterable(final Iterable<? extends T> iterable)\n    {\n        checkNotNull(iterable);\n        if (iterable instanceof UnmodifiableIterable || iterable instanceof ImmutableCollection)\n        {\n            @SuppressWarnings(\"unchecked\") // Since it's unmodifiable, the covariant cast is safe\n            Iterable<T> result = (Iterable<T>) iterable;\n            return result;\n        }\n        return new UnmodifiableIterable<>(iterable);\n    }\n\n    /**\n     * Simply returns its argument.\n     *\n     * @deprecated no need to use this\n     * @since 10.0\n     */\n    @Deprecated\n    public static <E> Iterable<E> unmodifiableIterable(ImmutableCollection<E> iterable)\n    {\n        return checkNotNull(iterable);\n    }\n\n    private static final class UnmodifiableIterable<T> extends FluentIterable<T>\n    {\n        private final Iterable<? extends T> iterable;\n\n        private UnmodifiableIterable(Iterable<? extends T> iterable)\n        {\n            this.iterable = iterable;\n        }\n\n        @Override\n        public Iterator<T> iterator()\n        {\n            return Iterators.unmodifiableIterator(iterable.iterator());\n        }\n\n        @Override\n        public String toString()\n        {\n            return iterable.toString();\n        }\n        // no equals and hashCode; it would break the contract!\n    }\n\n    /** Returns the number of elements in {@code iterable}. */\n    public static int size(Iterable<?> iterable)\n    {\n        return (iterable instanceof Collection)\n               ? ((Collection<?>) iterable).size()\n               : Iterators.size(iterable.iterator());\n    }\n\n    /**\n     * Returns {@code true} if {@code iterable} contains any element {@code o} for which {@code\n     * Objects.equals(o, element)} would return {@code true}. Otherwise returns {@code false}, even in\n     * cases where {@link Collection#contains} might throw {@link NullPointerException} or {@link\n     * ClassCastException}.\n     */\n    public static boolean contains(Iterable<?> iterable, @NullableDecl Object element)\n    {\n        if (iterable instanceof Collection)\n        {\n            Collection<?> collection = (Collection<?>) iterable;\n            return Collections2.safeContains(collection, element);\n        }\n        return Iterators.contains(iterable.iterator(), element);\n    }\n\n    /**\n     * Removes, from an iterable, every element that belongs to the provided collection.\n     *\n     * <p>This method calls {@link Collection#removeAll} if {@code iterable} is a collection, and\n     * {@link Iterators#removeAll} otherwise.\n     *\n     * @param removeFrom the iterable to (potentially) remove elements from\n     * @param elementsToRemove the elements to remove\n     * @return {@code true} if any element was removed from {@code iterable}\n     */\n    @CanIgnoreReturnValue\n    public static boolean removeAll(Iterable<?> removeFrom, Collection<?> elementsToRemove)\n    {\n        return (removeFrom instanceof Collection)\n               ? ((Collection<?>) removeFrom).removeAll(checkNotNull(elementsToRemove))\n               : Iterators.removeAll(removeFrom.iterator(), elementsToRemove);\n    }\n\n    /**\n     * Removes, from an iterable, every element that does not belong to the provided collection.\n     *\n     * <p>This method calls {@link Collection#retainAll} if {@code iterable} is a collection, and\n     * {@link Iterators#retainAll} otherwise.\n     *\n     * @param removeFrom the iterable to (potentially) remove elements from\n     * @param elementsToRetain the elements to retain\n     * @return {@code true} if any element was removed from {@code iterable}\n     */\n    @CanIgnoreReturnValue\n    public static boolean retainAll(Iterable<?> removeFrom, Collection<?> elementsToRetain)\n    {\n        return (removeFrom instanceof Collection)\n               ? ((Collection<?>) removeFrom).retainAll(checkNotNull(elementsToRetain))\n               : Iterators.retainAll(removeFrom.iterator(), elementsToRetain);\n    }\n\n    /**\n     * Removes, from an iterable, every element that satisfies the provided predicate.\n     *\n     * <p>Removals may or may not happen immediately as each element is tested against the predicate.\n     * The behavior of this method is not specified if {@code predicate} is dependent on {@code\n     * removeFrom}.\n     *\n     * @param removeFrom the iterable to (potentially) remove elements from\n     * @param predicate a predicate that determines whether an element should be removed\n     * @return {@code true} if any elements were removed from the iterable\n     * @throws UnsupportedOperationException if the iterable does not support {@code remove()}.\n     * @since 2.0\n     */\n    @CanIgnoreReturnValue\n    public static <T> boolean removeIf(Iterable<T> removeFrom, Predicate<? super T> predicate)\n    {\n        if (removeFrom instanceof RandomAccess && removeFrom instanceof List)\n        {\n            return removeIfFromRandomAccessList((List<T>) removeFrom, checkNotNull(predicate));\n        }\n        return Iterators.removeIf(removeFrom.iterator(), predicate);\n    }\n\n    private static <T> boolean removeIfFromRandomAccessList(\n        List<T> list, Predicate<? super T> predicate)\n    {\n        // Note: Not all random access lists support set(). Additionally, it's possible\n        // for a list to reject setting an element, such as when the list does not permit\n        // duplicate elements. For both of those cases,  we need to fall back to a slower\n        // implementation.\n        int from = 0;\n        int to = 0;\n\n        for (; from < list.size(); from++)\n        {\n            T element = list.get(from);\n            if (!predicate.apply(element))\n            {\n                if (from > to)\n                {\n                    try\n                    {\n                        list.set(to, element);\n                    }\n                    catch (UnsupportedOperationException e)\n                    {\n                        slowRemoveIfForRemainingElements(list, predicate, to, from);\n                        return true;\n                    }\n                    catch (IllegalArgumentException e)\n                    {\n                        slowRemoveIfForRemainingElements(list, predicate, to, from);\n                        return true;\n                    }\n                }\n                to++;\n            }\n        }\n\n        // Clear the tail of any remaining items\n        list.subList(to, list.size()).clear();\n        return from != to;\n    }\n\n    private static <T> void slowRemoveIfForRemainingElements(\n        List<T> list, Predicate<? super T> predicate, int to, int from)\n    {\n        // Here we know that:\n        // * (to < from) and that both are valid indices.\n        // * Everything with (index < to) should be kept.\n        // * Everything with (to <= index < from) should be removed.\n        // * The element with (index == from) should be kept.\n        // * Everything with (index > from) has not been checked yet.\n\n        // Check from the end of the list backwards (minimize expected cost of\n        // moving elements when remove() is called). Stop before 'from' because\n        // we already know that should be kept.\n        for (int n = list.size() - 1; n > from; n--)\n        {\n            if (predicate.apply(list.get(n)))\n            {\n                list.remove(n);\n            }\n        }\n        // And now remove everything in the range [to, from) (going backwards).\n        for (int n = from - 1; n >= to; n--)\n        {\n            list.remove(n);\n        }\n    }\n\n    /** Removes and returns the first matching element, or returns {@code null} if there is none. */\n    @NullableDecl\n    static <T> T removeFirstMatching(Iterable<T> removeFrom, Predicate<? super T> predicate)\n    {\n        checkNotNull(predicate);\n        Iterator<T> iterator = removeFrom.iterator();\n        while (iterator.hasNext())\n        {\n            T next = iterator.next();\n            if (predicate.apply(next))\n            {\n                iterator.remove();\n                return next;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Determines whether two iterables contain equal elements in the same order. More specifically,\n     * this method returns {@code true} if {@code iterable1} and {@code iterable2} contain the same\n     * number of elements and every element of {@code iterable1} is equal to the corresponding element\n     * of {@code iterable2}.\n     */\n    public static boolean elementsEqual(Iterable<?> iterable1, Iterable<?> iterable2)\n    {\n        if (iterable1 instanceof Collection && iterable2 instanceof Collection)\n        {\n            Collection<?> collection1 = (Collection<?>) iterable1;\n            Collection<?> collection2 = (Collection<?>) iterable2;\n            if (collection1.size() != collection2.size())\n            {\n                return false;\n            }\n        }\n        return Iterators.elementsEqual(iterable1.iterator(), iterable2.iterator());\n    }\n\n    /**\n     * Returns a string representation of {@code iterable}, with the format {@code [e1, e2, ..., en]}\n     * (that is, identical to {@link java.util.Arrays Arrays}{@code\n     * .toString(Iterables.toArray(iterable))}). Note that for <i>most</i> implementations of {@link\n     * Collection}, {@code collection.toString()} also gives the same result, but that behavior is not\n     * generally guaranteed.\n     */\n    public static String toString(Iterable<?> iterable)\n    {\n        return Iterators.toString(iterable.iterator());\n    }\n\n    /**\n     * Returns the single element contained in {@code iterable}.\n     *\n     * <p><b>Java 8 users:</b> the {@code Stream} equivalent to this method is {@code\n     * stream.collect(MoreCollectors.onlyElement())}.\n     *\n     * @throws NoSuchElementException if the iterable is empty\n     * @throws IllegalArgumentException if the iterable contains multiple elements\n     */\n    public static <T> T getOnlyElement(Iterable<T> iterable)\n    {\n        return Iterators.getOnlyElement(iterable.iterator());\n    }\n\n    /**\n     * Returns the single element contained in {@code iterable}, or {@code defaultValue} if the\n     * iterable is empty.\n     *\n     * <p><b>Java 8 users:</b> the {@code Stream} equivalent to this method is {@code\n     * stream.collect(MoreCollectors.toOptional()).orElse(defaultValue)}.\n     *\n     * @throws IllegalArgumentException if the iterator contains multiple elements\n     */\n    @NullableDecl\n    public static <T> T getOnlyElement(Iterable<? extends T> iterable, @NullableDecl T defaultValue)\n    {\n        return Iterators.getOnlyElement(iterable.iterator(), defaultValue);\n    }\n\n    /**\n     * Copies an iterable's elements into an array.\n     *\n     * @param iterable the iterable to copy\n     * @param type the type of the elements\n     * @return a newly-allocated array into which all the elements of the iterable have been copied\n     */\n\n    static <T> T[] toArray(Iterable<? extends T> iterable, T[] array)\n    {\n        Collection<? extends T> collection = castOrCopyToCollection(iterable);\n        return collection.toArray(array);\n    }\n\n    /**\n     * Copies an iterable's elements into an array.\n     *\n     * @param iterable the iterable to copy\n     * @return a newly-allocated array into which all the elements of the iterable have been copied\n     */\n    static Object[] toArray(Iterable<?> iterable)\n    {\n        return castOrCopyToCollection(iterable).toArray();\n    }\n\n    /**\n     * Converts an iterable into a collection. If the iterable is already a collection, it is\n     * returned. Otherwise, an {@link java.util.ArrayList} is created with the contents of the\n     * iterable in the same iteration order.\n     */\n    private static <E> Collection<E> castOrCopyToCollection(Iterable<E> iterable)\n    {\n        return (iterable instanceof Collection)\n               ? (Collection<E>) iterable\n               : Lists.newArrayList(iterable.iterator());\n    }\n\n    /**\n     * Adds all elements in {@code iterable} to {@code collection}.\n     *\n     * @return {@code true} if {@code collection} was modified as a result of this operation.\n     */\n    @CanIgnoreReturnValue\n    public static <T> boolean addAll(Collection<T> addTo, Iterable<? extends T> elementsToAdd)\n    {\n        if (elementsToAdd instanceof Collection)\n        {\n            Collection<? extends T> c = Collections2.cast(elementsToAdd);\n            return addTo.addAll(c);\n        }\n        return Iterators.addAll(addTo, checkNotNull(elementsToAdd).iterator());\n    }\n\n    /**\n     * Returns the number of elements in the specified iterable that equal the specified object. This\n     * implementation avoids a full iteration when the iterable is a {@link Multiset} or {@link Set}.\n     *\n     * <p><b>Java 8 users:</b> In most cases, the {@code Stream} equivalent of this method is {@code\n     * stream.filter(element::equals).count()}. If {@code element} might be null, use {@code\n     * stream.filter(Predicate.isEqual(element)).count()} instead.\n     *\n     * @see java.util.Collections#frequency(Collection, Object) Collections.frequency(Collection,\n     *     Object)\n     */\n    public static int frequency(Iterable<?> iterable, @NullableDecl Object element)\n    {\n        if ((iterable instanceof Multiset))\n        {\n            return ((Multiset<?>) iterable).count(element);\n        }\n        else if ((iterable instanceof Set))\n        {\n            return ((Set<?>) iterable).contains(element) ? 1 : 0;\n        }\n        return Iterators.frequency(iterable.iterator(), element);\n    }\n\n    /**\n     * Returns an iterable whose iterators cycle indefinitely over the elements of {@code iterable}.\n     *\n     * <p>That iterator supports {@code remove()} if {@code iterable.iterator()} does. After {@code\n     * remove()} is called, subsequent cycles omit the removed element, which is no longer in {@code\n     * iterable}. The iterator's {@code hasNext()} method returns {@code true} until {@code iterable}\n     * is empty.\n     *\n     * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You\n     * should use an explicit {@code break} or be certain that you will eventually remove all the\n     * elements.\n     *\n     * <p>To cycle over the iterable {@code n} times, use the following: {@code\n     * Iterables.concat(Collections.nCopies(n, iterable))}\n     *\n     * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code\n     * Stream.generate(() -> iterable).flatMap(Streams::stream)}.\n     */\n    public static <T> Iterable<T> cycle(final Iterable<T> iterable)\n    {\n        checkNotNull(iterable);\n        return new FluentIterable<T>()\n        {\n            @Override\n            public Iterator<T> iterator()\n            {\n                return Iterators.cycle(iterable);\n            }\n\n            @Override\n            public String toString()\n            {\n                return iterable.toString() + \" (cycled)\";\n            }\n        };\n    }\n\n    /**\n     * Returns an iterable whose iterators cycle indefinitely over the provided elements.\n     *\n     * <p>After {@code remove} is invoked on a generated iterator, the removed element will no longer\n     * appear in either that iterator or any other iterator created from the same source iterable.\n     * That is, this method behaves exactly as {@code Iterables.cycle(Lists.newArrayList(elements))}.\n     * The iterator's {@code hasNext} method returns {@code true} until all of the original elements\n     * have been removed.\n     *\n     * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You\n     * should use an explicit {@code break} or be certain that you will eventually remove all the\n     * elements.\n     *\n     * <p>To cycle over the elements {@code n} times, use the following: {@code\n     * Iterables.concat(Collections.nCopies(n, Arrays.asList(elements)))}\n     *\n     * <p><b>Java 8 users:</b> If passing a single element {@code e}, the {@code Stream} equivalent of\n     * this method is {@code Stream.generate(() -> e)}. Otherwise, put the elements in a collection\n     * and use {@code Stream.generate(() -> collection).flatMap(Collection::stream)}.\n     */\n    @SafeVarargs\n    public static <T> Iterable<T> cycle(T... elements)\n    {\n        return cycle(Lists.newArrayList(elements));\n    }\n\n    /**\n     * Combines two iterables into a single iterable. The returned iterable has an iterator that\n     * traverses the elements in {@code a}, followed by the elements in {@code b}. The source\n     * iterators are not polled until necessary.\n     *\n     * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input\n     * iterator supports it.\n     *\n     * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code Stream.concat(a,\n     * b)}.\n     */\n    public static <T> Iterable<T> concat(Iterable<? extends T> a, Iterable<? extends T> b)\n    {\n        return FluentIterable.concat(a, b);\n    }\n\n    /**\n     * Combines three iterables into a single iterable. The returned iterable has an iterator that\n     * traverses the elements in {@code a}, followed by the elements in {@code b}, followed by the\n     * elements in {@code c}. The source iterators are not polled until necessary.\n     *\n     * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input\n     * iterator supports it.\n     *\n     * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code\n     * Streams.concat(a, b, c)}.\n     */\n    public static <T> Iterable<T> concat(\n        Iterable<? extends T> a, Iterable<? extends T> b, Iterable<? extends T> c)\n    {\n        return FluentIterable.concat(a, b, c);\n    }\n\n    /**\n     * Combines four iterables into a single iterable. The returned iterable has an iterator that\n     * traverses the elements in {@code a}, followed by the elements in {@code b}, followed by the\n     * elements in {@code c}, followed by the elements in {@code d}. The source iterators are not\n     * polled until necessary.\n     *\n     * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input\n     * iterator supports it.\n     *\n     * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code\n     * Streams.concat(a, b, c, d)}.\n     */\n    public static <T> Iterable<T> concat(\n        Iterable<? extends T> a,\n        Iterable<? extends T> b,\n        Iterable<? extends T> c,\n        Iterable<? extends T> d)\n    {\n        return FluentIterable.concat(a, b, c, d);\n    }\n\n    /**\n     * Combines multiple iterables into a single iterable. The returned iterable has an iterator that\n     * traverses the elements of each iterable in {@code inputs}. The input iterators are not polled\n     * until necessary.\n     *\n     * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input\n     * iterator supports it.\n     *\n     * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code\n     * Streams.concat(...)}.\n     *\n     * @throws NullPointerException if any of the provided iterables is null\n     */\n    @SafeVarargs\n    public static <T> Iterable<T> concat(Iterable<? extends T>... inputs)\n    {\n        return FluentIterable.concat(inputs);\n    }\n\n    /**\n     * Combines multiple iterables into a single iterable. The returned iterable has an iterator that\n     * traverses the elements of each iterable in {@code inputs}. The input iterators are not polled\n     * until necessary.\n     *\n     * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input\n     * iterator supports it. The methods of the returned iterable may throw {@code\n     * NullPointerException} if any of the input iterators is null.\n     *\n     * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code\n     * streamOfStreams.flatMap(s -> s)}.\n     */\n    public static <T> Iterable<T> concat(Iterable<? extends Iterable<? extends T>> inputs)\n    {\n        return FluentIterable.concat(inputs);\n    }\n\n    /**\n     * Divides an iterable into unmodifiable sublists of the given size (the final iterable may be\n     * smaller). For example, partitioning an iterable containing {@code [a, b, c, d, e]} with a\n     * partition size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer iterable containing two\n     * inner lists of three and two elements, all in the original order.\n     *\n     * <p>Iterators returned by the returned iterable do not support the {@link Iterator#remove()}\n     * method. The returned lists implement {@link RandomAccess}, whether or not the input list does.\n     *\n     * <p><b>Note:</b> if {@code iterable} is a {@link List}, use {@link Lists#partition(List, int)}\n     * instead.\n     *\n     * @param iterable the iterable to return a partitioned view of\n     * @param size the desired size of each partition (the last may be smaller)\n     * @return an iterable of unmodifiable lists containing the elements of {@code iterable} divided\n     *     into partitions\n     * @throws IllegalArgumentException if {@code size} is nonpositive\n     */\n    public static <T> Iterable<List<T>> partition(final Iterable<T> iterable, final int size)\n    {\n        checkNotNull(iterable);\n        checkArgument(size > 0);\n        return new FluentIterable<List<T>>()\n        {\n            @Override\n            public Iterator<List<T>> iterator()\n            {\n                return Iterators.partition(iterable.iterator(), size);\n            }\n        };\n    }\n\n    /**\n     * Divides an iterable into unmodifiable sublists of the given size, padding the final iterable\n     * with null values if necessary. For example, partitioning an iterable containing {@code [a, b,\n     * c, d, e]} with a partition size of 3 yields {@code [[a, b, c], [d, e, null]]} -- an outer\n     * iterable containing two inner lists of three elements each, all in the original order.\n     *\n     * <p>Iterators returned by the returned iterable do not support the {@link Iterator#remove()}\n     * method.\n     *\n     * @param iterable the iterable to return a partitioned view of\n     * @param size the desired size of each partition\n     * @return an iterable of unmodifiable lists containing the elements of {@code iterable} divided\n     *     into partitions (the final iterable may have trailing null elements)\n     * @throws IllegalArgumentException if {@code size} is nonpositive\n     */\n    public static <T> Iterable<List<T>> paddedPartition(final Iterable<T> iterable, final int size)\n    {\n        checkNotNull(iterable);\n        checkArgument(size > 0);\n        return new FluentIterable<List<T>>()\n        {\n            @Override\n            public Iterator<List<T>> iterator()\n            {\n                return Iterators.paddedPartition(iterable.iterator(), size);\n            }\n        };\n    }\n\n    /**\n     * Returns a view of {@code unfiltered} containing all elements that satisfy the input predicate\n     * {@code retainIfTrue}. The returned iterable's iterator does not support {@code remove()}.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link Stream#filter}.\n     */\n    public static <T> Iterable<T> filter(\n        final Iterable<T> unfiltered, final Predicate<? super T> retainIfTrue)\n    {\n        checkNotNull(unfiltered);\n        checkNotNull(retainIfTrue);\n        return new FluentIterable<T>()\n        {\n            @Override\n            public Iterator<T> iterator()\n            {\n                return Iterators.filter(unfiltered.iterator(), retainIfTrue);\n            }\n        };\n    }\n\n    /**\n     * Returns a view of {@code unfiltered} containing all elements that are of the type {@code\n     * desiredType}. The returned iterable's iterator does not support {@code remove()}.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(type::isInstance).map(type::cast)}.\n     * This does perform a little more work than necessary, so another option is to insert an\n     * unchecked cast at some later point:\n     *\n     * <pre>\n     * {@code @SuppressWarnings(\"unchecked\") // safe because of ::isInstance check\n     * ImmutableList<NewType> result =\n     *     (ImmutableList) stream.filter(NewType.class::isInstance).collect(toImmutableList());}\n     * </pre>\n     */\n    @SuppressWarnings(\"unchecked\")\n    @GwtIncompatible // Class.isInstance\n    public static <T> Iterable<T> filter(final Iterable<?> unfiltered, final Class<T> desiredType)\n    {\n        checkNotNull(unfiltered);\n        checkNotNull(desiredType);\n        return (Iterable<T>) filter(unfiltered, Predicates.instanceOf(desiredType));\n    }\n\n    /**\n     * Returns {@code true} if any element in {@code iterable} satisfies the predicate.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link Stream#anyMatch}.\n     */\n    public static <T> boolean any(Iterable<T> iterable, Predicate<? super T> predicate)\n    {\n        return Iterators.any(iterable.iterator(), predicate);\n    }\n\n    /**\n     * Returns {@code true} if every element in {@code iterable} satisfies the predicate. If {@code\n     * iterable} is empty, {@code true} is returned.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link Stream#allMatch}.\n     */\n    public static <T> boolean all(Iterable<T> iterable, Predicate<? super T> predicate)\n    {\n        return Iterators.all(iterable.iterator(), predicate);\n    }\n\n    /**\n     * Returns the first element in {@code iterable} that satisfies the given predicate; use this\n     * method only when such an element is known to exist. If it is possible that <i>no</i> element\n     * will match, use {@link #tryFind} or {@link #find(Iterable, Predicate, Object)} instead.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate).findFirst().get()}\n     *\n     * @throws NoSuchElementException if no element in {@code iterable} matches the given predicate\n     */\n    public static <T> T find(Iterable<T> iterable, Predicate<? super T> predicate)\n    {\n        return Iterators.find(iterable.iterator(), predicate);\n    }\n\n    /**\n     * Returns the first element in {@code iterable} that satisfies the given predicate, or {@code\n     * defaultValue} if none found. Note that this can usually be handled more naturally using {@code\n     * tryFind(iterable, predicate).or(defaultValue)}.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code\n     * stream.filter(predicate).findFirst().orElse(defaultValue)}\n     *\n     * @since 7.0\n     */\n    @NullableDecl\n    public static <T> T find(\n        Iterable<? extends T> iterable,\n        Predicate<? super T> predicate,\n        @NullableDecl T defaultValue)\n    {\n        return Iterators.find(iterable.iterator(), predicate, defaultValue);\n    }\n\n    /**\n     * Returns an {@link Optional} containing the first element in {@code iterable} that satisfies the\n     * given predicate, if such an element exists.\n     *\n     * <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code null}. If {@code null}\n     * is matched in {@code iterable}, a NullPointerException will be thrown.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate).findFirst()}\n     *\n     * @since 11.0\n     */\n    public static <T> Optional<T> tryFind(Iterable<T> iterable, Predicate<? super T> predicate)\n    {\n        return Iterators.tryFind(iterable.iterator(), predicate);\n    }\n\n    /**\n     * Returns the index in {@code iterable} of the first element that satisfies the provided {@code\n     * predicate}, or {@code -1} if the Iterable has no such elements.\n     *\n     * <p>More formally, returns the lowest index {@code i} such that {@code\n     * predicate.apply(Iterables.get(iterable, i))} returns {@code true}, or {@code -1} if there is no\n     * such index.\n     *\n     * @since 2.0\n     */\n    public static <T> int indexOf(Iterable<T> iterable, Predicate<? super T> predicate)\n    {\n        return Iterators.indexOf(iterable.iterator(), predicate);\n    }\n\n    /**\n     * Returns a view containing the result of applying {@code function} to each element of {@code\n     * fromIterable}.\n     *\n     * <p>The returned iterable's iterator supports {@code remove()} if {@code fromIterable}'s\n     * iterator does. After a successful {@code remove()} call, {@code fromIterable} no longer\n     * contains the corresponding element.\n     *\n     * <p>If the input {@code Iterable} is known to be a {@code List} or other {@code Collection},\n     * consider {@link Lists#transform} and {@link Collections2#transform}.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link Stream#map}\n     */\n    public static <F, T> Iterable<T> transform(\n        final Iterable<F> fromIterable, final Function<? super F, ? extends T> function)\n    {\n        checkNotNull(fromIterable);\n        checkNotNull(function);\n        return new FluentIterable<T>()\n        {\n            @Override\n            public Iterator<T> iterator()\n            {\n                return Iterators.transform(fromIterable.iterator(), function);\n            }\n        };\n    }\n\n    /**\n     * Returns the element at the specified position in an iterable.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code stream.skip(position).findFirst().get()} (throws\n     * {@code NoSuchElementException} if out of bounds)\n     *\n     * @param position position of the element to return\n     * @return the element at the specified position in {@code iterable}\n     * @throws IndexOutOfBoundsException if {@code position} is negative or greater than or equal to\n     *     the size of {@code iterable}\n     */\n    public static <T> T get(Iterable<T> iterable, int position)\n    {\n        checkNotNull(iterable);\n        return (iterable instanceof List)\n               ? ((List<T>) iterable).get(position)\n               : Iterators.get(iterable.iterator(), position);\n    }\n\n    /**\n     * Returns the element at the specified position in an iterable or a default value otherwise.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code\n     * stream.skip(position).findFirst().orElse(defaultValue)} (returns the default value if the index\n     * is out of bounds)\n     *\n     * @param position position of the element to return\n     * @param defaultValue the default value to return if {@code position} is greater than or equal to\n     *     the size of the iterable\n     * @return the element at the specified position in {@code iterable} or {@code defaultValue} if\n     *     {@code iterable} contains fewer than {@code position + 1} elements.\n     * @throws IndexOutOfBoundsException if {@code position} is negative\n     * @since 4.0\n     */\n    @NullableDecl\n    public static <T> T get(\n        Iterable<? extends T> iterable, int position, @NullableDecl T defaultValue)\n    {\n        checkNotNull(iterable);\n        Iterators.checkNonnegative(position);\n        if (iterable instanceof List)\n        {\n            List<? extends T> list = Lists.cast(iterable);\n            return (position < list.size()) ? list.get(position) : defaultValue;\n        }\n        else\n        {\n            Iterator<? extends T> iterator = iterable.iterator();\n            Iterators.advance(iterator, position);\n            return Iterators.getNext(iterator, defaultValue);\n        }\n    }\n\n    /**\n     * Returns the first element in {@code iterable} or {@code defaultValue} if the iterable is empty.\n     * The {@link Iterators} analog to this method is {@link Iterators#getNext}.\n     *\n     * <p>If no default value is desired (and the caller instead wants a {@link\n     * NoSuchElementException} to be thrown), it is recommended that {@code\n     * iterable.iterator().next()} is used instead.\n     *\n     * <p>To get the only element in a single-element {@code Iterable}, consider using {@link\n     * #getOnlyElement(Iterable)} or {@link #getOnlyElement(Iterable, Object)} instead.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code stream.findFirst().orElse(defaultValue)}\n     *\n     * @param defaultValue the default value to return if the iterable is empty\n     * @return the first element of {@code iterable} or the default value\n     * @since 7.0\n     */\n    @NullableDecl\n    public static <T> T getFirst(Iterable<? extends T> iterable, @NullableDecl T defaultValue)\n    {\n        return Iterators.getNext(iterable.iterator(), defaultValue);\n    }\n\n    /**\n     * Returns the last element of {@code iterable}. If {@code iterable} is a {@link List} with {@link\n     * RandomAccess} support, then this operation is guaranteed to be {@code O(1)}.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link Streams#findLast Streams.findLast(stream).get()}\n     *\n     * @return the last element of {@code iterable}\n     * @throws NoSuchElementException if the iterable is empty\n     */\n    public static <T> T getLast(Iterable<T> iterable)\n    {\n        // TODO(kevinb): Support a concurrently modified collection?\n        if (iterable instanceof List)\n        {\n            List<T> list = (List<T>) iterable;\n            if (list.isEmpty())\n            {\n                throw new NoSuchElementException();\n            }\n            return getLastInNonemptyList(list);\n        }\n\n        return Iterators.getLast(iterable.iterator());\n    }\n\n    /**\n     * Returns the last element of {@code iterable} or {@code defaultValue} if the iterable is empty.\n     * If {@code iterable} is a {@link List} with {@link RandomAccess} support, then this operation is\n     * guaranteed to be {@code O(1)}.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code Streams.findLast(stream).orElse(defaultValue)}\n     *\n     * @param defaultValue the value to return if {@code iterable} is empty\n     * @return the last element of {@code iterable} or the default value\n     * @since 3.0\n     */\n    @NullableDecl\n    public static <T> T getLast(Iterable<? extends T> iterable, @NullableDecl T defaultValue)\n    {\n        if (iterable instanceof Collection)\n        {\n            Collection<? extends T> c = Collections2.cast(iterable);\n            if (c.isEmpty())\n            {\n                return defaultValue;\n            }\n            else if (iterable instanceof List)\n            {\n                return getLastInNonemptyList(Lists.cast(iterable));\n            }\n        }\n\n        return Iterators.getLast(iterable.iterator(), defaultValue);\n    }\n\n    private static <T> T getLastInNonemptyList(List<T> list)\n    {\n        return list.get(list.size() - 1);\n    }\n\n    /**\n     * Returns a view of {@code iterable} that skips its first {@code numberToSkip} elements. If\n     * {@code iterable} contains fewer than {@code numberToSkip} elements, the returned iterable skips\n     * all of its elements.\n     *\n     * <p>Modifications to the underlying {@link Iterable} before a call to {@code iterator()} are\n     * reflected in the returned iterator. That is, the iterator skips the first {@code numberToSkip}\n     * elements that exist when the {@code Iterator} is created, not when {@code skip()} is called.\n     *\n     * <p>The returned iterable's iterator supports {@code remove()} if the iterator of the underlying\n     * iterable supports it. Note that it is <i>not</i> possible to delete the last skipped element by\n     * immediately calling {@code remove()} on that iterator, as the {@code Iterator} contract states\n     * that a call to {@code remove()} before a call to {@code next()} will throw an {@link\n     * IllegalStateException}.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link Stream#skip}\n     *\n     * @since 3.0\n     */\n    public static <T> Iterable<T> skip(final Iterable<T> iterable, final int numberToSkip)\n    {\n        checkNotNull(iterable);\n        checkArgument(numberToSkip >= 0, \"number to skip cannot be negative\");\n\n        return new FluentIterable<T>()\n        {\n            @Override\n            public Iterator<T> iterator()\n            {\n                if (iterable instanceof List)\n                {\n                    final List<T> list = (List<T>) iterable;\n                    int toSkip = Math.min(list.size(), numberToSkip);\n                    return list.subList(toSkip, list.size()).iterator();\n                }\n                final Iterator<T> iterator = iterable.iterator();\n\n                Iterators.advance(iterator, numberToSkip);\n\n                /*\n                 * We can't just return the iterator because an immediate call to its\n                 * remove() method would remove one of the skipped elements instead of\n                 * throwing an IllegalStateException.\n                 */\n                return new Iterator<T>()\n                {\n                    boolean atStart = true;\n\n                    @Override\n                    public boolean hasNext()\n                    {\n                        return iterator.hasNext();\n                    }\n\n                    @Override\n                    public T next()\n                    {\n                        T result = iterator.next();\n                        atStart = false; // not called if next() fails\n                        return result;\n                    }\n\n                    @Override\n                    public void remove()\n                    {\n                        checkRemove(!atStart);\n                        iterator.remove();\n                    }\n                };\n            }\n        };\n    }\n\n    /**\n     * Returns a view of {@code iterable} containing its first {@code limitSize} elements. If {@code\n     * iterable} contains fewer than {@code limitSize} elements, the returned view contains all of its\n     * elements. The returned iterable's iterator supports {@code remove()} if {@code iterable}'s\n     * iterator does.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link Stream#limit}\n     *\n     * @param iterable the iterable to limit\n     * @param limitSize the maximum number of elements in the returned iterable\n     * @throws IllegalArgumentException if {@code limitSize} is negative\n     * @since 3.0\n     */\n    public static <T> Iterable<T> limit(final Iterable<T> iterable, final int limitSize)\n    {\n        checkNotNull(iterable);\n        checkArgument(limitSize >= 0, \"limit is negative\");\n        return new FluentIterable<T>()\n        {\n            @Override\n            public Iterator<T> iterator()\n            {\n                return Iterators.limit(iterable.iterator(), limitSize);\n            }\n        };\n    }\n\n    /**\n     * Returns a view of the supplied iterable that wraps each generated {@link Iterator} through\n     * {@link Iterators#consumingIterator(Iterator)}.\n     *\n     * <p>Note: If {@code iterable} is a {@link Queue}, the returned iterable will get entries from\n     * {@link Queue#remove()} since {@link Queue}'s iteration order is undefined. Calling {@link\n     * Iterator#hasNext()} on a generated iterator from the returned iterable may cause an item to be\n     * immediately dequeued for return on a subsequent call to {@link Iterator#next()}.\n     *\n     * @param iterable the iterable to wrap\n     * @return a view of the supplied iterable that wraps each generated iterator through {@link\n     *     Iterators#consumingIterator(Iterator)}; for queues, an iterable that generates iterators\n     *     that return and consume the queue's elements in queue order\n     * @see Iterators#consumingIterator(Iterator)\n     * @since 2.0\n     */\n    public static <T> Iterable<T> consumingIterable(final Iterable<T> iterable)\n    {\n        checkNotNull(iterable);\n\n        return new FluentIterable<T>()\n        {\n            @Override\n            public Iterator<T> iterator()\n            {\n                return (iterable instanceof Queue)\n                       ? new ConsumingQueueIterator<>((Queue<T>) iterable)\n                       : Iterators.consumingIterator(iterable.iterator());\n            }\n\n            @Override\n            public String toString()\n            {\n                return \"Iterables.consumingIterable(...)\";\n            }\n        };\n    }\n\n    // Methods only in Iterables, not in Iterators\n\n    /**\n     * Determines if the given iterable contains no elements.\n     *\n     * <p>There is no precise {@link Iterator} equivalent to this method, since one can only ask an\n     * iterator whether it has any elements <i>remaining</i> (which one does using {@link\n     * Iterator#hasNext}).\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code !stream.findAny().isPresent()}\n     *\n     * @return {@code true} if the iterable contains no elements\n     */\n    public static boolean isEmpty(Iterable<?> iterable)\n    {\n        if (iterable instanceof Collection)\n        {\n            return ((Collection<?>) iterable).isEmpty();\n        }\n        return !iterable.iterator().hasNext();\n    }\n\n    /**\n     * Returns an iterable over the merged contents of all given {@code iterables}. Equivalent entries\n     * will not be de-duplicated.\n     *\n     * <p>Callers must ensure that the source {@code iterables} are in non-descending order as this\n     * method does not sort its input.\n     *\n     * <p>For any equivalent elements across all {@code iterables}, it is undefined which element is\n     * returned first.\n     *\n     * @since 11.0\n     */\n    @Beta\n    public static <T> Iterable<T> mergeSorted(\n        final Iterable<? extends Iterable<? extends T>> iterables,\n        final Comparator<? super T> comparator)\n    {\n        checkNotNull(iterables, \"iterables\");\n        checkNotNull(comparator, \"comparator\");\n        Iterable<T> iterable =\n            new FluentIterable<T>()\n        {\n            @Override\n            public Iterator<T> iterator()\n            {\n                return Iterators.mergeSorted(\n                           Iterables.transform(iterables, Iterables.<T>toIterator()), comparator);\n            }\n        };\n        return new UnmodifiableIterable<>(iterable);\n    }\n\n    // TODO(user): Is this the best place for this? Move to fluent functions?\n    // Useful as a public method?\n    static <T> Function<Iterable<? extends T>, Iterator<? extends T>> toIterator()\n    {\n        return new Function<Iterable<? extends T>, Iterator<? extends T>>()\n        {\n            @Override\n            public Iterator<? extends T> apply(Iterable<? extends T> iterable)\n            {\n                return iterable.iterator();\n            }\n        };\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/Iterables.java", "func_name": "Iterables.isEmpty", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Determines if the given iterable contains no elements.\n\n<p>There is no precise {@link Iterator} equivalent to this method, since one can only ask an\niterator whether it has any elements <i>remaining</i> (which one does using {@link\nIterator#hasNext}).\n\n<p><b>{@code Stream} equivalent:</b> {@code !stream.findAny().isPresent()}\n\n@return {@code true} if the iterable contains no elements", "docstring_tokens": ["Determines", "if", "the", "given", "iterable", "contains", "no", "elements", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/Iterables.java#L980-L985", "partition": "valid", "up_fun_num": 49, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.collect.CollectPreconditions.checkRemove;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.Function;", "import com.google.common.base.Optional;", "import com.google.common.base.Predicate;", "import com.google.common.base.Predicates;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.util.Collection;", "import java.util.Comparator;", "import java.util.Iterator;", "import java.util.List;", "import java.util.NoSuchElementException;", "import java.util.Queue;", "import java.util.RandomAccess;", "import java.util.Set;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Iterables\n", "    public static <T> Iterable<T> unmodifiableIterable(final Iterable<? extends T> iterable)\n", "    public static <E> Iterable<E> unmodifiableIterable(ImmutableCollection<E> iterable)\n", "    public static int size(Iterable<?> iterable)\n", "    public static boolean contains(Iterable<?> iterable, @NullableDecl Object element)\n", "    public static boolean removeAll(Iterable<?> removeFrom, Collection<?> elementsToRemove)\n", "    public static boolean retainAll(Iterable<?> removeFrom, Collection<?> elementsToRetain)\n", "    public static <T> boolean removeIf(Iterable<T> removeFrom, Predicate<? super T> predicate)\n", "    private static <T> boolean removeIfFromRandomAccessList(\n", "    private static <T> void slowRemoveIfForRemainingElements(\n", "    static <T> T removeFirstMatching(Iterable<T> removeFrom, Predicate<? super T> predicate)\n", "    public static boolean elementsEqual(Iterable<?> iterable1, Iterable<?> iterable2)\n", "    public static String toString(Iterable<?> iterable)\n", "    public static <T> T getOnlyElement(Iterable<T> iterable)\n", "    public static <T> T getOnlyElement(Iterable<? extends T> iterable, @NullableDecl T defaultValue)\n", "    public static <T> T[] toArray(Iterable<? extends T> iterable, Class<T> type)\n", "    static <T> T[] toArray(Iterable<? extends T> iterable, T[] array)\n", "    static Object[] toArray(Iterable<?> iterable)\n", "    private static <E> Collection<E> castOrCopyToCollection(Iterable<E> iterable)\n", "    public static <T> boolean addAll(Collection<T> addTo, Iterable<? extends T> elementsToAdd)\n", "    public static int frequency(Iterable<?> iterable, @NullableDecl Object element)\n", "    public static <T> Iterable<T> cycle(final Iterable<T> iterable)\n", "    public static <T> Iterable<T> cycle(T... elements)\n", "    public static <T> Iterable<T> concat(Iterable<? extends T> a, Iterable<? extends T> b)\n", "    public static <T> Iterable<T> concat(\n", "    public static <T> Iterable<T> concat(\n", "    public static <T> Iterable<T> concat(Iterable<? extends T>... inputs)\n", "    public static <T> Iterable<T> concat(Iterable<? extends Iterable<? extends T>> inputs)\n", "    public static <T> Iterable<List<T>> partition(final Iterable<T> iterable, final int size)\n", "    public static <T> Iterable<List<T>> paddedPartition(final Iterable<T> iterable, final int size)\n", "    public static <T> Iterable<T> filter(\n", "    public static <T> Iterable<T> filter(final Iterable<?> unfiltered, final Class<T> desiredType)\n", "    public static <T> boolean any(Iterable<T> iterable, Predicate<? super T> predicate)\n", "    public static <T> boolean all(Iterable<T> iterable, Predicate<? super T> predicate)\n", "    public static <T> T find(Iterable<T> iterable, Predicate<? super T> predicate)\n", "    public static <T> T find(\n", "    public static <T> Optional<T> tryFind(Iterable<T> iterable, Predicate<? super T> predicate)\n", "    public static <T> int indexOf(Iterable<T> iterable, Predicate<? super T> predicate)\n", "    public static <F, T> Iterable<T> transform(\n", "    public static <T> T get(Iterable<T> iterable, int position)\n", "    public static <T> T get(\n", "    public static <T> T getFirst(Iterable<? extends T> iterable, @NullableDecl T defaultValue)\n", "    public static <T> T getLast(Iterable<T> iterable)\n", "    public static <T> T getLast(Iterable<? extends T> iterable, @NullableDecl T defaultValue)\n", "    private static <T> T getLastInNonemptyList(List<T> list)\n", "    public static <T> Iterable<T> skip(final Iterable<T> iterable, final int numberToSkip)\n", "    public static <T> Iterable<T> limit(final Iterable<T> iterable, final int limitSize)\n", "    public static <T> Iterable<T> consumingIterable(final Iterable<T> iterable)\n", "    public static <T> Iterable<T> mergeSorted(\n", "    static <T> Function<Iterable<? extends T>, Iterator<? extends T>> toIterator()\n"], "context": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.collect.CollectPreconditions.checkRemove;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Function;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Queue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * An assortment of mainly legacy static utility methods that operate on or return objects of type\n * {@code Iterable}. Except as noted, each method has a corresponding {@link Iterator}-based method\n * in the {@link Iterators} class.\n *\n * <p><b>Java 8 users:</b> several common uses for this class are now more comprehensively addressed\n * by the new {@link java.util.stream.Stream} library. Read the method documentation below for\n * comparisons. This class is not being deprecated, but we gently encourage you to migrate to\n * streams.\n *\n * <p><i>Performance notes:</i> Unless otherwise noted, all of the iterables produced in this class\n * are <i>lazy</i>, which means that their iterators only advance the backing iteration when\n * absolutely necessary.\n *\n * <p>See the Guava User Guide article on <a href=\n * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#iterables\"> {@code\n * Iterables}</a>.\n *\n * @author Kevin Bourrillion\n * @author Jared Levy\n * @since 2.0\n */\n@GwtCompatible(emulated = true)\npublic final class Iterables\n{\n    private Iterables() {}\n\n    /** Returns an unmodifiable view of {@code iterable}. */\n    public static <T> Iterable<T> unmodifiableIterable(final Iterable<? extends T> iterable)\n    {\n        checkNotNull(iterable);\n        if (iterable instanceof UnmodifiableIterable || iterable instanceof ImmutableCollection)\n        {\n            @SuppressWarnings(\"unchecked\") // Since it's unmodifiable, the covariant cast is safe\n            Iterable<T> result = (Iterable<T>) iterable;\n            return result;\n        }\n        return new UnmodifiableIterable<>(iterable);\n    }\n\n    /**\n     * Simply returns its argument.\n     *\n     * @deprecated no need to use this\n     * @since 10.0\n     */\n    @Deprecated\n    public static <E> Iterable<E> unmodifiableIterable(ImmutableCollection<E> iterable)\n    {\n        return checkNotNull(iterable);\n    }\n\n    private static final class UnmodifiableIterable<T> extends FluentIterable<T>\n    {\n        private final Iterable<? extends T> iterable;\n\n        private UnmodifiableIterable(Iterable<? extends T> iterable)\n        {\n            this.iterable = iterable;\n        }\n\n        @Override\n        public Iterator<T> iterator()\n        {\n            return Iterators.unmodifiableIterator(iterable.iterator());\n        }\n\n        @Override\n        public String toString()\n        {\n            return iterable.toString();\n        }\n        // no equals and hashCode; it would break the contract!\n    }\n\n    /** Returns the number of elements in {@code iterable}. */\n    public static int size(Iterable<?> iterable)\n    {\n        return (iterable instanceof Collection)\n               ? ((Collection<?>) iterable).size()\n               : Iterators.size(iterable.iterator());\n    }\n\n    /**\n     * Returns {@code true} if {@code iterable} contains any element {@code o} for which {@code\n     * Objects.equals(o, element)} would return {@code true}. Otherwise returns {@code false}, even in\n     * cases where {@link Collection#contains} might throw {@link NullPointerException} or {@link\n     * ClassCastException}.\n     */\n    public static boolean contains(Iterable<?> iterable, @NullableDecl Object element)\n    {\n        if (iterable instanceof Collection)\n        {\n            Collection<?> collection = (Collection<?>) iterable;\n            return Collections2.safeContains(collection, element);\n        }\n        return Iterators.contains(iterable.iterator(), element);\n    }\n\n    /**\n     * Removes, from an iterable, every element that belongs to the provided collection.\n     *\n     * <p>This method calls {@link Collection#removeAll} if {@code iterable} is a collection, and\n     * {@link Iterators#removeAll} otherwise.\n     *\n     * @param removeFrom the iterable to (potentially) remove elements from\n     * @param elementsToRemove the elements to remove\n     * @return {@code true} if any element was removed from {@code iterable}\n     */\n    @CanIgnoreReturnValue\n    public static boolean removeAll(Iterable<?> removeFrom, Collection<?> elementsToRemove)\n    {\n        return (removeFrom instanceof Collection)\n               ? ((Collection<?>) removeFrom).removeAll(checkNotNull(elementsToRemove))\n               : Iterators.removeAll(removeFrom.iterator(), elementsToRemove);\n    }\n\n    /**\n     * Removes, from an iterable, every element that does not belong to the provided collection.\n     *\n     * <p>This method calls {@link Collection#retainAll} if {@code iterable} is a collection, and\n     * {@link Iterators#retainAll} otherwise.\n     *\n     * @param removeFrom the iterable to (potentially) remove elements from\n     * @param elementsToRetain the elements to retain\n     * @return {@code true} if any element was removed from {@code iterable}\n     */\n    @CanIgnoreReturnValue\n    public static boolean retainAll(Iterable<?> removeFrom, Collection<?> elementsToRetain)\n    {\n        return (removeFrom instanceof Collection)\n               ? ((Collection<?>) removeFrom).retainAll(checkNotNull(elementsToRetain))\n               : Iterators.retainAll(removeFrom.iterator(), elementsToRetain);\n    }\n\n    /**\n     * Removes, from an iterable, every element that satisfies the provided predicate.\n     *\n     * <p>Removals may or may not happen immediately as each element is tested against the predicate.\n     * The behavior of this method is not specified if {@code predicate} is dependent on {@code\n     * removeFrom}.\n     *\n     * @param removeFrom the iterable to (potentially) remove elements from\n     * @param predicate a predicate that determines whether an element should be removed\n     * @return {@code true} if any elements were removed from the iterable\n     * @throws UnsupportedOperationException if the iterable does not support {@code remove()}.\n     * @since 2.0\n     */\n    @CanIgnoreReturnValue\n    public static <T> boolean removeIf(Iterable<T> removeFrom, Predicate<? super T> predicate)\n    {\n        if (removeFrom instanceof RandomAccess && removeFrom instanceof List)\n        {\n            return removeIfFromRandomAccessList((List<T>) removeFrom, checkNotNull(predicate));\n        }\n        return Iterators.removeIf(removeFrom.iterator(), predicate);\n    }\n\n    private static <T> boolean removeIfFromRandomAccessList(\n        List<T> list, Predicate<? super T> predicate)\n    {\n        // Note: Not all random access lists support set(). Additionally, it's possible\n        // for a list to reject setting an element, such as when the list does not permit\n        // duplicate elements. For both of those cases,  we need to fall back to a slower\n        // implementation.\n        int from = 0;\n        int to = 0;\n\n        for (; from < list.size(); from++)\n        {\n            T element = list.get(from);\n            if (!predicate.apply(element))\n            {\n                if (from > to)\n                {\n                    try\n                    {\n                        list.set(to, element);\n                    }\n                    catch (UnsupportedOperationException e)\n                    {\n                        slowRemoveIfForRemainingElements(list, predicate, to, from);\n                        return true;\n                    }\n                    catch (IllegalArgumentException e)\n                    {\n                        slowRemoveIfForRemainingElements(list, predicate, to, from);\n                        return true;\n                    }\n                }\n                to++;\n            }\n        }\n\n        // Clear the tail of any remaining items\n        list.subList(to, list.size()).clear();\n        return from != to;\n    }\n\n    private static <T> void slowRemoveIfForRemainingElements(\n        List<T> list, Predicate<? super T> predicate, int to, int from)\n    {\n        // Here we know that:\n        // * (to < from) and that both are valid indices.\n        // * Everything with (index < to) should be kept.\n        // * Everything with (to <= index < from) should be removed.\n        // * The element with (index == from) should be kept.\n        // * Everything with (index > from) has not been checked yet.\n\n        // Check from the end of the list backwards (minimize expected cost of\n        // moving elements when remove() is called). Stop before 'from' because\n        // we already know that should be kept.\n        for (int n = list.size() - 1; n > from; n--)\n        {\n            if (predicate.apply(list.get(n)))\n            {\n                list.remove(n);\n            }\n        }\n        // And now remove everything in the range [to, from) (going backwards).\n        for (int n = from - 1; n >= to; n--)\n        {\n            list.remove(n);\n        }\n    }\n\n    /** Removes and returns the first matching element, or returns {@code null} if there is none. */\n    @NullableDecl\n    static <T> T removeFirstMatching(Iterable<T> removeFrom, Predicate<? super T> predicate)\n    {\n        checkNotNull(predicate);\n        Iterator<T> iterator = removeFrom.iterator();\n        while (iterator.hasNext())\n        {\n            T next = iterator.next();\n            if (predicate.apply(next))\n            {\n                iterator.remove();\n                return next;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Determines whether two iterables contain equal elements in the same order. More specifically,\n     * this method returns {@code true} if {@code iterable1} and {@code iterable2} contain the same\n     * number of elements and every element of {@code iterable1} is equal to the corresponding element\n     * of {@code iterable2}.\n     */\n    public static boolean elementsEqual(Iterable<?> iterable1, Iterable<?> iterable2)\n    {\n        if (iterable1 instanceof Collection && iterable2 instanceof Collection)\n        {\n            Collection<?> collection1 = (Collection<?>) iterable1;\n            Collection<?> collection2 = (Collection<?>) iterable2;\n            if (collection1.size() != collection2.size())\n            {\n                return false;\n            }\n        }\n        return Iterators.elementsEqual(iterable1.iterator(), iterable2.iterator());\n    }\n\n    /**\n     * Returns a string representation of {@code iterable}, with the format {@code [e1, e2, ..., en]}\n     * (that is, identical to {@link java.util.Arrays Arrays}{@code\n     * .toString(Iterables.toArray(iterable))}). Note that for <i>most</i> implementations of {@link\n     * Collection}, {@code collection.toString()} also gives the same result, but that behavior is not\n     * generally guaranteed.\n     */\n    public static String toString(Iterable<?> iterable)\n    {\n        return Iterators.toString(iterable.iterator());\n    }\n\n    /**\n     * Returns the single element contained in {@code iterable}.\n     *\n     * <p><b>Java 8 users:</b> the {@code Stream} equivalent to this method is {@code\n     * stream.collect(MoreCollectors.onlyElement())}.\n     *\n     * @throws NoSuchElementException if the iterable is empty\n     * @throws IllegalArgumentException if the iterable contains multiple elements\n     */\n    public static <T> T getOnlyElement(Iterable<T> iterable)\n    {\n        return Iterators.getOnlyElement(iterable.iterator());\n    }\n\n    /**\n     * Returns the single element contained in {@code iterable}, or {@code defaultValue} if the\n     * iterable is empty.\n     *\n     * <p><b>Java 8 users:</b> the {@code Stream} equivalent to this method is {@code\n     * stream.collect(MoreCollectors.toOptional()).orElse(defaultValue)}.\n     *\n     * @throws IllegalArgumentException if the iterator contains multiple elements\n     */\n    @NullableDecl\n    public static <T> T getOnlyElement(Iterable<? extends T> iterable, @NullableDecl T defaultValue)\n    {\n        return Iterators.getOnlyElement(iterable.iterator(), defaultValue);\n    }\n\n    /**\n     * Copies an iterable's elements into an array.\n     *\n     * @param iterable the iterable to copy\n     * @param type the type of the elements\n     * @return a newly-allocated array into which all the elements of the iterable have been copied\n     */\n    @GwtIncompatible // Array.newInstance(Class, int)\n    public static <T> T[] toArray(Iterable<? extends T> iterable, Class<T> type)\n    {\n        return toArray(iterable, ObjectArrays.newArray(type, 0));\n    }\n\n    static <T> T[] toArray(Iterable<? extends T> iterable, T[] array)\n    {\n        Collection<? extends T> collection = castOrCopyToCollection(iterable);\n        return collection.toArray(array);\n    }\n\n    /**\n     * Copies an iterable's elements into an array.\n     *\n     * @param iterable the iterable to copy\n     * @return a newly-allocated array into which all the elements of the iterable have been copied\n     */\n    static Object[] toArray(Iterable<?> iterable)\n    {\n        return castOrCopyToCollection(iterable).toArray();\n    }\n\n    /**\n     * Converts an iterable into a collection. If the iterable is already a collection, it is\n     * returned. Otherwise, an {@link java.util.ArrayList} is created with the contents of the\n     * iterable in the same iteration order.\n     */\n    private static <E> Collection<E> castOrCopyToCollection(Iterable<E> iterable)\n    {\n        return (iterable instanceof Collection)\n               ? (Collection<E>) iterable\n               : Lists.newArrayList(iterable.iterator());\n    }\n\n    /**\n     * Adds all elements in {@code iterable} to {@code collection}.\n     *\n     * @return {@code true} if {@code collection} was modified as a result of this operation.\n     */\n    @CanIgnoreReturnValue\n    public static <T> boolean addAll(Collection<T> addTo, Iterable<? extends T> elementsToAdd)\n    {\n        if (elementsToAdd instanceof Collection)\n        {\n            Collection<? extends T> c = Collections2.cast(elementsToAdd);\n            return addTo.addAll(c);\n        }\n        return Iterators.addAll(addTo, checkNotNull(elementsToAdd).iterator());\n    }\n\n    /**\n     * Returns the number of elements in the specified iterable that equal the specified object. This\n     * implementation avoids a full iteration when the iterable is a {@link Multiset} or {@link Set}.\n     *\n     * <p><b>Java 8 users:</b> In most cases, the {@code Stream} equivalent of this method is {@code\n     * stream.filter(element::equals).count()}. If {@code element} might be null, use {@code\n     * stream.filter(Predicate.isEqual(element)).count()} instead.\n     *\n     * @see java.util.Collections#frequency(Collection, Object) Collections.frequency(Collection,\n     *     Object)\n     */\n    public static int frequency(Iterable<?> iterable, @NullableDecl Object element)\n    {\n        if ((iterable instanceof Multiset))\n        {\n            return ((Multiset<?>) iterable).count(element);\n        }\n        else if ((iterable instanceof Set))\n        {\n            return ((Set<?>) iterable).contains(element) ? 1 : 0;\n        }\n        return Iterators.frequency(iterable.iterator(), element);\n    }\n\n    /**\n     * Returns an iterable whose iterators cycle indefinitely over the elements of {@code iterable}.\n     *\n     * <p>That iterator supports {@code remove()} if {@code iterable.iterator()} does. After {@code\n     * remove()} is called, subsequent cycles omit the removed element, which is no longer in {@code\n     * iterable}. The iterator's {@code hasNext()} method returns {@code true} until {@code iterable}\n     * is empty.\n     *\n     * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You\n     * should use an explicit {@code break} or be certain that you will eventually remove all the\n     * elements.\n     *\n     * <p>To cycle over the iterable {@code n} times, use the following: {@code\n     * Iterables.concat(Collections.nCopies(n, iterable))}\n     *\n     * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code\n     * Stream.generate(() -> iterable).flatMap(Streams::stream)}.\n     */\n    public static <T> Iterable<T> cycle(final Iterable<T> iterable)\n    {\n        checkNotNull(iterable);\n        return new FluentIterable<T>()\n        {\n            @Override\n            public Iterator<T> iterator()\n            {\n                return Iterators.cycle(iterable);\n            }\n\n            @Override\n            public String toString()\n            {\n                return iterable.toString() + \" (cycled)\";\n            }\n        };\n    }\n\n    /**\n     * Returns an iterable whose iterators cycle indefinitely over the provided elements.\n     *\n     * <p>After {@code remove} is invoked on a generated iterator, the removed element will no longer\n     * appear in either that iterator or any other iterator created from the same source iterable.\n     * That is, this method behaves exactly as {@code Iterables.cycle(Lists.newArrayList(elements))}.\n     * The iterator's {@code hasNext} method returns {@code true} until all of the original elements\n     * have been removed.\n     *\n     * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You\n     * should use an explicit {@code break} or be certain that you will eventually remove all the\n     * elements.\n     *\n     * <p>To cycle over the elements {@code n} times, use the following: {@code\n     * Iterables.concat(Collections.nCopies(n, Arrays.asList(elements)))}\n     *\n     * <p><b>Java 8 users:</b> If passing a single element {@code e}, the {@code Stream} equivalent of\n     * this method is {@code Stream.generate(() -> e)}. Otherwise, put the elements in a collection\n     * and use {@code Stream.generate(() -> collection).flatMap(Collection::stream)}.\n     */\n    @SafeVarargs\n    public static <T> Iterable<T> cycle(T... elements)\n    {\n        return cycle(Lists.newArrayList(elements));\n    }\n\n    /**\n     * Combines two iterables into a single iterable. The returned iterable has an iterator that\n     * traverses the elements in {@code a}, followed by the elements in {@code b}. The source\n     * iterators are not polled until necessary.\n     *\n     * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input\n     * iterator supports it.\n     *\n     * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code Stream.concat(a,\n     * b)}.\n     */\n    public static <T> Iterable<T> concat(Iterable<? extends T> a, Iterable<? extends T> b)\n    {\n        return FluentIterable.concat(a, b);\n    }\n\n    /**\n     * Combines three iterables into a single iterable. The returned iterable has an iterator that\n     * traverses the elements in {@code a}, followed by the elements in {@code b}, followed by the\n     * elements in {@code c}. The source iterators are not polled until necessary.\n     *\n     * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input\n     * iterator supports it.\n     *\n     * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code\n     * Streams.concat(a, b, c)}.\n     */\n    public static <T> Iterable<T> concat(\n        Iterable<? extends T> a, Iterable<? extends T> b, Iterable<? extends T> c)\n    {\n        return FluentIterable.concat(a, b, c);\n    }\n\n    /**\n     * Combines four iterables into a single iterable. The returned iterable has an iterator that\n     * traverses the elements in {@code a}, followed by the elements in {@code b}, followed by the\n     * elements in {@code c}, followed by the elements in {@code d}. The source iterators are not\n     * polled until necessary.\n     *\n     * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input\n     * iterator supports it.\n     *\n     * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code\n     * Streams.concat(a, b, c, d)}.\n     */\n    public static <T> Iterable<T> concat(\n        Iterable<? extends T> a,\n        Iterable<? extends T> b,\n        Iterable<? extends T> c,\n        Iterable<? extends T> d)\n    {\n        return FluentIterable.concat(a, b, c, d);\n    }\n\n    /**\n     * Combines multiple iterables into a single iterable. The returned iterable has an iterator that\n     * traverses the elements of each iterable in {@code inputs}. The input iterators are not polled\n     * until necessary.\n     *\n     * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input\n     * iterator supports it.\n     *\n     * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code\n     * Streams.concat(...)}.\n     *\n     * @throws NullPointerException if any of the provided iterables is null\n     */\n    @SafeVarargs\n    public static <T> Iterable<T> concat(Iterable<? extends T>... inputs)\n    {\n        return FluentIterable.concat(inputs);\n    }\n\n    /**\n     * Combines multiple iterables into a single iterable. The returned iterable has an iterator that\n     * traverses the elements of each iterable in {@code inputs}. The input iterators are not polled\n     * until necessary.\n     *\n     * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input\n     * iterator supports it. The methods of the returned iterable may throw {@code\n     * NullPointerException} if any of the input iterators is null.\n     *\n     * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code\n     * streamOfStreams.flatMap(s -> s)}.\n     */\n    public static <T> Iterable<T> concat(Iterable<? extends Iterable<? extends T>> inputs)\n    {\n        return FluentIterable.concat(inputs);\n    }\n\n    /**\n     * Divides an iterable into unmodifiable sublists of the given size (the final iterable may be\n     * smaller). For example, partitioning an iterable containing {@code [a, b, c, d, e]} with a\n     * partition size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer iterable containing two\n     * inner lists of three and two elements, all in the original order.\n     *\n     * <p>Iterators returned by the returned iterable do not support the {@link Iterator#remove()}\n     * method. The returned lists implement {@link RandomAccess}, whether or not the input list does.\n     *\n     * <p><b>Note:</b> if {@code iterable} is a {@link List}, use {@link Lists#partition(List, int)}\n     * instead.\n     *\n     * @param iterable the iterable to return a partitioned view of\n     * @param size the desired size of each partition (the last may be smaller)\n     * @return an iterable of unmodifiable lists containing the elements of {@code iterable} divided\n     *     into partitions\n     * @throws IllegalArgumentException if {@code size} is nonpositive\n     */\n    public static <T> Iterable<List<T>> partition(final Iterable<T> iterable, final int size)\n    {\n        checkNotNull(iterable);\n        checkArgument(size > 0);\n        return new FluentIterable<List<T>>()\n        {\n            @Override\n            public Iterator<List<T>> iterator()\n            {\n                return Iterators.partition(iterable.iterator(), size);\n            }\n        };\n    }\n\n    /**\n     * Divides an iterable into unmodifiable sublists of the given size, padding the final iterable\n     * with null values if necessary. For example, partitioning an iterable containing {@code [a, b,\n     * c, d, e]} with a partition size of 3 yields {@code [[a, b, c], [d, e, null]]} -- an outer\n     * iterable containing two inner lists of three elements each, all in the original order.\n     *\n     * <p>Iterators returned by the returned iterable do not support the {@link Iterator#remove()}\n     * method.\n     *\n     * @param iterable the iterable to return a partitioned view of\n     * @param size the desired size of each partition\n     * @return an iterable of unmodifiable lists containing the elements of {@code iterable} divided\n     *     into partitions (the final iterable may have trailing null elements)\n     * @throws IllegalArgumentException if {@code size} is nonpositive\n     */\n    public static <T> Iterable<List<T>> paddedPartition(final Iterable<T> iterable, final int size)\n    {\n        checkNotNull(iterable);\n        checkArgument(size > 0);\n        return new FluentIterable<List<T>>()\n        {\n            @Override\n            public Iterator<List<T>> iterator()\n            {\n                return Iterators.paddedPartition(iterable.iterator(), size);\n            }\n        };\n    }\n\n    /**\n     * Returns a view of {@code unfiltered} containing all elements that satisfy the input predicate\n     * {@code retainIfTrue}. The returned iterable's iterator does not support {@code remove()}.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link Stream#filter}.\n     */\n    public static <T> Iterable<T> filter(\n        final Iterable<T> unfiltered, final Predicate<? super T> retainIfTrue)\n    {\n        checkNotNull(unfiltered);\n        checkNotNull(retainIfTrue);\n        return new FluentIterable<T>()\n        {\n            @Override\n            public Iterator<T> iterator()\n            {\n                return Iterators.filter(unfiltered.iterator(), retainIfTrue);\n            }\n        };\n    }\n\n    /**\n     * Returns a view of {@code unfiltered} containing all elements that are of the type {@code\n     * desiredType}. The returned iterable's iterator does not support {@code remove()}.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(type::isInstance).map(type::cast)}.\n     * This does perform a little more work than necessary, so another option is to insert an\n     * unchecked cast at some later point:\n     *\n     * <pre>\n     * {@code @SuppressWarnings(\"unchecked\") // safe because of ::isInstance check\n     * ImmutableList<NewType> result =\n     *     (ImmutableList) stream.filter(NewType.class::isInstance).collect(toImmutableList());}\n     * </pre>\n     */\n    @SuppressWarnings(\"unchecked\")\n    @GwtIncompatible // Class.isInstance\n    public static <T> Iterable<T> filter(final Iterable<?> unfiltered, final Class<T> desiredType)\n    {\n        checkNotNull(unfiltered);\n        checkNotNull(desiredType);\n        return (Iterable<T>) filter(unfiltered, Predicates.instanceOf(desiredType));\n    }\n\n    /**\n     * Returns {@code true} if any element in {@code iterable} satisfies the predicate.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link Stream#anyMatch}.\n     */\n    public static <T> boolean any(Iterable<T> iterable, Predicate<? super T> predicate)\n    {\n        return Iterators.any(iterable.iterator(), predicate);\n    }\n\n    /**\n     * Returns {@code true} if every element in {@code iterable} satisfies the predicate. If {@code\n     * iterable} is empty, {@code true} is returned.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link Stream#allMatch}.\n     */\n    public static <T> boolean all(Iterable<T> iterable, Predicate<? super T> predicate)\n    {\n        return Iterators.all(iterable.iterator(), predicate);\n    }\n\n    /**\n     * Returns the first element in {@code iterable} that satisfies the given predicate; use this\n     * method only when such an element is known to exist. If it is possible that <i>no</i> element\n     * will match, use {@link #tryFind} or {@link #find(Iterable, Predicate, Object)} instead.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate).findFirst().get()}\n     *\n     * @throws NoSuchElementException if no element in {@code iterable} matches the given predicate\n     */\n    public static <T> T find(Iterable<T> iterable, Predicate<? super T> predicate)\n    {\n        return Iterators.find(iterable.iterator(), predicate);\n    }\n\n    /**\n     * Returns the first element in {@code iterable} that satisfies the given predicate, or {@code\n     * defaultValue} if none found. Note that this can usually be handled more naturally using {@code\n     * tryFind(iterable, predicate).or(defaultValue)}.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code\n     * stream.filter(predicate).findFirst().orElse(defaultValue)}\n     *\n     * @since 7.0\n     */\n    @NullableDecl\n    public static <T> T find(\n        Iterable<? extends T> iterable,\n        Predicate<? super T> predicate,\n        @NullableDecl T defaultValue)\n    {\n        return Iterators.find(iterable.iterator(), predicate, defaultValue);\n    }\n\n    /**\n     * Returns an {@link Optional} containing the first element in {@code iterable} that satisfies the\n     * given predicate, if such an element exists.\n     *\n     * <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code null}. If {@code null}\n     * is matched in {@code iterable}, a NullPointerException will be thrown.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate).findFirst()}\n     *\n     * @since 11.0\n     */\n    public static <T> Optional<T> tryFind(Iterable<T> iterable, Predicate<? super T> predicate)\n    {\n        return Iterators.tryFind(iterable.iterator(), predicate);\n    }\n\n    /**\n     * Returns the index in {@code iterable} of the first element that satisfies the provided {@code\n     * predicate}, or {@code -1} if the Iterable has no such elements.\n     *\n     * <p>More formally, returns the lowest index {@code i} such that {@code\n     * predicate.apply(Iterables.get(iterable, i))} returns {@code true}, or {@code -1} if there is no\n     * such index.\n     *\n     * @since 2.0\n     */\n    public static <T> int indexOf(Iterable<T> iterable, Predicate<? super T> predicate)\n    {\n        return Iterators.indexOf(iterable.iterator(), predicate);\n    }\n\n    /**\n     * Returns a view containing the result of applying {@code function} to each element of {@code\n     * fromIterable}.\n     *\n     * <p>The returned iterable's iterator supports {@code remove()} if {@code fromIterable}'s\n     * iterator does. After a successful {@code remove()} call, {@code fromIterable} no longer\n     * contains the corresponding element.\n     *\n     * <p>If the input {@code Iterable} is known to be a {@code List} or other {@code Collection},\n     * consider {@link Lists#transform} and {@link Collections2#transform}.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link Stream#map}\n     */\n    public static <F, T> Iterable<T> transform(\n        final Iterable<F> fromIterable, final Function<? super F, ? extends T> function)\n    {\n        checkNotNull(fromIterable);\n        checkNotNull(function);\n        return new FluentIterable<T>()\n        {\n            @Override\n            public Iterator<T> iterator()\n            {\n                return Iterators.transform(fromIterable.iterator(), function);\n            }\n        };\n    }\n\n    /**\n     * Returns the element at the specified position in an iterable.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code stream.skip(position).findFirst().get()} (throws\n     * {@code NoSuchElementException} if out of bounds)\n     *\n     * @param position position of the element to return\n     * @return the element at the specified position in {@code iterable}\n     * @throws IndexOutOfBoundsException if {@code position} is negative or greater than or equal to\n     *     the size of {@code iterable}\n     */\n    public static <T> T get(Iterable<T> iterable, int position)\n    {\n        checkNotNull(iterable);\n        return (iterable instanceof List)\n               ? ((List<T>) iterable).get(position)\n               : Iterators.get(iterable.iterator(), position);\n    }\n\n    /**\n     * Returns the element at the specified position in an iterable or a default value otherwise.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code\n     * stream.skip(position).findFirst().orElse(defaultValue)} (returns the default value if the index\n     * is out of bounds)\n     *\n     * @param position position of the element to return\n     * @param defaultValue the default value to return if {@code position} is greater than or equal to\n     *     the size of the iterable\n     * @return the element at the specified position in {@code iterable} or {@code defaultValue} if\n     *     {@code iterable} contains fewer than {@code position + 1} elements.\n     * @throws IndexOutOfBoundsException if {@code position} is negative\n     * @since 4.0\n     */\n    @NullableDecl\n    public static <T> T get(\n        Iterable<? extends T> iterable, int position, @NullableDecl T defaultValue)\n    {\n        checkNotNull(iterable);\n        Iterators.checkNonnegative(position);\n        if (iterable instanceof List)\n        {\n            List<? extends T> list = Lists.cast(iterable);\n            return (position < list.size()) ? list.get(position) : defaultValue;\n        }\n        else\n        {\n            Iterator<? extends T> iterator = iterable.iterator();\n            Iterators.advance(iterator, position);\n            return Iterators.getNext(iterator, defaultValue);\n        }\n    }\n\n    /**\n     * Returns the first element in {@code iterable} or {@code defaultValue} if the iterable is empty.\n     * The {@link Iterators} analog to this method is {@link Iterators#getNext}.\n     *\n     * <p>If no default value is desired (and the caller instead wants a {@link\n     * NoSuchElementException} to be thrown), it is recommended that {@code\n     * iterable.iterator().next()} is used instead.\n     *\n     * <p>To get the only element in a single-element {@code Iterable}, consider using {@link\n     * #getOnlyElement(Iterable)} or {@link #getOnlyElement(Iterable, Object)} instead.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code stream.findFirst().orElse(defaultValue)}\n     *\n     * @param defaultValue the default value to return if the iterable is empty\n     * @return the first element of {@code iterable} or the default value\n     * @since 7.0\n     */\n    @NullableDecl\n    public static <T> T getFirst(Iterable<? extends T> iterable, @NullableDecl T defaultValue)\n    {\n        return Iterators.getNext(iterable.iterator(), defaultValue);\n    }\n\n    /**\n     * Returns the last element of {@code iterable}. If {@code iterable} is a {@link List} with {@link\n     * RandomAccess} support, then this operation is guaranteed to be {@code O(1)}.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link Streams#findLast Streams.findLast(stream).get()}\n     *\n     * @return the last element of {@code iterable}\n     * @throws NoSuchElementException if the iterable is empty\n     */\n    public static <T> T getLast(Iterable<T> iterable)\n    {\n        // TODO(kevinb): Support a concurrently modified collection?\n        if (iterable instanceof List)\n        {\n            List<T> list = (List<T>) iterable;\n            if (list.isEmpty())\n            {\n                throw new NoSuchElementException();\n            }\n            return getLastInNonemptyList(list);\n        }\n\n        return Iterators.getLast(iterable.iterator());\n    }\n\n    /**\n     * Returns the last element of {@code iterable} or {@code defaultValue} if the iterable is empty.\n     * If {@code iterable} is a {@link List} with {@link RandomAccess} support, then this operation is\n     * guaranteed to be {@code O(1)}.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code Streams.findLast(stream).orElse(defaultValue)}\n     *\n     * @param defaultValue the value to return if {@code iterable} is empty\n     * @return the last element of {@code iterable} or the default value\n     * @since 3.0\n     */\n    @NullableDecl\n    public static <T> T getLast(Iterable<? extends T> iterable, @NullableDecl T defaultValue)\n    {\n        if (iterable instanceof Collection)\n        {\n            Collection<? extends T> c = Collections2.cast(iterable);\n            if (c.isEmpty())\n            {\n                return defaultValue;\n            }\n            else if (iterable instanceof List)\n            {\n                return getLastInNonemptyList(Lists.cast(iterable));\n            }\n        }\n\n        return Iterators.getLast(iterable.iterator(), defaultValue);\n    }\n\n    private static <T> T getLastInNonemptyList(List<T> list)\n    {\n        return list.get(list.size() - 1);\n    }\n\n    /**\n     * Returns a view of {@code iterable} that skips its first {@code numberToSkip} elements. If\n     * {@code iterable} contains fewer than {@code numberToSkip} elements, the returned iterable skips\n     * all of its elements.\n     *\n     * <p>Modifications to the underlying {@link Iterable} before a call to {@code iterator()} are\n     * reflected in the returned iterator. That is, the iterator skips the first {@code numberToSkip}\n     * elements that exist when the {@code Iterator} is created, not when {@code skip()} is called.\n     *\n     * <p>The returned iterable's iterator supports {@code remove()} if the iterator of the underlying\n     * iterable supports it. Note that it is <i>not</i> possible to delete the last skipped element by\n     * immediately calling {@code remove()} on that iterator, as the {@code Iterator} contract states\n     * that a call to {@code remove()} before a call to {@code next()} will throw an {@link\n     * IllegalStateException}.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link Stream#skip}\n     *\n     * @since 3.0\n     */\n    public static <T> Iterable<T> skip(final Iterable<T> iterable, final int numberToSkip)\n    {\n        checkNotNull(iterable);\n        checkArgument(numberToSkip >= 0, \"number to skip cannot be negative\");\n\n        return new FluentIterable<T>()\n        {\n            @Override\n            public Iterator<T> iterator()\n            {\n                if (iterable instanceof List)\n                {\n                    final List<T> list = (List<T>) iterable;\n                    int toSkip = Math.min(list.size(), numberToSkip);\n                    return list.subList(toSkip, list.size()).iterator();\n                }\n                final Iterator<T> iterator = iterable.iterator();\n\n                Iterators.advance(iterator, numberToSkip);\n\n                /*\n                 * We can't just return the iterator because an immediate call to its\n                 * remove() method would remove one of the skipped elements instead of\n                 * throwing an IllegalStateException.\n                 */\n                return new Iterator<T>()\n                {\n                    boolean atStart = true;\n\n                    @Override\n                    public boolean hasNext()\n                    {\n                        return iterator.hasNext();\n                    }\n\n                    @Override\n                    public T next()\n                    {\n                        T result = iterator.next();\n                        atStart = false; // not called if next() fails\n                        return result;\n                    }\n\n                    @Override\n                    public void remove()\n                    {\n                        checkRemove(!atStart);\n                        iterator.remove();\n                    }\n                };\n            }\n        };\n    }\n\n    /**\n     * Returns a view of {@code iterable} containing its first {@code limitSize} elements. If {@code\n     * iterable} contains fewer than {@code limitSize} elements, the returned view contains all of its\n     * elements. The returned iterable's iterator supports {@code remove()} if {@code iterable}'s\n     * iterator does.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link Stream#limit}\n     *\n     * @param iterable the iterable to limit\n     * @param limitSize the maximum number of elements in the returned iterable\n     * @throws IllegalArgumentException if {@code limitSize} is negative\n     * @since 3.0\n     */\n    public static <T> Iterable<T> limit(final Iterable<T> iterable, final int limitSize)\n    {\n        checkNotNull(iterable);\n        checkArgument(limitSize >= 0, \"limit is negative\");\n        return new FluentIterable<T>()\n        {\n            @Override\n            public Iterator<T> iterator()\n            {\n                return Iterators.limit(iterable.iterator(), limitSize);\n            }\n        };\n    }\n\n    /**\n     * Returns a view of the supplied iterable that wraps each generated {@link Iterator} through\n     * {@link Iterators#consumingIterator(Iterator)}.\n     *\n     * <p>Note: If {@code iterable} is a {@link Queue}, the returned iterable will get entries from\n     * {@link Queue#remove()} since {@link Queue}'s iteration order is undefined. Calling {@link\n     * Iterator#hasNext()} on a generated iterator from the returned iterable may cause an item to be\n     * immediately dequeued for return on a subsequent call to {@link Iterator#next()}.\n     *\n     * @param iterable the iterable to wrap\n     * @return a view of the supplied iterable that wraps each generated iterator through {@link\n     *     Iterators#consumingIterator(Iterator)}; for queues, an iterable that generates iterators\n     *     that return and consume the queue's elements in queue order\n     * @see Iterators#consumingIterator(Iterator)\n     * @since 2.0\n     */\n    public static <T> Iterable<T> consumingIterable(final Iterable<T> iterable)\n    {\n        checkNotNull(iterable);\n\n        return new FluentIterable<T>()\n        {\n            @Override\n            public Iterator<T> iterator()\n            {\n                return (iterable instanceof Queue)\n                       ? new ConsumingQueueIterator<>((Queue<T>) iterable)\n                       : Iterators.consumingIterator(iterable.iterator());\n            }\n\n            @Override\n            public String toString()\n            {\n                return \"Iterables.consumingIterable(...)\";\n            }\n        };\n    }\n\n    // Methods only in Iterables, not in Iterators\n\n    /**\n     * Determines if the given iterable contains no elements.\n     *\n     * <p>There is no precise {@link Iterator} equivalent to this method, since one can only ask an\n     * iterator whether it has any elements <i>remaining</i> (which one does using {@link\n     * Iterator#hasNext}).\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code !stream.findAny().isPresent()}\n     *\n     * @return {@code true} if the iterable contains no elements\n     */\n\n    /**\n     * Returns an iterable over the merged contents of all given {@code iterables}. Equivalent entries\n     * will not be de-duplicated.\n     *\n     * <p>Callers must ensure that the source {@code iterables} are in non-descending order as this\n     * method does not sort its input.\n     *\n     * <p>For any equivalent elements across all {@code iterables}, it is undefined which element is\n     * returned first.\n     *\n     * @since 11.0\n     */\n    @Beta\n    public static <T> Iterable<T> mergeSorted(\n        final Iterable<? extends Iterable<? extends T>> iterables,\n        final Comparator<? super T> comparator)\n    {\n        checkNotNull(iterables, \"iterables\");\n        checkNotNull(comparator, \"comparator\");\n        Iterable<T> iterable =\n            new FluentIterable<T>()\n        {\n            @Override\n            public Iterator<T> iterator()\n            {\n                return Iterators.mergeSorted(\n                           Iterables.transform(iterables, Iterables.<T>toIterator()), comparator);\n            }\n        };\n        return new UnmodifiableIterable<>(iterable);\n    }\n\n    // TODO(user): Is this the best place for this? Move to fluent functions?\n    // Useful as a public method?\n    static <T> Function<Iterable<? extends T>, Iterator<? extends T>> toIterator()\n    {\n        return new Function<Iterable<? extends T>, Iterator<? extends T>>()\n        {\n            @Override\n            public Iterator<? extends T> apply(Iterable<? extends T> iterable)\n            {\n                return iterable.iterator();\n            }\n        };\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/Iterables.java", "func_name": "Iterables.toIterator", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Useful as a public method?", "docstring_tokens": ["Useful", "as", "a", "public", "method?"], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/Iterables.java#L1018-L1025", "partition": "valid", "up_fun_num": 50, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.collect.CollectPreconditions.checkRemove;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.Function;", "import com.google.common.base.Optional;", "import com.google.common.base.Predicate;", "import com.google.common.base.Predicates;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.util.Collection;", "import java.util.Comparator;", "import java.util.Iterator;", "import java.util.List;", "import java.util.NoSuchElementException;", "import java.util.Queue;", "import java.util.RandomAccess;", "import java.util.Set;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Iterables\n", "    public static <T> Iterable<T> unmodifiableIterable(final Iterable<? extends T> iterable)\n", "    public static <E> Iterable<E> unmodifiableIterable(ImmutableCollection<E> iterable)\n", "    public static int size(Iterable<?> iterable)\n", "    public static boolean contains(Iterable<?> iterable, @NullableDecl Object element)\n", "    public static boolean removeAll(Iterable<?> removeFrom, Collection<?> elementsToRemove)\n", "    public static boolean retainAll(Iterable<?> removeFrom, Collection<?> elementsToRetain)\n", "    public static <T> boolean removeIf(Iterable<T> removeFrom, Predicate<? super T> predicate)\n", "    private static <T> boolean removeIfFromRandomAccessList(\n", "    private static <T> void slowRemoveIfForRemainingElements(\n", "    static <T> T removeFirstMatching(Iterable<T> removeFrom, Predicate<? super T> predicate)\n", "    public static boolean elementsEqual(Iterable<?> iterable1, Iterable<?> iterable2)\n", "    public static String toString(Iterable<?> iterable)\n", "    public static <T> T getOnlyElement(Iterable<T> iterable)\n", "    public static <T> T getOnlyElement(Iterable<? extends T> iterable, @NullableDecl T defaultValue)\n", "    public static <T> T[] toArray(Iterable<? extends T> iterable, Class<T> type)\n", "    static <T> T[] toArray(Iterable<? extends T> iterable, T[] array)\n", "    static Object[] toArray(Iterable<?> iterable)\n", "    private static <E> Collection<E> castOrCopyToCollection(Iterable<E> iterable)\n", "    public static <T> boolean addAll(Collection<T> addTo, Iterable<? extends T> elementsToAdd)\n", "    public static int frequency(Iterable<?> iterable, @NullableDecl Object element)\n", "    public static <T> Iterable<T> cycle(final Iterable<T> iterable)\n", "    public static <T> Iterable<T> cycle(T... elements)\n", "    public static <T> Iterable<T> concat(Iterable<? extends T> a, Iterable<? extends T> b)\n", "    public static <T> Iterable<T> concat(\n", "    public static <T> Iterable<T> concat(\n", "    public static <T> Iterable<T> concat(Iterable<? extends T>... inputs)\n", "    public static <T> Iterable<T> concat(Iterable<? extends Iterable<? extends T>> inputs)\n", "    public static <T> Iterable<List<T>> partition(final Iterable<T> iterable, final int size)\n", "    public static <T> Iterable<List<T>> paddedPartition(final Iterable<T> iterable, final int size)\n", "    public static <T> Iterable<T> filter(\n", "    public static <T> Iterable<T> filter(final Iterable<?> unfiltered, final Class<T> desiredType)\n", "    public static <T> boolean any(Iterable<T> iterable, Predicate<? super T> predicate)\n", "    public static <T> boolean all(Iterable<T> iterable, Predicate<? super T> predicate)\n", "    public static <T> T find(Iterable<T> iterable, Predicate<? super T> predicate)\n", "    public static <T> T find(\n", "    public static <T> Optional<T> tryFind(Iterable<T> iterable, Predicate<? super T> predicate)\n", "    public static <T> int indexOf(Iterable<T> iterable, Predicate<? super T> predicate)\n", "    public static <F, T> Iterable<T> transform(\n", "    public static <T> T get(Iterable<T> iterable, int position)\n", "    public static <T> T get(\n", "    public static <T> T getFirst(Iterable<? extends T> iterable, @NullableDecl T defaultValue)\n", "    public static <T> T getLast(Iterable<T> iterable)\n", "    public static <T> T getLast(Iterable<? extends T> iterable, @NullableDecl T defaultValue)\n", "    private static <T> T getLastInNonemptyList(List<T> list)\n", "    public static <T> Iterable<T> skip(final Iterable<T> iterable, final int numberToSkip)\n", "    public static <T> Iterable<T> limit(final Iterable<T> iterable, final int limitSize)\n", "    public static <T> Iterable<T> consumingIterable(final Iterable<T> iterable)\n", "    public static boolean isEmpty(Iterable<?> iterable)\n", "    public static <T> Iterable<T> mergeSorted(\n"], "context": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.collect.CollectPreconditions.checkRemove;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Function;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Queue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * An assortment of mainly legacy static utility methods that operate on or return objects of type\n * {@code Iterable}. Except as noted, each method has a corresponding {@link Iterator}-based method\n * in the {@link Iterators} class.\n *\n * <p><b>Java 8 users:</b> several common uses for this class are now more comprehensively addressed\n * by the new {@link java.util.stream.Stream} library. Read the method documentation below for\n * comparisons. This class is not being deprecated, but we gently encourage you to migrate to\n * streams.\n *\n * <p><i>Performance notes:</i> Unless otherwise noted, all of the iterables produced in this class\n * are <i>lazy</i>, which means that their iterators only advance the backing iteration when\n * absolutely necessary.\n *\n * <p>See the Guava User Guide article on <a href=\n * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#iterables\"> {@code\n * Iterables}</a>.\n *\n * @author Kevin Bourrillion\n * @author Jared Levy\n * @since 2.0\n */\n@GwtCompatible(emulated = true)\npublic final class Iterables\n{\n    private Iterables() {}\n\n    /** Returns an unmodifiable view of {@code iterable}. */\n    public static <T> Iterable<T> unmodifiableIterable(final Iterable<? extends T> iterable)\n    {\n        checkNotNull(iterable);\n        if (iterable instanceof UnmodifiableIterable || iterable instanceof ImmutableCollection)\n        {\n            @SuppressWarnings(\"unchecked\") // Since it's unmodifiable, the covariant cast is safe\n            Iterable<T> result = (Iterable<T>) iterable;\n            return result;\n        }\n        return new UnmodifiableIterable<>(iterable);\n    }\n\n    /**\n     * Simply returns its argument.\n     *\n     * @deprecated no need to use this\n     * @since 10.0\n     */\n    @Deprecated\n    public static <E> Iterable<E> unmodifiableIterable(ImmutableCollection<E> iterable)\n    {\n        return checkNotNull(iterable);\n    }\n\n    private static final class UnmodifiableIterable<T> extends FluentIterable<T>\n    {\n        private final Iterable<? extends T> iterable;\n\n        private UnmodifiableIterable(Iterable<? extends T> iterable)\n        {\n            this.iterable = iterable;\n        }\n\n        @Override\n        public Iterator<T> iterator()\n        {\n            return Iterators.unmodifiableIterator(iterable.iterator());\n        }\n\n        @Override\n        public String toString()\n        {\n            return iterable.toString();\n        }\n        // no equals and hashCode; it would break the contract!\n    }\n\n    /** Returns the number of elements in {@code iterable}. */\n    public static int size(Iterable<?> iterable)\n    {\n        return (iterable instanceof Collection)\n               ? ((Collection<?>) iterable).size()\n               : Iterators.size(iterable.iterator());\n    }\n\n    /**\n     * Returns {@code true} if {@code iterable} contains any element {@code o} for which {@code\n     * Objects.equals(o, element)} would return {@code true}. Otherwise returns {@code false}, even in\n     * cases where {@link Collection#contains} might throw {@link NullPointerException} or {@link\n     * ClassCastException}.\n     */\n    public static boolean contains(Iterable<?> iterable, @NullableDecl Object element)\n    {\n        if (iterable instanceof Collection)\n        {\n            Collection<?> collection = (Collection<?>) iterable;\n            return Collections2.safeContains(collection, element);\n        }\n        return Iterators.contains(iterable.iterator(), element);\n    }\n\n    /**\n     * Removes, from an iterable, every element that belongs to the provided collection.\n     *\n     * <p>This method calls {@link Collection#removeAll} if {@code iterable} is a collection, and\n     * {@link Iterators#removeAll} otherwise.\n     *\n     * @param removeFrom the iterable to (potentially) remove elements from\n     * @param elementsToRemove the elements to remove\n     * @return {@code true} if any element was removed from {@code iterable}\n     */\n    @CanIgnoreReturnValue\n    public static boolean removeAll(Iterable<?> removeFrom, Collection<?> elementsToRemove)\n    {\n        return (removeFrom instanceof Collection)\n               ? ((Collection<?>) removeFrom).removeAll(checkNotNull(elementsToRemove))\n               : Iterators.removeAll(removeFrom.iterator(), elementsToRemove);\n    }\n\n    /**\n     * Removes, from an iterable, every element that does not belong to the provided collection.\n     *\n     * <p>This method calls {@link Collection#retainAll} if {@code iterable} is a collection, and\n     * {@link Iterators#retainAll} otherwise.\n     *\n     * @param removeFrom the iterable to (potentially) remove elements from\n     * @param elementsToRetain the elements to retain\n     * @return {@code true} if any element was removed from {@code iterable}\n     */\n    @CanIgnoreReturnValue\n    public static boolean retainAll(Iterable<?> removeFrom, Collection<?> elementsToRetain)\n    {\n        return (removeFrom instanceof Collection)\n               ? ((Collection<?>) removeFrom).retainAll(checkNotNull(elementsToRetain))\n               : Iterators.retainAll(removeFrom.iterator(), elementsToRetain);\n    }\n\n    /**\n     * Removes, from an iterable, every element that satisfies the provided predicate.\n     *\n     * <p>Removals may or may not happen immediately as each element is tested against the predicate.\n     * The behavior of this method is not specified if {@code predicate} is dependent on {@code\n     * removeFrom}.\n     *\n     * @param removeFrom the iterable to (potentially) remove elements from\n     * @param predicate a predicate that determines whether an element should be removed\n     * @return {@code true} if any elements were removed from the iterable\n     * @throws UnsupportedOperationException if the iterable does not support {@code remove()}.\n     * @since 2.0\n     */\n    @CanIgnoreReturnValue\n    public static <T> boolean removeIf(Iterable<T> removeFrom, Predicate<? super T> predicate)\n    {\n        if (removeFrom instanceof RandomAccess && removeFrom instanceof List)\n        {\n            return removeIfFromRandomAccessList((List<T>) removeFrom, checkNotNull(predicate));\n        }\n        return Iterators.removeIf(removeFrom.iterator(), predicate);\n    }\n\n    private static <T> boolean removeIfFromRandomAccessList(\n        List<T> list, Predicate<? super T> predicate)\n    {\n        // Note: Not all random access lists support set(). Additionally, it's possible\n        // for a list to reject setting an element, such as when the list does not permit\n        // duplicate elements. For both of those cases,  we need to fall back to a slower\n        // implementation.\n        int from = 0;\n        int to = 0;\n\n        for (; from < list.size(); from++)\n        {\n            T element = list.get(from);\n            if (!predicate.apply(element))\n            {\n                if (from > to)\n                {\n                    try\n                    {\n                        list.set(to, element);\n                    }\n                    catch (UnsupportedOperationException e)\n                    {\n                        slowRemoveIfForRemainingElements(list, predicate, to, from);\n                        return true;\n                    }\n                    catch (IllegalArgumentException e)\n                    {\n                        slowRemoveIfForRemainingElements(list, predicate, to, from);\n                        return true;\n                    }\n                }\n                to++;\n            }\n        }\n\n        // Clear the tail of any remaining items\n        list.subList(to, list.size()).clear();\n        return from != to;\n    }\n\n    private static <T> void slowRemoveIfForRemainingElements(\n        List<T> list, Predicate<? super T> predicate, int to, int from)\n    {\n        // Here we know that:\n        // * (to < from) and that both are valid indices.\n        // * Everything with (index < to) should be kept.\n        // * Everything with (to <= index < from) should be removed.\n        // * The element with (index == from) should be kept.\n        // * Everything with (index > from) has not been checked yet.\n\n        // Check from the end of the list backwards (minimize expected cost of\n        // moving elements when remove() is called). Stop before 'from' because\n        // we already know that should be kept.\n        for (int n = list.size() - 1; n > from; n--)\n        {\n            if (predicate.apply(list.get(n)))\n            {\n                list.remove(n);\n            }\n        }\n        // And now remove everything in the range [to, from) (going backwards).\n        for (int n = from - 1; n >= to; n--)\n        {\n            list.remove(n);\n        }\n    }\n\n    /** Removes and returns the first matching element, or returns {@code null} if there is none. */\n    @NullableDecl\n    static <T> T removeFirstMatching(Iterable<T> removeFrom, Predicate<? super T> predicate)\n    {\n        checkNotNull(predicate);\n        Iterator<T> iterator = removeFrom.iterator();\n        while (iterator.hasNext())\n        {\n            T next = iterator.next();\n            if (predicate.apply(next))\n            {\n                iterator.remove();\n                return next;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Determines whether two iterables contain equal elements in the same order. More specifically,\n     * this method returns {@code true} if {@code iterable1} and {@code iterable2} contain the same\n     * number of elements and every element of {@code iterable1} is equal to the corresponding element\n     * of {@code iterable2}.\n     */\n    public static boolean elementsEqual(Iterable<?> iterable1, Iterable<?> iterable2)\n    {\n        if (iterable1 instanceof Collection && iterable2 instanceof Collection)\n        {\n            Collection<?> collection1 = (Collection<?>) iterable1;\n            Collection<?> collection2 = (Collection<?>) iterable2;\n            if (collection1.size() != collection2.size())\n            {\n                return false;\n            }\n        }\n        return Iterators.elementsEqual(iterable1.iterator(), iterable2.iterator());\n    }\n\n    /**\n     * Returns a string representation of {@code iterable}, with the format {@code [e1, e2, ..., en]}\n     * (that is, identical to {@link java.util.Arrays Arrays}{@code\n     * .toString(Iterables.toArray(iterable))}). Note that for <i>most</i> implementations of {@link\n     * Collection}, {@code collection.toString()} also gives the same result, but that behavior is not\n     * generally guaranteed.\n     */\n    public static String toString(Iterable<?> iterable)\n    {\n        return Iterators.toString(iterable.iterator());\n    }\n\n    /**\n     * Returns the single element contained in {@code iterable}.\n     *\n     * <p><b>Java 8 users:</b> the {@code Stream} equivalent to this method is {@code\n     * stream.collect(MoreCollectors.onlyElement())}.\n     *\n     * @throws NoSuchElementException if the iterable is empty\n     * @throws IllegalArgumentException if the iterable contains multiple elements\n     */\n    public static <T> T getOnlyElement(Iterable<T> iterable)\n    {\n        return Iterators.getOnlyElement(iterable.iterator());\n    }\n\n    /**\n     * Returns the single element contained in {@code iterable}, or {@code defaultValue} if the\n     * iterable is empty.\n     *\n     * <p><b>Java 8 users:</b> the {@code Stream} equivalent to this method is {@code\n     * stream.collect(MoreCollectors.toOptional()).orElse(defaultValue)}.\n     *\n     * @throws IllegalArgumentException if the iterator contains multiple elements\n     */\n    @NullableDecl\n    public static <T> T getOnlyElement(Iterable<? extends T> iterable, @NullableDecl T defaultValue)\n    {\n        return Iterators.getOnlyElement(iterable.iterator(), defaultValue);\n    }\n\n    /**\n     * Copies an iterable's elements into an array.\n     *\n     * @param iterable the iterable to copy\n     * @param type the type of the elements\n     * @return a newly-allocated array into which all the elements of the iterable have been copied\n     */\n    @GwtIncompatible // Array.newInstance(Class, int)\n    public static <T> T[] toArray(Iterable<? extends T> iterable, Class<T> type)\n    {\n        return toArray(iterable, ObjectArrays.newArray(type, 0));\n    }\n\n    static <T> T[] toArray(Iterable<? extends T> iterable, T[] array)\n    {\n        Collection<? extends T> collection = castOrCopyToCollection(iterable);\n        return collection.toArray(array);\n    }\n\n    /**\n     * Copies an iterable's elements into an array.\n     *\n     * @param iterable the iterable to copy\n     * @return a newly-allocated array into which all the elements of the iterable have been copied\n     */\n    static Object[] toArray(Iterable<?> iterable)\n    {\n        return castOrCopyToCollection(iterable).toArray();\n    }\n\n    /**\n     * Converts an iterable into a collection. If the iterable is already a collection, it is\n     * returned. Otherwise, an {@link java.util.ArrayList} is created with the contents of the\n     * iterable in the same iteration order.\n     */\n    private static <E> Collection<E> castOrCopyToCollection(Iterable<E> iterable)\n    {\n        return (iterable instanceof Collection)\n               ? (Collection<E>) iterable\n               : Lists.newArrayList(iterable.iterator());\n    }\n\n    /**\n     * Adds all elements in {@code iterable} to {@code collection}.\n     *\n     * @return {@code true} if {@code collection} was modified as a result of this operation.\n     */\n    @CanIgnoreReturnValue\n    public static <T> boolean addAll(Collection<T> addTo, Iterable<? extends T> elementsToAdd)\n    {\n        if (elementsToAdd instanceof Collection)\n        {\n            Collection<? extends T> c = Collections2.cast(elementsToAdd);\n            return addTo.addAll(c);\n        }\n        return Iterators.addAll(addTo, checkNotNull(elementsToAdd).iterator());\n    }\n\n    /**\n     * Returns the number of elements in the specified iterable that equal the specified object. This\n     * implementation avoids a full iteration when the iterable is a {@link Multiset} or {@link Set}.\n     *\n     * <p><b>Java 8 users:</b> In most cases, the {@code Stream} equivalent of this method is {@code\n     * stream.filter(element::equals).count()}. If {@code element} might be null, use {@code\n     * stream.filter(Predicate.isEqual(element)).count()} instead.\n     *\n     * @see java.util.Collections#frequency(Collection, Object) Collections.frequency(Collection,\n     *     Object)\n     */\n    public static int frequency(Iterable<?> iterable, @NullableDecl Object element)\n    {\n        if ((iterable instanceof Multiset))\n        {\n            return ((Multiset<?>) iterable).count(element);\n        }\n        else if ((iterable instanceof Set))\n        {\n            return ((Set<?>) iterable).contains(element) ? 1 : 0;\n        }\n        return Iterators.frequency(iterable.iterator(), element);\n    }\n\n    /**\n     * Returns an iterable whose iterators cycle indefinitely over the elements of {@code iterable}.\n     *\n     * <p>That iterator supports {@code remove()} if {@code iterable.iterator()} does. After {@code\n     * remove()} is called, subsequent cycles omit the removed element, which is no longer in {@code\n     * iterable}. The iterator's {@code hasNext()} method returns {@code true} until {@code iterable}\n     * is empty.\n     *\n     * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You\n     * should use an explicit {@code break} or be certain that you will eventually remove all the\n     * elements.\n     *\n     * <p>To cycle over the iterable {@code n} times, use the following: {@code\n     * Iterables.concat(Collections.nCopies(n, iterable))}\n     *\n     * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code\n     * Stream.generate(() -> iterable).flatMap(Streams::stream)}.\n     */\n    public static <T> Iterable<T> cycle(final Iterable<T> iterable)\n    {\n        checkNotNull(iterable);\n        return new FluentIterable<T>()\n        {\n            @Override\n            public Iterator<T> iterator()\n            {\n                return Iterators.cycle(iterable);\n            }\n\n            @Override\n            public String toString()\n            {\n                return iterable.toString() + \" (cycled)\";\n            }\n        };\n    }\n\n    /**\n     * Returns an iterable whose iterators cycle indefinitely over the provided elements.\n     *\n     * <p>After {@code remove} is invoked on a generated iterator, the removed element will no longer\n     * appear in either that iterator or any other iterator created from the same source iterable.\n     * That is, this method behaves exactly as {@code Iterables.cycle(Lists.newArrayList(elements))}.\n     * The iterator's {@code hasNext} method returns {@code true} until all of the original elements\n     * have been removed.\n     *\n     * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You\n     * should use an explicit {@code break} or be certain that you will eventually remove all the\n     * elements.\n     *\n     * <p>To cycle over the elements {@code n} times, use the following: {@code\n     * Iterables.concat(Collections.nCopies(n, Arrays.asList(elements)))}\n     *\n     * <p><b>Java 8 users:</b> If passing a single element {@code e}, the {@code Stream} equivalent of\n     * this method is {@code Stream.generate(() -> e)}. Otherwise, put the elements in a collection\n     * and use {@code Stream.generate(() -> collection).flatMap(Collection::stream)}.\n     */\n    @SafeVarargs\n    public static <T> Iterable<T> cycle(T... elements)\n    {\n        return cycle(Lists.newArrayList(elements));\n    }\n\n    /**\n     * Combines two iterables into a single iterable. The returned iterable has an iterator that\n     * traverses the elements in {@code a}, followed by the elements in {@code b}. The source\n     * iterators are not polled until necessary.\n     *\n     * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input\n     * iterator supports it.\n     *\n     * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code Stream.concat(a,\n     * b)}.\n     */\n    public static <T> Iterable<T> concat(Iterable<? extends T> a, Iterable<? extends T> b)\n    {\n        return FluentIterable.concat(a, b);\n    }\n\n    /**\n     * Combines three iterables into a single iterable. The returned iterable has an iterator that\n     * traverses the elements in {@code a}, followed by the elements in {@code b}, followed by the\n     * elements in {@code c}. The source iterators are not polled until necessary.\n     *\n     * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input\n     * iterator supports it.\n     *\n     * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code\n     * Streams.concat(a, b, c)}.\n     */\n    public static <T> Iterable<T> concat(\n        Iterable<? extends T> a, Iterable<? extends T> b, Iterable<? extends T> c)\n    {\n        return FluentIterable.concat(a, b, c);\n    }\n\n    /**\n     * Combines four iterables into a single iterable. The returned iterable has an iterator that\n     * traverses the elements in {@code a}, followed by the elements in {@code b}, followed by the\n     * elements in {@code c}, followed by the elements in {@code d}. The source iterators are not\n     * polled until necessary.\n     *\n     * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input\n     * iterator supports it.\n     *\n     * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code\n     * Streams.concat(a, b, c, d)}.\n     */\n    public static <T> Iterable<T> concat(\n        Iterable<? extends T> a,\n        Iterable<? extends T> b,\n        Iterable<? extends T> c,\n        Iterable<? extends T> d)\n    {\n        return FluentIterable.concat(a, b, c, d);\n    }\n\n    /**\n     * Combines multiple iterables into a single iterable. The returned iterable has an iterator that\n     * traverses the elements of each iterable in {@code inputs}. The input iterators are not polled\n     * until necessary.\n     *\n     * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input\n     * iterator supports it.\n     *\n     * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code\n     * Streams.concat(...)}.\n     *\n     * @throws NullPointerException if any of the provided iterables is null\n     */\n    @SafeVarargs\n    public static <T> Iterable<T> concat(Iterable<? extends T>... inputs)\n    {\n        return FluentIterable.concat(inputs);\n    }\n\n    /**\n     * Combines multiple iterables into a single iterable. The returned iterable has an iterator that\n     * traverses the elements of each iterable in {@code inputs}. The input iterators are not polled\n     * until necessary.\n     *\n     * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input\n     * iterator supports it. The methods of the returned iterable may throw {@code\n     * NullPointerException} if any of the input iterators is null.\n     *\n     * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code\n     * streamOfStreams.flatMap(s -> s)}.\n     */\n    public static <T> Iterable<T> concat(Iterable<? extends Iterable<? extends T>> inputs)\n    {\n        return FluentIterable.concat(inputs);\n    }\n\n    /**\n     * Divides an iterable into unmodifiable sublists of the given size (the final iterable may be\n     * smaller). For example, partitioning an iterable containing {@code [a, b, c, d, e]} with a\n     * partition size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer iterable containing two\n     * inner lists of three and two elements, all in the original order.\n     *\n     * <p>Iterators returned by the returned iterable do not support the {@link Iterator#remove()}\n     * method. The returned lists implement {@link RandomAccess}, whether or not the input list does.\n     *\n     * <p><b>Note:</b> if {@code iterable} is a {@link List}, use {@link Lists#partition(List, int)}\n     * instead.\n     *\n     * @param iterable the iterable to return a partitioned view of\n     * @param size the desired size of each partition (the last may be smaller)\n     * @return an iterable of unmodifiable lists containing the elements of {@code iterable} divided\n     *     into partitions\n     * @throws IllegalArgumentException if {@code size} is nonpositive\n     */\n    public static <T> Iterable<List<T>> partition(final Iterable<T> iterable, final int size)\n    {\n        checkNotNull(iterable);\n        checkArgument(size > 0);\n        return new FluentIterable<List<T>>()\n        {\n            @Override\n            public Iterator<List<T>> iterator()\n            {\n                return Iterators.partition(iterable.iterator(), size);\n            }\n        };\n    }\n\n    /**\n     * Divides an iterable into unmodifiable sublists of the given size, padding the final iterable\n     * with null values if necessary. For example, partitioning an iterable containing {@code [a, b,\n     * c, d, e]} with a partition size of 3 yields {@code [[a, b, c], [d, e, null]]} -- an outer\n     * iterable containing two inner lists of three elements each, all in the original order.\n     *\n     * <p>Iterators returned by the returned iterable do not support the {@link Iterator#remove()}\n     * method.\n     *\n     * @param iterable the iterable to return a partitioned view of\n     * @param size the desired size of each partition\n     * @return an iterable of unmodifiable lists containing the elements of {@code iterable} divided\n     *     into partitions (the final iterable may have trailing null elements)\n     * @throws IllegalArgumentException if {@code size} is nonpositive\n     */\n    public static <T> Iterable<List<T>> paddedPartition(final Iterable<T> iterable, final int size)\n    {\n        checkNotNull(iterable);\n        checkArgument(size > 0);\n        return new FluentIterable<List<T>>()\n        {\n            @Override\n            public Iterator<List<T>> iterator()\n            {\n                return Iterators.paddedPartition(iterable.iterator(), size);\n            }\n        };\n    }\n\n    /**\n     * Returns a view of {@code unfiltered} containing all elements that satisfy the input predicate\n     * {@code retainIfTrue}. The returned iterable's iterator does not support {@code remove()}.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link Stream#filter}.\n     */\n    public static <T> Iterable<T> filter(\n        final Iterable<T> unfiltered, final Predicate<? super T> retainIfTrue)\n    {\n        checkNotNull(unfiltered);\n        checkNotNull(retainIfTrue);\n        return new FluentIterable<T>()\n        {\n            @Override\n            public Iterator<T> iterator()\n            {\n                return Iterators.filter(unfiltered.iterator(), retainIfTrue);\n            }\n        };\n    }\n\n    /**\n     * Returns a view of {@code unfiltered} containing all elements that are of the type {@code\n     * desiredType}. The returned iterable's iterator does not support {@code remove()}.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(type::isInstance).map(type::cast)}.\n     * This does perform a little more work than necessary, so another option is to insert an\n     * unchecked cast at some later point:\n     *\n     * <pre>\n     * {@code @SuppressWarnings(\"unchecked\") // safe because of ::isInstance check\n     * ImmutableList<NewType> result =\n     *     (ImmutableList) stream.filter(NewType.class::isInstance).collect(toImmutableList());}\n     * </pre>\n     */\n    @SuppressWarnings(\"unchecked\")\n    @GwtIncompatible // Class.isInstance\n    public static <T> Iterable<T> filter(final Iterable<?> unfiltered, final Class<T> desiredType)\n    {\n        checkNotNull(unfiltered);\n        checkNotNull(desiredType);\n        return (Iterable<T>) filter(unfiltered, Predicates.instanceOf(desiredType));\n    }\n\n    /**\n     * Returns {@code true} if any element in {@code iterable} satisfies the predicate.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link Stream#anyMatch}.\n     */\n    public static <T> boolean any(Iterable<T> iterable, Predicate<? super T> predicate)\n    {\n        return Iterators.any(iterable.iterator(), predicate);\n    }\n\n    /**\n     * Returns {@code true} if every element in {@code iterable} satisfies the predicate. If {@code\n     * iterable} is empty, {@code true} is returned.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link Stream#allMatch}.\n     */\n    public static <T> boolean all(Iterable<T> iterable, Predicate<? super T> predicate)\n    {\n        return Iterators.all(iterable.iterator(), predicate);\n    }\n\n    /**\n     * Returns the first element in {@code iterable} that satisfies the given predicate; use this\n     * method only when such an element is known to exist. If it is possible that <i>no</i> element\n     * will match, use {@link #tryFind} or {@link #find(Iterable, Predicate, Object)} instead.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate).findFirst().get()}\n     *\n     * @throws NoSuchElementException if no element in {@code iterable} matches the given predicate\n     */\n    public static <T> T find(Iterable<T> iterable, Predicate<? super T> predicate)\n    {\n        return Iterators.find(iterable.iterator(), predicate);\n    }\n\n    /**\n     * Returns the first element in {@code iterable} that satisfies the given predicate, or {@code\n     * defaultValue} if none found. Note that this can usually be handled more naturally using {@code\n     * tryFind(iterable, predicate).or(defaultValue)}.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code\n     * stream.filter(predicate).findFirst().orElse(defaultValue)}\n     *\n     * @since 7.0\n     */\n    @NullableDecl\n    public static <T> T find(\n        Iterable<? extends T> iterable,\n        Predicate<? super T> predicate,\n        @NullableDecl T defaultValue)\n    {\n        return Iterators.find(iterable.iterator(), predicate, defaultValue);\n    }\n\n    /**\n     * Returns an {@link Optional} containing the first element in {@code iterable} that satisfies the\n     * given predicate, if such an element exists.\n     *\n     * <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code null}. If {@code null}\n     * is matched in {@code iterable}, a NullPointerException will be thrown.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate).findFirst()}\n     *\n     * @since 11.0\n     */\n    public static <T> Optional<T> tryFind(Iterable<T> iterable, Predicate<? super T> predicate)\n    {\n        return Iterators.tryFind(iterable.iterator(), predicate);\n    }\n\n    /**\n     * Returns the index in {@code iterable} of the first element that satisfies the provided {@code\n     * predicate}, or {@code -1} if the Iterable has no such elements.\n     *\n     * <p>More formally, returns the lowest index {@code i} such that {@code\n     * predicate.apply(Iterables.get(iterable, i))} returns {@code true}, or {@code -1} if there is no\n     * such index.\n     *\n     * @since 2.0\n     */\n    public static <T> int indexOf(Iterable<T> iterable, Predicate<? super T> predicate)\n    {\n        return Iterators.indexOf(iterable.iterator(), predicate);\n    }\n\n    /**\n     * Returns a view containing the result of applying {@code function} to each element of {@code\n     * fromIterable}.\n     *\n     * <p>The returned iterable's iterator supports {@code remove()} if {@code fromIterable}'s\n     * iterator does. After a successful {@code remove()} call, {@code fromIterable} no longer\n     * contains the corresponding element.\n     *\n     * <p>If the input {@code Iterable} is known to be a {@code List} or other {@code Collection},\n     * consider {@link Lists#transform} and {@link Collections2#transform}.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link Stream#map}\n     */\n    public static <F, T> Iterable<T> transform(\n        final Iterable<F> fromIterable, final Function<? super F, ? extends T> function)\n    {\n        checkNotNull(fromIterable);\n        checkNotNull(function);\n        return new FluentIterable<T>()\n        {\n            @Override\n            public Iterator<T> iterator()\n            {\n                return Iterators.transform(fromIterable.iterator(), function);\n            }\n        };\n    }\n\n    /**\n     * Returns the element at the specified position in an iterable.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code stream.skip(position).findFirst().get()} (throws\n     * {@code NoSuchElementException} if out of bounds)\n     *\n     * @param position position of the element to return\n     * @return the element at the specified position in {@code iterable}\n     * @throws IndexOutOfBoundsException if {@code position} is negative or greater than or equal to\n     *     the size of {@code iterable}\n     */\n    public static <T> T get(Iterable<T> iterable, int position)\n    {\n        checkNotNull(iterable);\n        return (iterable instanceof List)\n               ? ((List<T>) iterable).get(position)\n               : Iterators.get(iterable.iterator(), position);\n    }\n\n    /**\n     * Returns the element at the specified position in an iterable or a default value otherwise.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code\n     * stream.skip(position).findFirst().orElse(defaultValue)} (returns the default value if the index\n     * is out of bounds)\n     *\n     * @param position position of the element to return\n     * @param defaultValue the default value to return if {@code position} is greater than or equal to\n     *     the size of the iterable\n     * @return the element at the specified position in {@code iterable} or {@code defaultValue} if\n     *     {@code iterable} contains fewer than {@code position + 1} elements.\n     * @throws IndexOutOfBoundsException if {@code position} is negative\n     * @since 4.0\n     */\n    @NullableDecl\n    public static <T> T get(\n        Iterable<? extends T> iterable, int position, @NullableDecl T defaultValue)\n    {\n        checkNotNull(iterable);\n        Iterators.checkNonnegative(position);\n        if (iterable instanceof List)\n        {\n            List<? extends T> list = Lists.cast(iterable);\n            return (position < list.size()) ? list.get(position) : defaultValue;\n        }\n        else\n        {\n            Iterator<? extends T> iterator = iterable.iterator();\n            Iterators.advance(iterator, position);\n            return Iterators.getNext(iterator, defaultValue);\n        }\n    }\n\n    /**\n     * Returns the first element in {@code iterable} or {@code defaultValue} if the iterable is empty.\n     * The {@link Iterators} analog to this method is {@link Iterators#getNext}.\n     *\n     * <p>If no default value is desired (and the caller instead wants a {@link\n     * NoSuchElementException} to be thrown), it is recommended that {@code\n     * iterable.iterator().next()} is used instead.\n     *\n     * <p>To get the only element in a single-element {@code Iterable}, consider using {@link\n     * #getOnlyElement(Iterable)} or {@link #getOnlyElement(Iterable, Object)} instead.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code stream.findFirst().orElse(defaultValue)}\n     *\n     * @param defaultValue the default value to return if the iterable is empty\n     * @return the first element of {@code iterable} or the default value\n     * @since 7.0\n     */\n    @NullableDecl\n    public static <T> T getFirst(Iterable<? extends T> iterable, @NullableDecl T defaultValue)\n    {\n        return Iterators.getNext(iterable.iterator(), defaultValue);\n    }\n\n    /**\n     * Returns the last element of {@code iterable}. If {@code iterable} is a {@link List} with {@link\n     * RandomAccess} support, then this operation is guaranteed to be {@code O(1)}.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link Streams#findLast Streams.findLast(stream).get()}\n     *\n     * @return the last element of {@code iterable}\n     * @throws NoSuchElementException if the iterable is empty\n     */\n    public static <T> T getLast(Iterable<T> iterable)\n    {\n        // TODO(kevinb): Support a concurrently modified collection?\n        if (iterable instanceof List)\n        {\n            List<T> list = (List<T>) iterable;\n            if (list.isEmpty())\n            {\n                throw new NoSuchElementException();\n            }\n            return getLastInNonemptyList(list);\n        }\n\n        return Iterators.getLast(iterable.iterator());\n    }\n\n    /**\n     * Returns the last element of {@code iterable} or {@code defaultValue} if the iterable is empty.\n     * If {@code iterable} is a {@link List} with {@link RandomAccess} support, then this operation is\n     * guaranteed to be {@code O(1)}.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code Streams.findLast(stream).orElse(defaultValue)}\n     *\n     * @param defaultValue the value to return if {@code iterable} is empty\n     * @return the last element of {@code iterable} or the default value\n     * @since 3.0\n     */\n    @NullableDecl\n    public static <T> T getLast(Iterable<? extends T> iterable, @NullableDecl T defaultValue)\n    {\n        if (iterable instanceof Collection)\n        {\n            Collection<? extends T> c = Collections2.cast(iterable);\n            if (c.isEmpty())\n            {\n                return defaultValue;\n            }\n            else if (iterable instanceof List)\n            {\n                return getLastInNonemptyList(Lists.cast(iterable));\n            }\n        }\n\n        return Iterators.getLast(iterable.iterator(), defaultValue);\n    }\n\n    private static <T> T getLastInNonemptyList(List<T> list)\n    {\n        return list.get(list.size() - 1);\n    }\n\n    /**\n     * Returns a view of {@code iterable} that skips its first {@code numberToSkip} elements. If\n     * {@code iterable} contains fewer than {@code numberToSkip} elements, the returned iterable skips\n     * all of its elements.\n     *\n     * <p>Modifications to the underlying {@link Iterable} before a call to {@code iterator()} are\n     * reflected in the returned iterator. That is, the iterator skips the first {@code numberToSkip}\n     * elements that exist when the {@code Iterator} is created, not when {@code skip()} is called.\n     *\n     * <p>The returned iterable's iterator supports {@code remove()} if the iterator of the underlying\n     * iterable supports it. Note that it is <i>not</i> possible to delete the last skipped element by\n     * immediately calling {@code remove()} on that iterator, as the {@code Iterator} contract states\n     * that a call to {@code remove()} before a call to {@code next()} will throw an {@link\n     * IllegalStateException}.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link Stream#skip}\n     *\n     * @since 3.0\n     */\n    public static <T> Iterable<T> skip(final Iterable<T> iterable, final int numberToSkip)\n    {\n        checkNotNull(iterable);\n        checkArgument(numberToSkip >= 0, \"number to skip cannot be negative\");\n\n        return new FluentIterable<T>()\n        {\n            @Override\n            public Iterator<T> iterator()\n            {\n                if (iterable instanceof List)\n                {\n                    final List<T> list = (List<T>) iterable;\n                    int toSkip = Math.min(list.size(), numberToSkip);\n                    return list.subList(toSkip, list.size()).iterator();\n                }\n                final Iterator<T> iterator = iterable.iterator();\n\n                Iterators.advance(iterator, numberToSkip);\n\n                /*\n                 * We can't just return the iterator because an immediate call to its\n                 * remove() method would remove one of the skipped elements instead of\n                 * throwing an IllegalStateException.\n                 */\n                return new Iterator<T>()\n                {\n                    boolean atStart = true;\n\n                    @Override\n                    public boolean hasNext()\n                    {\n                        return iterator.hasNext();\n                    }\n\n                    @Override\n                    public T next()\n                    {\n                        T result = iterator.next();\n                        atStart = false; // not called if next() fails\n                        return result;\n                    }\n\n                    @Override\n                    public void remove()\n                    {\n                        checkRemove(!atStart);\n                        iterator.remove();\n                    }\n                };\n            }\n        };\n    }\n\n    /**\n     * Returns a view of {@code iterable} containing its first {@code limitSize} elements. If {@code\n     * iterable} contains fewer than {@code limitSize} elements, the returned view contains all of its\n     * elements. The returned iterable's iterator supports {@code remove()} if {@code iterable}'s\n     * iterator does.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link Stream#limit}\n     *\n     * @param iterable the iterable to limit\n     * @param limitSize the maximum number of elements in the returned iterable\n     * @throws IllegalArgumentException if {@code limitSize} is negative\n     * @since 3.0\n     */\n    public static <T> Iterable<T> limit(final Iterable<T> iterable, final int limitSize)\n    {\n        checkNotNull(iterable);\n        checkArgument(limitSize >= 0, \"limit is negative\");\n        return new FluentIterable<T>()\n        {\n            @Override\n            public Iterator<T> iterator()\n            {\n                return Iterators.limit(iterable.iterator(), limitSize);\n            }\n        };\n    }\n\n    /**\n     * Returns a view of the supplied iterable that wraps each generated {@link Iterator} through\n     * {@link Iterators#consumingIterator(Iterator)}.\n     *\n     * <p>Note: If {@code iterable} is a {@link Queue}, the returned iterable will get entries from\n     * {@link Queue#remove()} since {@link Queue}'s iteration order is undefined. Calling {@link\n     * Iterator#hasNext()} on a generated iterator from the returned iterable may cause an item to be\n     * immediately dequeued for return on a subsequent call to {@link Iterator#next()}.\n     *\n     * @param iterable the iterable to wrap\n     * @return a view of the supplied iterable that wraps each generated iterator through {@link\n     *     Iterators#consumingIterator(Iterator)}; for queues, an iterable that generates iterators\n     *     that return and consume the queue's elements in queue order\n     * @see Iterators#consumingIterator(Iterator)\n     * @since 2.0\n     */\n    public static <T> Iterable<T> consumingIterable(final Iterable<T> iterable)\n    {\n        checkNotNull(iterable);\n\n        return new FluentIterable<T>()\n        {\n            @Override\n            public Iterator<T> iterator()\n            {\n                return (iterable instanceof Queue)\n                       ? new ConsumingQueueIterator<>((Queue<T>) iterable)\n                       : Iterators.consumingIterator(iterable.iterator());\n            }\n\n            @Override\n            public String toString()\n            {\n                return \"Iterables.consumingIterable(...)\";\n            }\n        };\n    }\n\n    // Methods only in Iterables, not in Iterators\n\n    /**\n     * Determines if the given iterable contains no elements.\n     *\n     * <p>There is no precise {@link Iterator} equivalent to this method, since one can only ask an\n     * iterator whether it has any elements <i>remaining</i> (which one does using {@link\n     * Iterator#hasNext}).\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@code !stream.findAny().isPresent()}\n     *\n     * @return {@code true} if the iterable contains no elements\n     */\n    public static boolean isEmpty(Iterable<?> iterable)\n    {\n        if (iterable instanceof Collection)\n        {\n            return ((Collection<?>) iterable).isEmpty();\n        }\n        return !iterable.iterator().hasNext();\n    }\n\n    /**\n     * Returns an iterable over the merged contents of all given {@code iterables}. Equivalent entries\n     * will not be de-duplicated.\n     *\n     * <p>Callers must ensure that the source {@code iterables} are in non-descending order as this\n     * method does not sort its input.\n     *\n     * <p>For any equivalent elements across all {@code iterables}, it is undefined which element is\n     * returned first.\n     *\n     * @since 11.0\n     */\n    @Beta\n    public static <T> Iterable<T> mergeSorted(\n        final Iterable<? extends Iterable<? extends T>> iterables,\n        final Comparator<? super T> comparator)\n    {\n        checkNotNull(iterables, \"iterables\");\n        checkNotNull(comparator, \"comparator\");\n        Iterable<T> iterable =\n            new FluentIterable<T>()\n        {\n            @Override\n            public Iterator<T> iterator()\n            {\n                return Iterators.mergeSorted(\n                           Iterables.transform(iterables, Iterables.<T>toIterator()), comparator);\n            }\n        };\n        return new UnmodifiableIterable<>(iterable);\n    }\n\n    // TODO(user): Is this the best place for this? Move to fluent functions?\n    // Useful as a public method?\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/Iterators.java", "func_name": "Iterators.consumingForArray", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns an Iterator that walks the specified array, nulling out elements behind it. This can\navoid memory leaks when an element is no longer necessary.\n\n<p>This is mainly just to avoid the intermediate ArrayDeque in ConsumingQueueIterator.", "docstring_tokens": ["Returns", "an", "Iterator", "that", "walks", "the", "specified", "array", "nulling", "out", "elements", "behind", "it", ".", "This", "can", "avoid", "memory", "leaks", "when", "an", "element", "is", "no", "longer", "necessary", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/Iterators.java#L449-L469", "partition": "valid", "up_fun_num": 21, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.base.Preconditions.checkState;", "import static com.google.common.base.Predicates.instanceOf;", "import static com.google.common.collect.CollectPreconditions.checkRemove;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.Function;", "import com.google.common.base.Objects;", "import com.google.common.base.Optional;", "import com.google.common.base.Preconditions;", "import com.google.common.base.Predicate;", "import com.google.common.primitives.Ints;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.util.ArrayDeque;", "import java.util.Arrays;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.Comparator;", "import java.util.Deque;", "import java.util.Enumeration;", "import java.util.Iterator;", "import java.util.List;", "import java.util.ListIterator;", "import java.util.NoSuchElementException;", "import java.util.PriorityQueue;", "import java.util.Queue;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Iterators\n", "    static <T> UnmodifiableIterator<T> emptyIterator()\n", "    static <T> UnmodifiableListIterator<T> emptyListIterator()\n", "    static <T> Iterator<T> emptyModifiableIterator()\n", "    public static <T> UnmodifiableIterator<T> unmodifiableIterator(\n", "    public static <T> UnmodifiableIterator<T> unmodifiableIterator(UnmodifiableIterator<T> iterator)\n", "    public static int size(Iterator<?> iterator)\n", "    public static boolean contains(Iterator<?> iterator, @NullableDecl Object element)\n", "    public static boolean removeAll(Iterator<?> removeFrom, Collection<?> elementsToRemove)\n", "    public static <T> boolean removeIf(Iterator<T> removeFrom, Predicate<? super T> predicate)\n", "    public static boolean retainAll(Iterator<?> removeFrom, Collection<?> elementsToRetain)\n", "    public static boolean elementsEqual(Iterator<?> iterator1, Iterator<?> iterator2)\n", "    public static String toString(Iterator<?> iterator)\n", "    public static <T> T getOnlyElement(Iterator<T> iterator)\n", "    public static <T> T getOnlyElement(Iterator<? extends T> iterator, @NullableDecl T defaultValue)\n", "    public static <T> T[] toArray(Iterator<? extends T> iterator, Class<T> type)\n", "    public static <T> boolean addAll(Collection<T> addTo, Iterator<? extends T> iterator)\n", "    public static int frequency(Iterator<?> iterator, @NullableDecl Object element)\n", "    public static <T> Iterator<T> cycle(final Iterable<T> iterable)\n", "    public static <T> Iterator<T> cycle(T... elements)\n", "    public static <T> Iterator<T> concat(Iterator<? extends T> a, Iterator<? extends T> b)\n", "    public static <T> Iterator<T> concat(\n", "    public static <T> Iterator<T> concat(\n", "    public static <T> Iterator<T> concat(Iterator<? extends T>... inputs)\n", "    public static <T> Iterator<T> concat(Iterator<? extends Iterator<? extends T>> inputs)\n", "    static <T> Iterator<T> concatNoDefensiveCopy(Iterator<? extends T>... inputs)\n", "    public static <T> UnmodifiableIterator<List<T>> partition(Iterator<T> iterator, int size)\n", "    public static <T> UnmodifiableIterator<List<T>> paddedPartition(Iterator<T> iterator, int size)\n", "    private static <T> UnmodifiableIterator<List<T>> partitionImpl(\n", "    public static <T> UnmodifiableIterator<T> filter(\n", "    public static <T> UnmodifiableIterator<T> filter(Iterator<?> unfiltered, Class<T> desiredType)\n", "    public static <T> boolean any(Iterator<T> iterator, Predicate<? super T> predicate)\n", "    public static <T> boolean all(Iterator<T> iterator, Predicate<? super T> predicate)\n", "    public static <T> T find(Iterator<T> iterator, Predicate<? super T> predicate)\n", "    public static <T> T find(\n", "    public static <T> Optional<T> tryFind(Iterator<T> iterator, Predicate<? super T> predicate)\n", "    public static <T> int indexOf(Iterator<T> iterator, Predicate<? super T> predicate)\n", "    public static <F, T> Iterator<T> transform(\n", "    public static <T> T get(Iterator<T> iterator, int position)\n", "    public static <T> T get(\n", "    static void checkNonnegative(int position)\n", "    public static <T> T getNext(Iterator<? extends T> iterator, @NullableDecl T defaultValue)\n", "    public static <T> T getLast(Iterator<T> iterator)\n", "    public static <T> T getLast(Iterator<? extends T> iterator, @NullableDecl T defaultValue)\n", "    public static int advance(Iterator<?> iterator, int numberToAdvance)\n", "    public static <T> Iterator<T> limit(final Iterator<T> iterator, final int limitSize)\n", "    public static <T> Iterator<T> consumingIterator(final Iterator<T> iterator)\n", "    static <T> T pollNext(Iterator<T> iterator)\n", "    static void clear(Iterator<?> iterator)\n", "    public static <T> UnmodifiableIterator<T> forArray(final T... array)\n", "    static <T> UnmodifiableListIterator<T> forArray(\n", "    public static <T> UnmodifiableIterator<T> singletonIterator(@NullableDecl final T value)\n", "    public static <T> UnmodifiableIterator<T> forEnumeration(final Enumeration<T> enumeration)\n", "    public static <T> Enumeration<T> asEnumeration(final Iterator<T> iterator)\n", "    public static <T> PeekingIterator<T> peekingIterator(Iterator<? extends T> iterator)\n", "    public static <T> PeekingIterator<T> peekingIterator(PeekingIterator<T> iterator)\n", "    public static <T> UnmodifiableIterator<T> mergeSorted(\n", "    static <T> ListIterator<T> cast(Iterator<T> iterator)\n"], "context": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Predicates.instanceOf;\nimport static com.google.common.collect.CollectPreconditions.checkRemove;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Function;\nimport com.google.common.base.Objects;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.common.primitives.Ints;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * This class contains static utility methods that operate on or return objects of type {@link\n * Iterator}. Except as noted, each method has a corresponding {@link Iterable}-based method in the\n * {@link Iterables} class.\n *\n * <p><i>Performance notes:</i> Unless otherwise noted, all of the iterators produced in this class\n * are <i>lazy</i>, which means that they only advance the backing iteration when absolutely\n * necessary.\n *\n * <p>See the Guava User Guide section on <a href=\n * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#iterables\"> {@code\n * Iterators}</a>.\n *\n * @author Kevin Bourrillion\n * @author Jared Levy\n * @since 2.0\n */\n@GwtCompatible(emulated = true)\npublic final class Iterators\n{\n    private Iterators() {}\n\n    /**\n     * Returns the empty iterator.\n     *\n     * <p>The {@link Iterable} equivalent of this method is {@link ImmutableSet#of()}.\n     */\n    static <T> UnmodifiableIterator<T> emptyIterator()\n    {\n        return emptyListIterator();\n    }\n\n    /**\n     * Returns the empty iterator.\n     *\n     * <p>The {@link Iterable} equivalent of this method is {@link ImmutableSet#of()}.\n     */\n    // Casting to any type is safe since there are no actual elements.\n    @SuppressWarnings(\"unchecked\")\n    static <T> UnmodifiableListIterator<T> emptyListIterator()\n    {\n        return (UnmodifiableListIterator<T>) ArrayItr.EMPTY;\n    }\n\n    /**\n     * This is an enum singleton rather than an anonymous class so ProGuard can figure out it's only\n     * referenced by emptyModifiableIterator().\n     */\n    private enum EmptyModifiableIterator implements Iterator<Object>\n    {\n        INSTANCE;\n\n        @Override\n        public boolean hasNext()\n        {\n            return false;\n        }\n\n        @Override\n        public Object next()\n        {\n            throw new NoSuchElementException();\n        }\n\n        @Override\n        public void remove()\n        {\n            checkRemove(false);\n        }\n    }\n\n    /**\n     * Returns the empty {@code Iterator} that throws {@link IllegalStateException} instead of {@link\n     * UnsupportedOperationException} on a call to {@link Iterator#remove()}.\n     */\n    // Casting to any type is safe since there are no actual elements.\n    @SuppressWarnings(\"unchecked\")\n    static <T> Iterator<T> emptyModifiableIterator()\n    {\n        return (Iterator<T>) EmptyModifiableIterator.INSTANCE;\n    }\n\n    /** Returns an unmodifiable view of {@code iterator}. */\n    public static <T> UnmodifiableIterator<T> unmodifiableIterator(\n        final Iterator<? extends T> iterator)\n    {\n        checkNotNull(iterator);\n        if (iterator instanceof UnmodifiableIterator)\n        {\n            @SuppressWarnings(\"unchecked\") // Since it's unmodifiable, the covariant cast is safe\n            UnmodifiableIterator<T> result = (UnmodifiableIterator<T>) iterator;\n            return result;\n        }\n        return new UnmodifiableIterator<T>()\n        {\n            @Override\n            public boolean hasNext()\n            {\n                return iterator.hasNext();\n            }\n\n            @Override\n            public T next()\n            {\n                return iterator.next();\n            }\n        };\n    }\n\n    /**\n     * Simply returns its argument.\n     *\n     * @deprecated no need to use this\n     * @since 10.0\n     */\n    @Deprecated\n    public static <T> UnmodifiableIterator<T> unmodifiableIterator(UnmodifiableIterator<T> iterator)\n    {\n        return checkNotNull(iterator);\n    }\n\n    /**\n     * Returns the number of elements remaining in {@code iterator}. The iterator will be left\n     * exhausted: its {@code hasNext()} method will return {@code false}.\n     */\n    public static int size(Iterator<?> iterator)\n    {\n        long count = 0L;\n        while (iterator.hasNext())\n        {\n            iterator.next();\n            count++;\n        }\n        return Ints.saturatedCast(count);\n    }\n\n    /** Returns {@code true} if {@code iterator} contains {@code element}. */\n    public static boolean contains(Iterator<?> iterator, @NullableDecl Object element)\n    {\n        if (element == null)\n        {\n            while (iterator.hasNext())\n            {\n                if (iterator.next() == null)\n                {\n                    return true;\n                }\n            }\n        }\n        else\n        {\n            while (iterator.hasNext())\n            {\n                if (element.equals(iterator.next()))\n                {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Traverses an iterator and removes every element that belongs to the provided collection. The\n     * iterator will be left exhausted: its {@code hasNext()} method will return {@code false}.\n     *\n     * @param removeFrom the iterator to (potentially) remove elements from\n     * @param elementsToRemove the elements to remove\n     * @return {@code true} if any element was removed from {@code iterator}\n     */\n    @CanIgnoreReturnValue\n    public static boolean removeAll(Iterator<?> removeFrom, Collection<?> elementsToRemove)\n    {\n        checkNotNull(elementsToRemove);\n        boolean result = false;\n        while (removeFrom.hasNext())\n        {\n            if (elementsToRemove.contains(removeFrom.next()))\n            {\n                removeFrom.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Removes every element that satisfies the provided predicate from the iterator. The iterator\n     * will be left exhausted: its {@code hasNext()} method will return {@code false}.\n     *\n     * @param removeFrom the iterator to (potentially) remove elements from\n     * @param predicate a predicate that determines whether an element should be removed\n     * @return {@code true} if any elements were removed from the iterator\n     * @since 2.0\n     */\n    @CanIgnoreReturnValue\n    public static <T> boolean removeIf(Iterator<T> removeFrom, Predicate<? super T> predicate)\n    {\n        checkNotNull(predicate);\n        boolean modified = false;\n        while (removeFrom.hasNext())\n        {\n            if (predicate.apply(removeFrom.next()))\n            {\n                removeFrom.remove();\n                modified = true;\n            }\n        }\n        return modified;\n    }\n\n    /**\n     * Traverses an iterator and removes every element that does not belong to the provided\n     * collection. The iterator will be left exhausted: its {@code hasNext()} method will return\n     * {@code false}.\n     *\n     * @param removeFrom the iterator to (potentially) remove elements from\n     * @param elementsToRetain the elements to retain\n     * @return {@code true} if any element was removed from {@code iterator}\n     */\n    @CanIgnoreReturnValue\n    public static boolean retainAll(Iterator<?> removeFrom, Collection<?> elementsToRetain)\n    {\n        checkNotNull(elementsToRetain);\n        boolean result = false;\n        while (removeFrom.hasNext())\n        {\n            if (!elementsToRetain.contains(removeFrom.next()))\n            {\n                removeFrom.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Determines whether two iterators contain equal elements in the same order. More specifically,\n     * this method returns {@code true} if {@code iterator1} and {@code iterator2} contain the same\n     * number of elements and every element of {@code iterator1} is equal to the corresponding element\n     * of {@code iterator2}.\n     *\n     * <p>Note that this will modify the supplied iterators, since they will have been advanced some\n     * number of elements forward.\n     */\n    public static boolean elementsEqual(Iterator<?> iterator1, Iterator<?> iterator2)\n    {\n        while (iterator1.hasNext())\n        {\n            if (!iterator2.hasNext())\n            {\n                return false;\n            }\n            Object o1 = iterator1.next();\n            Object o2 = iterator2.next();\n            if (!Objects.equal(o1, o2))\n            {\n                return false;\n            }\n        }\n        return !iterator2.hasNext();\n    }\n\n    /**\n     * Returns a string representation of {@code iterator}, with the format {@code [e1, e2, ..., en]}.\n     * The iterator will be left exhausted: its {@code hasNext()} method will return {@code false}.\n     */\n    public static String toString(Iterator<?> iterator)\n    {\n        StringBuilder sb = new StringBuilder().append('[');\n        boolean first = true;\n        while (iterator.hasNext())\n        {\n            if (!first)\n            {\n                sb.append(\", \");\n            }\n            first = false;\n            sb.append(iterator.next());\n        }\n        return sb.append(']').toString();\n    }\n\n    /**\n     * Returns the single element contained in {@code iterator}.\n     *\n     * @throws NoSuchElementException if the iterator is empty\n     * @throws IllegalArgumentException if the iterator contains multiple elements. The state of the\n     *     iterator is unspecified.\n     */\n    public static <T> T getOnlyElement(Iterator<T> iterator)\n    {\n        T first = iterator.next();\n        if (!iterator.hasNext())\n        {\n            return first;\n        }\n\n        StringBuilder sb = new StringBuilder().append(\"expected one element but was: <\").append(first);\n        for (int i = 0; i < 4 && iterator.hasNext(); i++)\n        {\n            sb.append(\", \").append(iterator.next());\n        }\n        if (iterator.hasNext())\n        {\n            sb.append(\", ...\");\n        }\n        sb.append('>');\n\n        throw new IllegalArgumentException(sb.toString());\n    }\n\n    /**\n     * Returns the single element contained in {@code iterator}, or {@code defaultValue} if the\n     * iterator is empty.\n     *\n     * @throws IllegalArgumentException if the iterator contains multiple elements. The state of the\n     *     iterator is unspecified.\n     */\n    @NullableDecl\n    public static <T> T getOnlyElement(Iterator<? extends T> iterator, @NullableDecl T defaultValue)\n    {\n        return iterator.hasNext() ? getOnlyElement(iterator) : defaultValue;\n    }\n\n    /**\n     * Copies an iterator's elements into an array. The iterator will be left exhausted: its {@code\n     * hasNext()} method will return {@code false}.\n     *\n     * @param iterator the iterator to copy\n     * @param type the type of the elements\n     * @return a newly-allocated array into which all the elements of the iterator have been copied\n     */\n    @GwtIncompatible // Array.newInstance(Class, int)\n    public static <T> T[] toArray(Iterator<? extends T> iterator, Class<T> type)\n    {\n        List<T> list = Lists.newArrayList(iterator);\n        return Iterables.toArray(list, type);\n    }\n\n    /**\n     * Adds all elements in {@code iterator} to {@code collection}. The iterator will be left\n     * exhausted: its {@code hasNext()} method will return {@code false}.\n     *\n     * @return {@code true} if {@code collection} was modified as a result of this operation\n     */\n    @CanIgnoreReturnValue\n    public static <T> boolean addAll(Collection<T> addTo, Iterator<? extends T> iterator)\n    {\n        checkNotNull(addTo);\n        checkNotNull(iterator);\n        boolean wasModified = false;\n        while (iterator.hasNext())\n        {\n            wasModified |= addTo.add(iterator.next());\n        }\n        return wasModified;\n    }\n\n    /**\n     * Returns the number of elements in the specified iterator that equal the specified object. The\n     * iterator will be left exhausted: its {@code hasNext()} method will return {@code false}.\n     *\n     * @see Collections#frequency\n     */\n    public static int frequency(Iterator<?> iterator, @NullableDecl Object element)\n    {\n        int count = 0;\n        while (contains(iterator, element))\n        {\n            // Since it lives in the same class, we know contains gets to the element and then stops,\n            // though that isn't currently publicly documented.\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Returns an iterator that cycles indefinitely over the elements of {@code iterable}.\n     *\n     * <p>The returned iterator supports {@code remove()} if the provided iterator does. After {@code\n     * remove()} is called, subsequent cycles omit the removed element, which is no longer in {@code\n     * iterable}. The iterator's {@code hasNext()} method returns {@code true} until {@code iterable}\n     * is empty.\n     *\n     * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You\n     * should use an explicit {@code break} or be certain that you will eventually remove all the\n     * elements.\n     */\n    public static <T> Iterator<T> cycle(final Iterable<T> iterable)\n    {\n        checkNotNull(iterable);\n        return new Iterator<T>()\n        {\n            Iterator<T> iterator = emptyModifiableIterator();\n\n            @Override\n            public boolean hasNext()\n            {\n                /*\n                 * Don't store a new Iterator until we know the user can't remove() the last returned\n                 * element anymore. Otherwise, when we remove from the old iterator, we may be invalidating\n                 * the new one. The result is a ConcurrentModificationException or other bad behavior.\n                 *\n                 * (If we decide that we really, really hate allocating two Iterators per cycle instead of\n                 * one, we can optimistically store the new Iterator and then be willing to throw it out if\n                 * the user calls remove().)\n                 */\n                return iterator.hasNext() || iterable.iterator().hasNext();\n            }\n\n            @Override\n            public T next()\n            {\n                if (!iterator.hasNext())\n                {\n                    iterator = iterable.iterator();\n                    if (!iterator.hasNext())\n                    {\n                        throw new NoSuchElementException();\n                    }\n                }\n                return iterator.next();\n            }\n\n            @Override\n            public void remove()\n            {\n                iterator.remove();\n            }\n        };\n    }\n\n    /**\n     * Returns an iterator that cycles indefinitely over the provided elements.\n     *\n     * <p>The returned iterator supports {@code remove()}. After {@code remove()} is called,\n     * subsequent cycles omit the removed element, but {@code elements} does not change. The\n     * iterator's {@code hasNext()} method returns {@code true} until all of the original elements\n     * have been removed.\n     *\n     * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You\n     * should use an explicit {@code break} or be certain that you will eventually remove all the\n     * elements.\n     */\n    @SafeVarargs\n    public static <T> Iterator<T> cycle(T... elements)\n    {\n        return cycle(Lists.newArrayList(elements));\n    }\n\n    /**\n     * Returns an Iterator that walks the specified array, nulling out elements behind it. This can\n     * avoid memory leaks when an element is no longer necessary.\n     *\n     * <p>This is mainly just to avoid the intermediate ArrayDeque in ConsumingQueueIterator.\n     */\n\n    /**\n     * Combines two iterators into a single iterator. The returned iterator iterates across the\n     * elements in {@code a}, followed by the elements in {@code b}. The source iterators are not\n     * polled until necessary.\n     *\n     * <p>The returned iterator supports {@code remove()} when the corresponding input iterator\n     * supports it.\n     */\n    public static <T> Iterator<T> concat(Iterator<? extends T> a, Iterator<? extends T> b)\n    {\n        checkNotNull(a);\n        checkNotNull(b);\n        return concat(consumingForArray(a, b));\n    }\n\n    /**\n     * Combines three iterators into a single iterator. The returned iterator iterates across the\n     * elements in {@code a}, followed by the elements in {@code b}, followed by the elements in\n     * {@code c}. The source iterators are not polled until necessary.\n     *\n     * <p>The returned iterator supports {@code remove()} when the corresponding input iterator\n     * supports it.\n     */\n    public static <T> Iterator<T> concat(\n        Iterator<? extends T> a, Iterator<? extends T> b, Iterator<? extends T> c)\n    {\n        checkNotNull(a);\n        checkNotNull(b);\n        checkNotNull(c);\n        return concat(consumingForArray(a, b, c));\n    }\n\n    /**\n     * Combines four iterators into a single iterator. The returned iterator iterates across the\n     * elements in {@code a}, followed by the elements in {@code b}, followed by the elements in\n     * {@code c}, followed by the elements in {@code d}. The source iterators are not polled until\n     * necessary.\n     *\n     * <p>The returned iterator supports {@code remove()} when the corresponding input iterator\n     * supports it.\n     */\n    public static <T> Iterator<T> concat(\n        Iterator<? extends T> a,\n        Iterator<? extends T> b,\n        Iterator<? extends T> c,\n        Iterator<? extends T> d)\n    {\n        checkNotNull(a);\n        checkNotNull(b);\n        checkNotNull(c);\n        checkNotNull(d);\n        return concat(consumingForArray(a, b, c, d));\n    }\n\n    /**\n     * Combines multiple iterators into a single iterator. The returned iterator iterates across the\n     * elements of each iterator in {@code inputs}. The input iterators are not polled until\n     * necessary.\n     *\n     * <p>The returned iterator supports {@code remove()} when the corresponding input iterator\n     * supports it.\n     *\n     * @throws NullPointerException if any of the provided iterators is null\n     */\n    public static <T> Iterator<T> concat(Iterator<? extends T>... inputs)\n    {\n        return concatNoDefensiveCopy(Arrays.copyOf(inputs, inputs.length));\n    }\n\n    /**\n     * Combines multiple iterators into a single iterator. The returned iterator iterates across the\n     * elements of each iterator in {@code inputs}. The input iterators are not polled until\n     * necessary.\n     *\n     * <p>The returned iterator supports {@code remove()} when the corresponding input iterator\n     * supports it. The methods of the returned iterator may throw {@code NullPointerException} if any\n     * of the input iterators is null.\n     */\n    public static <T> Iterator<T> concat(Iterator<? extends Iterator<? extends T>> inputs)\n    {\n        return new ConcatenatedIterator<T>(inputs);\n    }\n\n    /** Concats a varargs array of iterators without making a defensive copy of the array. */\n    static <T> Iterator<T> concatNoDefensiveCopy(Iterator<? extends T>... inputs)\n    {\n        for (Iterator<? extends T> input : checkNotNull(inputs))\n        {\n            checkNotNull(input);\n        }\n        return concat(consumingForArray(inputs));\n    }\n\n    /**\n     * Divides an iterator into unmodifiable sublists of the given size (the final list may be\n     * smaller). For example, partitioning an iterator containing {@code [a, b, c, d, e]} with a\n     * partition size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer iterator containing two\n     * inner lists of three and two elements, all in the original order.\n     *\n     * <p>The returned lists implement {@link java.util.RandomAccess}.\n     *\n     * @param iterator the iterator to return a partitioned view of\n     * @param size the desired size of each partition (the last may be smaller)\n     * @return an iterator of immutable lists containing the elements of {@code iterator} divided into\n     *     partitions\n     * @throws IllegalArgumentException if {@code size} is nonpositive\n     */\n    public static <T> UnmodifiableIterator<List<T>> partition(Iterator<T> iterator, int size)\n    {\n        return partitionImpl(iterator, size, false);\n    }\n\n    /**\n     * Divides an iterator into unmodifiable sublists of the given size, padding the final iterator\n     * with null values if necessary. For example, partitioning an iterator containing {@code [a, b,\n     * c, d, e]} with a partition size of 3 yields {@code [[a, b, c], [d, e, null]]} -- an outer\n     * iterator containing two inner lists of three elements each, all in the original order.\n     *\n     * <p>The returned lists implement {@link java.util.RandomAccess}.\n     *\n     * @param iterator the iterator to return a partitioned view of\n     * @param size the desired size of each partition\n     * @return an iterator of immutable lists containing the elements of {@code iterator} divided into\n     *     partitions (the final iterable may have trailing null elements)\n     * @throws IllegalArgumentException if {@code size} is nonpositive\n     */\n    public static <T> UnmodifiableIterator<List<T>> paddedPartition(Iterator<T> iterator, int size)\n    {\n        return partitionImpl(iterator, size, true);\n    }\n\n    private static <T> UnmodifiableIterator<List<T>> partitionImpl(\n        final Iterator<T> iterator, final int size, final boolean pad)\n    {\n        checkNotNull(iterator);\n        checkArgument(size > 0);\n        return new UnmodifiableIterator<List<T>>()\n        {\n            @Override\n            public boolean hasNext()\n            {\n                return iterator.hasNext();\n            }\n\n            @Override\n            public List<T> next()\n            {\n                if (!hasNext())\n                {\n                    throw new NoSuchElementException();\n                }\n                Object[] array = new Object[size];\n                int count = 0;\n                for (; count < size && iterator.hasNext(); count++)\n                {\n                    array[count] = iterator.next();\n                }\n                for (int i = count; i < size; i++)\n                {\n                    array[i] = null; // for GWT\n                }\n\n                @SuppressWarnings(\"unchecked\") // we only put Ts in it\n                List<T> list = Collections.unmodifiableList((List<T>) Arrays.asList(array));\n                return (pad || count == size) ? list : list.subList(0, count);\n            }\n        };\n    }\n\n    /**\n     * Returns a view of {@code unfiltered} containing all elements that satisfy the input predicate\n     * {@code retainIfTrue}.\n     */\n    public static <T> UnmodifiableIterator<T> filter(\n        final Iterator<T> unfiltered, final Predicate<? super T> retainIfTrue)\n    {\n        checkNotNull(unfiltered);\n        checkNotNull(retainIfTrue);\n        return new AbstractIterator<T>()\n        {\n            @Override\n            protected T computeNext()\n            {\n                while (unfiltered.hasNext())\n                {\n                    T element = unfiltered.next();\n                    if (retainIfTrue.apply(element))\n                    {\n                        return element;\n                    }\n                }\n                return endOfData();\n            }\n        };\n    }\n\n    /**\n     * Returns a view of {@code unfiltered} containing all elements that are of the type {@code\n     * desiredType}.\n     */\n    @SuppressWarnings(\"unchecked\") // can cast to <T> because non-Ts are removed\n    @GwtIncompatible // Class.isInstance\n    public static <T> UnmodifiableIterator<T> filter(Iterator<?> unfiltered, Class<T> desiredType)\n    {\n        return (UnmodifiableIterator<T>) filter(unfiltered, instanceOf(desiredType));\n    }\n\n    /**\n     * Returns {@code true} if one or more elements returned by {@code iterator} satisfy the given\n     * predicate.\n     */\n    public static <T> boolean any(Iterator<T> iterator, Predicate<? super T> predicate)\n    {\n        return indexOf(iterator, predicate) != -1;\n    }\n\n    /**\n     * Returns {@code true} if every element returned by {@code iterator} satisfies the given\n     * predicate. If {@code iterator} is empty, {@code true} is returned.\n     */\n    public static <T> boolean all(Iterator<T> iterator, Predicate<? super T> predicate)\n    {\n        checkNotNull(predicate);\n        while (iterator.hasNext())\n        {\n            T element = iterator.next();\n            if (!predicate.apply(element))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the first element in {@code iterator} that satisfies the given predicate; use this\n     * method only when such an element is known to exist. If no such element is found, the iterator\n     * will be left exhausted: its {@code hasNext()} method will return {@code false}. If it is\n     * possible that <i>no</i> element will match, use {@link #tryFind} or {@link #find(Iterator,\n     * Predicate, Object)} instead.\n     *\n     * @throws NoSuchElementException if no element in {@code iterator} matches the given predicate\n     */\n    public static <T> T find(Iterator<T> iterator, Predicate<? super T> predicate)\n    {\n        checkNotNull(iterator);\n        checkNotNull(predicate);\n        while (iterator.hasNext())\n        {\n            T t = iterator.next();\n            if (predicate.apply(t))\n            {\n                return t;\n            }\n        }\n        throw new NoSuchElementException();\n    }\n\n    /**\n     * Returns the first element in {@code iterator} that satisfies the given predicate. If no such\n     * element is found, {@code defaultValue} will be returned from this method and the iterator will\n     * be left exhausted: its {@code hasNext()} method will return {@code false}. Note that this can\n     * usually be handled more naturally using {@code tryFind(iterator, predicate).or(defaultValue)}.\n     *\n     * @since 7.0\n     */\n    @NullableDecl\n    public static <T> T find(\n        Iterator<? extends T> iterator,\n        Predicate<? super T> predicate,\n        @NullableDecl T defaultValue)\n    {\n        checkNotNull(iterator);\n        checkNotNull(predicate);\n        while (iterator.hasNext())\n        {\n            T t = iterator.next();\n            if (predicate.apply(t))\n            {\n                return t;\n            }\n        }\n        return defaultValue;\n    }\n\n    /**\n     * Returns an {@link Optional} containing the first element in {@code iterator} that satisfies the\n     * given predicate, if such an element exists. If no such element is found, an empty {@link\n     * Optional} will be returned from this method and the iterator will be left exhausted: its {@code\n     * hasNext()} method will return {@code false}.\n     *\n     * <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code null}. If {@code null}\n     * is matched in {@code iterator}, a NullPointerException will be thrown.\n     *\n     * @since 11.0\n     */\n    public static <T> Optional<T> tryFind(Iterator<T> iterator, Predicate<? super T> predicate)\n    {\n        checkNotNull(iterator);\n        checkNotNull(predicate);\n        while (iterator.hasNext())\n        {\n            T t = iterator.next();\n            if (predicate.apply(t))\n            {\n                return Optional.of(t);\n            }\n        }\n        return Optional.absent();\n    }\n\n    /**\n     * Returns the index in {@code iterator} of the first element that satisfies the provided {@code\n     * predicate}, or {@code -1} if the Iterator has no such elements.\n     *\n     * <p>More formally, returns the lowest index {@code i} such that {@code\n     * predicate.apply(Iterators.get(iterator, i))} returns {@code true}, or {@code -1} if there is no\n     * such index.\n     *\n     * <p>If -1 is returned, the iterator will be left exhausted: its {@code hasNext()} method will\n     * return {@code false}. Otherwise, the iterator will be set to the element which satisfies the\n     * {@code predicate}.\n     *\n     * @since 2.0\n     */\n    public static <T> int indexOf(Iterator<T> iterator, Predicate<? super T> predicate)\n    {\n        checkNotNull(predicate, \"predicate\");\n        for (int i = 0; iterator.hasNext(); i++)\n        {\n            T current = iterator.next();\n            if (predicate.apply(current))\n            {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns a view containing the result of applying {@code function} to each element of {@code\n     * fromIterator}.\n     *\n     * <p>The returned iterator supports {@code remove()} if {@code fromIterator} does. After a\n     * successful {@code remove()} call, {@code fromIterator} no longer contains the corresponding\n     * element.\n     */\n    public static <F, T> Iterator<T> transform(\n        final Iterator<F> fromIterator, final Function<? super F, ? extends T> function)\n    {\n        checkNotNull(function);\n        return new TransformedIterator<F, T>(fromIterator)\n        {\n            @Override\n            T transform(F from)\n            {\n                return function.apply(from);\n            }\n        };\n    }\n\n    /**\n     * Advances {@code iterator} {@code position + 1} times, returning the element at the {@code\n     * position}th position.\n     *\n     * @param position position of the element to return\n     * @return the element at the specified position in {@code iterator}\n     * @throws IndexOutOfBoundsException if {@code position} is negative or greater than or equal to\n     *     the number of elements remaining in {@code iterator}\n     */\n    public static <T> T get(Iterator<T> iterator, int position)\n    {\n        checkNonnegative(position);\n        int skipped = advance(iterator, position);\n        if (!iterator.hasNext())\n        {\n            throw new IndexOutOfBoundsException(\n                \"position (\"\n                + position\n                + \") must be less than the number of elements that remained (\"\n                + skipped\n                + \")\");\n        }\n        return iterator.next();\n    }\n\n    /**\n     * Advances {@code iterator} {@code position + 1} times, returning the element at the {@code\n     * position}th position or {@code defaultValue} otherwise.\n     *\n     * @param position position of the element to return\n     * @param defaultValue the default value to return if the iterator is empty or if {@code position}\n     *     is greater than the number of elements remaining in {@code iterator}\n     * @return the element at the specified position in {@code iterator} or {@code defaultValue} if\n     *     {@code iterator} produces fewer than {@code position + 1} elements.\n     * @throws IndexOutOfBoundsException if {@code position} is negative\n     * @since 4.0\n     */\n    @NullableDecl\n    public static <T> T get(\n        Iterator<? extends T> iterator, int position, @NullableDecl T defaultValue)\n    {\n        checkNonnegative(position);\n        advance(iterator, position);\n        return getNext(iterator, defaultValue);\n    }\n\n    static void checkNonnegative(int position)\n    {\n        if (position < 0)\n        {\n            throw new IndexOutOfBoundsException(\"position (\" + position + \") must not be negative\");\n        }\n    }\n\n    /**\n     * Returns the next element in {@code iterator} or {@code defaultValue} if the iterator is empty.\n     * The {@link Iterables} analog to this method is {@link Iterables#getFirst}.\n     *\n     * @param defaultValue the default value to return if the iterator is empty\n     * @return the next element of {@code iterator} or the default value\n     * @since 7.0\n     */\n    @NullableDecl\n    public static <T> T getNext(Iterator<? extends T> iterator, @NullableDecl T defaultValue)\n    {\n        return iterator.hasNext() ? iterator.next() : defaultValue;\n    }\n\n    /**\n     * Advances {@code iterator} to the end, returning the last element.\n     *\n     * @return the last element of {@code iterator}\n     * @throws NoSuchElementException if the iterator is empty\n     */\n    public static <T> T getLast(Iterator<T> iterator)\n    {\n        while (true)\n        {\n            T current = iterator.next();\n            if (!iterator.hasNext())\n            {\n                return current;\n            }\n        }\n    }\n\n    /**\n     * Advances {@code iterator} to the end, returning the last element or {@code defaultValue} if the\n     * iterator is empty.\n     *\n     * @param defaultValue the default value to return if the iterator is empty\n     * @return the last element of {@code iterator}\n     * @since 3.0\n     */\n    @NullableDecl\n    public static <T> T getLast(Iterator<? extends T> iterator, @NullableDecl T defaultValue)\n    {\n        return iterator.hasNext() ? getLast(iterator) : defaultValue;\n    }\n\n    /**\n     * Calls {@code next()} on {@code iterator}, either {@code numberToAdvance} times or until {@code\n     * hasNext()} returns {@code false}, whichever comes first.\n     *\n     * @return the number of elements the iterator was advanced\n     * @since 13.0 (since 3.0 as {@code Iterators.skip})\n     */\n    @CanIgnoreReturnValue\n    public static int advance(Iterator<?> iterator, int numberToAdvance)\n    {\n        checkNotNull(iterator);\n        checkArgument(numberToAdvance >= 0, \"numberToAdvance must be nonnegative\");\n\n        int i;\n        for (i = 0; i < numberToAdvance && iterator.hasNext(); i++)\n        {\n            iterator.next();\n        }\n        return i;\n    }\n\n    /**\n     * Returns a view containing the first {@code limitSize} elements of {@code iterator}. If {@code\n     * iterator} contains fewer than {@code limitSize} elements, the returned view contains all of its\n     * elements. The returned iterator supports {@code remove()} if {@code iterator} does.\n     *\n     * @param iterator the iterator to limit\n     * @param limitSize the maximum number of elements in the returned iterator\n     * @throws IllegalArgumentException if {@code limitSize} is negative\n     * @since 3.0\n     */\n    public static <T> Iterator<T> limit(final Iterator<T> iterator, final int limitSize)\n    {\n        checkNotNull(iterator);\n        checkArgument(limitSize >= 0, \"limit is negative\");\n        return new Iterator<T>()\n        {\n            private int count;\n\n            @Override\n            public boolean hasNext()\n            {\n                return count < limitSize && iterator.hasNext();\n            }\n\n            @Override\n            public T next()\n            {\n                if (!hasNext())\n                {\n                    throw new NoSuchElementException();\n                }\n                count++;\n                return iterator.next();\n            }\n\n            @Override\n            public void remove()\n            {\n                iterator.remove();\n            }\n        };\n    }\n\n    /**\n     * Returns a view of the supplied {@code iterator} that removes each element from the supplied\n     * {@code iterator} as it is returned.\n     *\n     * <p>The provided iterator must support {@link Iterator#remove()} or else the returned iterator\n     * will fail on the first call to {@code next}.\n     *\n     * @param iterator the iterator to remove and return elements from\n     * @return an iterator that removes and returns elements from the supplied iterator\n     * @since 2.0\n     */\n    public static <T> Iterator<T> consumingIterator(final Iterator<T> iterator)\n    {\n        checkNotNull(iterator);\n        return new UnmodifiableIterator<T>()\n        {\n            @Override\n            public boolean hasNext()\n            {\n                return iterator.hasNext();\n            }\n\n            @Override\n            public T next()\n            {\n                T next = iterator.next();\n                iterator.remove();\n                return next;\n            }\n\n            @Override\n            public String toString()\n            {\n                return \"Iterators.consumingIterator(...)\";\n            }\n        };\n    }\n\n    /**\n     * Deletes and returns the next value from the iterator, or returns {@code null} if there is no\n     * such value.\n     */\n    @NullableDecl\n    static <T> T pollNext(Iterator<T> iterator)\n    {\n        if (iterator.hasNext())\n        {\n            T result = iterator.next();\n            iterator.remove();\n            return result;\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    // Methods only in Iterators, not in Iterables\n\n    /** Clears the iterator using its remove method. */\n    static void clear(Iterator<?> iterator)\n    {\n        checkNotNull(iterator);\n        while (iterator.hasNext())\n        {\n            iterator.next();\n            iterator.remove();\n        }\n    }\n\n    /**\n     * Returns an iterator containing the elements of {@code array} in order. The returned iterator is\n     * a view of the array; subsequent changes to the array will be reflected in the iterator.\n     *\n     * <p><b>Note:</b> It is often preferable to represent your data using a collection type, for\n     * example using {@link Arrays#asList(Object[])}, making this method unnecessary.\n     *\n     * <p>The {@code Iterable} equivalent of this method is either {@link Arrays#asList(Object[])},\n     * {@link ImmutableList#copyOf(Object[])}}, or {@link ImmutableList#of}.\n     */\n    @SafeVarargs\n    public static <T> UnmodifiableIterator<T> forArray(final T... array)\n    {\n        return forArray(array, 0, array.length, 0);\n    }\n\n    /**\n     * Returns a list iterator containing the elements in the specified range of {@code array} in\n     * order, starting at the specified index.\n     *\n     * <p>The {@code Iterable} equivalent of this method is {@code\n     * Arrays.asList(array).subList(offset, offset + length).listIterator(index)}.\n     */\n    static <T> UnmodifiableListIterator<T> forArray(\n        final T[] array, final int offset, int length, int index)\n    {\n        checkArgument(length >= 0);\n        int end = offset + length;\n\n        // Technically we should give a slightly more descriptive error on overflow\n        Preconditions.checkPositionIndexes(offset, end, array.length);\n        Preconditions.checkPositionIndex(index, length);\n        if (length == 0)\n        {\n            return emptyListIterator();\n        }\n        return new ArrayItr<T>(array, offset, length, index);\n    }\n\n    private static final class ArrayItr<T> extends AbstractIndexedListIterator<T>\n    {\n        static final UnmodifiableListIterator<Object> EMPTY = new ArrayItr<>(new Object[0], 0, 0, 0);\n\n        private final T[] array;\n        private final int offset;\n\n        ArrayItr(T[] array, int offset, int length, int index)\n        {\n            super(length, index);\n            this.array = array;\n            this.offset = offset;\n        }\n\n        @Override\n        protected T get(int index)\n        {\n            return array[offset + index];\n        }\n    }\n\n    /**\n     * Returns an iterator containing only {@code value}.\n     *\n     * <p>The {@link Iterable} equivalent of this method is {@link Collections#singleton}.\n     */\n    public static <T> UnmodifiableIterator<T> singletonIterator(@NullableDecl final T value)\n    {\n        return new UnmodifiableIterator<T>()\n        {\n            boolean done;\n\n            @Override\n            public boolean hasNext()\n            {\n                return !done;\n            }\n\n            @Override\n            public T next()\n            {\n                if (done)\n                {\n                    throw new NoSuchElementException();\n                }\n                done = true;\n                return value;\n            }\n        };\n    }\n\n    /**\n     * Adapts an {@code Enumeration} to the {@code Iterator} interface.\n     *\n     * <p>This method has no equivalent in {@link Iterables} because viewing an {@code Enumeration} as\n     * an {@code Iterable} is impossible. However, the contents can be <i>copied</i> into a collection\n     * using {@link Collections#list}.\n     */\n    public static <T> UnmodifiableIterator<T> forEnumeration(final Enumeration<T> enumeration)\n    {\n        checkNotNull(enumeration);\n        return new UnmodifiableIterator<T>()\n        {\n            @Override\n            public boolean hasNext()\n            {\n                return enumeration.hasMoreElements();\n            }\n\n            @Override\n            public T next()\n            {\n                return enumeration.nextElement();\n            }\n        };\n    }\n\n    /**\n     * Adapts an {@code Iterator} to the {@code Enumeration} interface.\n     *\n     * <p>The {@code Iterable} equivalent of this method is either {@link Collections#enumeration} (if\n     * you have a {@link Collection}), or {@code Iterators.asEnumeration(collection.iterator())}.\n     */\n    public static <T> Enumeration<T> asEnumeration(final Iterator<T> iterator)\n    {\n        checkNotNull(iterator);\n        return new Enumeration<T>()\n        {\n            @Override\n            public boolean hasMoreElements()\n            {\n                return iterator.hasNext();\n            }\n\n            @Override\n            public T nextElement()\n            {\n                return iterator.next();\n            }\n        };\n    }\n\n    /** Implementation of PeekingIterator that avoids peeking unless necessary. */\n    private static class PeekingImpl<E> implements PeekingIterator<E>\n    {\n\n        private final Iterator<? extends E> iterator;\n        private boolean hasPeeked;\n        @NullableDecl private E peekedElement;\n\n        public PeekingImpl(Iterator<? extends E> iterator)\n        {\n            this.iterator = checkNotNull(iterator);\n        }\n\n        @Override\n        public boolean hasNext()\n        {\n            return hasPeeked || iterator.hasNext();\n        }\n\n        @Override\n        public E next()\n        {\n            if (!hasPeeked)\n            {\n                return iterator.next();\n            }\n            E result = peekedElement;\n            hasPeeked = false;\n            peekedElement = null;\n            return result;\n        }\n\n        @Override\n        public void remove()\n        {\n            checkState(!hasPeeked, \"Can't remove after you've peeked at next\");\n            iterator.remove();\n        }\n\n        @Override\n        public E peek()\n        {\n            if (!hasPeeked)\n            {\n                peekedElement = iterator.next();\n                hasPeeked = true;\n            }\n            return peekedElement;\n        }\n    }\n\n    /**\n     * Returns a {@code PeekingIterator} backed by the given iterator.\n     *\n     * <p>Calls to the {@code peek} method with no intervening calls to {@code next} do not affect the\n     * iteration, and hence return the same object each time. A subsequent call to {@code next} is\n     * guaranteed to return the same object again. For example:\n     *\n     * <pre>{@code\n     * PeekingIterator<String> peekingIterator =\n     *     Iterators.peekingIterator(Iterators.forArray(\"a\", \"b\"));\n     * String a1 = peekingIterator.peek(); // returns \"a\"\n     * String a2 = peekingIterator.peek(); // also returns \"a\"\n     * String a3 = peekingIterator.next(); // also returns \"a\"\n     * }</pre>\n     *\n     * <p>Any structural changes to the underlying iteration (aside from those performed by the\n     * iterator's own {@link PeekingIterator#remove()} method) will leave the iterator in an undefined\n     * state.\n     *\n     * <p>The returned iterator does not support removal after peeking, as explained by {@link\n     * PeekingIterator#remove()}.\n     *\n     * <p>Note: If the given iterator is already a {@code PeekingIterator}, it <i>might</i> be\n     * returned to the caller, although this is neither guaranteed to occur nor required to be\n     * consistent. For example, this method <i>might</i> choose to pass through recognized\n     * implementations of {@code PeekingIterator} when the behavior of the implementation is known to\n     * meet the contract guaranteed by this method.\n     *\n     * <p>There is no {@link Iterable} equivalent to this method, so use this method to wrap each\n     * individual iterator as it is generated.\n     *\n     * @param iterator the backing iterator. The {@link PeekingIterator} assumes ownership of this\n     *     iterator, so users should cease making direct calls to it after calling this method.\n     * @return a peeking iterator backed by that iterator. Apart from the additional {@link\n     *     PeekingIterator#peek()} method, this iterator behaves exactly the same as {@code iterator}.\n     */\n    public static <T> PeekingIterator<T> peekingIterator(Iterator<? extends T> iterator)\n    {\n        if (iterator instanceof PeekingImpl)\n        {\n            // Safe to cast <? extends T> to <T> because PeekingImpl only uses T\n            // covariantly (and cannot be subclassed to add non-covariant uses).\n            @SuppressWarnings(\"unchecked\")\n            PeekingImpl<T> peeking = (PeekingImpl<T>) iterator;\n            return peeking;\n        }\n        return new PeekingImpl<T>(iterator);\n    }\n\n    /**\n     * Simply returns its argument.\n     *\n     * @deprecated no need to use this\n     * @since 10.0\n     */\n    @Deprecated\n    public static <T> PeekingIterator<T> peekingIterator(PeekingIterator<T> iterator)\n    {\n        return checkNotNull(iterator);\n    }\n\n    /**\n     * Returns an iterator over the merged contents of all given {@code iterators}, traversing every\n     * element of the input iterators. Equivalent entries will not be de-duplicated.\n     *\n     * <p>Callers must ensure that the source {@code iterators} are in non-descending order as this\n     * method does not sort its input.\n     *\n     * <p>For any equivalent elements across all {@code iterators}, it is undefined which element is\n     * returned first.\n     *\n     * @since 11.0\n     */\n    @Beta\n    public static <T> UnmodifiableIterator<T> mergeSorted(\n        Iterable<? extends Iterator<? extends T>> iterators, Comparator<? super T> comparator)\n    {\n        checkNotNull(iterators, \"iterators\");\n        checkNotNull(comparator, \"comparator\");\n\n        return new MergingIterator<T>(iterators, comparator);\n    }\n\n    /**\n     * An iterator that performs a lazy N-way merge, calculating the next value each time the iterator\n     * is polled. This amortizes the sorting cost over the iteration and requires less memory than\n     * sorting all elements at once.\n     *\n     * <p>Retrieving a single element takes approximately O(log(M)) time, where M is the number of\n     * iterators. (Retrieving all elements takes approximately O(N*log(M)) time, where N is the total\n     * number of elements.)\n     */\n    private static class MergingIterator<T> extends UnmodifiableIterator<T>\n    {\n        final Queue<PeekingIterator<T>> queue;\n\n        public MergingIterator(\n            Iterable<? extends Iterator<? extends T>> iterators,\n            final Comparator<? super T> itemComparator)\n        {\n            // A comparator that's used by the heap, allowing the heap\n            // to be sorted based on the top of each iterator.\n            Comparator<PeekingIterator<T>> heapComparator =\n                new Comparator<PeekingIterator<T>>()\n            {\n                @Override\n                public int compare(PeekingIterator<T> o1, PeekingIterator<T> o2)\n                {\n                    return itemComparator.compare(o1.peek(), o2.peek());\n                }\n            };\n\n            queue = new PriorityQueue<>(2, heapComparator);\n\n            for (Iterator<? extends T> iterator : iterators)\n            {\n                if (iterator.hasNext())\n                {\n                    queue.add(Iterators.peekingIterator(iterator));\n                }\n            }\n        }\n\n        @Override\n        public boolean hasNext()\n        {\n            return !queue.isEmpty();\n        }\n\n        @Override\n        public T next()\n        {\n            PeekingIterator<T> nextIter = queue.remove();\n            T next = nextIter.next();\n            if (nextIter.hasNext())\n            {\n                queue.add(nextIter);\n            }\n            return next;\n        }\n    }\n\n    private static class ConcatenatedIterator<T> implements Iterator<T>\n    {\n        /* The last iterator to return an element.  Calls to remove() go to this iterator. */\n        @NullableDecl private Iterator<? extends T> toRemove;\n\n        /* The iterator currently returning elements. */\n        private Iterator<? extends T> iterator;\n\n        /*\n         * We track the \"meta iterators,\" the iterators-of-iterators, below.  Usually, topMetaIterator\n         * is the only one in use, but if we encounter nested concatenations, we start a deque of\n         * meta-iterators rather than letting the nesting get arbitrarily deep.  This keeps each\n         * operation O(1).\n         */\n\n        private Iterator<? extends Iterator<? extends T>> topMetaIterator;\n\n        // Only becomes nonnull if we encounter nested concatenations.\n        @NullableDecl private Deque<Iterator<? extends Iterator<? extends T>>> metaIterators;\n\n        ConcatenatedIterator(Iterator<? extends Iterator<? extends T>> metaIterator)\n        {\n            iterator = emptyIterator();\n            topMetaIterator = checkNotNull(metaIterator);\n        }\n\n        // Returns a nonempty meta-iterator or, if all meta-iterators are empty, null.\n        @NullableDecl\n        private Iterator<? extends Iterator<? extends T>> getTopMetaIterator()\n        {\n            while (topMetaIterator == null || !topMetaIterator.hasNext())\n            {\n                if (metaIterators != null && !metaIterators.isEmpty())\n                {\n                    topMetaIterator = metaIterators.removeFirst();\n                }\n                else\n                {\n                    return null;\n                }\n            }\n            return topMetaIterator;\n        }\n\n        @Override\n        public boolean hasNext()\n        {\n            while (!checkNotNull(iterator).hasNext())\n            {\n                // this weird checkNotNull positioning appears required by our tests, which expect\n                // both hasNext and next to throw NPE if an input iterator is null.\n\n                topMetaIterator = getTopMetaIterator();\n                if (topMetaIterator == null)\n                {\n                    return false;\n                }\n\n                iterator = topMetaIterator.next();\n\n                if (iterator instanceof ConcatenatedIterator)\n                {\n                    // Instead of taking linear time in the number of nested concatenations, unpack\n                    // them into the queue\n                    @SuppressWarnings(\"unchecked\")\n                    ConcatenatedIterator<T> topConcat = (ConcatenatedIterator<T>) iterator;\n                    iterator = topConcat.iterator;\n\n                    // topConcat.topMetaIterator, then topConcat.metaIterators, then this.topMetaIterator,\n                    // then this.metaIterators\n\n                    if (this.metaIterators == null)\n                    {\n                        this.metaIterators = new ArrayDeque<>();\n                    }\n                    this.metaIterators.addFirst(this.topMetaIterator);\n                    if (topConcat.metaIterators != null)\n                    {\n                        while (!topConcat.metaIterators.isEmpty())\n                        {\n                            this.metaIterators.addFirst(topConcat.metaIterators.removeLast());\n                        }\n                    }\n                    this.topMetaIterator = topConcat.topMetaIterator;\n                }\n            }\n            return true;\n        }\n\n        @Override\n        public T next()\n        {\n            if (hasNext())\n            {\n                toRemove = iterator;\n                return iterator.next();\n            }\n            else\n            {\n                throw new NoSuchElementException();\n            }\n        }\n\n        @Override\n        public void remove()\n        {\n            CollectPreconditions.checkRemove(toRemove != null);\n            toRemove.remove();\n            toRemove = null;\n        }\n    }\n\n    /** Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557 */\n    static <T> ListIterator<T> cast(Iterator<T> iterator)\n    {\n        return (ListIterator<T>) iterator;\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/Iterators.java", "func_name": "Iterators.concatNoDefensiveCopy", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Concats a varargs array of iterators without making a defensive copy of the array.", "docstring_tokens": ["Concats", "a", "varargs", "array", "of", "iterators", "without", "making", "a", "defensive", "copy", "of", "the", "array", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/Iterators.java#L550-L555", "partition": "valid", "up_fun_num": 27, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.base.Preconditions.checkState;", "import static com.google.common.base.Predicates.instanceOf;", "import static com.google.common.collect.CollectPreconditions.checkRemove;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.Function;", "import com.google.common.base.Objects;", "import com.google.common.base.Optional;", "import com.google.common.base.Preconditions;", "import com.google.common.base.Predicate;", "import com.google.common.primitives.Ints;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.util.ArrayDeque;", "import java.util.Arrays;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.Comparator;", "import java.util.Deque;", "import java.util.Enumeration;", "import java.util.Iterator;", "import java.util.List;", "import java.util.ListIterator;", "import java.util.NoSuchElementException;", "import java.util.PriorityQueue;", "import java.util.Queue;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Iterators\n", "    static <T> UnmodifiableIterator<T> emptyIterator()\n", "    static <T> UnmodifiableListIterator<T> emptyListIterator()\n", "    static <T> Iterator<T> emptyModifiableIterator()\n", "    public static <T> UnmodifiableIterator<T> unmodifiableIterator(\n", "    public static <T> UnmodifiableIterator<T> unmodifiableIterator(UnmodifiableIterator<T> iterator)\n", "    public static int size(Iterator<?> iterator)\n", "    public static boolean contains(Iterator<?> iterator, @NullableDecl Object element)\n", "    public static boolean removeAll(Iterator<?> removeFrom, Collection<?> elementsToRemove)\n", "    public static <T> boolean removeIf(Iterator<T> removeFrom, Predicate<? super T> predicate)\n", "    public static boolean retainAll(Iterator<?> removeFrom, Collection<?> elementsToRetain)\n", "    public static boolean elementsEqual(Iterator<?> iterator1, Iterator<?> iterator2)\n", "    public static String toString(Iterator<?> iterator)\n", "    public static <T> T getOnlyElement(Iterator<T> iterator)\n", "    public static <T> T getOnlyElement(Iterator<? extends T> iterator, @NullableDecl T defaultValue)\n", "    public static <T> T[] toArray(Iterator<? extends T> iterator, Class<T> type)\n", "    public static <T> boolean addAll(Collection<T> addTo, Iterator<? extends T> iterator)\n", "    public static int frequency(Iterator<?> iterator, @NullableDecl Object element)\n", "    public static <T> Iterator<T> cycle(final Iterable<T> iterable)\n", "    public static <T> Iterator<T> cycle(T... elements)\n", "    private static <T> Iterator<T> consumingForArray(final T... elements)\n", "    public static <T> Iterator<T> concat(Iterator<? extends T> a, Iterator<? extends T> b)\n", "    public static <T> Iterator<T> concat(\n", "    public static <T> Iterator<T> concat(\n", "    public static <T> Iterator<T> concat(Iterator<? extends T>... inputs)\n", "    public static <T> Iterator<T> concat(Iterator<? extends Iterator<? extends T>> inputs)\n", "    public static <T> UnmodifiableIterator<List<T>> partition(Iterator<T> iterator, int size)\n", "    public static <T> UnmodifiableIterator<List<T>> paddedPartition(Iterator<T> iterator, int size)\n", "    private static <T> UnmodifiableIterator<List<T>> partitionImpl(\n", "    public static <T> UnmodifiableIterator<T> filter(\n", "    public static <T> UnmodifiableIterator<T> filter(Iterator<?> unfiltered, Class<T> desiredType)\n", "    public static <T> boolean any(Iterator<T> iterator, Predicate<? super T> predicate)\n", "    public static <T> boolean all(Iterator<T> iterator, Predicate<? super T> predicate)\n", "    public static <T> T find(Iterator<T> iterator, Predicate<? super T> predicate)\n", "    public static <T> T find(\n", "    public static <T> Optional<T> tryFind(Iterator<T> iterator, Predicate<? super T> predicate)\n", "    public static <T> int indexOf(Iterator<T> iterator, Predicate<? super T> predicate)\n", "    public static <F, T> Iterator<T> transform(\n", "    public static <T> T get(Iterator<T> iterator, int position)\n", "    public static <T> T get(\n", "    static void checkNonnegative(int position)\n", "    public static <T> T getNext(Iterator<? extends T> iterator, @NullableDecl T defaultValue)\n", "    public static <T> T getLast(Iterator<T> iterator)\n", "    public static <T> T getLast(Iterator<? extends T> iterator, @NullableDecl T defaultValue)\n", "    public static int advance(Iterator<?> iterator, int numberToAdvance)\n", "    public static <T> Iterator<T> limit(final Iterator<T> iterator, final int limitSize)\n", "    public static <T> Iterator<T> consumingIterator(final Iterator<T> iterator)\n", "    static <T> T pollNext(Iterator<T> iterator)\n", "    static void clear(Iterator<?> iterator)\n", "    public static <T> UnmodifiableIterator<T> forArray(final T... array)\n", "    static <T> UnmodifiableListIterator<T> forArray(\n", "    public static <T> UnmodifiableIterator<T> singletonIterator(@NullableDecl final T value)\n", "    public static <T> UnmodifiableIterator<T> forEnumeration(final Enumeration<T> enumeration)\n", "    public static <T> Enumeration<T> asEnumeration(final Iterator<T> iterator)\n", "    public static <T> PeekingIterator<T> peekingIterator(Iterator<? extends T> iterator)\n", "    public static <T> PeekingIterator<T> peekingIterator(PeekingIterator<T> iterator)\n", "    public static <T> UnmodifiableIterator<T> mergeSorted(\n", "    static <T> ListIterator<T> cast(Iterator<T> iterator)\n"], "context": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Predicates.instanceOf;\nimport static com.google.common.collect.CollectPreconditions.checkRemove;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Function;\nimport com.google.common.base.Objects;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.common.primitives.Ints;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * This class contains static utility methods that operate on or return objects of type {@link\n * Iterator}. Except as noted, each method has a corresponding {@link Iterable}-based method in the\n * {@link Iterables} class.\n *\n * <p><i>Performance notes:</i> Unless otherwise noted, all of the iterators produced in this class\n * are <i>lazy</i>, which means that they only advance the backing iteration when absolutely\n * necessary.\n *\n * <p>See the Guava User Guide section on <a href=\n * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#iterables\"> {@code\n * Iterators}</a>.\n *\n * @author Kevin Bourrillion\n * @author Jared Levy\n * @since 2.0\n */\n@GwtCompatible(emulated = true)\npublic final class Iterators\n{\n    private Iterators() {}\n\n    /**\n     * Returns the empty iterator.\n     *\n     * <p>The {@link Iterable} equivalent of this method is {@link ImmutableSet#of()}.\n     */\n    static <T> UnmodifiableIterator<T> emptyIterator()\n    {\n        return emptyListIterator();\n    }\n\n    /**\n     * Returns the empty iterator.\n     *\n     * <p>The {@link Iterable} equivalent of this method is {@link ImmutableSet#of()}.\n     */\n    // Casting to any type is safe since there are no actual elements.\n    @SuppressWarnings(\"unchecked\")\n    static <T> UnmodifiableListIterator<T> emptyListIterator()\n    {\n        return (UnmodifiableListIterator<T>) ArrayItr.EMPTY;\n    }\n\n    /**\n     * This is an enum singleton rather than an anonymous class so ProGuard can figure out it's only\n     * referenced by emptyModifiableIterator().\n     */\n    private enum EmptyModifiableIterator implements Iterator<Object>\n    {\n        INSTANCE;\n\n        @Override\n        public boolean hasNext()\n        {\n            return false;\n        }\n\n        @Override\n        public Object next()\n        {\n            throw new NoSuchElementException();\n        }\n\n        @Override\n        public void remove()\n        {\n            checkRemove(false);\n        }\n    }\n\n    /**\n     * Returns the empty {@code Iterator} that throws {@link IllegalStateException} instead of {@link\n     * UnsupportedOperationException} on a call to {@link Iterator#remove()}.\n     */\n    // Casting to any type is safe since there are no actual elements.\n    @SuppressWarnings(\"unchecked\")\n    static <T> Iterator<T> emptyModifiableIterator()\n    {\n        return (Iterator<T>) EmptyModifiableIterator.INSTANCE;\n    }\n\n    /** Returns an unmodifiable view of {@code iterator}. */\n    public static <T> UnmodifiableIterator<T> unmodifiableIterator(\n        final Iterator<? extends T> iterator)\n    {\n        checkNotNull(iterator);\n        if (iterator instanceof UnmodifiableIterator)\n        {\n            @SuppressWarnings(\"unchecked\") // Since it's unmodifiable, the covariant cast is safe\n            UnmodifiableIterator<T> result = (UnmodifiableIterator<T>) iterator;\n            return result;\n        }\n        return new UnmodifiableIterator<T>()\n        {\n            @Override\n            public boolean hasNext()\n            {\n                return iterator.hasNext();\n            }\n\n            @Override\n            public T next()\n            {\n                return iterator.next();\n            }\n        };\n    }\n\n    /**\n     * Simply returns its argument.\n     *\n     * @deprecated no need to use this\n     * @since 10.0\n     */\n    @Deprecated\n    public static <T> UnmodifiableIterator<T> unmodifiableIterator(UnmodifiableIterator<T> iterator)\n    {\n        return checkNotNull(iterator);\n    }\n\n    /**\n     * Returns the number of elements remaining in {@code iterator}. The iterator will be left\n     * exhausted: its {@code hasNext()} method will return {@code false}.\n     */\n    public static int size(Iterator<?> iterator)\n    {\n        long count = 0L;\n        while (iterator.hasNext())\n        {\n            iterator.next();\n            count++;\n        }\n        return Ints.saturatedCast(count);\n    }\n\n    /** Returns {@code true} if {@code iterator} contains {@code element}. */\n    public static boolean contains(Iterator<?> iterator, @NullableDecl Object element)\n    {\n        if (element == null)\n        {\n            while (iterator.hasNext())\n            {\n                if (iterator.next() == null)\n                {\n                    return true;\n                }\n            }\n        }\n        else\n        {\n            while (iterator.hasNext())\n            {\n                if (element.equals(iterator.next()))\n                {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Traverses an iterator and removes every element that belongs to the provided collection. The\n     * iterator will be left exhausted: its {@code hasNext()} method will return {@code false}.\n     *\n     * @param removeFrom the iterator to (potentially) remove elements from\n     * @param elementsToRemove the elements to remove\n     * @return {@code true} if any element was removed from {@code iterator}\n     */\n    @CanIgnoreReturnValue\n    public static boolean removeAll(Iterator<?> removeFrom, Collection<?> elementsToRemove)\n    {\n        checkNotNull(elementsToRemove);\n        boolean result = false;\n        while (removeFrom.hasNext())\n        {\n            if (elementsToRemove.contains(removeFrom.next()))\n            {\n                removeFrom.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Removes every element that satisfies the provided predicate from the iterator. The iterator\n     * will be left exhausted: its {@code hasNext()} method will return {@code false}.\n     *\n     * @param removeFrom the iterator to (potentially) remove elements from\n     * @param predicate a predicate that determines whether an element should be removed\n     * @return {@code true} if any elements were removed from the iterator\n     * @since 2.0\n     */\n    @CanIgnoreReturnValue\n    public static <T> boolean removeIf(Iterator<T> removeFrom, Predicate<? super T> predicate)\n    {\n        checkNotNull(predicate);\n        boolean modified = false;\n        while (removeFrom.hasNext())\n        {\n            if (predicate.apply(removeFrom.next()))\n            {\n                removeFrom.remove();\n                modified = true;\n            }\n        }\n        return modified;\n    }\n\n    /**\n     * Traverses an iterator and removes every element that does not belong to the provided\n     * collection. The iterator will be left exhausted: its {@code hasNext()} method will return\n     * {@code false}.\n     *\n     * @param removeFrom the iterator to (potentially) remove elements from\n     * @param elementsToRetain the elements to retain\n     * @return {@code true} if any element was removed from {@code iterator}\n     */\n    @CanIgnoreReturnValue\n    public static boolean retainAll(Iterator<?> removeFrom, Collection<?> elementsToRetain)\n    {\n        checkNotNull(elementsToRetain);\n        boolean result = false;\n        while (removeFrom.hasNext())\n        {\n            if (!elementsToRetain.contains(removeFrom.next()))\n            {\n                removeFrom.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Determines whether two iterators contain equal elements in the same order. More specifically,\n     * this method returns {@code true} if {@code iterator1} and {@code iterator2} contain the same\n     * number of elements and every element of {@code iterator1} is equal to the corresponding element\n     * of {@code iterator2}.\n     *\n     * <p>Note that this will modify the supplied iterators, since they will have been advanced some\n     * number of elements forward.\n     */\n    public static boolean elementsEqual(Iterator<?> iterator1, Iterator<?> iterator2)\n    {\n        while (iterator1.hasNext())\n        {\n            if (!iterator2.hasNext())\n            {\n                return false;\n            }\n            Object o1 = iterator1.next();\n            Object o2 = iterator2.next();\n            if (!Objects.equal(o1, o2))\n            {\n                return false;\n            }\n        }\n        return !iterator2.hasNext();\n    }\n\n    /**\n     * Returns a string representation of {@code iterator}, with the format {@code [e1, e2, ..., en]}.\n     * The iterator will be left exhausted: its {@code hasNext()} method will return {@code false}.\n     */\n    public static String toString(Iterator<?> iterator)\n    {\n        StringBuilder sb = new StringBuilder().append('[');\n        boolean first = true;\n        while (iterator.hasNext())\n        {\n            if (!first)\n            {\n                sb.append(\", \");\n            }\n            first = false;\n            sb.append(iterator.next());\n        }\n        return sb.append(']').toString();\n    }\n\n    /**\n     * Returns the single element contained in {@code iterator}.\n     *\n     * @throws NoSuchElementException if the iterator is empty\n     * @throws IllegalArgumentException if the iterator contains multiple elements. The state of the\n     *     iterator is unspecified.\n     */\n    public static <T> T getOnlyElement(Iterator<T> iterator)\n    {\n        T first = iterator.next();\n        if (!iterator.hasNext())\n        {\n            return first;\n        }\n\n        StringBuilder sb = new StringBuilder().append(\"expected one element but was: <\").append(first);\n        for (int i = 0; i < 4 && iterator.hasNext(); i++)\n        {\n            sb.append(\", \").append(iterator.next());\n        }\n        if (iterator.hasNext())\n        {\n            sb.append(\", ...\");\n        }\n        sb.append('>');\n\n        throw new IllegalArgumentException(sb.toString());\n    }\n\n    /**\n     * Returns the single element contained in {@code iterator}, or {@code defaultValue} if the\n     * iterator is empty.\n     *\n     * @throws IllegalArgumentException if the iterator contains multiple elements. The state of the\n     *     iterator is unspecified.\n     */\n    @NullableDecl\n    public static <T> T getOnlyElement(Iterator<? extends T> iterator, @NullableDecl T defaultValue)\n    {\n        return iterator.hasNext() ? getOnlyElement(iterator) : defaultValue;\n    }\n\n    /**\n     * Copies an iterator's elements into an array. The iterator will be left exhausted: its {@code\n     * hasNext()} method will return {@code false}.\n     *\n     * @param iterator the iterator to copy\n     * @param type the type of the elements\n     * @return a newly-allocated array into which all the elements of the iterator have been copied\n     */\n    @GwtIncompatible // Array.newInstance(Class, int)\n    public static <T> T[] toArray(Iterator<? extends T> iterator, Class<T> type)\n    {\n        List<T> list = Lists.newArrayList(iterator);\n        return Iterables.toArray(list, type);\n    }\n\n    /**\n     * Adds all elements in {@code iterator} to {@code collection}. The iterator will be left\n     * exhausted: its {@code hasNext()} method will return {@code false}.\n     *\n     * @return {@code true} if {@code collection} was modified as a result of this operation\n     */\n    @CanIgnoreReturnValue\n    public static <T> boolean addAll(Collection<T> addTo, Iterator<? extends T> iterator)\n    {\n        checkNotNull(addTo);\n        checkNotNull(iterator);\n        boolean wasModified = false;\n        while (iterator.hasNext())\n        {\n            wasModified |= addTo.add(iterator.next());\n        }\n        return wasModified;\n    }\n\n    /**\n     * Returns the number of elements in the specified iterator that equal the specified object. The\n     * iterator will be left exhausted: its {@code hasNext()} method will return {@code false}.\n     *\n     * @see Collections#frequency\n     */\n    public static int frequency(Iterator<?> iterator, @NullableDecl Object element)\n    {\n        int count = 0;\n        while (contains(iterator, element))\n        {\n            // Since it lives in the same class, we know contains gets to the element and then stops,\n            // though that isn't currently publicly documented.\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Returns an iterator that cycles indefinitely over the elements of {@code iterable}.\n     *\n     * <p>The returned iterator supports {@code remove()} if the provided iterator does. After {@code\n     * remove()} is called, subsequent cycles omit the removed element, which is no longer in {@code\n     * iterable}. The iterator's {@code hasNext()} method returns {@code true} until {@code iterable}\n     * is empty.\n     *\n     * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You\n     * should use an explicit {@code break} or be certain that you will eventually remove all the\n     * elements.\n     */\n    public static <T> Iterator<T> cycle(final Iterable<T> iterable)\n    {\n        checkNotNull(iterable);\n        return new Iterator<T>()\n        {\n            Iterator<T> iterator = emptyModifiableIterator();\n\n            @Override\n            public boolean hasNext()\n            {\n                /*\n                 * Don't store a new Iterator until we know the user can't remove() the last returned\n                 * element anymore. Otherwise, when we remove from the old iterator, we may be invalidating\n                 * the new one. The result is a ConcurrentModificationException or other bad behavior.\n                 *\n                 * (If we decide that we really, really hate allocating two Iterators per cycle instead of\n                 * one, we can optimistically store the new Iterator and then be willing to throw it out if\n                 * the user calls remove().)\n                 */\n                return iterator.hasNext() || iterable.iterator().hasNext();\n            }\n\n            @Override\n            public T next()\n            {\n                if (!iterator.hasNext())\n                {\n                    iterator = iterable.iterator();\n                    if (!iterator.hasNext())\n                    {\n                        throw new NoSuchElementException();\n                    }\n                }\n                return iterator.next();\n            }\n\n            @Override\n            public void remove()\n            {\n                iterator.remove();\n            }\n        };\n    }\n\n    /**\n     * Returns an iterator that cycles indefinitely over the provided elements.\n     *\n     * <p>The returned iterator supports {@code remove()}. After {@code remove()} is called,\n     * subsequent cycles omit the removed element, but {@code elements} does not change. The\n     * iterator's {@code hasNext()} method returns {@code true} until all of the original elements\n     * have been removed.\n     *\n     * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You\n     * should use an explicit {@code break} or be certain that you will eventually remove all the\n     * elements.\n     */\n    @SafeVarargs\n    public static <T> Iterator<T> cycle(T... elements)\n    {\n        return cycle(Lists.newArrayList(elements));\n    }\n\n    /**\n     * Returns an Iterator that walks the specified array, nulling out elements behind it. This can\n     * avoid memory leaks when an element is no longer necessary.\n     *\n     * <p>This is mainly just to avoid the intermediate ArrayDeque in ConsumingQueueIterator.\n     */\n    private static <T> Iterator<T> consumingForArray(final T... elements)\n    {\n        return new UnmodifiableIterator<T>()\n        {\n            int index = 0;\n\n            @Override\n            public boolean hasNext()\n            {\n                return index < elements.length;\n            }\n\n            @Override\n            public T next()\n            {\n                if (!hasNext())\n                {\n                    throw new NoSuchElementException();\n                }\n                T result = elements[index];\n                elements[index] = null;\n                index++;\n                return result;\n            }\n        };\n    }\n\n    /**\n     * Combines two iterators into a single iterator. The returned iterator iterates across the\n     * elements in {@code a}, followed by the elements in {@code b}. The source iterators are not\n     * polled until necessary.\n     *\n     * <p>The returned iterator supports {@code remove()} when the corresponding input iterator\n     * supports it.\n     */\n    public static <T> Iterator<T> concat(Iterator<? extends T> a, Iterator<? extends T> b)\n    {\n        checkNotNull(a);\n        checkNotNull(b);\n        return concat(consumingForArray(a, b));\n    }\n\n    /**\n     * Combines three iterators into a single iterator. The returned iterator iterates across the\n     * elements in {@code a}, followed by the elements in {@code b}, followed by the elements in\n     * {@code c}. The source iterators are not polled until necessary.\n     *\n     * <p>The returned iterator supports {@code remove()} when the corresponding input iterator\n     * supports it.\n     */\n    public static <T> Iterator<T> concat(\n        Iterator<? extends T> a, Iterator<? extends T> b, Iterator<? extends T> c)\n    {\n        checkNotNull(a);\n        checkNotNull(b);\n        checkNotNull(c);\n        return concat(consumingForArray(a, b, c));\n    }\n\n    /**\n     * Combines four iterators into a single iterator. The returned iterator iterates across the\n     * elements in {@code a}, followed by the elements in {@code b}, followed by the elements in\n     * {@code c}, followed by the elements in {@code d}. The source iterators are not polled until\n     * necessary.\n     *\n     * <p>The returned iterator supports {@code remove()} when the corresponding input iterator\n     * supports it.\n     */\n    public static <T> Iterator<T> concat(\n        Iterator<? extends T> a,\n        Iterator<? extends T> b,\n        Iterator<? extends T> c,\n        Iterator<? extends T> d)\n    {\n        checkNotNull(a);\n        checkNotNull(b);\n        checkNotNull(c);\n        checkNotNull(d);\n        return concat(consumingForArray(a, b, c, d));\n    }\n\n    /**\n     * Combines multiple iterators into a single iterator. The returned iterator iterates across the\n     * elements of each iterator in {@code inputs}. The input iterators are not polled until\n     * necessary.\n     *\n     * <p>The returned iterator supports {@code remove()} when the corresponding input iterator\n     * supports it.\n     *\n     * @throws NullPointerException if any of the provided iterators is null\n     */\n    public static <T> Iterator<T> concat(Iterator<? extends T>... inputs)\n    {\n        return concatNoDefensiveCopy(Arrays.copyOf(inputs, inputs.length));\n    }\n\n    /**\n     * Combines multiple iterators into a single iterator. The returned iterator iterates across the\n     * elements of each iterator in {@code inputs}. The input iterators are not polled until\n     * necessary.\n     *\n     * <p>The returned iterator supports {@code remove()} when the corresponding input iterator\n     * supports it. The methods of the returned iterator may throw {@code NullPointerException} if any\n     * of the input iterators is null.\n     */\n    public static <T> Iterator<T> concat(Iterator<? extends Iterator<? extends T>> inputs)\n    {\n        return new ConcatenatedIterator<T>(inputs);\n    }\n\n    /** Concats a varargs array of iterators without making a defensive copy of the array. */\n\n    /**\n     * Divides an iterator into unmodifiable sublists of the given size (the final list may be\n     * smaller). For example, partitioning an iterator containing {@code [a, b, c, d, e]} with a\n     * partition size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer iterator containing two\n     * inner lists of three and two elements, all in the original order.\n     *\n     * <p>The returned lists implement {@link java.util.RandomAccess}.\n     *\n     * @param iterator the iterator to return a partitioned view of\n     * @param size the desired size of each partition (the last may be smaller)\n     * @return an iterator of immutable lists containing the elements of {@code iterator} divided into\n     *     partitions\n     * @throws IllegalArgumentException if {@code size} is nonpositive\n     */\n    public static <T> UnmodifiableIterator<List<T>> partition(Iterator<T> iterator, int size)\n    {\n        return partitionImpl(iterator, size, false);\n    }\n\n    /**\n     * Divides an iterator into unmodifiable sublists of the given size, padding the final iterator\n     * with null values if necessary. For example, partitioning an iterator containing {@code [a, b,\n     * c, d, e]} with a partition size of 3 yields {@code [[a, b, c], [d, e, null]]} -- an outer\n     * iterator containing two inner lists of three elements each, all in the original order.\n     *\n     * <p>The returned lists implement {@link java.util.RandomAccess}.\n     *\n     * @param iterator the iterator to return a partitioned view of\n     * @param size the desired size of each partition\n     * @return an iterator of immutable lists containing the elements of {@code iterator} divided into\n     *     partitions (the final iterable may have trailing null elements)\n     * @throws IllegalArgumentException if {@code size} is nonpositive\n     */\n    public static <T> UnmodifiableIterator<List<T>> paddedPartition(Iterator<T> iterator, int size)\n    {\n        return partitionImpl(iterator, size, true);\n    }\n\n    private static <T> UnmodifiableIterator<List<T>> partitionImpl(\n        final Iterator<T> iterator, final int size, final boolean pad)\n    {\n        checkNotNull(iterator);\n        checkArgument(size > 0);\n        return new UnmodifiableIterator<List<T>>()\n        {\n            @Override\n            public boolean hasNext()\n            {\n                return iterator.hasNext();\n            }\n\n            @Override\n            public List<T> next()\n            {\n                if (!hasNext())\n                {\n                    throw new NoSuchElementException();\n                }\n                Object[] array = new Object[size];\n                int count = 0;\n                for (; count < size && iterator.hasNext(); count++)\n                {\n                    array[count] = iterator.next();\n                }\n                for (int i = count; i < size; i++)\n                {\n                    array[i] = null; // for GWT\n                }\n\n                @SuppressWarnings(\"unchecked\") // we only put Ts in it\n                List<T> list = Collections.unmodifiableList((List<T>) Arrays.asList(array));\n                return (pad || count == size) ? list : list.subList(0, count);\n            }\n        };\n    }\n\n    /**\n     * Returns a view of {@code unfiltered} containing all elements that satisfy the input predicate\n     * {@code retainIfTrue}.\n     */\n    public static <T> UnmodifiableIterator<T> filter(\n        final Iterator<T> unfiltered, final Predicate<? super T> retainIfTrue)\n    {\n        checkNotNull(unfiltered);\n        checkNotNull(retainIfTrue);\n        return new AbstractIterator<T>()\n        {\n            @Override\n            protected T computeNext()\n            {\n                while (unfiltered.hasNext())\n                {\n                    T element = unfiltered.next();\n                    if (retainIfTrue.apply(element))\n                    {\n                        return element;\n                    }\n                }\n                return endOfData();\n            }\n        };\n    }\n\n    /**\n     * Returns a view of {@code unfiltered} containing all elements that are of the type {@code\n     * desiredType}.\n     */\n    @SuppressWarnings(\"unchecked\") // can cast to <T> because non-Ts are removed\n    @GwtIncompatible // Class.isInstance\n    public static <T> UnmodifiableIterator<T> filter(Iterator<?> unfiltered, Class<T> desiredType)\n    {\n        return (UnmodifiableIterator<T>) filter(unfiltered, instanceOf(desiredType));\n    }\n\n    /**\n     * Returns {@code true} if one or more elements returned by {@code iterator} satisfy the given\n     * predicate.\n     */\n    public static <T> boolean any(Iterator<T> iterator, Predicate<? super T> predicate)\n    {\n        return indexOf(iterator, predicate) != -1;\n    }\n\n    /**\n     * Returns {@code true} if every element returned by {@code iterator} satisfies the given\n     * predicate. If {@code iterator} is empty, {@code true} is returned.\n     */\n    public static <T> boolean all(Iterator<T> iterator, Predicate<? super T> predicate)\n    {\n        checkNotNull(predicate);\n        while (iterator.hasNext())\n        {\n            T element = iterator.next();\n            if (!predicate.apply(element))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the first element in {@code iterator} that satisfies the given predicate; use this\n     * method only when such an element is known to exist. If no such element is found, the iterator\n     * will be left exhausted: its {@code hasNext()} method will return {@code false}. If it is\n     * possible that <i>no</i> element will match, use {@link #tryFind} or {@link #find(Iterator,\n     * Predicate, Object)} instead.\n     *\n     * @throws NoSuchElementException if no element in {@code iterator} matches the given predicate\n     */\n    public static <T> T find(Iterator<T> iterator, Predicate<? super T> predicate)\n    {\n        checkNotNull(iterator);\n        checkNotNull(predicate);\n        while (iterator.hasNext())\n        {\n            T t = iterator.next();\n            if (predicate.apply(t))\n            {\n                return t;\n            }\n        }\n        throw new NoSuchElementException();\n    }\n\n    /**\n     * Returns the first element in {@code iterator} that satisfies the given predicate. If no such\n     * element is found, {@code defaultValue} will be returned from this method and the iterator will\n     * be left exhausted: its {@code hasNext()} method will return {@code false}. Note that this can\n     * usually be handled more naturally using {@code tryFind(iterator, predicate).or(defaultValue)}.\n     *\n     * @since 7.0\n     */\n    @NullableDecl\n    public static <T> T find(\n        Iterator<? extends T> iterator,\n        Predicate<? super T> predicate,\n        @NullableDecl T defaultValue)\n    {\n        checkNotNull(iterator);\n        checkNotNull(predicate);\n        while (iterator.hasNext())\n        {\n            T t = iterator.next();\n            if (predicate.apply(t))\n            {\n                return t;\n            }\n        }\n        return defaultValue;\n    }\n\n    /**\n     * Returns an {@link Optional} containing the first element in {@code iterator} that satisfies the\n     * given predicate, if such an element exists. If no such element is found, an empty {@link\n     * Optional} will be returned from this method and the iterator will be left exhausted: its {@code\n     * hasNext()} method will return {@code false}.\n     *\n     * <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code null}. If {@code null}\n     * is matched in {@code iterator}, a NullPointerException will be thrown.\n     *\n     * @since 11.0\n     */\n    public static <T> Optional<T> tryFind(Iterator<T> iterator, Predicate<? super T> predicate)\n    {\n        checkNotNull(iterator);\n        checkNotNull(predicate);\n        while (iterator.hasNext())\n        {\n            T t = iterator.next();\n            if (predicate.apply(t))\n            {\n                return Optional.of(t);\n            }\n        }\n        return Optional.absent();\n    }\n\n    /**\n     * Returns the index in {@code iterator} of the first element that satisfies the provided {@code\n     * predicate}, or {@code -1} if the Iterator has no such elements.\n     *\n     * <p>More formally, returns the lowest index {@code i} such that {@code\n     * predicate.apply(Iterators.get(iterator, i))} returns {@code true}, or {@code -1} if there is no\n     * such index.\n     *\n     * <p>If -1 is returned, the iterator will be left exhausted: its {@code hasNext()} method will\n     * return {@code false}. Otherwise, the iterator will be set to the element which satisfies the\n     * {@code predicate}.\n     *\n     * @since 2.0\n     */\n    public static <T> int indexOf(Iterator<T> iterator, Predicate<? super T> predicate)\n    {\n        checkNotNull(predicate, \"predicate\");\n        for (int i = 0; iterator.hasNext(); i++)\n        {\n            T current = iterator.next();\n            if (predicate.apply(current))\n            {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns a view containing the result of applying {@code function} to each element of {@code\n     * fromIterator}.\n     *\n     * <p>The returned iterator supports {@code remove()} if {@code fromIterator} does. After a\n     * successful {@code remove()} call, {@code fromIterator} no longer contains the corresponding\n     * element.\n     */\n    public static <F, T> Iterator<T> transform(\n        final Iterator<F> fromIterator, final Function<? super F, ? extends T> function)\n    {\n        checkNotNull(function);\n        return new TransformedIterator<F, T>(fromIterator)\n        {\n            @Override\n            T transform(F from)\n            {\n                return function.apply(from);\n            }\n        };\n    }\n\n    /**\n     * Advances {@code iterator} {@code position + 1} times, returning the element at the {@code\n     * position}th position.\n     *\n     * @param position position of the element to return\n     * @return the element at the specified position in {@code iterator}\n     * @throws IndexOutOfBoundsException if {@code position} is negative or greater than or equal to\n     *     the number of elements remaining in {@code iterator}\n     */\n    public static <T> T get(Iterator<T> iterator, int position)\n    {\n        checkNonnegative(position);\n        int skipped = advance(iterator, position);\n        if (!iterator.hasNext())\n        {\n            throw new IndexOutOfBoundsException(\n                \"position (\"\n                + position\n                + \") must be less than the number of elements that remained (\"\n                + skipped\n                + \")\");\n        }\n        return iterator.next();\n    }\n\n    /**\n     * Advances {@code iterator} {@code position + 1} times, returning the element at the {@code\n     * position}th position or {@code defaultValue} otherwise.\n     *\n     * @param position position of the element to return\n     * @param defaultValue the default value to return if the iterator is empty or if {@code position}\n     *     is greater than the number of elements remaining in {@code iterator}\n     * @return the element at the specified position in {@code iterator} or {@code defaultValue} if\n     *     {@code iterator} produces fewer than {@code position + 1} elements.\n     * @throws IndexOutOfBoundsException if {@code position} is negative\n     * @since 4.0\n     */\n    @NullableDecl\n    public static <T> T get(\n        Iterator<? extends T> iterator, int position, @NullableDecl T defaultValue)\n    {\n        checkNonnegative(position);\n        advance(iterator, position);\n        return getNext(iterator, defaultValue);\n    }\n\n    static void checkNonnegative(int position)\n    {\n        if (position < 0)\n        {\n            throw new IndexOutOfBoundsException(\"position (\" + position + \") must not be negative\");\n        }\n    }\n\n    /**\n     * Returns the next element in {@code iterator} or {@code defaultValue} if the iterator is empty.\n     * The {@link Iterables} analog to this method is {@link Iterables#getFirst}.\n     *\n     * @param defaultValue the default value to return if the iterator is empty\n     * @return the next element of {@code iterator} or the default value\n     * @since 7.0\n     */\n    @NullableDecl\n    public static <T> T getNext(Iterator<? extends T> iterator, @NullableDecl T defaultValue)\n    {\n        return iterator.hasNext() ? iterator.next() : defaultValue;\n    }\n\n    /**\n     * Advances {@code iterator} to the end, returning the last element.\n     *\n     * @return the last element of {@code iterator}\n     * @throws NoSuchElementException if the iterator is empty\n     */\n    public static <T> T getLast(Iterator<T> iterator)\n    {\n        while (true)\n        {\n            T current = iterator.next();\n            if (!iterator.hasNext())\n            {\n                return current;\n            }\n        }\n    }\n\n    /**\n     * Advances {@code iterator} to the end, returning the last element or {@code defaultValue} if the\n     * iterator is empty.\n     *\n     * @param defaultValue the default value to return if the iterator is empty\n     * @return the last element of {@code iterator}\n     * @since 3.0\n     */\n    @NullableDecl\n    public static <T> T getLast(Iterator<? extends T> iterator, @NullableDecl T defaultValue)\n    {\n        return iterator.hasNext() ? getLast(iterator) : defaultValue;\n    }\n\n    /**\n     * Calls {@code next()} on {@code iterator}, either {@code numberToAdvance} times or until {@code\n     * hasNext()} returns {@code false}, whichever comes first.\n     *\n     * @return the number of elements the iterator was advanced\n     * @since 13.0 (since 3.0 as {@code Iterators.skip})\n     */\n    @CanIgnoreReturnValue\n    public static int advance(Iterator<?> iterator, int numberToAdvance)\n    {\n        checkNotNull(iterator);\n        checkArgument(numberToAdvance >= 0, \"numberToAdvance must be nonnegative\");\n\n        int i;\n        for (i = 0; i < numberToAdvance && iterator.hasNext(); i++)\n        {\n            iterator.next();\n        }\n        return i;\n    }\n\n    /**\n     * Returns a view containing the first {@code limitSize} elements of {@code iterator}. If {@code\n     * iterator} contains fewer than {@code limitSize} elements, the returned view contains all of its\n     * elements. The returned iterator supports {@code remove()} if {@code iterator} does.\n     *\n     * @param iterator the iterator to limit\n     * @param limitSize the maximum number of elements in the returned iterator\n     * @throws IllegalArgumentException if {@code limitSize} is negative\n     * @since 3.0\n     */\n    public static <T> Iterator<T> limit(final Iterator<T> iterator, final int limitSize)\n    {\n        checkNotNull(iterator);\n        checkArgument(limitSize >= 0, \"limit is negative\");\n        return new Iterator<T>()\n        {\n            private int count;\n\n            @Override\n            public boolean hasNext()\n            {\n                return count < limitSize && iterator.hasNext();\n            }\n\n            @Override\n            public T next()\n            {\n                if (!hasNext())\n                {\n                    throw new NoSuchElementException();\n                }\n                count++;\n                return iterator.next();\n            }\n\n            @Override\n            public void remove()\n            {\n                iterator.remove();\n            }\n        };\n    }\n\n    /**\n     * Returns a view of the supplied {@code iterator} that removes each element from the supplied\n     * {@code iterator} as it is returned.\n     *\n     * <p>The provided iterator must support {@link Iterator#remove()} or else the returned iterator\n     * will fail on the first call to {@code next}.\n     *\n     * @param iterator the iterator to remove and return elements from\n     * @return an iterator that removes and returns elements from the supplied iterator\n     * @since 2.0\n     */\n    public static <T> Iterator<T> consumingIterator(final Iterator<T> iterator)\n    {\n        checkNotNull(iterator);\n        return new UnmodifiableIterator<T>()\n        {\n            @Override\n            public boolean hasNext()\n            {\n                return iterator.hasNext();\n            }\n\n            @Override\n            public T next()\n            {\n                T next = iterator.next();\n                iterator.remove();\n                return next;\n            }\n\n            @Override\n            public String toString()\n            {\n                return \"Iterators.consumingIterator(...)\";\n            }\n        };\n    }\n\n    /**\n     * Deletes and returns the next value from the iterator, or returns {@code null} if there is no\n     * such value.\n     */\n    @NullableDecl\n    static <T> T pollNext(Iterator<T> iterator)\n    {\n        if (iterator.hasNext())\n        {\n            T result = iterator.next();\n            iterator.remove();\n            return result;\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    // Methods only in Iterators, not in Iterables\n\n    /** Clears the iterator using its remove method. */\n    static void clear(Iterator<?> iterator)\n    {\n        checkNotNull(iterator);\n        while (iterator.hasNext())\n        {\n            iterator.next();\n            iterator.remove();\n        }\n    }\n\n    /**\n     * Returns an iterator containing the elements of {@code array} in order. The returned iterator is\n     * a view of the array; subsequent changes to the array will be reflected in the iterator.\n     *\n     * <p><b>Note:</b> It is often preferable to represent your data using a collection type, for\n     * example using {@link Arrays#asList(Object[])}, making this method unnecessary.\n     *\n     * <p>The {@code Iterable} equivalent of this method is either {@link Arrays#asList(Object[])},\n     * {@link ImmutableList#copyOf(Object[])}}, or {@link ImmutableList#of}.\n     */\n    @SafeVarargs\n    public static <T> UnmodifiableIterator<T> forArray(final T... array)\n    {\n        return forArray(array, 0, array.length, 0);\n    }\n\n    /**\n     * Returns a list iterator containing the elements in the specified range of {@code array} in\n     * order, starting at the specified index.\n     *\n     * <p>The {@code Iterable} equivalent of this method is {@code\n     * Arrays.asList(array).subList(offset, offset + length).listIterator(index)}.\n     */\n    static <T> UnmodifiableListIterator<T> forArray(\n        final T[] array, final int offset, int length, int index)\n    {\n        checkArgument(length >= 0);\n        int end = offset + length;\n\n        // Technically we should give a slightly more descriptive error on overflow\n        Preconditions.checkPositionIndexes(offset, end, array.length);\n        Preconditions.checkPositionIndex(index, length);\n        if (length == 0)\n        {\n            return emptyListIterator();\n        }\n        return new ArrayItr<T>(array, offset, length, index);\n    }\n\n    private static final class ArrayItr<T> extends AbstractIndexedListIterator<T>\n    {\n        static final UnmodifiableListIterator<Object> EMPTY = new ArrayItr<>(new Object[0], 0, 0, 0);\n\n        private final T[] array;\n        private final int offset;\n\n        ArrayItr(T[] array, int offset, int length, int index)\n        {\n            super(length, index);\n            this.array = array;\n            this.offset = offset;\n        }\n\n        @Override\n        protected T get(int index)\n        {\n            return array[offset + index];\n        }\n    }\n\n    /**\n     * Returns an iterator containing only {@code value}.\n     *\n     * <p>The {@link Iterable} equivalent of this method is {@link Collections#singleton}.\n     */\n    public static <T> UnmodifiableIterator<T> singletonIterator(@NullableDecl final T value)\n    {\n        return new UnmodifiableIterator<T>()\n        {\n            boolean done;\n\n            @Override\n            public boolean hasNext()\n            {\n                return !done;\n            }\n\n            @Override\n            public T next()\n            {\n                if (done)\n                {\n                    throw new NoSuchElementException();\n                }\n                done = true;\n                return value;\n            }\n        };\n    }\n\n    /**\n     * Adapts an {@code Enumeration} to the {@code Iterator} interface.\n     *\n     * <p>This method has no equivalent in {@link Iterables} because viewing an {@code Enumeration} as\n     * an {@code Iterable} is impossible. However, the contents can be <i>copied</i> into a collection\n     * using {@link Collections#list}.\n     */\n    public static <T> UnmodifiableIterator<T> forEnumeration(final Enumeration<T> enumeration)\n    {\n        checkNotNull(enumeration);\n        return new UnmodifiableIterator<T>()\n        {\n            @Override\n            public boolean hasNext()\n            {\n                return enumeration.hasMoreElements();\n            }\n\n            @Override\n            public T next()\n            {\n                return enumeration.nextElement();\n            }\n        };\n    }\n\n    /**\n     * Adapts an {@code Iterator} to the {@code Enumeration} interface.\n     *\n     * <p>The {@code Iterable} equivalent of this method is either {@link Collections#enumeration} (if\n     * you have a {@link Collection}), or {@code Iterators.asEnumeration(collection.iterator())}.\n     */\n    public static <T> Enumeration<T> asEnumeration(final Iterator<T> iterator)\n    {\n        checkNotNull(iterator);\n        return new Enumeration<T>()\n        {\n            @Override\n            public boolean hasMoreElements()\n            {\n                return iterator.hasNext();\n            }\n\n            @Override\n            public T nextElement()\n            {\n                return iterator.next();\n            }\n        };\n    }\n\n    /** Implementation of PeekingIterator that avoids peeking unless necessary. */\n    private static class PeekingImpl<E> implements PeekingIterator<E>\n    {\n\n        private final Iterator<? extends E> iterator;\n        private boolean hasPeeked;\n        @NullableDecl private E peekedElement;\n\n        public PeekingImpl(Iterator<? extends E> iterator)\n        {\n            this.iterator = checkNotNull(iterator);\n        }\n\n        @Override\n        public boolean hasNext()\n        {\n            return hasPeeked || iterator.hasNext();\n        }\n\n        @Override\n        public E next()\n        {\n            if (!hasPeeked)\n            {\n                return iterator.next();\n            }\n            E result = peekedElement;\n            hasPeeked = false;\n            peekedElement = null;\n            return result;\n        }\n\n        @Override\n        public void remove()\n        {\n            checkState(!hasPeeked, \"Can't remove after you've peeked at next\");\n            iterator.remove();\n        }\n\n        @Override\n        public E peek()\n        {\n            if (!hasPeeked)\n            {\n                peekedElement = iterator.next();\n                hasPeeked = true;\n            }\n            return peekedElement;\n        }\n    }\n\n    /**\n     * Returns a {@code PeekingIterator} backed by the given iterator.\n     *\n     * <p>Calls to the {@code peek} method with no intervening calls to {@code next} do not affect the\n     * iteration, and hence return the same object each time. A subsequent call to {@code next} is\n     * guaranteed to return the same object again. For example:\n     *\n     * <pre>{@code\n     * PeekingIterator<String> peekingIterator =\n     *     Iterators.peekingIterator(Iterators.forArray(\"a\", \"b\"));\n     * String a1 = peekingIterator.peek(); // returns \"a\"\n     * String a2 = peekingIterator.peek(); // also returns \"a\"\n     * String a3 = peekingIterator.next(); // also returns \"a\"\n     * }</pre>\n     *\n     * <p>Any structural changes to the underlying iteration (aside from those performed by the\n     * iterator's own {@link PeekingIterator#remove()} method) will leave the iterator in an undefined\n     * state.\n     *\n     * <p>The returned iterator does not support removal after peeking, as explained by {@link\n     * PeekingIterator#remove()}.\n     *\n     * <p>Note: If the given iterator is already a {@code PeekingIterator}, it <i>might</i> be\n     * returned to the caller, although this is neither guaranteed to occur nor required to be\n     * consistent. For example, this method <i>might</i> choose to pass through recognized\n     * implementations of {@code PeekingIterator} when the behavior of the implementation is known to\n     * meet the contract guaranteed by this method.\n     *\n     * <p>There is no {@link Iterable} equivalent to this method, so use this method to wrap each\n     * individual iterator as it is generated.\n     *\n     * @param iterator the backing iterator. The {@link PeekingIterator} assumes ownership of this\n     *     iterator, so users should cease making direct calls to it after calling this method.\n     * @return a peeking iterator backed by that iterator. Apart from the additional {@link\n     *     PeekingIterator#peek()} method, this iterator behaves exactly the same as {@code iterator}.\n     */\n    public static <T> PeekingIterator<T> peekingIterator(Iterator<? extends T> iterator)\n    {\n        if (iterator instanceof PeekingImpl)\n        {\n            // Safe to cast <? extends T> to <T> because PeekingImpl only uses T\n            // covariantly (and cannot be subclassed to add non-covariant uses).\n            @SuppressWarnings(\"unchecked\")\n            PeekingImpl<T> peeking = (PeekingImpl<T>) iterator;\n            return peeking;\n        }\n        return new PeekingImpl<T>(iterator);\n    }\n\n    /**\n     * Simply returns its argument.\n     *\n     * @deprecated no need to use this\n     * @since 10.0\n     */\n    @Deprecated\n    public static <T> PeekingIterator<T> peekingIterator(PeekingIterator<T> iterator)\n    {\n        return checkNotNull(iterator);\n    }\n\n    /**\n     * Returns an iterator over the merged contents of all given {@code iterators}, traversing every\n     * element of the input iterators. Equivalent entries will not be de-duplicated.\n     *\n     * <p>Callers must ensure that the source {@code iterators} are in non-descending order as this\n     * method does not sort its input.\n     *\n     * <p>For any equivalent elements across all {@code iterators}, it is undefined which element is\n     * returned first.\n     *\n     * @since 11.0\n     */\n    @Beta\n    public static <T> UnmodifiableIterator<T> mergeSorted(\n        Iterable<? extends Iterator<? extends T>> iterators, Comparator<? super T> comparator)\n    {\n        checkNotNull(iterators, \"iterators\");\n        checkNotNull(comparator, \"comparator\");\n\n        return new MergingIterator<T>(iterators, comparator);\n    }\n\n    /**\n     * An iterator that performs a lazy N-way merge, calculating the next value each time the iterator\n     * is polled. This amortizes the sorting cost over the iteration and requires less memory than\n     * sorting all elements at once.\n     *\n     * <p>Retrieving a single element takes approximately O(log(M)) time, where M is the number of\n     * iterators. (Retrieving all elements takes approximately O(N*log(M)) time, where N is the total\n     * number of elements.)\n     */\n    private static class MergingIterator<T> extends UnmodifiableIterator<T>\n    {\n        final Queue<PeekingIterator<T>> queue;\n\n        public MergingIterator(\n            Iterable<? extends Iterator<? extends T>> iterators,\n            final Comparator<? super T> itemComparator)\n        {\n            // A comparator that's used by the heap, allowing the heap\n            // to be sorted based on the top of each iterator.\n            Comparator<PeekingIterator<T>> heapComparator =\n                new Comparator<PeekingIterator<T>>()\n            {\n                @Override\n                public int compare(PeekingIterator<T> o1, PeekingIterator<T> o2)\n                {\n                    return itemComparator.compare(o1.peek(), o2.peek());\n                }\n            };\n\n            queue = new PriorityQueue<>(2, heapComparator);\n\n            for (Iterator<? extends T> iterator : iterators)\n            {\n                if (iterator.hasNext())\n                {\n                    queue.add(Iterators.peekingIterator(iterator));\n                }\n            }\n        }\n\n        @Override\n        public boolean hasNext()\n        {\n            return !queue.isEmpty();\n        }\n\n        @Override\n        public T next()\n        {\n            PeekingIterator<T> nextIter = queue.remove();\n            T next = nextIter.next();\n            if (nextIter.hasNext())\n            {\n                queue.add(nextIter);\n            }\n            return next;\n        }\n    }\n\n    private static class ConcatenatedIterator<T> implements Iterator<T>\n    {\n        /* The last iterator to return an element.  Calls to remove() go to this iterator. */\n        @NullableDecl private Iterator<? extends T> toRemove;\n\n        /* The iterator currently returning elements. */\n        private Iterator<? extends T> iterator;\n\n        /*\n         * We track the \"meta iterators,\" the iterators-of-iterators, below.  Usually, topMetaIterator\n         * is the only one in use, but if we encounter nested concatenations, we start a deque of\n         * meta-iterators rather than letting the nesting get arbitrarily deep.  This keeps each\n         * operation O(1).\n         */\n\n        private Iterator<? extends Iterator<? extends T>> topMetaIterator;\n\n        // Only becomes nonnull if we encounter nested concatenations.\n        @NullableDecl private Deque<Iterator<? extends Iterator<? extends T>>> metaIterators;\n\n        ConcatenatedIterator(Iterator<? extends Iterator<? extends T>> metaIterator)\n        {\n            iterator = emptyIterator();\n            topMetaIterator = checkNotNull(metaIterator);\n        }\n\n        // Returns a nonempty meta-iterator or, if all meta-iterators are empty, null.\n        @NullableDecl\n        private Iterator<? extends Iterator<? extends T>> getTopMetaIterator()\n        {\n            while (topMetaIterator == null || !topMetaIterator.hasNext())\n            {\n                if (metaIterators != null && !metaIterators.isEmpty())\n                {\n                    topMetaIterator = metaIterators.removeFirst();\n                }\n                else\n                {\n                    return null;\n                }\n            }\n            return topMetaIterator;\n        }\n\n        @Override\n        public boolean hasNext()\n        {\n            while (!checkNotNull(iterator).hasNext())\n            {\n                // this weird checkNotNull positioning appears required by our tests, which expect\n                // both hasNext and next to throw NPE if an input iterator is null.\n\n                topMetaIterator = getTopMetaIterator();\n                if (topMetaIterator == null)\n                {\n                    return false;\n                }\n\n                iterator = topMetaIterator.next();\n\n                if (iterator instanceof ConcatenatedIterator)\n                {\n                    // Instead of taking linear time in the number of nested concatenations, unpack\n                    // them into the queue\n                    @SuppressWarnings(\"unchecked\")\n                    ConcatenatedIterator<T> topConcat = (ConcatenatedIterator<T>) iterator;\n                    iterator = topConcat.iterator;\n\n                    // topConcat.topMetaIterator, then topConcat.metaIterators, then this.topMetaIterator,\n                    // then this.metaIterators\n\n                    if (this.metaIterators == null)\n                    {\n                        this.metaIterators = new ArrayDeque<>();\n                    }\n                    this.metaIterators.addFirst(this.topMetaIterator);\n                    if (topConcat.metaIterators != null)\n                    {\n                        while (!topConcat.metaIterators.isEmpty())\n                        {\n                            this.metaIterators.addFirst(topConcat.metaIterators.removeLast());\n                        }\n                    }\n                    this.topMetaIterator = topConcat.topMetaIterator;\n                }\n            }\n            return true;\n        }\n\n        @Override\n        public T next()\n        {\n            if (hasNext())\n            {\n                toRemove = iterator;\n                return iterator.next();\n            }\n            else\n            {\n                throw new NoSuchElementException();\n            }\n        }\n\n        @Override\n        public void remove()\n        {\n            CollectPreconditions.checkRemove(toRemove != null);\n            toRemove.remove();\n            toRemove = null;\n        }\n    }\n\n    /** Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557 */\n    static <T> ListIterator<T> cast(Iterator<T> iterator)\n    {\n        return (ListIterator<T>) iterator;\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/Iterators.java", "func_name": "Iterators.clear", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Clears the iterator using its remove method.", "docstring_tokens": ["Clears", "the", "iterator", "using", "its", "remove", "method", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/Iterators.java#L988-L994", "partition": "valid", "up_fun_num": 50, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.base.Preconditions.checkState;", "import static com.google.common.base.Predicates.instanceOf;", "import static com.google.common.collect.CollectPreconditions.checkRemove;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.Function;", "import com.google.common.base.Objects;", "import com.google.common.base.Optional;", "import com.google.common.base.Preconditions;", "import com.google.common.base.Predicate;", "import com.google.common.primitives.Ints;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.util.ArrayDeque;", "import java.util.Arrays;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.Comparator;", "import java.util.Deque;", "import java.util.Enumeration;", "import java.util.Iterator;", "import java.util.List;", "import java.util.ListIterator;", "import java.util.NoSuchElementException;", "import java.util.PriorityQueue;", "import java.util.Queue;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Iterators\n", "    static <T> UnmodifiableIterator<T> emptyIterator()\n", "    static <T> UnmodifiableListIterator<T> emptyListIterator()\n", "    static <T> Iterator<T> emptyModifiableIterator()\n", "    public static <T> UnmodifiableIterator<T> unmodifiableIterator(\n", "    public static <T> UnmodifiableIterator<T> unmodifiableIterator(UnmodifiableIterator<T> iterator)\n", "    public static int size(Iterator<?> iterator)\n", "    public static boolean contains(Iterator<?> iterator, @NullableDecl Object element)\n", "    public static boolean removeAll(Iterator<?> removeFrom, Collection<?> elementsToRemove)\n", "    public static <T> boolean removeIf(Iterator<T> removeFrom, Predicate<? super T> predicate)\n", "    public static boolean retainAll(Iterator<?> removeFrom, Collection<?> elementsToRetain)\n", "    public static boolean elementsEqual(Iterator<?> iterator1, Iterator<?> iterator2)\n", "    public static String toString(Iterator<?> iterator)\n", "    public static <T> T getOnlyElement(Iterator<T> iterator)\n", "    public static <T> T getOnlyElement(Iterator<? extends T> iterator, @NullableDecl T defaultValue)\n", "    public static <T> T[] toArray(Iterator<? extends T> iterator, Class<T> type)\n", "    public static <T> boolean addAll(Collection<T> addTo, Iterator<? extends T> iterator)\n", "    public static int frequency(Iterator<?> iterator, @NullableDecl Object element)\n", "    public static <T> Iterator<T> cycle(final Iterable<T> iterable)\n", "    public static <T> Iterator<T> cycle(T... elements)\n", "    private static <T> Iterator<T> consumingForArray(final T... elements)\n", "    public static <T> Iterator<T> concat(Iterator<? extends T> a, Iterator<? extends T> b)\n", "    public static <T> Iterator<T> concat(\n", "    public static <T> Iterator<T> concat(\n", "    public static <T> Iterator<T> concat(Iterator<? extends T>... inputs)\n", "    public static <T> Iterator<T> concat(Iterator<? extends Iterator<? extends T>> inputs)\n", "    static <T> Iterator<T> concatNoDefensiveCopy(Iterator<? extends T>... inputs)\n", "    public static <T> UnmodifiableIterator<List<T>> partition(Iterator<T> iterator, int size)\n", "    public static <T> UnmodifiableIterator<List<T>> paddedPartition(Iterator<T> iterator, int size)\n", "    private static <T> UnmodifiableIterator<List<T>> partitionImpl(\n", "    public static <T> UnmodifiableIterator<T> filter(\n", "    public static <T> UnmodifiableIterator<T> filter(Iterator<?> unfiltered, Class<T> desiredType)\n", "    public static <T> boolean any(Iterator<T> iterator, Predicate<? super T> predicate)\n", "    public static <T> boolean all(Iterator<T> iterator, Predicate<? super T> predicate)\n", "    public static <T> T find(Iterator<T> iterator, Predicate<? super T> predicate)\n", "    public static <T> T find(\n", "    public static <T> Optional<T> tryFind(Iterator<T> iterator, Predicate<? super T> predicate)\n", "    public static <T> int indexOf(Iterator<T> iterator, Predicate<? super T> predicate)\n", "    public static <F, T> Iterator<T> transform(\n", "    public static <T> T get(Iterator<T> iterator, int position)\n", "    public static <T> T get(\n", "    static void checkNonnegative(int position)\n", "    public static <T> T getNext(Iterator<? extends T> iterator, @NullableDecl T defaultValue)\n", "    public static <T> T getLast(Iterator<T> iterator)\n", "    public static <T> T getLast(Iterator<? extends T> iterator, @NullableDecl T defaultValue)\n", "    public static int advance(Iterator<?> iterator, int numberToAdvance)\n", "    public static <T> Iterator<T> limit(final Iterator<T> iterator, final int limitSize)\n", "    public static <T> Iterator<T> consumingIterator(final Iterator<T> iterator)\n", "    static <T> T pollNext(Iterator<T> iterator)\n", "    public static <T> UnmodifiableIterator<T> forArray(final T... array)\n", "    static <T> UnmodifiableListIterator<T> forArray(\n", "    public static <T> UnmodifiableIterator<T> singletonIterator(@NullableDecl final T value)\n", "    public static <T> UnmodifiableIterator<T> forEnumeration(final Enumeration<T> enumeration)\n", "    public static <T> Enumeration<T> asEnumeration(final Iterator<T> iterator)\n", "    public static <T> PeekingIterator<T> peekingIterator(Iterator<? extends T> iterator)\n", "    public static <T> PeekingIterator<T> peekingIterator(PeekingIterator<T> iterator)\n", "    public static <T> UnmodifiableIterator<T> mergeSorted(\n", "    static <T> ListIterator<T> cast(Iterator<T> iterator)\n"], "context": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Predicates.instanceOf;\nimport static com.google.common.collect.CollectPreconditions.checkRemove;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Function;\nimport com.google.common.base.Objects;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.common.primitives.Ints;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * This class contains static utility methods that operate on or return objects of type {@link\n * Iterator}. Except as noted, each method has a corresponding {@link Iterable}-based method in the\n * {@link Iterables} class.\n *\n * <p><i>Performance notes:</i> Unless otherwise noted, all of the iterators produced in this class\n * are <i>lazy</i>, which means that they only advance the backing iteration when absolutely\n * necessary.\n *\n * <p>See the Guava User Guide section on <a href=\n * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#iterables\"> {@code\n * Iterators}</a>.\n *\n * @author Kevin Bourrillion\n * @author Jared Levy\n * @since 2.0\n */\n@GwtCompatible(emulated = true)\npublic final class Iterators\n{\n    private Iterators() {}\n\n    /**\n     * Returns the empty iterator.\n     *\n     * <p>The {@link Iterable} equivalent of this method is {@link ImmutableSet#of()}.\n     */\n    static <T> UnmodifiableIterator<T> emptyIterator()\n    {\n        return emptyListIterator();\n    }\n\n    /**\n     * Returns the empty iterator.\n     *\n     * <p>The {@link Iterable} equivalent of this method is {@link ImmutableSet#of()}.\n     */\n    // Casting to any type is safe since there are no actual elements.\n    @SuppressWarnings(\"unchecked\")\n    static <T> UnmodifiableListIterator<T> emptyListIterator()\n    {\n        return (UnmodifiableListIterator<T>) ArrayItr.EMPTY;\n    }\n\n    /**\n     * This is an enum singleton rather than an anonymous class so ProGuard can figure out it's only\n     * referenced by emptyModifiableIterator().\n     */\n    private enum EmptyModifiableIterator implements Iterator<Object>\n    {\n        INSTANCE;\n\n        @Override\n        public boolean hasNext()\n        {\n            return false;\n        }\n\n        @Override\n        public Object next()\n        {\n            throw new NoSuchElementException();\n        }\n\n        @Override\n        public void remove()\n        {\n            checkRemove(false);\n        }\n    }\n\n    /**\n     * Returns the empty {@code Iterator} that throws {@link IllegalStateException} instead of {@link\n     * UnsupportedOperationException} on a call to {@link Iterator#remove()}.\n     */\n    // Casting to any type is safe since there are no actual elements.\n    @SuppressWarnings(\"unchecked\")\n    static <T> Iterator<T> emptyModifiableIterator()\n    {\n        return (Iterator<T>) EmptyModifiableIterator.INSTANCE;\n    }\n\n    /** Returns an unmodifiable view of {@code iterator}. */\n    public static <T> UnmodifiableIterator<T> unmodifiableIterator(\n        final Iterator<? extends T> iterator)\n    {\n        checkNotNull(iterator);\n        if (iterator instanceof UnmodifiableIterator)\n        {\n            @SuppressWarnings(\"unchecked\") // Since it's unmodifiable, the covariant cast is safe\n            UnmodifiableIterator<T> result = (UnmodifiableIterator<T>) iterator;\n            return result;\n        }\n        return new UnmodifiableIterator<T>()\n        {\n            @Override\n            public boolean hasNext()\n            {\n                return iterator.hasNext();\n            }\n\n            @Override\n            public T next()\n            {\n                return iterator.next();\n            }\n        };\n    }\n\n    /**\n     * Simply returns its argument.\n     *\n     * @deprecated no need to use this\n     * @since 10.0\n     */\n    @Deprecated\n    public static <T> UnmodifiableIterator<T> unmodifiableIterator(UnmodifiableIterator<T> iterator)\n    {\n        return checkNotNull(iterator);\n    }\n\n    /**\n     * Returns the number of elements remaining in {@code iterator}. The iterator will be left\n     * exhausted: its {@code hasNext()} method will return {@code false}.\n     */\n    public static int size(Iterator<?> iterator)\n    {\n        long count = 0L;\n        while (iterator.hasNext())\n        {\n            iterator.next();\n            count++;\n        }\n        return Ints.saturatedCast(count);\n    }\n\n    /** Returns {@code true} if {@code iterator} contains {@code element}. */\n    public static boolean contains(Iterator<?> iterator, @NullableDecl Object element)\n    {\n        if (element == null)\n        {\n            while (iterator.hasNext())\n            {\n                if (iterator.next() == null)\n                {\n                    return true;\n                }\n            }\n        }\n        else\n        {\n            while (iterator.hasNext())\n            {\n                if (element.equals(iterator.next()))\n                {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Traverses an iterator and removes every element that belongs to the provided collection. The\n     * iterator will be left exhausted: its {@code hasNext()} method will return {@code false}.\n     *\n     * @param removeFrom the iterator to (potentially) remove elements from\n     * @param elementsToRemove the elements to remove\n     * @return {@code true} if any element was removed from {@code iterator}\n     */\n    @CanIgnoreReturnValue\n    public static boolean removeAll(Iterator<?> removeFrom, Collection<?> elementsToRemove)\n    {\n        checkNotNull(elementsToRemove);\n        boolean result = false;\n        while (removeFrom.hasNext())\n        {\n            if (elementsToRemove.contains(removeFrom.next()))\n            {\n                removeFrom.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Removes every element that satisfies the provided predicate from the iterator. The iterator\n     * will be left exhausted: its {@code hasNext()} method will return {@code false}.\n     *\n     * @param removeFrom the iterator to (potentially) remove elements from\n     * @param predicate a predicate that determines whether an element should be removed\n     * @return {@code true} if any elements were removed from the iterator\n     * @since 2.0\n     */\n    @CanIgnoreReturnValue\n    public static <T> boolean removeIf(Iterator<T> removeFrom, Predicate<? super T> predicate)\n    {\n        checkNotNull(predicate);\n        boolean modified = false;\n        while (removeFrom.hasNext())\n        {\n            if (predicate.apply(removeFrom.next()))\n            {\n                removeFrom.remove();\n                modified = true;\n            }\n        }\n        return modified;\n    }\n\n    /**\n     * Traverses an iterator and removes every element that does not belong to the provided\n     * collection. The iterator will be left exhausted: its {@code hasNext()} method will return\n     * {@code false}.\n     *\n     * @param removeFrom the iterator to (potentially) remove elements from\n     * @param elementsToRetain the elements to retain\n     * @return {@code true} if any element was removed from {@code iterator}\n     */\n    @CanIgnoreReturnValue\n    public static boolean retainAll(Iterator<?> removeFrom, Collection<?> elementsToRetain)\n    {\n        checkNotNull(elementsToRetain);\n        boolean result = false;\n        while (removeFrom.hasNext())\n        {\n            if (!elementsToRetain.contains(removeFrom.next()))\n            {\n                removeFrom.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Determines whether two iterators contain equal elements in the same order. More specifically,\n     * this method returns {@code true} if {@code iterator1} and {@code iterator2} contain the same\n     * number of elements and every element of {@code iterator1} is equal to the corresponding element\n     * of {@code iterator2}.\n     *\n     * <p>Note that this will modify the supplied iterators, since they will have been advanced some\n     * number of elements forward.\n     */\n    public static boolean elementsEqual(Iterator<?> iterator1, Iterator<?> iterator2)\n    {\n        while (iterator1.hasNext())\n        {\n            if (!iterator2.hasNext())\n            {\n                return false;\n            }\n            Object o1 = iterator1.next();\n            Object o2 = iterator2.next();\n            if (!Objects.equal(o1, o2))\n            {\n                return false;\n            }\n        }\n        return !iterator2.hasNext();\n    }\n\n    /**\n     * Returns a string representation of {@code iterator}, with the format {@code [e1, e2, ..., en]}.\n     * The iterator will be left exhausted: its {@code hasNext()} method will return {@code false}.\n     */\n    public static String toString(Iterator<?> iterator)\n    {\n        StringBuilder sb = new StringBuilder().append('[');\n        boolean first = true;\n        while (iterator.hasNext())\n        {\n            if (!first)\n            {\n                sb.append(\", \");\n            }\n            first = false;\n            sb.append(iterator.next());\n        }\n        return sb.append(']').toString();\n    }\n\n    /**\n     * Returns the single element contained in {@code iterator}.\n     *\n     * @throws NoSuchElementException if the iterator is empty\n     * @throws IllegalArgumentException if the iterator contains multiple elements. The state of the\n     *     iterator is unspecified.\n     */\n    public static <T> T getOnlyElement(Iterator<T> iterator)\n    {\n        T first = iterator.next();\n        if (!iterator.hasNext())\n        {\n            return first;\n        }\n\n        StringBuilder sb = new StringBuilder().append(\"expected one element but was: <\").append(first);\n        for (int i = 0; i < 4 && iterator.hasNext(); i++)\n        {\n            sb.append(\", \").append(iterator.next());\n        }\n        if (iterator.hasNext())\n        {\n            sb.append(\", ...\");\n        }\n        sb.append('>');\n\n        throw new IllegalArgumentException(sb.toString());\n    }\n\n    /**\n     * Returns the single element contained in {@code iterator}, or {@code defaultValue} if the\n     * iterator is empty.\n     *\n     * @throws IllegalArgumentException if the iterator contains multiple elements. The state of the\n     *     iterator is unspecified.\n     */\n    @NullableDecl\n    public static <T> T getOnlyElement(Iterator<? extends T> iterator, @NullableDecl T defaultValue)\n    {\n        return iterator.hasNext() ? getOnlyElement(iterator) : defaultValue;\n    }\n\n    /**\n     * Copies an iterator's elements into an array. The iterator will be left exhausted: its {@code\n     * hasNext()} method will return {@code false}.\n     *\n     * @param iterator the iterator to copy\n     * @param type the type of the elements\n     * @return a newly-allocated array into which all the elements of the iterator have been copied\n     */\n    @GwtIncompatible // Array.newInstance(Class, int)\n    public static <T> T[] toArray(Iterator<? extends T> iterator, Class<T> type)\n    {\n        List<T> list = Lists.newArrayList(iterator);\n        return Iterables.toArray(list, type);\n    }\n\n    /**\n     * Adds all elements in {@code iterator} to {@code collection}. The iterator will be left\n     * exhausted: its {@code hasNext()} method will return {@code false}.\n     *\n     * @return {@code true} if {@code collection} was modified as a result of this operation\n     */\n    @CanIgnoreReturnValue\n    public static <T> boolean addAll(Collection<T> addTo, Iterator<? extends T> iterator)\n    {\n        checkNotNull(addTo);\n        checkNotNull(iterator);\n        boolean wasModified = false;\n        while (iterator.hasNext())\n        {\n            wasModified |= addTo.add(iterator.next());\n        }\n        return wasModified;\n    }\n\n    /**\n     * Returns the number of elements in the specified iterator that equal the specified object. The\n     * iterator will be left exhausted: its {@code hasNext()} method will return {@code false}.\n     *\n     * @see Collections#frequency\n     */\n    public static int frequency(Iterator<?> iterator, @NullableDecl Object element)\n    {\n        int count = 0;\n        while (contains(iterator, element))\n        {\n            // Since it lives in the same class, we know contains gets to the element and then stops,\n            // though that isn't currently publicly documented.\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Returns an iterator that cycles indefinitely over the elements of {@code iterable}.\n     *\n     * <p>The returned iterator supports {@code remove()} if the provided iterator does. After {@code\n     * remove()} is called, subsequent cycles omit the removed element, which is no longer in {@code\n     * iterable}. The iterator's {@code hasNext()} method returns {@code true} until {@code iterable}\n     * is empty.\n     *\n     * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You\n     * should use an explicit {@code break} or be certain that you will eventually remove all the\n     * elements.\n     */\n    public static <T> Iterator<T> cycle(final Iterable<T> iterable)\n    {\n        checkNotNull(iterable);\n        return new Iterator<T>()\n        {\n            Iterator<T> iterator = emptyModifiableIterator();\n\n            @Override\n            public boolean hasNext()\n            {\n                /*\n                 * Don't store a new Iterator until we know the user can't remove() the last returned\n                 * element anymore. Otherwise, when we remove from the old iterator, we may be invalidating\n                 * the new one. The result is a ConcurrentModificationException or other bad behavior.\n                 *\n                 * (If we decide that we really, really hate allocating two Iterators per cycle instead of\n                 * one, we can optimistically store the new Iterator and then be willing to throw it out if\n                 * the user calls remove().)\n                 */\n                return iterator.hasNext() || iterable.iterator().hasNext();\n            }\n\n            @Override\n            public T next()\n            {\n                if (!iterator.hasNext())\n                {\n                    iterator = iterable.iterator();\n                    if (!iterator.hasNext())\n                    {\n                        throw new NoSuchElementException();\n                    }\n                }\n                return iterator.next();\n            }\n\n            @Override\n            public void remove()\n            {\n                iterator.remove();\n            }\n        };\n    }\n\n    /**\n     * Returns an iterator that cycles indefinitely over the provided elements.\n     *\n     * <p>The returned iterator supports {@code remove()}. After {@code remove()} is called,\n     * subsequent cycles omit the removed element, but {@code elements} does not change. The\n     * iterator's {@code hasNext()} method returns {@code true} until all of the original elements\n     * have been removed.\n     *\n     * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You\n     * should use an explicit {@code break} or be certain that you will eventually remove all the\n     * elements.\n     */\n    @SafeVarargs\n    public static <T> Iterator<T> cycle(T... elements)\n    {\n        return cycle(Lists.newArrayList(elements));\n    }\n\n    /**\n     * Returns an Iterator that walks the specified array, nulling out elements behind it. This can\n     * avoid memory leaks when an element is no longer necessary.\n     *\n     * <p>This is mainly just to avoid the intermediate ArrayDeque in ConsumingQueueIterator.\n     */\n    private static <T> Iterator<T> consumingForArray(final T... elements)\n    {\n        return new UnmodifiableIterator<T>()\n        {\n            int index = 0;\n\n            @Override\n            public boolean hasNext()\n            {\n                return index < elements.length;\n            }\n\n            @Override\n            public T next()\n            {\n                if (!hasNext())\n                {\n                    throw new NoSuchElementException();\n                }\n                T result = elements[index];\n                elements[index] = null;\n                index++;\n                return result;\n            }\n        };\n    }\n\n    /**\n     * Combines two iterators into a single iterator. The returned iterator iterates across the\n     * elements in {@code a}, followed by the elements in {@code b}. The source iterators are not\n     * polled until necessary.\n     *\n     * <p>The returned iterator supports {@code remove()} when the corresponding input iterator\n     * supports it.\n     */\n    public static <T> Iterator<T> concat(Iterator<? extends T> a, Iterator<? extends T> b)\n    {\n        checkNotNull(a);\n        checkNotNull(b);\n        return concat(consumingForArray(a, b));\n    }\n\n    /**\n     * Combines three iterators into a single iterator. The returned iterator iterates across the\n     * elements in {@code a}, followed by the elements in {@code b}, followed by the elements in\n     * {@code c}. The source iterators are not polled until necessary.\n     *\n     * <p>The returned iterator supports {@code remove()} when the corresponding input iterator\n     * supports it.\n     */\n    public static <T> Iterator<T> concat(\n        Iterator<? extends T> a, Iterator<? extends T> b, Iterator<? extends T> c)\n    {\n        checkNotNull(a);\n        checkNotNull(b);\n        checkNotNull(c);\n        return concat(consumingForArray(a, b, c));\n    }\n\n    /**\n     * Combines four iterators into a single iterator. The returned iterator iterates across the\n     * elements in {@code a}, followed by the elements in {@code b}, followed by the elements in\n     * {@code c}, followed by the elements in {@code d}. The source iterators are not polled until\n     * necessary.\n     *\n     * <p>The returned iterator supports {@code remove()} when the corresponding input iterator\n     * supports it.\n     */\n    public static <T> Iterator<T> concat(\n        Iterator<? extends T> a,\n        Iterator<? extends T> b,\n        Iterator<? extends T> c,\n        Iterator<? extends T> d)\n    {\n        checkNotNull(a);\n        checkNotNull(b);\n        checkNotNull(c);\n        checkNotNull(d);\n        return concat(consumingForArray(a, b, c, d));\n    }\n\n    /**\n     * Combines multiple iterators into a single iterator. The returned iterator iterates across the\n     * elements of each iterator in {@code inputs}. The input iterators are not polled until\n     * necessary.\n     *\n     * <p>The returned iterator supports {@code remove()} when the corresponding input iterator\n     * supports it.\n     *\n     * @throws NullPointerException if any of the provided iterators is null\n     */\n    public static <T> Iterator<T> concat(Iterator<? extends T>... inputs)\n    {\n        return concatNoDefensiveCopy(Arrays.copyOf(inputs, inputs.length));\n    }\n\n    /**\n     * Combines multiple iterators into a single iterator. The returned iterator iterates across the\n     * elements of each iterator in {@code inputs}. The input iterators are not polled until\n     * necessary.\n     *\n     * <p>The returned iterator supports {@code remove()} when the corresponding input iterator\n     * supports it. The methods of the returned iterator may throw {@code NullPointerException} if any\n     * of the input iterators is null.\n     */\n    public static <T> Iterator<T> concat(Iterator<? extends Iterator<? extends T>> inputs)\n    {\n        return new ConcatenatedIterator<T>(inputs);\n    }\n\n    /** Concats a varargs array of iterators without making a defensive copy of the array. */\n    static <T> Iterator<T> concatNoDefensiveCopy(Iterator<? extends T>... inputs)\n    {\n        for (Iterator<? extends T> input : checkNotNull(inputs))\n        {\n            checkNotNull(input);\n        }\n        return concat(consumingForArray(inputs));\n    }\n\n    /**\n     * Divides an iterator into unmodifiable sublists of the given size (the final list may be\n     * smaller). For example, partitioning an iterator containing {@code [a, b, c, d, e]} with a\n     * partition size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer iterator containing two\n     * inner lists of three and two elements, all in the original order.\n     *\n     * <p>The returned lists implement {@link java.util.RandomAccess}.\n     *\n     * @param iterator the iterator to return a partitioned view of\n     * @param size the desired size of each partition (the last may be smaller)\n     * @return an iterator of immutable lists containing the elements of {@code iterator} divided into\n     *     partitions\n     * @throws IllegalArgumentException if {@code size} is nonpositive\n     */\n    public static <T> UnmodifiableIterator<List<T>> partition(Iterator<T> iterator, int size)\n    {\n        return partitionImpl(iterator, size, false);\n    }\n\n    /**\n     * Divides an iterator into unmodifiable sublists of the given size, padding the final iterator\n     * with null values if necessary. For example, partitioning an iterator containing {@code [a, b,\n     * c, d, e]} with a partition size of 3 yields {@code [[a, b, c], [d, e, null]]} -- an outer\n     * iterator containing two inner lists of three elements each, all in the original order.\n     *\n     * <p>The returned lists implement {@link java.util.RandomAccess}.\n     *\n     * @param iterator the iterator to return a partitioned view of\n     * @param size the desired size of each partition\n     * @return an iterator of immutable lists containing the elements of {@code iterator} divided into\n     *     partitions (the final iterable may have trailing null elements)\n     * @throws IllegalArgumentException if {@code size} is nonpositive\n     */\n    public static <T> UnmodifiableIterator<List<T>> paddedPartition(Iterator<T> iterator, int size)\n    {\n        return partitionImpl(iterator, size, true);\n    }\n\n    private static <T> UnmodifiableIterator<List<T>> partitionImpl(\n        final Iterator<T> iterator, final int size, final boolean pad)\n    {\n        checkNotNull(iterator);\n        checkArgument(size > 0);\n        return new UnmodifiableIterator<List<T>>()\n        {\n            @Override\n            public boolean hasNext()\n            {\n                return iterator.hasNext();\n            }\n\n            @Override\n            public List<T> next()\n            {\n                if (!hasNext())\n                {\n                    throw new NoSuchElementException();\n                }\n                Object[] array = new Object[size];\n                int count = 0;\n                for (; count < size && iterator.hasNext(); count++)\n                {\n                    array[count] = iterator.next();\n                }\n                for (int i = count; i < size; i++)\n                {\n                    array[i] = null; // for GWT\n                }\n\n                @SuppressWarnings(\"unchecked\") // we only put Ts in it\n                List<T> list = Collections.unmodifiableList((List<T>) Arrays.asList(array));\n                return (pad || count == size) ? list : list.subList(0, count);\n            }\n        };\n    }\n\n    /**\n     * Returns a view of {@code unfiltered} containing all elements that satisfy the input predicate\n     * {@code retainIfTrue}.\n     */\n    public static <T> UnmodifiableIterator<T> filter(\n        final Iterator<T> unfiltered, final Predicate<? super T> retainIfTrue)\n    {\n        checkNotNull(unfiltered);\n        checkNotNull(retainIfTrue);\n        return new AbstractIterator<T>()\n        {\n            @Override\n            protected T computeNext()\n            {\n                while (unfiltered.hasNext())\n                {\n                    T element = unfiltered.next();\n                    if (retainIfTrue.apply(element))\n                    {\n                        return element;\n                    }\n                }\n                return endOfData();\n            }\n        };\n    }\n\n    /**\n     * Returns a view of {@code unfiltered} containing all elements that are of the type {@code\n     * desiredType}.\n     */\n    @SuppressWarnings(\"unchecked\") // can cast to <T> because non-Ts are removed\n    @GwtIncompatible // Class.isInstance\n    public static <T> UnmodifiableIterator<T> filter(Iterator<?> unfiltered, Class<T> desiredType)\n    {\n        return (UnmodifiableIterator<T>) filter(unfiltered, instanceOf(desiredType));\n    }\n\n    /**\n     * Returns {@code true} if one or more elements returned by {@code iterator} satisfy the given\n     * predicate.\n     */\n    public static <T> boolean any(Iterator<T> iterator, Predicate<? super T> predicate)\n    {\n        return indexOf(iterator, predicate) != -1;\n    }\n\n    /**\n     * Returns {@code true} if every element returned by {@code iterator} satisfies the given\n     * predicate. If {@code iterator} is empty, {@code true} is returned.\n     */\n    public static <T> boolean all(Iterator<T> iterator, Predicate<? super T> predicate)\n    {\n        checkNotNull(predicate);\n        while (iterator.hasNext())\n        {\n            T element = iterator.next();\n            if (!predicate.apply(element))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the first element in {@code iterator} that satisfies the given predicate; use this\n     * method only when such an element is known to exist. If no such element is found, the iterator\n     * will be left exhausted: its {@code hasNext()} method will return {@code false}. If it is\n     * possible that <i>no</i> element will match, use {@link #tryFind} or {@link #find(Iterator,\n     * Predicate, Object)} instead.\n     *\n     * @throws NoSuchElementException if no element in {@code iterator} matches the given predicate\n     */\n    public static <T> T find(Iterator<T> iterator, Predicate<? super T> predicate)\n    {\n        checkNotNull(iterator);\n        checkNotNull(predicate);\n        while (iterator.hasNext())\n        {\n            T t = iterator.next();\n            if (predicate.apply(t))\n            {\n                return t;\n            }\n        }\n        throw new NoSuchElementException();\n    }\n\n    /**\n     * Returns the first element in {@code iterator} that satisfies the given predicate. If no such\n     * element is found, {@code defaultValue} will be returned from this method and the iterator will\n     * be left exhausted: its {@code hasNext()} method will return {@code false}. Note that this can\n     * usually be handled more naturally using {@code tryFind(iterator, predicate).or(defaultValue)}.\n     *\n     * @since 7.0\n     */\n    @NullableDecl\n    public static <T> T find(\n        Iterator<? extends T> iterator,\n        Predicate<? super T> predicate,\n        @NullableDecl T defaultValue)\n    {\n        checkNotNull(iterator);\n        checkNotNull(predicate);\n        while (iterator.hasNext())\n        {\n            T t = iterator.next();\n            if (predicate.apply(t))\n            {\n                return t;\n            }\n        }\n        return defaultValue;\n    }\n\n    /**\n     * Returns an {@link Optional} containing the first element in {@code iterator} that satisfies the\n     * given predicate, if such an element exists. If no such element is found, an empty {@link\n     * Optional} will be returned from this method and the iterator will be left exhausted: its {@code\n     * hasNext()} method will return {@code false}.\n     *\n     * <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code null}. If {@code null}\n     * is matched in {@code iterator}, a NullPointerException will be thrown.\n     *\n     * @since 11.0\n     */\n    public static <T> Optional<T> tryFind(Iterator<T> iterator, Predicate<? super T> predicate)\n    {\n        checkNotNull(iterator);\n        checkNotNull(predicate);\n        while (iterator.hasNext())\n        {\n            T t = iterator.next();\n            if (predicate.apply(t))\n            {\n                return Optional.of(t);\n            }\n        }\n        return Optional.absent();\n    }\n\n    /**\n     * Returns the index in {@code iterator} of the first element that satisfies the provided {@code\n     * predicate}, or {@code -1} if the Iterator has no such elements.\n     *\n     * <p>More formally, returns the lowest index {@code i} such that {@code\n     * predicate.apply(Iterators.get(iterator, i))} returns {@code true}, or {@code -1} if there is no\n     * such index.\n     *\n     * <p>If -1 is returned, the iterator will be left exhausted: its {@code hasNext()} method will\n     * return {@code false}. Otherwise, the iterator will be set to the element which satisfies the\n     * {@code predicate}.\n     *\n     * @since 2.0\n     */\n    public static <T> int indexOf(Iterator<T> iterator, Predicate<? super T> predicate)\n    {\n        checkNotNull(predicate, \"predicate\");\n        for (int i = 0; iterator.hasNext(); i++)\n        {\n            T current = iterator.next();\n            if (predicate.apply(current))\n            {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns a view containing the result of applying {@code function} to each element of {@code\n     * fromIterator}.\n     *\n     * <p>The returned iterator supports {@code remove()} if {@code fromIterator} does. After a\n     * successful {@code remove()} call, {@code fromIterator} no longer contains the corresponding\n     * element.\n     */\n    public static <F, T> Iterator<T> transform(\n        final Iterator<F> fromIterator, final Function<? super F, ? extends T> function)\n    {\n        checkNotNull(function);\n        return new TransformedIterator<F, T>(fromIterator)\n        {\n            @Override\n            T transform(F from)\n            {\n                return function.apply(from);\n            }\n        };\n    }\n\n    /**\n     * Advances {@code iterator} {@code position + 1} times, returning the element at the {@code\n     * position}th position.\n     *\n     * @param position position of the element to return\n     * @return the element at the specified position in {@code iterator}\n     * @throws IndexOutOfBoundsException if {@code position} is negative or greater than or equal to\n     *     the number of elements remaining in {@code iterator}\n     */\n    public static <T> T get(Iterator<T> iterator, int position)\n    {\n        checkNonnegative(position);\n        int skipped = advance(iterator, position);\n        if (!iterator.hasNext())\n        {\n            throw new IndexOutOfBoundsException(\n                \"position (\"\n                + position\n                + \") must be less than the number of elements that remained (\"\n                + skipped\n                + \")\");\n        }\n        return iterator.next();\n    }\n\n    /**\n     * Advances {@code iterator} {@code position + 1} times, returning the element at the {@code\n     * position}th position or {@code defaultValue} otherwise.\n     *\n     * @param position position of the element to return\n     * @param defaultValue the default value to return if the iterator is empty or if {@code position}\n     *     is greater than the number of elements remaining in {@code iterator}\n     * @return the element at the specified position in {@code iterator} or {@code defaultValue} if\n     *     {@code iterator} produces fewer than {@code position + 1} elements.\n     * @throws IndexOutOfBoundsException if {@code position} is negative\n     * @since 4.0\n     */\n    @NullableDecl\n    public static <T> T get(\n        Iterator<? extends T> iterator, int position, @NullableDecl T defaultValue)\n    {\n        checkNonnegative(position);\n        advance(iterator, position);\n        return getNext(iterator, defaultValue);\n    }\n\n    static void checkNonnegative(int position)\n    {\n        if (position < 0)\n        {\n            throw new IndexOutOfBoundsException(\"position (\" + position + \") must not be negative\");\n        }\n    }\n\n    /**\n     * Returns the next element in {@code iterator} or {@code defaultValue} if the iterator is empty.\n     * The {@link Iterables} analog to this method is {@link Iterables#getFirst}.\n     *\n     * @param defaultValue the default value to return if the iterator is empty\n     * @return the next element of {@code iterator} or the default value\n     * @since 7.0\n     */\n    @NullableDecl\n    public static <T> T getNext(Iterator<? extends T> iterator, @NullableDecl T defaultValue)\n    {\n        return iterator.hasNext() ? iterator.next() : defaultValue;\n    }\n\n    /**\n     * Advances {@code iterator} to the end, returning the last element.\n     *\n     * @return the last element of {@code iterator}\n     * @throws NoSuchElementException if the iterator is empty\n     */\n    public static <T> T getLast(Iterator<T> iterator)\n    {\n        while (true)\n        {\n            T current = iterator.next();\n            if (!iterator.hasNext())\n            {\n                return current;\n            }\n        }\n    }\n\n    /**\n     * Advances {@code iterator} to the end, returning the last element or {@code defaultValue} if the\n     * iterator is empty.\n     *\n     * @param defaultValue the default value to return if the iterator is empty\n     * @return the last element of {@code iterator}\n     * @since 3.0\n     */\n    @NullableDecl\n    public static <T> T getLast(Iterator<? extends T> iterator, @NullableDecl T defaultValue)\n    {\n        return iterator.hasNext() ? getLast(iterator) : defaultValue;\n    }\n\n    /**\n     * Calls {@code next()} on {@code iterator}, either {@code numberToAdvance} times or until {@code\n     * hasNext()} returns {@code false}, whichever comes first.\n     *\n     * @return the number of elements the iterator was advanced\n     * @since 13.0 (since 3.0 as {@code Iterators.skip})\n     */\n    @CanIgnoreReturnValue\n    public static int advance(Iterator<?> iterator, int numberToAdvance)\n    {\n        checkNotNull(iterator);\n        checkArgument(numberToAdvance >= 0, \"numberToAdvance must be nonnegative\");\n\n        int i;\n        for (i = 0; i < numberToAdvance && iterator.hasNext(); i++)\n        {\n            iterator.next();\n        }\n        return i;\n    }\n\n    /**\n     * Returns a view containing the first {@code limitSize} elements of {@code iterator}. If {@code\n     * iterator} contains fewer than {@code limitSize} elements, the returned view contains all of its\n     * elements. The returned iterator supports {@code remove()} if {@code iterator} does.\n     *\n     * @param iterator the iterator to limit\n     * @param limitSize the maximum number of elements in the returned iterator\n     * @throws IllegalArgumentException if {@code limitSize} is negative\n     * @since 3.0\n     */\n    public static <T> Iterator<T> limit(final Iterator<T> iterator, final int limitSize)\n    {\n        checkNotNull(iterator);\n        checkArgument(limitSize >= 0, \"limit is negative\");\n        return new Iterator<T>()\n        {\n            private int count;\n\n            @Override\n            public boolean hasNext()\n            {\n                return count < limitSize && iterator.hasNext();\n            }\n\n            @Override\n            public T next()\n            {\n                if (!hasNext())\n                {\n                    throw new NoSuchElementException();\n                }\n                count++;\n                return iterator.next();\n            }\n\n            @Override\n            public void remove()\n            {\n                iterator.remove();\n            }\n        };\n    }\n\n    /**\n     * Returns a view of the supplied {@code iterator} that removes each element from the supplied\n     * {@code iterator} as it is returned.\n     *\n     * <p>The provided iterator must support {@link Iterator#remove()} or else the returned iterator\n     * will fail on the first call to {@code next}.\n     *\n     * @param iterator the iterator to remove and return elements from\n     * @return an iterator that removes and returns elements from the supplied iterator\n     * @since 2.0\n     */\n    public static <T> Iterator<T> consumingIterator(final Iterator<T> iterator)\n    {\n        checkNotNull(iterator);\n        return new UnmodifiableIterator<T>()\n        {\n            @Override\n            public boolean hasNext()\n            {\n                return iterator.hasNext();\n            }\n\n            @Override\n            public T next()\n            {\n                T next = iterator.next();\n                iterator.remove();\n                return next;\n            }\n\n            @Override\n            public String toString()\n            {\n                return \"Iterators.consumingIterator(...)\";\n            }\n        };\n    }\n\n    /**\n     * Deletes and returns the next value from the iterator, or returns {@code null} if there is no\n     * such value.\n     */\n    @NullableDecl\n    static <T> T pollNext(Iterator<T> iterator)\n    {\n        if (iterator.hasNext())\n        {\n            T result = iterator.next();\n            iterator.remove();\n            return result;\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    // Methods only in Iterators, not in Iterables\n\n    /** Clears the iterator using its remove method. */\n\n    /**\n     * Returns an iterator containing the elements of {@code array} in order. The returned iterator is\n     * a view of the array; subsequent changes to the array will be reflected in the iterator.\n     *\n     * <p><b>Note:</b> It is often preferable to represent your data using a collection type, for\n     * example using {@link Arrays#asList(Object[])}, making this method unnecessary.\n     *\n     * <p>The {@code Iterable} equivalent of this method is either {@link Arrays#asList(Object[])},\n     * {@link ImmutableList#copyOf(Object[])}}, or {@link ImmutableList#of}.\n     */\n    @SafeVarargs\n    public static <T> UnmodifiableIterator<T> forArray(final T... array)\n    {\n        return forArray(array, 0, array.length, 0);\n    }\n\n    /**\n     * Returns a list iterator containing the elements in the specified range of {@code array} in\n     * order, starting at the specified index.\n     *\n     * <p>The {@code Iterable} equivalent of this method is {@code\n     * Arrays.asList(array).subList(offset, offset + length).listIterator(index)}.\n     */\n    static <T> UnmodifiableListIterator<T> forArray(\n        final T[] array, final int offset, int length, int index)\n    {\n        checkArgument(length >= 0);\n        int end = offset + length;\n\n        // Technically we should give a slightly more descriptive error on overflow\n        Preconditions.checkPositionIndexes(offset, end, array.length);\n        Preconditions.checkPositionIndex(index, length);\n        if (length == 0)\n        {\n            return emptyListIterator();\n        }\n        return new ArrayItr<T>(array, offset, length, index);\n    }\n\n    private static final class ArrayItr<T> extends AbstractIndexedListIterator<T>\n    {\n        static final UnmodifiableListIterator<Object> EMPTY = new ArrayItr<>(new Object[0], 0, 0, 0);\n\n        private final T[] array;\n        private final int offset;\n\n        ArrayItr(T[] array, int offset, int length, int index)\n        {\n            super(length, index);\n            this.array = array;\n            this.offset = offset;\n        }\n\n        @Override\n        protected T get(int index)\n        {\n            return array[offset + index];\n        }\n    }\n\n    /**\n     * Returns an iterator containing only {@code value}.\n     *\n     * <p>The {@link Iterable} equivalent of this method is {@link Collections#singleton}.\n     */\n    public static <T> UnmodifiableIterator<T> singletonIterator(@NullableDecl final T value)\n    {\n        return new UnmodifiableIterator<T>()\n        {\n            boolean done;\n\n            @Override\n            public boolean hasNext()\n            {\n                return !done;\n            }\n\n            @Override\n            public T next()\n            {\n                if (done)\n                {\n                    throw new NoSuchElementException();\n                }\n                done = true;\n                return value;\n            }\n        };\n    }\n\n    /**\n     * Adapts an {@code Enumeration} to the {@code Iterator} interface.\n     *\n     * <p>This method has no equivalent in {@link Iterables} because viewing an {@code Enumeration} as\n     * an {@code Iterable} is impossible. However, the contents can be <i>copied</i> into a collection\n     * using {@link Collections#list}.\n     */\n    public static <T> UnmodifiableIterator<T> forEnumeration(final Enumeration<T> enumeration)\n    {\n        checkNotNull(enumeration);\n        return new UnmodifiableIterator<T>()\n        {\n            @Override\n            public boolean hasNext()\n            {\n                return enumeration.hasMoreElements();\n            }\n\n            @Override\n            public T next()\n            {\n                return enumeration.nextElement();\n            }\n        };\n    }\n\n    /**\n     * Adapts an {@code Iterator} to the {@code Enumeration} interface.\n     *\n     * <p>The {@code Iterable} equivalent of this method is either {@link Collections#enumeration} (if\n     * you have a {@link Collection}), or {@code Iterators.asEnumeration(collection.iterator())}.\n     */\n    public static <T> Enumeration<T> asEnumeration(final Iterator<T> iterator)\n    {\n        checkNotNull(iterator);\n        return new Enumeration<T>()\n        {\n            @Override\n            public boolean hasMoreElements()\n            {\n                return iterator.hasNext();\n            }\n\n            @Override\n            public T nextElement()\n            {\n                return iterator.next();\n            }\n        };\n    }\n\n    /** Implementation of PeekingIterator that avoids peeking unless necessary. */\n    private static class PeekingImpl<E> implements PeekingIterator<E>\n    {\n\n        private final Iterator<? extends E> iterator;\n        private boolean hasPeeked;\n        @NullableDecl private E peekedElement;\n\n        public PeekingImpl(Iterator<? extends E> iterator)\n        {\n            this.iterator = checkNotNull(iterator);\n        }\n\n        @Override\n        public boolean hasNext()\n        {\n            return hasPeeked || iterator.hasNext();\n        }\n\n        @Override\n        public E next()\n        {\n            if (!hasPeeked)\n            {\n                return iterator.next();\n            }\n            E result = peekedElement;\n            hasPeeked = false;\n            peekedElement = null;\n            return result;\n        }\n\n        @Override\n        public void remove()\n        {\n            checkState(!hasPeeked, \"Can't remove after you've peeked at next\");\n            iterator.remove();\n        }\n\n        @Override\n        public E peek()\n        {\n            if (!hasPeeked)\n            {\n                peekedElement = iterator.next();\n                hasPeeked = true;\n            }\n            return peekedElement;\n        }\n    }\n\n    /**\n     * Returns a {@code PeekingIterator} backed by the given iterator.\n     *\n     * <p>Calls to the {@code peek} method with no intervening calls to {@code next} do not affect the\n     * iteration, and hence return the same object each time. A subsequent call to {@code next} is\n     * guaranteed to return the same object again. For example:\n     *\n     * <pre>{@code\n     * PeekingIterator<String> peekingIterator =\n     *     Iterators.peekingIterator(Iterators.forArray(\"a\", \"b\"));\n     * String a1 = peekingIterator.peek(); // returns \"a\"\n     * String a2 = peekingIterator.peek(); // also returns \"a\"\n     * String a3 = peekingIterator.next(); // also returns \"a\"\n     * }</pre>\n     *\n     * <p>Any structural changes to the underlying iteration (aside from those performed by the\n     * iterator's own {@link PeekingIterator#remove()} method) will leave the iterator in an undefined\n     * state.\n     *\n     * <p>The returned iterator does not support removal after peeking, as explained by {@link\n     * PeekingIterator#remove()}.\n     *\n     * <p>Note: If the given iterator is already a {@code PeekingIterator}, it <i>might</i> be\n     * returned to the caller, although this is neither guaranteed to occur nor required to be\n     * consistent. For example, this method <i>might</i> choose to pass through recognized\n     * implementations of {@code PeekingIterator} when the behavior of the implementation is known to\n     * meet the contract guaranteed by this method.\n     *\n     * <p>There is no {@link Iterable} equivalent to this method, so use this method to wrap each\n     * individual iterator as it is generated.\n     *\n     * @param iterator the backing iterator. The {@link PeekingIterator} assumes ownership of this\n     *     iterator, so users should cease making direct calls to it after calling this method.\n     * @return a peeking iterator backed by that iterator. Apart from the additional {@link\n     *     PeekingIterator#peek()} method, this iterator behaves exactly the same as {@code iterator}.\n     */\n    public static <T> PeekingIterator<T> peekingIterator(Iterator<? extends T> iterator)\n    {\n        if (iterator instanceof PeekingImpl)\n        {\n            // Safe to cast <? extends T> to <T> because PeekingImpl only uses T\n            // covariantly (and cannot be subclassed to add non-covariant uses).\n            @SuppressWarnings(\"unchecked\")\n            PeekingImpl<T> peeking = (PeekingImpl<T>) iterator;\n            return peeking;\n        }\n        return new PeekingImpl<T>(iterator);\n    }\n\n    /**\n     * Simply returns its argument.\n     *\n     * @deprecated no need to use this\n     * @since 10.0\n     */\n    @Deprecated\n    public static <T> PeekingIterator<T> peekingIterator(PeekingIterator<T> iterator)\n    {\n        return checkNotNull(iterator);\n    }\n\n    /**\n     * Returns an iterator over the merged contents of all given {@code iterators}, traversing every\n     * element of the input iterators. Equivalent entries will not be de-duplicated.\n     *\n     * <p>Callers must ensure that the source {@code iterators} are in non-descending order as this\n     * method does not sort its input.\n     *\n     * <p>For any equivalent elements across all {@code iterators}, it is undefined which element is\n     * returned first.\n     *\n     * @since 11.0\n     */\n    @Beta\n    public static <T> UnmodifiableIterator<T> mergeSorted(\n        Iterable<? extends Iterator<? extends T>> iterators, Comparator<? super T> comparator)\n    {\n        checkNotNull(iterators, \"iterators\");\n        checkNotNull(comparator, \"comparator\");\n\n        return new MergingIterator<T>(iterators, comparator);\n    }\n\n    /**\n     * An iterator that performs a lazy N-way merge, calculating the next value each time the iterator\n     * is polled. This amortizes the sorting cost over the iteration and requires less memory than\n     * sorting all elements at once.\n     *\n     * <p>Retrieving a single element takes approximately O(log(M)) time, where M is the number of\n     * iterators. (Retrieving all elements takes approximately O(N*log(M)) time, where N is the total\n     * number of elements.)\n     */\n    private static class MergingIterator<T> extends UnmodifiableIterator<T>\n    {\n        final Queue<PeekingIterator<T>> queue;\n\n        public MergingIterator(\n            Iterable<? extends Iterator<? extends T>> iterators,\n            final Comparator<? super T> itemComparator)\n        {\n            // A comparator that's used by the heap, allowing the heap\n            // to be sorted based on the top of each iterator.\n            Comparator<PeekingIterator<T>> heapComparator =\n                new Comparator<PeekingIterator<T>>()\n            {\n                @Override\n                public int compare(PeekingIterator<T> o1, PeekingIterator<T> o2)\n                {\n                    return itemComparator.compare(o1.peek(), o2.peek());\n                }\n            };\n\n            queue = new PriorityQueue<>(2, heapComparator);\n\n            for (Iterator<? extends T> iterator : iterators)\n            {\n                if (iterator.hasNext())\n                {\n                    queue.add(Iterators.peekingIterator(iterator));\n                }\n            }\n        }\n\n        @Override\n        public boolean hasNext()\n        {\n            return !queue.isEmpty();\n        }\n\n        @Override\n        public T next()\n        {\n            PeekingIterator<T> nextIter = queue.remove();\n            T next = nextIter.next();\n            if (nextIter.hasNext())\n            {\n                queue.add(nextIter);\n            }\n            return next;\n        }\n    }\n\n    private static class ConcatenatedIterator<T> implements Iterator<T>\n    {\n        /* The last iterator to return an element.  Calls to remove() go to this iterator. */\n        @NullableDecl private Iterator<? extends T> toRemove;\n\n        /* The iterator currently returning elements. */\n        private Iterator<? extends T> iterator;\n\n        /*\n         * We track the \"meta iterators,\" the iterators-of-iterators, below.  Usually, topMetaIterator\n         * is the only one in use, but if we encounter nested concatenations, we start a deque of\n         * meta-iterators rather than letting the nesting get arbitrarily deep.  This keeps each\n         * operation O(1).\n         */\n\n        private Iterator<? extends Iterator<? extends T>> topMetaIterator;\n\n        // Only becomes nonnull if we encounter nested concatenations.\n        @NullableDecl private Deque<Iterator<? extends Iterator<? extends T>>> metaIterators;\n\n        ConcatenatedIterator(Iterator<? extends Iterator<? extends T>> metaIterator)\n        {\n            iterator = emptyIterator();\n            topMetaIterator = checkNotNull(metaIterator);\n        }\n\n        // Returns a nonempty meta-iterator or, if all meta-iterators are empty, null.\n        @NullableDecl\n        private Iterator<? extends Iterator<? extends T>> getTopMetaIterator()\n        {\n            while (topMetaIterator == null || !topMetaIterator.hasNext())\n            {\n                if (metaIterators != null && !metaIterators.isEmpty())\n                {\n                    topMetaIterator = metaIterators.removeFirst();\n                }\n                else\n                {\n                    return null;\n                }\n            }\n            return topMetaIterator;\n        }\n\n        @Override\n        public boolean hasNext()\n        {\n            while (!checkNotNull(iterator).hasNext())\n            {\n                // this weird checkNotNull positioning appears required by our tests, which expect\n                // both hasNext and next to throw NPE if an input iterator is null.\n\n                topMetaIterator = getTopMetaIterator();\n                if (topMetaIterator == null)\n                {\n                    return false;\n                }\n\n                iterator = topMetaIterator.next();\n\n                if (iterator instanceof ConcatenatedIterator)\n                {\n                    // Instead of taking linear time in the number of nested concatenations, unpack\n                    // them into the queue\n                    @SuppressWarnings(\"unchecked\")\n                    ConcatenatedIterator<T> topConcat = (ConcatenatedIterator<T>) iterator;\n                    iterator = topConcat.iterator;\n\n                    // topConcat.topMetaIterator, then topConcat.metaIterators, then this.topMetaIterator,\n                    // then this.metaIterators\n\n                    if (this.metaIterators == null)\n                    {\n                        this.metaIterators = new ArrayDeque<>();\n                    }\n                    this.metaIterators.addFirst(this.topMetaIterator);\n                    if (topConcat.metaIterators != null)\n                    {\n                        while (!topConcat.metaIterators.isEmpty())\n                        {\n                            this.metaIterators.addFirst(topConcat.metaIterators.removeLast());\n                        }\n                    }\n                    this.topMetaIterator = topConcat.topMetaIterator;\n                }\n            }\n            return true;\n        }\n\n        @Override\n        public T next()\n        {\n            if (hasNext())\n            {\n                toRemove = iterator;\n                return iterator.next();\n            }\n            else\n            {\n                throw new NoSuchElementException();\n            }\n        }\n\n        @Override\n        public void remove()\n        {\n            CollectPreconditions.checkRemove(toRemove != null);\n            toRemove.remove();\n            toRemove = null;\n        }\n    }\n\n    /** Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557 */\n    static <T> ListIterator<T> cast(Iterator<T> iterator)\n    {\n        return (ListIterator<T>) iterator;\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/ByteSink.java", "func_name": "ByteSink.write", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Writes all the given bytes to this sink.\n\n@throws IOException if an I/O occurs while writing to this sink", "docstring_tokens": ["Writes", "all", "the", "given", "bytes", "to", "this", "sink", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/ByteSink.java#L96-L109", "partition": "valid", "up_fun_num": 5, "levels": [0, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.io.BufferedOutputStream;", "import java.io.IOException;", "import java.io.InputStream;", "import java.io.OutputStream;", "import java.io.OutputStreamWriter;", "import java.io.Writer;", "import java.nio.charset.Charset;"], "function": ["public abstract class ByteSink\n", "    public CharSink asCharSink(Charset charset)\n", "    public abstract OutputStream openStream() throws IOException;\n", "    public OutputStream openBufferedStream() throws IOException\n", "    public long writeFrom(InputStream input) throws IOException\n"], "context": "/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\n\n/**\n * A destination to which bytes can be written, such as a file. Unlike an {@link OutputStream}, a\n * {@code ByteSink} is not an open, stateful stream that can be written to and closed. Instead, it\n * is an immutable <i>supplier</i> of {@code OutputStream} instances.\n *\n * <p>{@code ByteSink} provides two kinds of methods:\n *\n * <ul>\n *   <li><b>Methods that return a stream:</b> These methods should return a <i>new</i>, independent\n *       instance each time they are called. The caller is responsible for ensuring that the\n *       returned stream is closed.\n *   <li><b>Convenience methods:</b> These are implementations of common operations that are\n *       typically implemented by opening a stream using one of the methods in the first category,\n *       doing something and finally closing the stream or channel that was opened.\n * </ul>\n *\n * @since 14.0\n * @author Colin Decker\n */\n@GwtIncompatible\npublic abstract class ByteSink\n{\n\n    /** Constructor for use by subclasses. */\n    protected ByteSink() {}\n\n    /**\n     * Returns a {@link CharSink} view of this {@code ByteSink} that writes characters to this sink as\n     * bytes encoded with the given {@link Charset charset}.\n     */\n    public CharSink asCharSink(Charset charset)\n    {\n        return new AsCharSink(charset);\n    }\n\n    /**\n     * Opens a new {@link OutputStream} for writing to this sink. This method returns a new,\n     * independent stream each time it is called.\n     *\n     * <p>The caller is responsible for ensuring that the returned stream is closed.\n     *\n     * @throws IOException if an I/O error occurs while opening the stream\n     */\n    public abstract OutputStream openStream() throws IOException;\n\n    /**\n     * Opens a new buffered {@link OutputStream} for writing to this sink. The returned stream is not\n     * required to be a {@link BufferedOutputStream} in order to allow implementations to simply\n     * delegate to {@link #openStream()} when the stream returned by that method does not benefit from\n     * additional buffering (for example, a {@code ByteArrayOutputStream}). This method returns a new,\n     * independent stream each time it is called.\n     *\n     * <p>The caller is responsible for ensuring that the returned stream is closed.\n     *\n     * @throws IOException if an I/O error occurs while opening the stream\n     * @since 15.0 (in 14.0 with return type {@link BufferedOutputStream})\n     */\n    public OutputStream openBufferedStream() throws IOException\n    {\n        OutputStream out = openStream();\n        return (out instanceof BufferedOutputStream)\n               ? (BufferedOutputStream) out\n               : new BufferedOutputStream(out);\n    }\n\n    /**\n     * Writes all the given bytes to this sink.\n     *\n     * @throws IOException if an I/O occurs while writing to this sink\n     */\n\n    /**\n     * Writes all the bytes from the given {@code InputStream} to this sink. Does not close {@code\n     * input}.\n     *\n     * @return the number of bytes written\n     * @throws IOException if an I/O occurs while reading from {@code input} or writing to this sink\n     */\n    @CanIgnoreReturnValue\n    public long writeFrom(InputStream input) throws IOException\n    {\n        checkNotNull(input);\n\n        Closer closer = Closer.create();\n        try\n        {\n            OutputStream out = closer.register(openStream());\n            long written = ByteStreams.copy(input, out);\n            out.flush(); // https://code.google.com/p/guava-libraries/issues/detail?id=1330\n            return written;\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * A char sink that encodes written characters with a charset and writes resulting bytes to this\n     * byte sink.\n     */\n    private final class AsCharSink extends CharSink\n    {\n\n        private final Charset charset;\n\n        private AsCharSink(Charset charset)\n        {\n            this.charset = checkNotNull(charset);\n        }\n\n        @Override\n        public Writer openStream() throws IOException\n        {\n            return new OutputStreamWriter(ByteSink.this.openStream(), charset);\n        }\n\n        @Override\n        public String toString()\n        {\n            return ByteSink.this.toString() + \".asCharSink(\" + charset + \")\";\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/cache/CacheBuilderSpec.java", "func_name": "CacheBuilderSpec.parse", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Creates a CacheBuilderSpec from a string.\n\n@param cacheBuilderSpecification the string form", "docstring_tokens": ["Creates", "a", "CacheBuilderSpec", "from", "a", "string", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/cache/CacheBuilderSpec.java#L136-L158", "partition": "valid", "up_fun_num": 2, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.annotations.VisibleForTesting;", "import com.google.common.base.MoreObjects;", "import com.google.common.base.Objects;", "import com.google.common.base.Splitter;", "import com.google.common.cache.LocalCache.Strength;", "import com.google.common.collect.ImmutableList;", "import com.google.common.collect.ImmutableMap;", "import java.util.List;", "import java.util.Locale;", "import java.util.concurrent.TimeUnit;", "import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class CacheBuilderSpec\n", "    public static CacheBuilderSpec disableCaching()\n", "    CacheBuilder<Object, Object> toCacheBuilder()\n", "    public String toParsableString()\n", "    public String toString()\n", "    public int hashCode()\n", "    public boolean equals(@NullableDecl Object obj)\n", "    private static Long durationInNanos(long duration, @NullableDecl TimeUnit unit)\n", "    private static String format(String format, Object... args)\n"], "context": "/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.cache;\n\nimport static com.google.common.base.Preconditions.checkArgument;\n\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Objects;\nimport com.google.common.base.Splitter;\nimport com.google.common.cache.LocalCache.Strength;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.concurrent.TimeUnit;\nimport org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A specification of a {@link CacheBuilder} configuration.\n *\n * <p>{@code CacheBuilderSpec} supports parsing configuration off of a string, which makes it\n * especially useful for command-line configuration of a {@code CacheBuilder}.\n *\n * <p>The string syntax is a series of comma-separated keys or key-value pairs, each corresponding\n * to a {@code CacheBuilder} method.\n *\n * <ul>\n *   <li>{@code concurrencyLevel=[integer]}: sets {@link CacheBuilder#concurrencyLevel}.\n *   <li>{@code initialCapacity=[integer]}: sets {@link CacheBuilder#initialCapacity}.\n *   <li>{@code maximumSize=[long]}: sets {@link CacheBuilder#maximumSize}.\n *   <li>{@code maximumWeight=[long]}: sets {@link CacheBuilder#maximumWeight}.\n *   <li>{@code expireAfterAccess=[duration]}: sets {@link CacheBuilder#expireAfterAccess}.\n *   <li>{@code expireAfterWrite=[duration]}: sets {@link CacheBuilder#expireAfterWrite}.\n *   <li>{@code refreshAfterWrite=[duration]}: sets {@link CacheBuilder#refreshAfterWrite}.\n *   <li>{@code weakKeys}: sets {@link CacheBuilder#weakKeys}.\n *   <li>{@code softValues}: sets {@link CacheBuilder#softValues}.\n *   <li>{@code weakValues}: sets {@link CacheBuilder#weakValues}.\n *   <li>{@code recordStats}: sets {@link CacheBuilder#recordStats}.\n * </ul>\n *\n * <p>The set of supported keys will grow as {@code CacheBuilder} evolves, but existing keys will\n * never be removed.\n *\n * <p>Durations are represented by an integer, followed by one of \"d\", \"h\", \"m\", or \"s\",\n * representing days, hours, minutes, or seconds respectively. (There is currently no syntax to\n * request expiration in milliseconds, microseconds, or nanoseconds.)\n *\n * <p>Whitespace before and after commas and equal signs is ignored. Keys may not be repeated; it is\n * also illegal to use the following pairs of keys in a single value:\n *\n * <ul>\n *   <li>{@code maximumSize} and {@code maximumWeight}\n *   <li>{@code softValues} and {@code weakValues}\n * </ul>\n *\n * <p>{@code CacheBuilderSpec} does not support configuring {@code CacheBuilder} methods with\n * non-value parameters. These must be configured in code.\n *\n * <p>A new {@code CacheBuilder} can be instantiated from a {@code CacheBuilderSpec} using {@link\n * CacheBuilder#from(CacheBuilderSpec)} or {@link CacheBuilder#from(String)}.\n *\n * @author Adam Winer\n * @since 12.0\n */\n@SuppressWarnings(\"GoodTime\") // lots of violations (nanosecond math)\n@GwtIncompatible\npublic final class CacheBuilderSpec\n{\n    /** Parses a single value. */\n    private interface ValueParser\n    {\n        void parse(CacheBuilderSpec spec, String key, @NullableDecl String value);\n    }\n\n    /** Splits each key-value pair. */\n    private static final Splitter KEYS_SPLITTER = Splitter.on(',').trimResults();\n\n    /** Splits the key from the value. */\n    private static final Splitter KEY_VALUE_SPLITTER = Splitter.on('=').trimResults();\n\n    /** Map of names to ValueParser. */\n    private static final ImmutableMap<String, ValueParser> VALUE_PARSERS =\n        ImmutableMap.<String, ValueParser>builder()\n        .put(\"initialCapacity\", new InitialCapacityParser())\n        .put(\"maximumSize\", new MaximumSizeParser())\n        .put(\"maximumWeight\", new MaximumWeightParser())\n        .put(\"concurrencyLevel\", new ConcurrencyLevelParser())\n        .put(\"weakKeys\", new KeyStrengthParser(Strength.WEAK))\n        .put(\"softValues\", new ValueStrengthParser(Strength.SOFT))\n        .put(\"weakValues\", new ValueStrengthParser(Strength.WEAK))\n        .put(\"recordStats\", new RecordStatsParser())\n        .put(\"expireAfterAccess\", new AccessDurationParser())\n        .put(\"expireAfterWrite\", new WriteDurationParser())\n        .put(\"refreshAfterWrite\", new RefreshDurationParser())\n        .put(\"refreshInterval\", new RefreshDurationParser())\n        .build();\n\n    @MonotonicNonNullDecl @VisibleForTesting Integer initialCapacity;\n    @MonotonicNonNullDecl @VisibleForTesting Long maximumSize;\n    @MonotonicNonNullDecl @VisibleForTesting Long maximumWeight;\n    @MonotonicNonNullDecl @VisibleForTesting Integer concurrencyLevel;\n    @MonotonicNonNullDecl @VisibleForTesting Strength keyStrength;\n    @MonotonicNonNullDecl @VisibleForTesting Strength valueStrength;\n    @MonotonicNonNullDecl @VisibleForTesting Boolean recordStats;\n    @VisibleForTesting long writeExpirationDuration;\n    @MonotonicNonNullDecl @VisibleForTesting TimeUnit writeExpirationTimeUnit;\n    @VisibleForTesting long accessExpirationDuration;\n    @MonotonicNonNullDecl @VisibleForTesting TimeUnit accessExpirationTimeUnit;\n    @VisibleForTesting long refreshDuration;\n    @MonotonicNonNullDecl @VisibleForTesting TimeUnit refreshTimeUnit;\n    /** Specification; used for toParseableString(). */\n    private final String specification;\n\n    private CacheBuilderSpec(String specification)\n    {\n        this.specification = specification;\n    }\n\n    /**\n     * Creates a CacheBuilderSpec from a string.\n     *\n     * @param cacheBuilderSpecification the string form\n     */\n\n    /** Returns a CacheBuilderSpec that will prevent caching. */\n    public static CacheBuilderSpec disableCaching()\n    {\n        // Maximum size of zero is one way to block caching\n        return CacheBuilderSpec.parse(\"maximumSize=0\");\n    }\n\n    /** Returns a CacheBuilder configured according to this instance's specification. */\n    CacheBuilder<Object, Object> toCacheBuilder()\n    {\n        CacheBuilder<Object, Object> builder = CacheBuilder.newBuilder();\n        if (initialCapacity != null)\n        {\n            builder.initialCapacity(initialCapacity);\n        }\n        if (maximumSize != null)\n        {\n            builder.maximumSize(maximumSize);\n        }\n        if (maximumWeight != null)\n        {\n            builder.maximumWeight(maximumWeight);\n        }\n        if (concurrencyLevel != null)\n        {\n            builder.concurrencyLevel(concurrencyLevel);\n        }\n        if (keyStrength != null)\n        {\n            switch (keyStrength)\n            {\n            case WEAK:\n                builder.weakKeys();\n                break;\n            default:\n                throw new AssertionError();\n            }\n        }\n        if (valueStrength != null)\n        {\n            switch (valueStrength)\n            {\n            case SOFT:\n                builder.softValues();\n                break;\n            case WEAK:\n                builder.weakValues();\n                break;\n            default:\n                throw new AssertionError();\n            }\n        }\n        if (recordStats != null && recordStats)\n        {\n            builder.recordStats();\n        }\n        if (writeExpirationTimeUnit != null)\n        {\n            builder.expireAfterWrite(writeExpirationDuration, writeExpirationTimeUnit);\n        }\n        if (accessExpirationTimeUnit != null)\n        {\n            builder.expireAfterAccess(accessExpirationDuration, accessExpirationTimeUnit);\n        }\n        if (refreshTimeUnit != null)\n        {\n            builder.refreshAfterWrite(refreshDuration, refreshTimeUnit);\n        }\n\n        return builder;\n    }\n\n    /**\n     * Returns a string that can be used to parse an equivalent {@code CacheBuilderSpec}. The order\n     * and form of this representation is not guaranteed, except that reparsing its output will\n     * produce a {@code CacheBuilderSpec} equal to this instance.\n     */\n    public String toParsableString()\n    {\n        return specification;\n    }\n\n    /**\n     * Returns a string representation for this CacheBuilderSpec instance. The form of this\n     * representation is not guaranteed.\n     */\n    @Override\n    public String toString()\n    {\n        return MoreObjects.toStringHelper(this).addValue(toParsableString()).toString();\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return Objects.hashCode(\n                   initialCapacity,\n                   maximumSize,\n                   maximumWeight,\n                   concurrencyLevel,\n                   keyStrength,\n                   valueStrength,\n                   recordStats,\n                   durationInNanos(writeExpirationDuration, writeExpirationTimeUnit),\n                   durationInNanos(accessExpirationDuration, accessExpirationTimeUnit),\n                   durationInNanos(refreshDuration, refreshTimeUnit));\n    }\n\n    @Override\n    public boolean equals(@NullableDecl Object obj)\n    {\n        if (this == obj)\n        {\n            return true;\n        }\n        if (!(obj instanceof CacheBuilderSpec))\n        {\n            return false;\n        }\n        CacheBuilderSpec that = (CacheBuilderSpec) obj;\n        return Objects.equal(initialCapacity, that.initialCapacity)\n               && Objects.equal(maximumSize, that.maximumSize)\n               && Objects.equal(maximumWeight, that.maximumWeight)\n               && Objects.equal(concurrencyLevel, that.concurrencyLevel)\n               && Objects.equal(keyStrength, that.keyStrength)\n               && Objects.equal(valueStrength, that.valueStrength)\n               && Objects.equal(recordStats, that.recordStats)\n               && Objects.equal(\n                   durationInNanos(writeExpirationDuration, writeExpirationTimeUnit),\n                   durationInNanos(that.writeExpirationDuration, that.writeExpirationTimeUnit))\n               && Objects.equal(\n                   durationInNanos(accessExpirationDuration, accessExpirationTimeUnit),\n                   durationInNanos(that.accessExpirationDuration, that.accessExpirationTimeUnit))\n               && Objects.equal(\n                   durationInNanos(refreshDuration, refreshTimeUnit),\n                   durationInNanos(that.refreshDuration, that.refreshTimeUnit));\n    }\n\n    /**\n     * Converts an expiration duration/unit pair into a single Long for hashing and equality. Uses\n     * nanos to match CacheBuilder implementation.\n     */\n    @NullableDecl\n    private static Long durationInNanos(long duration, @NullableDecl TimeUnit unit)\n    {\n        return (unit == null) ? null : unit.toNanos(duration);\n    }\n\n    /** Base class for parsing integers. */\n    abstract static class IntegerParser implements ValueParser\n    {\n        protected abstract void parseInteger(CacheBuilderSpec spec, int value);\n\n        @Override\n        public void parse(CacheBuilderSpec spec, String key, String value)\n        {\n            checkArgument(value != null && !value.isEmpty(), \"value of key %s omitted\", key);\n            try\n            {\n                parseInteger(spec, Integer.parseInt(value));\n            }\n            catch (NumberFormatException e)\n            {\n                throw new IllegalArgumentException(\n                    format(\"key %s value set to %s, must be integer\", key, value), e);\n            }\n        }\n    }\n\n    /** Base class for parsing integers. */\n    abstract static class LongParser implements ValueParser\n    {\n        protected abstract void parseLong(CacheBuilderSpec spec, long value);\n\n        @Override\n        public void parse(CacheBuilderSpec spec, String key, String value)\n        {\n            checkArgument(value != null && !value.isEmpty(), \"value of key %s omitted\", key);\n            try\n            {\n                parseLong(spec, Long.parseLong(value));\n            }\n            catch (NumberFormatException e)\n            {\n                throw new IllegalArgumentException(\n                    format(\"key %s value set to %s, must be integer\", key, value), e);\n            }\n        }\n    }\n\n    /** Parse initialCapacity */\n    static class InitialCapacityParser extends IntegerParser\n    {\n        @Override\n        protected void parseInteger(CacheBuilderSpec spec, int value)\n        {\n            checkArgument(\n                spec.initialCapacity == null,\n                \"initial capacity was already set to \",\n                spec.initialCapacity);\n            spec.initialCapacity = value;\n        }\n    }\n\n    /** Parse maximumSize */\n    static class MaximumSizeParser extends LongParser\n    {\n        @Override\n        protected void parseLong(CacheBuilderSpec spec, long value)\n        {\n            checkArgument(spec.maximumSize == null, \"maximum size was already set to \", spec.maximumSize);\n            checkArgument(\n                spec.maximumWeight == null, \"maximum weight was already set to \", spec.maximumWeight);\n            spec.maximumSize = value;\n        }\n    }\n\n    /** Parse maximumWeight */\n    static class MaximumWeightParser extends LongParser\n    {\n        @Override\n        protected void parseLong(CacheBuilderSpec spec, long value)\n        {\n            checkArgument(\n                spec.maximumWeight == null, \"maximum weight was already set to \", spec.maximumWeight);\n            checkArgument(spec.maximumSize == null, \"maximum size was already set to \", spec.maximumSize);\n            spec.maximumWeight = value;\n        }\n    }\n\n    /** Parse concurrencyLevel */\n    static class ConcurrencyLevelParser extends IntegerParser\n    {\n        @Override\n        protected void parseInteger(CacheBuilderSpec spec, int value)\n        {\n            checkArgument(\n                spec.concurrencyLevel == null,\n                \"concurrency level was already set to \",\n                spec.concurrencyLevel);\n            spec.concurrencyLevel = value;\n        }\n    }\n\n    /** Parse weakKeys */\n    static class KeyStrengthParser implements ValueParser\n    {\n        private final Strength strength;\n\n        public KeyStrengthParser(Strength strength)\n        {\n            this.strength = strength;\n        }\n\n        @Override\n        public void parse(CacheBuilderSpec spec, String key, @NullableDecl String value)\n        {\n            checkArgument(value == null, \"key %s does not take values\", key);\n            checkArgument(spec.keyStrength == null, \"%s was already set to %s\", key, spec.keyStrength);\n            spec.keyStrength = strength;\n        }\n    }\n\n    /** Parse weakValues and softValues */\n    static class ValueStrengthParser implements ValueParser\n    {\n        private final Strength strength;\n\n        public ValueStrengthParser(Strength strength)\n        {\n            this.strength = strength;\n        }\n\n        @Override\n        public void parse(CacheBuilderSpec spec, String key, @NullableDecl String value)\n        {\n            checkArgument(value == null, \"key %s does not take values\", key);\n            checkArgument(\n                spec.valueStrength == null, \"%s was already set to %s\", key, spec.valueStrength);\n\n            spec.valueStrength = strength;\n        }\n    }\n\n    /** Parse recordStats */\n    static class RecordStatsParser implements ValueParser\n    {\n\n        @Override\n        public void parse(CacheBuilderSpec spec, String key, @NullableDecl String value)\n        {\n            checkArgument(value == null, \"recordStats does not take values\");\n            checkArgument(spec.recordStats == null, \"recordStats already set\");\n            spec.recordStats = true;\n        }\n    }\n\n    /** Base class for parsing times with durations */\n    abstract static class DurationParser implements ValueParser\n    {\n        protected abstract void parseDuration(CacheBuilderSpec spec, long duration, TimeUnit unit);\n\n        @Override\n        public void parse(CacheBuilderSpec spec, String key, String value)\n        {\n            checkArgument(value != null && !value.isEmpty(), \"value of key %s omitted\", key);\n            try\n            {\n                char lastChar = value.charAt(value.length() - 1);\n                TimeUnit timeUnit;\n                switch (lastChar)\n                {\n                case 'd':\n                    timeUnit = TimeUnit.DAYS;\n                    break;\n                case 'h':\n                    timeUnit = TimeUnit.HOURS;\n                    break;\n                case 'm':\n                    timeUnit = TimeUnit.MINUTES;\n                    break;\n                case 's':\n                    timeUnit = TimeUnit.SECONDS;\n                    break;\n                default:\n                    throw new IllegalArgumentException(\n                        format(\n                            \"key %s invalid format.  was %s, must end with one of [dDhHmMsS]\", key, value));\n                }\n\n                long duration = Long.parseLong(value.substring(0, value.length() - 1));\n                parseDuration(spec, duration, timeUnit);\n            }\n            catch (NumberFormatException e)\n            {\n                throw new IllegalArgumentException(\n                    format(\"key %s value set to %s, must be integer\", key, value));\n            }\n        }\n    }\n\n    /** Parse expireAfterAccess */\n    static class AccessDurationParser extends DurationParser\n    {\n        @Override\n        protected void parseDuration(CacheBuilderSpec spec, long duration, TimeUnit unit)\n        {\n            checkArgument(spec.accessExpirationTimeUnit == null, \"expireAfterAccess already set\");\n            spec.accessExpirationDuration = duration;\n            spec.accessExpirationTimeUnit = unit;\n        }\n    }\n\n    /** Parse expireAfterWrite */\n    static class WriteDurationParser extends DurationParser\n    {\n        @Override\n        protected void parseDuration(CacheBuilderSpec spec, long duration, TimeUnit unit)\n        {\n            checkArgument(spec.writeExpirationTimeUnit == null, \"expireAfterWrite already set\");\n            spec.writeExpirationDuration = duration;\n            spec.writeExpirationTimeUnit = unit;\n        }\n    }\n\n    /** Parse refreshAfterWrite */\n    static class RefreshDurationParser extends DurationParser\n    {\n        @Override\n        protected void parseDuration(CacheBuilderSpec spec, long duration, TimeUnit unit)\n        {\n            checkArgument(spec.refreshTimeUnit == null, \"refreshAfterWrite already set\");\n            spec.refreshDuration = duration;\n            spec.refreshTimeUnit = unit;\n        }\n    }\n\n    private static String format(String format, Object... args)\n    {\n        return String.format(Locale.ROOT, format, args);\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/cache/CacheBuilderSpec.java", "func_name": "CacheBuilderSpec.toCacheBuilder", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns a CacheBuilder configured according to this instance's specification.", "docstring_tokens": ["Returns", "a", "CacheBuilder", "configured", "according", "to", "this", "instance", "s", "specification", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/cache/CacheBuilderSpec.java#L167-L216", "partition": "valid", "up_fun_num": 4, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.annotations.VisibleForTesting;", "import com.google.common.base.MoreObjects;", "import com.google.common.base.Objects;", "import com.google.common.base.Splitter;", "import com.google.common.cache.LocalCache.Strength;", "import com.google.common.collect.ImmutableList;", "import com.google.common.collect.ImmutableMap;", "import java.util.List;", "import java.util.Locale;", "import java.util.concurrent.TimeUnit;", "import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class CacheBuilderSpec\n", "    public static CacheBuilderSpec parse(String cacheBuilderSpecification)\n", "    public static CacheBuilderSpec disableCaching()\n", "    public String toParsableString()\n", "    public String toString()\n", "    public int hashCode()\n", "    public boolean equals(@NullableDecl Object obj)\n", "    private static Long durationInNanos(long duration, @NullableDecl TimeUnit unit)\n", "    private static String format(String format, Object... args)\n"], "context": "/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.cache;\n\nimport static com.google.common.base.Preconditions.checkArgument;\n\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Objects;\nimport com.google.common.base.Splitter;\nimport com.google.common.cache.LocalCache.Strength;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.concurrent.TimeUnit;\nimport org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A specification of a {@link CacheBuilder} configuration.\n *\n * <p>{@code CacheBuilderSpec} supports parsing configuration off of a string, which makes it\n * especially useful for command-line configuration of a {@code CacheBuilder}.\n *\n * <p>The string syntax is a series of comma-separated keys or key-value pairs, each corresponding\n * to a {@code CacheBuilder} method.\n *\n * <ul>\n *   <li>{@code concurrencyLevel=[integer]}: sets {@link CacheBuilder#concurrencyLevel}.\n *   <li>{@code initialCapacity=[integer]}: sets {@link CacheBuilder#initialCapacity}.\n *   <li>{@code maximumSize=[long]}: sets {@link CacheBuilder#maximumSize}.\n *   <li>{@code maximumWeight=[long]}: sets {@link CacheBuilder#maximumWeight}.\n *   <li>{@code expireAfterAccess=[duration]}: sets {@link CacheBuilder#expireAfterAccess}.\n *   <li>{@code expireAfterWrite=[duration]}: sets {@link CacheBuilder#expireAfterWrite}.\n *   <li>{@code refreshAfterWrite=[duration]}: sets {@link CacheBuilder#refreshAfterWrite}.\n *   <li>{@code weakKeys}: sets {@link CacheBuilder#weakKeys}.\n *   <li>{@code softValues}: sets {@link CacheBuilder#softValues}.\n *   <li>{@code weakValues}: sets {@link CacheBuilder#weakValues}.\n *   <li>{@code recordStats}: sets {@link CacheBuilder#recordStats}.\n * </ul>\n *\n * <p>The set of supported keys will grow as {@code CacheBuilder} evolves, but existing keys will\n * never be removed.\n *\n * <p>Durations are represented by an integer, followed by one of \"d\", \"h\", \"m\", or \"s\",\n * representing days, hours, minutes, or seconds respectively. (There is currently no syntax to\n * request expiration in milliseconds, microseconds, or nanoseconds.)\n *\n * <p>Whitespace before and after commas and equal signs is ignored. Keys may not be repeated; it is\n * also illegal to use the following pairs of keys in a single value:\n *\n * <ul>\n *   <li>{@code maximumSize} and {@code maximumWeight}\n *   <li>{@code softValues} and {@code weakValues}\n * </ul>\n *\n * <p>{@code CacheBuilderSpec} does not support configuring {@code CacheBuilder} methods with\n * non-value parameters. These must be configured in code.\n *\n * <p>A new {@code CacheBuilder} can be instantiated from a {@code CacheBuilderSpec} using {@link\n * CacheBuilder#from(CacheBuilderSpec)} or {@link CacheBuilder#from(String)}.\n *\n * @author Adam Winer\n * @since 12.0\n */\n@SuppressWarnings(\"GoodTime\") // lots of violations (nanosecond math)\n@GwtIncompatible\npublic final class CacheBuilderSpec\n{\n    /** Parses a single value. */\n    private interface ValueParser\n    {\n        void parse(CacheBuilderSpec spec, String key, @NullableDecl String value);\n    }\n\n    /** Splits each key-value pair. */\n    private static final Splitter KEYS_SPLITTER = Splitter.on(',').trimResults();\n\n    /** Splits the key from the value. */\n    private static final Splitter KEY_VALUE_SPLITTER = Splitter.on('=').trimResults();\n\n    /** Map of names to ValueParser. */\n    private static final ImmutableMap<String, ValueParser> VALUE_PARSERS =\n        ImmutableMap.<String, ValueParser>builder()\n        .put(\"initialCapacity\", new InitialCapacityParser())\n        .put(\"maximumSize\", new MaximumSizeParser())\n        .put(\"maximumWeight\", new MaximumWeightParser())\n        .put(\"concurrencyLevel\", new ConcurrencyLevelParser())\n        .put(\"weakKeys\", new KeyStrengthParser(Strength.WEAK))\n        .put(\"softValues\", new ValueStrengthParser(Strength.SOFT))\n        .put(\"weakValues\", new ValueStrengthParser(Strength.WEAK))\n        .put(\"recordStats\", new RecordStatsParser())\n        .put(\"expireAfterAccess\", new AccessDurationParser())\n        .put(\"expireAfterWrite\", new WriteDurationParser())\n        .put(\"refreshAfterWrite\", new RefreshDurationParser())\n        .put(\"refreshInterval\", new RefreshDurationParser())\n        .build();\n\n    @MonotonicNonNullDecl @VisibleForTesting Integer initialCapacity;\n    @MonotonicNonNullDecl @VisibleForTesting Long maximumSize;\n    @MonotonicNonNullDecl @VisibleForTesting Long maximumWeight;\n    @MonotonicNonNullDecl @VisibleForTesting Integer concurrencyLevel;\n    @MonotonicNonNullDecl @VisibleForTesting Strength keyStrength;\n    @MonotonicNonNullDecl @VisibleForTesting Strength valueStrength;\n    @MonotonicNonNullDecl @VisibleForTesting Boolean recordStats;\n    @VisibleForTesting long writeExpirationDuration;\n    @MonotonicNonNullDecl @VisibleForTesting TimeUnit writeExpirationTimeUnit;\n    @VisibleForTesting long accessExpirationDuration;\n    @MonotonicNonNullDecl @VisibleForTesting TimeUnit accessExpirationTimeUnit;\n    @VisibleForTesting long refreshDuration;\n    @MonotonicNonNullDecl @VisibleForTesting TimeUnit refreshTimeUnit;\n    /** Specification; used for toParseableString(). */\n    private final String specification;\n\n    private CacheBuilderSpec(String specification)\n    {\n        this.specification = specification;\n    }\n\n    /**\n     * Creates a CacheBuilderSpec from a string.\n     *\n     * @param cacheBuilderSpecification the string form\n     */\n    public static CacheBuilderSpec parse(String cacheBuilderSpecification)\n    {\n        CacheBuilderSpec spec = new CacheBuilderSpec(cacheBuilderSpecification);\n        if (!cacheBuilderSpecification.isEmpty())\n        {\n            for (String keyValuePair : KEYS_SPLITTER.split(cacheBuilderSpecification))\n            {\n                List<String> keyAndValue = ImmutableList.copyOf(KEY_VALUE_SPLITTER.split(keyValuePair));\n                checkArgument(!keyAndValue.isEmpty(), \"blank key-value pair\");\n                checkArgument(\n                    keyAndValue.size() <= 2,\n                    \"key-value pair %s with more than one equals sign\",\n                    keyValuePair);\n\n                // Find the ValueParser for the current key.\n                String key = keyAndValue.get(0);\n                ValueParser valueParser = VALUE_PARSERS.get(key);\n                checkArgument(valueParser != null, \"unknown key %s\", key);\n\n                String value = keyAndValue.size() == 1 ? null : keyAndValue.get(1);\n                valueParser.parse(spec, key, value);\n            }\n        }\n\n        return spec;\n    }\n\n    /** Returns a CacheBuilderSpec that will prevent caching. */\n    public static CacheBuilderSpec disableCaching()\n    {\n        // Maximum size of zero is one way to block caching\n        return CacheBuilderSpec.parse(\"maximumSize=0\");\n    }\n\n    /** Returns a CacheBuilder configured according to this instance's specification. */\n\n    /**\n     * Returns a string that can be used to parse an equivalent {@code CacheBuilderSpec}. The order\n     * and form of this representation is not guaranteed, except that reparsing its output will\n     * produce a {@code CacheBuilderSpec} equal to this instance.\n     */\n    public String toParsableString()\n    {\n        return specification;\n    }\n\n    /**\n     * Returns a string representation for this CacheBuilderSpec instance. The form of this\n     * representation is not guaranteed.\n     */\n    @Override\n    public String toString()\n    {\n        return MoreObjects.toStringHelper(this).addValue(toParsableString()).toString();\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return Objects.hashCode(\n                   initialCapacity,\n                   maximumSize,\n                   maximumWeight,\n                   concurrencyLevel,\n                   keyStrength,\n                   valueStrength,\n                   recordStats,\n                   durationInNanos(writeExpirationDuration, writeExpirationTimeUnit),\n                   durationInNanos(accessExpirationDuration, accessExpirationTimeUnit),\n                   durationInNanos(refreshDuration, refreshTimeUnit));\n    }\n\n    @Override\n    public boolean equals(@NullableDecl Object obj)\n    {\n        if (this == obj)\n        {\n            return true;\n        }\n        if (!(obj instanceof CacheBuilderSpec))\n        {\n            return false;\n        }\n        CacheBuilderSpec that = (CacheBuilderSpec) obj;\n        return Objects.equal(initialCapacity, that.initialCapacity)\n               && Objects.equal(maximumSize, that.maximumSize)\n               && Objects.equal(maximumWeight, that.maximumWeight)\n               && Objects.equal(concurrencyLevel, that.concurrencyLevel)\n               && Objects.equal(keyStrength, that.keyStrength)\n               && Objects.equal(valueStrength, that.valueStrength)\n               && Objects.equal(recordStats, that.recordStats)\n               && Objects.equal(\n                   durationInNanos(writeExpirationDuration, writeExpirationTimeUnit),\n                   durationInNanos(that.writeExpirationDuration, that.writeExpirationTimeUnit))\n               && Objects.equal(\n                   durationInNanos(accessExpirationDuration, accessExpirationTimeUnit),\n                   durationInNanos(that.accessExpirationDuration, that.accessExpirationTimeUnit))\n               && Objects.equal(\n                   durationInNanos(refreshDuration, refreshTimeUnit),\n                   durationInNanos(that.refreshDuration, that.refreshTimeUnit));\n    }\n\n    /**\n     * Converts an expiration duration/unit pair into a single Long for hashing and equality. Uses\n     * nanos to match CacheBuilder implementation.\n     */\n    @NullableDecl\n    private static Long durationInNanos(long duration, @NullableDecl TimeUnit unit)\n    {\n        return (unit == null) ? null : unit.toNanos(duration);\n    }\n\n    /** Base class for parsing integers. */\n    abstract static class IntegerParser implements ValueParser\n    {\n        protected abstract void parseInteger(CacheBuilderSpec spec, int value);\n\n        @Override\n        public void parse(CacheBuilderSpec spec, String key, String value)\n        {\n            checkArgument(value != null && !value.isEmpty(), \"value of key %s omitted\", key);\n            try\n            {\n                parseInteger(spec, Integer.parseInt(value));\n            }\n            catch (NumberFormatException e)\n            {\n                throw new IllegalArgumentException(\n                    format(\"key %s value set to %s, must be integer\", key, value), e);\n            }\n        }\n    }\n\n    /** Base class for parsing integers. */\n    abstract static class LongParser implements ValueParser\n    {\n        protected abstract void parseLong(CacheBuilderSpec spec, long value);\n\n        @Override\n        public void parse(CacheBuilderSpec spec, String key, String value)\n        {\n            checkArgument(value != null && !value.isEmpty(), \"value of key %s omitted\", key);\n            try\n            {\n                parseLong(spec, Long.parseLong(value));\n            }\n            catch (NumberFormatException e)\n            {\n                throw new IllegalArgumentException(\n                    format(\"key %s value set to %s, must be integer\", key, value), e);\n            }\n        }\n    }\n\n    /** Parse initialCapacity */\n    static class InitialCapacityParser extends IntegerParser\n    {\n        @Override\n        protected void parseInteger(CacheBuilderSpec spec, int value)\n        {\n            checkArgument(\n                spec.initialCapacity == null,\n                \"initial capacity was already set to \",\n                spec.initialCapacity);\n            spec.initialCapacity = value;\n        }\n    }\n\n    /** Parse maximumSize */\n    static class MaximumSizeParser extends LongParser\n    {\n        @Override\n        protected void parseLong(CacheBuilderSpec spec, long value)\n        {\n            checkArgument(spec.maximumSize == null, \"maximum size was already set to \", spec.maximumSize);\n            checkArgument(\n                spec.maximumWeight == null, \"maximum weight was already set to \", spec.maximumWeight);\n            spec.maximumSize = value;\n        }\n    }\n\n    /** Parse maximumWeight */\n    static class MaximumWeightParser extends LongParser\n    {\n        @Override\n        protected void parseLong(CacheBuilderSpec spec, long value)\n        {\n            checkArgument(\n                spec.maximumWeight == null, \"maximum weight was already set to \", spec.maximumWeight);\n            checkArgument(spec.maximumSize == null, \"maximum size was already set to \", spec.maximumSize);\n            spec.maximumWeight = value;\n        }\n    }\n\n    /** Parse concurrencyLevel */\n    static class ConcurrencyLevelParser extends IntegerParser\n    {\n        @Override\n        protected void parseInteger(CacheBuilderSpec spec, int value)\n        {\n            checkArgument(\n                spec.concurrencyLevel == null,\n                \"concurrency level was already set to \",\n                spec.concurrencyLevel);\n            spec.concurrencyLevel = value;\n        }\n    }\n\n    /** Parse weakKeys */\n    static class KeyStrengthParser implements ValueParser\n    {\n        private final Strength strength;\n\n        public KeyStrengthParser(Strength strength)\n        {\n            this.strength = strength;\n        }\n\n        @Override\n        public void parse(CacheBuilderSpec spec, String key, @NullableDecl String value)\n        {\n            checkArgument(value == null, \"key %s does not take values\", key);\n            checkArgument(spec.keyStrength == null, \"%s was already set to %s\", key, spec.keyStrength);\n            spec.keyStrength = strength;\n        }\n    }\n\n    /** Parse weakValues and softValues */\n    static class ValueStrengthParser implements ValueParser\n    {\n        private final Strength strength;\n\n        public ValueStrengthParser(Strength strength)\n        {\n            this.strength = strength;\n        }\n\n        @Override\n        public void parse(CacheBuilderSpec spec, String key, @NullableDecl String value)\n        {\n            checkArgument(value == null, \"key %s does not take values\", key);\n            checkArgument(\n                spec.valueStrength == null, \"%s was already set to %s\", key, spec.valueStrength);\n\n            spec.valueStrength = strength;\n        }\n    }\n\n    /** Parse recordStats */\n    static class RecordStatsParser implements ValueParser\n    {\n\n        @Override\n        public void parse(CacheBuilderSpec spec, String key, @NullableDecl String value)\n        {\n            checkArgument(value == null, \"recordStats does not take values\");\n            checkArgument(spec.recordStats == null, \"recordStats already set\");\n            spec.recordStats = true;\n        }\n    }\n\n    /** Base class for parsing times with durations */\n    abstract static class DurationParser implements ValueParser\n    {\n        protected abstract void parseDuration(CacheBuilderSpec spec, long duration, TimeUnit unit);\n\n        @Override\n        public void parse(CacheBuilderSpec spec, String key, String value)\n        {\n            checkArgument(value != null && !value.isEmpty(), \"value of key %s omitted\", key);\n            try\n            {\n                char lastChar = value.charAt(value.length() - 1);\n                TimeUnit timeUnit;\n                switch (lastChar)\n                {\n                case 'd':\n                    timeUnit = TimeUnit.DAYS;\n                    break;\n                case 'h':\n                    timeUnit = TimeUnit.HOURS;\n                    break;\n                case 'm':\n                    timeUnit = TimeUnit.MINUTES;\n                    break;\n                case 's':\n                    timeUnit = TimeUnit.SECONDS;\n                    break;\n                default:\n                    throw new IllegalArgumentException(\n                        format(\n                            \"key %s invalid format.  was %s, must end with one of [dDhHmMsS]\", key, value));\n                }\n\n                long duration = Long.parseLong(value.substring(0, value.length() - 1));\n                parseDuration(spec, duration, timeUnit);\n            }\n            catch (NumberFormatException e)\n            {\n                throw new IllegalArgumentException(\n                    format(\"key %s value set to %s, must be integer\", key, value));\n            }\n        }\n    }\n\n    /** Parse expireAfterAccess */\n    static class AccessDurationParser extends DurationParser\n    {\n        @Override\n        protected void parseDuration(CacheBuilderSpec spec, long duration, TimeUnit unit)\n        {\n            checkArgument(spec.accessExpirationTimeUnit == null, \"expireAfterAccess already set\");\n            spec.accessExpirationDuration = duration;\n            spec.accessExpirationTimeUnit = unit;\n        }\n    }\n\n    /** Parse expireAfterWrite */\n    static class WriteDurationParser extends DurationParser\n    {\n        @Override\n        protected void parseDuration(CacheBuilderSpec spec, long duration, TimeUnit unit)\n        {\n            checkArgument(spec.writeExpirationTimeUnit == null, \"expireAfterWrite already set\");\n            spec.writeExpirationDuration = duration;\n            spec.writeExpirationTimeUnit = unit;\n        }\n    }\n\n    /** Parse refreshAfterWrite */\n    static class RefreshDurationParser extends DurationParser\n    {\n        @Override\n        protected void parseDuration(CacheBuilderSpec spec, long duration, TimeUnit unit)\n        {\n            checkArgument(spec.refreshTimeUnit == null, \"refreshAfterWrite already set\");\n            spec.refreshDuration = duration;\n            spec.refreshTimeUnit = unit;\n        }\n    }\n\n    private static String format(String format, Object... args)\n    {\n        return String.format(Locale.ROOT, format, args);\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/base/Joiner.java", "func_name": "Joiner.skipNulls", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns a joiner with the same behavior as this joiner, except automatically skipping over any\nprovided null elements.", "docstring_tokens": ["Returns", "a", "joiner", "with", "the", "same", "behavior", "as", "this", "joiner", "except", "automatically", "skipping", "over", "any", "provided", "null", "elements", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/base/Joiner.java#L242-L275", "partition": "valid", "up_fun_num": 17, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.io.IOException;", "import java.util.AbstractList;", "import java.util.Arrays;", "import java.util.Iterator;", "import java.util.Map;", "import java.util.Map.Entry;", "import org.checkerframework.checker.nullness.qual.Nullable;"], "function": ["public class Joiner\n", "    public static Joiner on(String separator)\n", "    public static Joiner on(char separator)\n", "    public <A extends Appendable> A appendTo(A appendable, Iterable<?> parts) throws IOException\n", "    public <A extends Appendable> A appendTo(A appendable, Iterator<?> parts) throws IOException\n", "    public final <A extends Appendable> A appendTo(A appendable, Object[] parts) throws IOException\n", "    public final <A extends Appendable> A appendTo(\n", "    public final StringBuilder appendTo(StringBuilder builder, Iterable<?> parts)\n", "    public final StringBuilder appendTo(StringBuilder builder, Iterator<?> parts)\n", "    public final StringBuilder appendTo(StringBuilder builder, Object[] parts)\n", "    public final StringBuilder appendTo(\n", "    public final String join(Iterable<?> parts)\n", "    public final String join(Iterator<?> parts)\n", "    public final String join(Object[] parts)\n", "    public final String join(@Nullable Object first, @Nullable Object second, Object... rest)\n", "    public Joiner useForNull(final String nullText)\n", "    public MapJoiner withKeyValueSeparator(char keyValueSeparator)\n", "    public MapJoiner withKeyValueSeparator(String keyValueSeparator)\n", "    CharSequence toString(Object part)\n", "    private static Iterable<Object> iterable(\n"], "context": "/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.base;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.IOException;\nimport java.util.AbstractList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\n/**\n * An object which joins pieces of text (specified as an array, {@link Iterable}, varargs or even a\n * {@link Map}) with a separator. It either appends the results to an {@link Appendable} or returns\n * them as a {@link String}. Example:\n *\n * <pre>{@code\n * Joiner joiner = Joiner.on(\"; \").skipNulls();\n *  . . .\n * return joiner.join(\"Harry\", null, \"Ron\", \"Hermione\");\n * }</pre>\n *\n * <p>This returns the string {@code \"Harry; Ron; Hermione\"}. Note that all input elements are\n * converted to strings using {@link Object#toString()} before being appended.\n *\n * <p>If neither {@link #skipNulls()} nor {@link #useForNull(String)} is specified, the joining\n * methods will throw {@link NullPointerException} if any given element is null.\n *\n * <p><b>Warning: joiner instances are always immutable</b>; a configuration method such as {@code\n * useForNull} has no effect on the instance it is invoked on! You must store and use the new joiner\n * instance returned by the method. This makes joiners thread-safe, and safe to store as {@code\n * static final} constants.\n *\n * <pre>{@code\n * // Bad! Do not do this!\n * Joiner joiner = Joiner.on(',');\n * joiner.skipNulls(); // does nothing!\n * return joiner.join(\"wrong\", null, \"wrong\");\n * }</pre>\n *\n * <p>See the Guava User Guide article on <a\n * href=\"https://github.com/google/guava/wiki/StringsExplained#joiner\">{@code Joiner}</a>.\n *\n * @author Kevin Bourrillion\n * @since 2.0\n */\n@GwtCompatible\npublic class Joiner\n{\n    /** Returns a joiner which automatically places {@code separator} between consecutive elements. */\n    public static Joiner on(String separator)\n    {\n        return new Joiner(separator);\n    }\n\n    /** Returns a joiner which automatically places {@code separator} between consecutive elements. */\n    public static Joiner on(char separator)\n    {\n        return new Joiner(String.valueOf(separator));\n    }\n\n    private final String separator;\n\n    private Joiner(String separator)\n    {\n        this.separator = checkNotNull(separator);\n    }\n\n    private Joiner(Joiner prototype)\n    {\n        this.separator = prototype.separator;\n    }\n\n    /**\n     * Appends the string representation of each of {@code parts}, using the previously configured\n     * separator between each, to {@code appendable}.\n     */\n    @CanIgnoreReturnValue\n    public <A extends Appendable> A appendTo(A appendable, Iterable<?> parts) throws IOException\n    {\n        return appendTo(appendable, parts.iterator());\n    }\n\n    /**\n     * Appends the string representation of each of {@code parts}, using the previously configured\n     * separator between each, to {@code appendable}.\n     *\n     * @since 11.0\n     */\n    @CanIgnoreReturnValue\n    public <A extends Appendable> A appendTo(A appendable, Iterator<?> parts) throws IOException\n    {\n        checkNotNull(appendable);\n        if (parts.hasNext())\n        {\n            appendable.append(toString(parts.next()));\n            while (parts.hasNext())\n            {\n                appendable.append(separator);\n                appendable.append(toString(parts.next()));\n            }\n        }\n        return appendable;\n    }\n\n    /**\n     * Appends the string representation of each of {@code parts}, using the previously configured\n     * separator between each, to {@code appendable}.\n     */\n    @CanIgnoreReturnValue\n    public final <A extends Appendable> A appendTo(A appendable, Object[] parts) throws IOException\n    {\n        return appendTo(appendable, Arrays.asList(parts));\n    }\n\n    /** Appends to {@code appendable} the string representation of each of the remaining arguments. */\n    @CanIgnoreReturnValue\n    public final <A extends Appendable> A appendTo(\n        A appendable, @Nullable Object first, @Nullable Object second, Object... rest)\n    throws IOException\n    {\n        return appendTo(appendable, iterable(first, second, rest));\n    }\n\n    /**\n     * Appends the string representation of each of {@code parts}, using the previously configured\n     * separator between each, to {@code builder}. Identical to {@link #appendTo(Appendable,\n     * Iterable)}, except that it does not throw {@link IOException}.\n     */\n    @CanIgnoreReturnValue\n    public final StringBuilder appendTo(StringBuilder builder, Iterable<?> parts)\n    {\n        return appendTo(builder, parts.iterator());\n    }\n\n    /**\n     * Appends the string representation of each of {@code parts}, using the previously configured\n     * separator between each, to {@code builder}. Identical to {@link #appendTo(Appendable,\n     * Iterable)}, except that it does not throw {@link IOException}.\n     *\n     * @since 11.0\n     */\n    @CanIgnoreReturnValue\n    public final StringBuilder appendTo(StringBuilder builder, Iterator<?> parts)\n    {\n        try\n        {\n            appendTo((Appendable) builder, parts);\n        }\n        catch (IOException impossible)\n        {\n            throw new AssertionError(impossible);\n        }\n        return builder;\n    }\n\n    /**\n     * Appends the string representation of each of {@code parts}, using the previously configured\n     * separator between each, to {@code builder}. Identical to {@link #appendTo(Appendable,\n     * Iterable)}, except that it does not throw {@link IOException}.\n     */\n    @CanIgnoreReturnValue\n    public final StringBuilder appendTo(StringBuilder builder, Object[] parts)\n    {\n        return appendTo(builder, Arrays.asList(parts));\n    }\n\n    /**\n     * Appends to {@code builder} the string representation of each of the remaining arguments.\n     * Identical to {@link #appendTo(Appendable, Object, Object, Object...)}, except that it does not\n     * throw {@link IOException}.\n     */\n    @CanIgnoreReturnValue\n    public final StringBuilder appendTo(\n        StringBuilder builder, @Nullable Object first, @Nullable Object second, Object... rest)\n    {\n        return appendTo(builder, iterable(first, second, rest));\n    }\n\n    /**\n     * Returns a string containing the string representation of each of {@code parts}, using the\n     * previously configured separator between each.\n     */\n    public final String join(Iterable<?> parts)\n    {\n        return join(parts.iterator());\n    }\n\n    /**\n     * Returns a string containing the string representation of each of {@code parts}, using the\n     * previously configured separator between each.\n     *\n     * @since 11.0\n     */\n    public final String join(Iterator<?> parts)\n    {\n        return appendTo(new StringBuilder(), parts).toString();\n    }\n\n    /**\n     * Returns a string containing the string representation of each of {@code parts}, using the\n     * previously configured separator between each.\n     */\n    public final String join(Object[] parts)\n    {\n        return join(Arrays.asList(parts));\n    }\n\n    /**\n     * Returns a string containing the string representation of each argument, using the previously\n     * configured separator between each.\n     */\n    public final String join(@Nullable Object first, @Nullable Object second, Object... rest)\n    {\n        return join(iterable(first, second, rest));\n    }\n\n    /**\n     * Returns a joiner with the same behavior as this one, except automatically substituting {@code\n     * nullText} for any provided null elements.\n     */\n    public Joiner useForNull(final String nullText)\n    {\n        checkNotNull(nullText);\n        return new Joiner(this)\n        {\n            @Override\n            CharSequence toString(@Nullable Object part)\n            {\n                return (part == null) ? nullText : Joiner.this.toString(part);\n            }\n\n            @Override\n            public Joiner useForNull(String nullText)\n            {\n                throw new UnsupportedOperationException(\"already specified useForNull\");\n            }\n\n            @Override\n            public Joiner skipNulls()\n            {\n                throw new UnsupportedOperationException(\"already specified useForNull\");\n            }\n        };\n    }\n\n    /**\n     * Returns a joiner with the same behavior as this joiner, except automatically skipping over any\n     * provided null elements.\n     */\n\n    /**\n     * Returns a {@code MapJoiner} using the given key-value separator, and the same configuration as\n     * this {@code Joiner} otherwise.\n     *\n     * @since 20.0\n     */\n    public MapJoiner withKeyValueSeparator(char keyValueSeparator)\n    {\n        return withKeyValueSeparator(String.valueOf(keyValueSeparator));\n    }\n\n    /**\n     * Returns a {@code MapJoiner} using the given key-value separator, and the same configuration as\n     * this {@code Joiner} otherwise.\n     */\n    public MapJoiner withKeyValueSeparator(String keyValueSeparator)\n    {\n        return new MapJoiner(this, keyValueSeparator);\n    }\n\n    /**\n     * An object that joins map entries in the same manner as {@code Joiner} joins iterables and\n     * arrays. Like {@code Joiner}, it is thread-safe and immutable.\n     *\n     * <p>In addition to operating on {@code Map} instances, {@code MapJoiner} can operate on {@code\n     * Multimap} entries in two distinct modes:\n     *\n     * <ul>\n     *   <li>To output a separate entry for each key-value pair, pass {@code multimap.entries()} to a\n     *       {@code MapJoiner} method that accepts entries as input, and receive output of the form\n     *       {@code key1=A&key1=B&key2=C}.\n     *   <li>To output a single entry for each key, pass {@code multimap.asMap()} to a {@code\n     *       MapJoiner} method that accepts a map as input, and receive output of the form {@code\n     *       key1=[A, B]&key2=C}.\n     * </ul>\n     *\n     * @since 2.0\n     */\n    public static final class MapJoiner\n    {\n        private final Joiner joiner;\n        private final String keyValueSeparator;\n\n        private MapJoiner(Joiner joiner, String keyValueSeparator)\n        {\n            this.joiner = joiner; // only \"this\" is ever passed, so don't checkNotNull\n            this.keyValueSeparator = checkNotNull(keyValueSeparator);\n        }\n\n        /**\n         * Appends the string representation of each entry of {@code map}, using the previously\n         * configured separator and key-value separator, to {@code appendable}.\n         */\n        @CanIgnoreReturnValue\n        public <A extends Appendable> A appendTo(A appendable, Map<?, ?> map) throws IOException\n        {\n            return appendTo(appendable, map.entrySet());\n        }\n\n        /**\n         * Appends the string representation of each entry of {@code map}, using the previously\n         * configured separator and key-value separator, to {@code builder}. Identical to {@link\n         * #appendTo(Appendable, Map)}, except that it does not throw {@link IOException}.\n         */\n        @CanIgnoreReturnValue\n        public StringBuilder appendTo(StringBuilder builder, Map<?, ?> map)\n        {\n            return appendTo(builder, map.entrySet());\n        }\n\n        /**\n         * Appends the string representation of each entry in {@code entries}, using the previously\n         * configured separator and key-value separator, to {@code appendable}.\n         *\n         * @since 10.0\n         */\n        @Beta\n        @CanIgnoreReturnValue\n        public <A extends Appendable> A appendTo(A appendable, Iterable<? extends Entry<?, ?>> entries)\n        throws IOException\n        {\n            return appendTo(appendable, entries.iterator());\n        }\n\n        /**\n         * Appends the string representation of each entry in {@code entries}, using the previously\n         * configured separator and key-value separator, to {@code appendable}.\n         *\n         * @since 11.0\n         */\n        @Beta\n        @CanIgnoreReturnValue\n        public <A extends Appendable> A appendTo(A appendable, Iterator<? extends Entry<?, ?>> parts)\n        throws IOException\n        {\n            checkNotNull(appendable);\n            if (parts.hasNext())\n            {\n                Entry<?, ?> entry = parts.next();\n                appendable.append(joiner.toString(entry.getKey()));\n                appendable.append(keyValueSeparator);\n                appendable.append(joiner.toString(entry.getValue()));\n                while (parts.hasNext())\n                {\n                    appendable.append(joiner.separator);\n                    Entry<?, ?> e = parts.next();\n                    appendable.append(joiner.toString(e.getKey()));\n                    appendable.append(keyValueSeparator);\n                    appendable.append(joiner.toString(e.getValue()));\n                }\n            }\n            return appendable;\n        }\n\n        /**\n         * Appends the string representation of each entry in {@code entries}, using the previously\n         * configured separator and key-value separator, to {@code builder}. Identical to {@link\n         * #appendTo(Appendable, Iterable)}, except that it does not throw {@link IOException}.\n         *\n         * @since 10.0\n         */\n        @Beta\n        @CanIgnoreReturnValue\n        public StringBuilder appendTo(StringBuilder builder, Iterable<? extends Entry<?, ?>> entries)\n        {\n            return appendTo(builder, entries.iterator());\n        }\n\n        /**\n         * Appends the string representation of each entry in {@code entries}, using the previously\n         * configured separator and key-value separator, to {@code builder}. Identical to {@link\n         * #appendTo(Appendable, Iterable)}, except that it does not throw {@link IOException}.\n         *\n         * @since 11.0\n         */\n        @Beta\n        @CanIgnoreReturnValue\n        public StringBuilder appendTo(StringBuilder builder, Iterator<? extends Entry<?, ?>> entries)\n        {\n            try\n            {\n                appendTo((Appendable) builder, entries);\n            }\n            catch (IOException impossible)\n            {\n                throw new AssertionError(impossible);\n            }\n            return builder;\n        }\n\n        /**\n         * Returns a string containing the string representation of each entry of {@code map}, using the\n         * previously configured separator and key-value separator.\n         */\n        public String join(Map<?, ?> map)\n        {\n            return join(map.entrySet());\n        }\n\n        /**\n         * Returns a string containing the string representation of each entry in {@code entries}, using\n         * the previously configured separator and key-value separator.\n         *\n         * @since 10.0\n         */\n        @Beta\n        public String join(Iterable<? extends Entry<?, ?>> entries)\n        {\n            return join(entries.iterator());\n        }\n\n        /**\n         * Returns a string containing the string representation of each entry in {@code entries}, using\n         * the previously configured separator and key-value separator.\n         *\n         * @since 11.0\n         */\n        @Beta\n        public String join(Iterator<? extends Entry<?, ?>> entries)\n        {\n            return appendTo(new StringBuilder(), entries).toString();\n        }\n\n        /**\n         * Returns a map joiner with the same behavior as this one, except automatically substituting\n         * {@code nullText} for any provided null keys or values.\n         */\n        public MapJoiner useForNull(String nullText)\n        {\n            return new MapJoiner(joiner.useForNull(nullText), keyValueSeparator);\n        }\n    }\n\n    CharSequence toString(Object part)\n    {\n        checkNotNull(part); // checkNotNull for GWT (do not optimize).\n        return (part instanceof CharSequence) ? (CharSequence) part : part.toString();\n    }\n\n    private static Iterable<Object> iterable(\n        final Object first, final Object second, final Object[] rest)\n    {\n        checkNotNull(rest);\n        return new AbstractList<Object>()\n        {\n            @Override\n            public int size()\n            {\n                return rest.length + 2;\n            }\n\n            @Override\n            public Object get(int index)\n            {\n                switch (index)\n                {\n                case 0:\n                    return first;\n                case 1:\n                    return second;\n                default:\n                    return rest[index - 2];\n                }\n            }\n        };\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/primitives/ImmutableIntArray.java", "func_name": "ImmutableIntArray.of", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "okay since we have to copy the just-created array anyway.", "docstring_tokens": ["okay", "since", "we", "have", "to", "copy", "the", "just", "-", "created", "array", "anyway", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/primitives/ImmutableIntArray.java#L138-L145", "partition": "valid", "up_fun_num": 9, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.base.Preconditions;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import com.google.errorprone.annotations.CheckReturnValue;", "import com.google.errorprone.annotations.Immutable;", "import java.io.Serializable;", "import java.util.AbstractList;", "import java.util.Arrays;", "import java.util.Collection;", "import java.util.List;", "import java.util.RandomAccess;", "import java.util.Spliterator;", "import java.util.Spliterators;", "import java.util.function.IntConsumer;", "import java.util.stream.IntStream;", "import org.checkerframework.checker.nullness.qual.Nullable;"], "function": ["public final class ImmutableIntArray implements Serializable\n", "    public static ImmutableIntArray of()\n", "    public static ImmutableIntArray of(int e0)\n", "    public static ImmutableIntArray of(int e0, int e1)\n", "    public static ImmutableIntArray of(int e0, int e1, int e2)\n", "    public static ImmutableIntArray of(int e0, int e1, int e2, int e3)\n", "    public static ImmutableIntArray of(int e0, int e1, int e2, int e3, int e4)\n", "    public static ImmutableIntArray of(int e0, int e1, int e2, int e3, int e4, int e5)\n", "    public static ImmutableIntArray copyOf(int[] values)\n", "    public static ImmutableIntArray copyOf(Collection<Integer> values)\n", "    public static ImmutableIntArray copyOf(Iterable<Integer> values)\n", "    public static ImmutableIntArray copyOf(IntStream stream)\n", "    public static Builder builder(int initialCapacity)\n", "    public static Builder builder()\n", "    public int length()\n", "    public boolean isEmpty()\n", "    public int get(int index)\n", "    public int indexOf(int target)\n", "    public int lastIndexOf(int target)\n", "    public boolean contains(int target)\n", "    public void forEach(IntConsumer consumer)\n", "    public IntStream stream()\n", "    public int[] toArray()\n", "    public ImmutableIntArray subArray(int startIndex, int endIndex)\n", "    private Spliterator.OfInt spliterator()\n", "    public List<Integer> asList()\n", "    public boolean equals(@Nullable Object object)\n", "    public int hashCode()\n", "    public String toString()\n", "    public ImmutableIntArray trimmed()\n", "    private boolean isPartialView()\n", "    Object writeReplace()\n", "    Object readResolve()\n"], "context": "/*\n * Copyright (C) 2017 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.primitives;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.base.Preconditions;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.google.errorprone.annotations.CheckReturnValue;\nimport com.google.errorprone.annotations.Immutable;\nimport java.io.Serializable;\nimport java.util.AbstractList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.RandomAccess;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.function.IntConsumer;\nimport java.util.stream.IntStream;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\n/**\n * An immutable array of {@code int} values, with an API resembling {@link List}.\n *\n * <p>Advantages compared to {@code int[]}:\n *\n * <ul>\n *   <li>All the many well-known advantages of immutability (read <i>Effective Java</i>, third\n *       edition, Item 17).\n *   <li>Has the value-based (not identity-based) {@link #equals}, {@link #hashCode}, and {@link\n *       #toString} behavior you expect.\n *   <li>Offers useful operations beyond just {@code get} and {@code length}, so you don't have to\n *       hunt through classes like {@link Arrays} and {@link Ints} for them.\n *   <li>Supports a copy-free {@link #subArray} view, so methods that accept this type don't need to\n *       add overloads that accept start and end indexes.\n *   <li>Can be streamed without \"breaking the chain\": {@code foo.getBarInts().stream()...}.\n *   <li>Access to all collection-based utilities via {@link #asList} (though at the cost of\n *       allocating garbage).\n * </ul>\n *\n * <p>Disadvantages compared to {@code int[]}:\n *\n * <ul>\n *   <li>Memory footprint has a fixed overhead (about 24 bytes per instance).\n *   <li><i>Some</i> construction use cases force the data to be copied (though several construction\n *       APIs are offered that don't).\n *   <li>Can't be passed directly to methods that expect {@code int[]} (though the most common\n *       utilities do have replacements here).\n *   <li>Dependency on {@code com.google.common} / Guava.\n * </ul>\n *\n * <p>Advantages compared to {@link com.google.common.collect.ImmutableList ImmutableList}{@code\n * <Integer>}:\n *\n * <ul>\n *   <li>Improved memory compactness and locality.\n *   <li>Can be queried without allocating garbage.\n *   <li>Access to {@code IntStream} features (like {@link IntStream#sum}) using {@code stream()}\n *       instead of the awkward {@code stream().mapToInt(v -> v)}.\n * </ul>\n *\n * <p>Disadvantages compared to {@code ImmutableList<Integer>}:\n *\n * <ul>\n *   <li>Can't be passed directly to methods that expect {@code Iterable}, {@code Collection}, or\n *       {@code List} (though the most common utilities do have replacements here, and there is a\n *       lazy {@link #asList} view).\n * </ul>\n *\n * @since 22.0\n */\n@Beta\n@GwtCompatible\n@Immutable\npublic final class ImmutableIntArray implements Serializable\n{\n    private static final ImmutableIntArray EMPTY = new ImmutableIntArray(new int[0]);\n\n    /** Returns the empty array. */\n    public static ImmutableIntArray of()\n    {\n        return EMPTY;\n    }\n\n    /** Returns an immutable array containing a single value. */\n    public static ImmutableIntArray of(int e0)\n    {\n        return new ImmutableIntArray(new int[] {e0});\n    }\n\n    /** Returns an immutable array containing the given values, in order. */\n    public static ImmutableIntArray of(int e0, int e1)\n    {\n        return new ImmutableIntArray(new int[] {e0, e1});\n    }\n\n    /** Returns an immutable array containing the given values, in order. */\n    public static ImmutableIntArray of(int e0, int e1, int e2)\n    {\n        return new ImmutableIntArray(new int[] {e0, e1, e2});\n    }\n\n    /** Returns an immutable array containing the given values, in order. */\n    public static ImmutableIntArray of(int e0, int e1, int e2, int e3)\n    {\n        return new ImmutableIntArray(new int[] {e0, e1, e2, e3});\n    }\n\n    /** Returns an immutable array containing the given values, in order. */\n    public static ImmutableIntArray of(int e0, int e1, int e2, int e3, int e4)\n    {\n        return new ImmutableIntArray(new int[] {e0, e1, e2, e3, e4});\n    }\n\n    /** Returns an immutable array containing the given values, in order. */\n    public static ImmutableIntArray of(int e0, int e1, int e2, int e3, int e4, int e5)\n    {\n        return new ImmutableIntArray(new int[] {e0, e1, e2, e3, e4, e5});\n    }\n\n    // TODO(kevinb): go up to 11?\n\n    /**\n     * Returns an immutable array containing the given values, in order.\n     *\n     * <p>The array {@code rest} must not be longer than {@code Integer.MAX_VALUE - 1}.\n     */\n    // Use (first, rest) so that `of(someIntArray)` won't compile (they should use copyOf), which is\n    // okay since we have to copy the just-created array anyway.\n\n    /** Returns an immutable array containing the given values, in order. */\n    public static ImmutableIntArray copyOf(int[] values)\n    {\n        return values.length == 0 ? EMPTY : new ImmutableIntArray(Arrays.copyOf(values, values.length));\n    }\n\n    /** Returns an immutable array containing the given values, in order. */\n    public static ImmutableIntArray copyOf(Collection<Integer> values)\n    {\n        return values.isEmpty() ? EMPTY : new ImmutableIntArray(Ints.toArray(values));\n    }\n\n    /**\n     * Returns an immutable array containing the given values, in order.\n     *\n     * <p><b>Performance note:</b> this method delegates to {@link #copyOf(Collection)} if {@code\n     * values} is a {@link Collection}. Otherwise it creates a {@link #builder} and uses {@link\n     * Builder#addAll(Iterable)}, with all the performance implications associated with that.\n     */\n    public static ImmutableIntArray copyOf(Iterable<Integer> values)\n    {\n        if (values instanceof Collection)\n        {\n            return copyOf((Collection<Integer>) values);\n        }\n        return builder().addAll(values).build();\n    }\n\n    /** Returns an immutable array containing all the values from {@code stream}, in order. */\n    public static ImmutableIntArray copyOf(IntStream stream)\n    {\n        // Note this uses very different growth behavior from copyOf(Iterable) and the builder.\n        int[] array = stream.toArray();\n        return (array.length == 0) ? EMPTY : new ImmutableIntArray(array);\n    }\n\n    /**\n     * Returns a new, empty builder for {@link ImmutableIntArray} instances, sized to hold up to\n     * {@code initialCapacity} values without resizing. The returned builder is not thread-safe.\n     *\n     * <p><b>Performance note:</b> When feasible, {@code initialCapacity} should be the exact number\n     * of values that will be added, if that knowledge is readily available. It is better to guess a\n     * value slightly too high than slightly too low. If the value is not exact, the {@link\n     * ImmutableIntArray} that is built will very likely occupy more memory than strictly necessary;\n     * to trim memory usage, build using {@code builder.build().trimmed()}.\n     */\n    public static Builder builder(int initialCapacity)\n    {\n        checkArgument(initialCapacity >= 0, \"Invalid initialCapacity: %s\", initialCapacity);\n        return new Builder(initialCapacity);\n    }\n\n    /**\n     * Returns a new, empty builder for {@link ImmutableIntArray} instances, with a default initial\n     * capacity. The returned builder is not thread-safe.\n     *\n     * <p><b>Performance note:</b> The {@link ImmutableIntArray} that is built will very likely occupy\n     * more memory than necessary; to trim memory usage, build using {@code\n     * builder.build().trimmed()}.\n     */\n    public static Builder builder()\n    {\n        return new Builder(10);\n    }\n\n    /**\n     * A builder for {@link ImmutableIntArray} instances; obtained using {@link\n     * ImmutableIntArray#builder}.\n     */\n    @CanIgnoreReturnValue\n    public static final class Builder\n    {\n        private int[] array;\n        private int count = 0; // <= array.length\n\n        Builder(int initialCapacity)\n        {\n            array = new int[initialCapacity];\n        }\n\n        /**\n         * Appends {@code value} to the end of the values the built {@link ImmutableIntArray} will\n         * contain.\n         */\n        public Builder add(int value)\n        {\n            ensureRoomFor(1);\n            array[count] = value;\n            count += 1;\n            return this;\n        }\n\n        /**\n         * Appends {@code values}, in order, to the end of the values the built {@link\n         * ImmutableIntArray} will contain.\n         */\n        public Builder addAll(int[] values)\n        {\n            ensureRoomFor(values.length);\n            System.arraycopy(values, 0, array, count, values.length);\n            count += values.length;\n            return this;\n        }\n\n        /**\n         * Appends {@code values}, in order, to the end of the values the built {@link\n         * ImmutableIntArray} will contain.\n         */\n        public Builder addAll(Iterable<Integer> values)\n        {\n            if (values instanceof Collection)\n            {\n                return addAll((Collection<Integer>) values);\n            }\n            for (Integer value : values)\n            {\n                add(value);\n            }\n            return this;\n        }\n\n        /**\n         * Appends {@code values}, in order, to the end of the values the built {@link\n         * ImmutableIntArray} will contain.\n         */\n        public Builder addAll(Collection<Integer> values)\n        {\n            ensureRoomFor(values.size());\n            for (Integer value : values)\n            {\n                array[count++] = value;\n            }\n            return this;\n        }\n\n        /**\n         * Appends all values from {@code stream}, in order, to the end of the values the built {@link\n         * ImmutableIntArray} will contain.\n         */\n        public Builder addAll(IntStream stream)\n        {\n            Spliterator.OfInt spliterator = stream.spliterator();\n            long size = spliterator.getExactSizeIfKnown();\n            if (size > 0)   // known *and* nonempty\n            {\n                ensureRoomFor(Ints.saturatedCast(size));\n            }\n            spliterator.forEachRemaining((IntConsumer) this::add);\n            return this;\n        }\n\n        /**\n         * Appends {@code values}, in order, to the end of the values the built {@link\n         * ImmutableIntArray} will contain.\n         */\n        public Builder addAll(ImmutableIntArray values)\n        {\n            ensureRoomFor(values.length());\n            System.arraycopy(values.array, values.start, array, count, values.length());\n            count += values.length();\n            return this;\n        }\n\n        private void ensureRoomFor(int numberToAdd)\n        {\n            int newCount = count + numberToAdd; // TODO(kevinb): check overflow now?\n            if (newCount > array.length)\n            {\n                int[] newArray = new int[expandedCapacity(array.length, newCount)];\n                System.arraycopy(array, 0, newArray, 0, count);\n                this.array = newArray;\n            }\n        }\n\n        // Unfortunately this is pasted from ImmutableCollection.Builder.\n        private static int expandedCapacity(int oldCapacity, int minCapacity)\n        {\n            if (minCapacity < 0)\n            {\n                throw new AssertionError(\"cannot store more than MAX_VALUE elements\");\n            }\n            // careful of overflow!\n            int newCapacity = oldCapacity + (oldCapacity >> 1) + 1;\n            if (newCapacity < minCapacity)\n            {\n                newCapacity = Integer.highestOneBit(minCapacity - 1) << 1;\n            }\n            if (newCapacity < 0)\n            {\n                newCapacity = Integer.MAX_VALUE; // guaranteed to be >= newCapacity\n            }\n            return newCapacity;\n        }\n\n        /**\n         * Returns a new immutable array. The builder can continue to be used after this call, to append\n         * more values and build again.\n         *\n         * <p><b>Performance note:</b> the returned array is backed by the same array as the builder, so\n         * no data is copied as part of this step, but this may occupy more memory than strictly\n         * necessary. To copy the data to a right-sized backing array, use {@code .build().trimmed()}.\n         */\n        @CheckReturnValue\n        public ImmutableIntArray build()\n        {\n            return count == 0 ? EMPTY : new ImmutableIntArray(array, 0, count);\n        }\n    }\n\n    // Instance stuff here\n\n    // The array is never mutated after storing in this field and the construction strategies ensure\n    // it doesn't escape this class\n    @SuppressWarnings(\"Immutable\")\n    private final int[] array;\n\n    /*\n     * TODO(kevinb): evaluate the trade-offs of going bimorphic to save these two fields from most\n     * instances. Note that the instances that would get smaller are the right set to care about\n     * optimizing, because the rest have the option of calling `trimmed`.\n     */\n\n    private final transient int start; // it happens that we only serialize instances where this is 0\n    private final int end; // exclusive\n\n    private ImmutableIntArray(int[] array)\n    {\n        this(array, 0, array.length);\n    }\n\n    private ImmutableIntArray(int[] array, int start, int end)\n    {\n        this.array = array;\n        this.start = start;\n        this.end = end;\n    }\n\n    /** Returns the number of values in this array. */\n    public int length()\n    {\n        return end - start;\n    }\n\n    /** Returns {@code true} if there are no values in this array ({@link #length} is zero). */\n    public boolean isEmpty()\n    {\n        return end == start;\n    }\n\n    /**\n     * Returns the {@code int} value present at the given index.\n     *\n     * @throws IndexOutOfBoundsException if {@code index} is negative, or greater than or equal to\n     *     {@link #length}\n     */\n    public int get(int index)\n    {\n        Preconditions.checkElementIndex(index, length());\n        return array[start + index];\n    }\n\n    /**\n     * Returns the smallest index for which {@link #get} returns {@code target}, or {@code -1} if no\n     * such index exists. Equivalent to {@code asList().indexOf(target)}.\n     */\n    public int indexOf(int target)\n    {\n        for (int i = start; i < end; i++)\n        {\n            if (array[i] == target)\n            {\n                return i - start;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the largest index for which {@link #get} returns {@code target}, or {@code -1} if no\n     * such index exists. Equivalent to {@code asList().lastIndexOf(target)}.\n     */\n    public int lastIndexOf(int target)\n    {\n        for (int i = end - 1; i >= start; i--)\n        {\n            if (array[i] == target)\n            {\n                return i - start;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns {@code true} if {@code target} is present at any index in this array. Equivalent to\n     * {@code asList().contains(target)}.\n     */\n    public boolean contains(int target)\n    {\n        return indexOf(target) >= 0;\n    }\n\n    /** Invokes {@code consumer} for each value contained in this array, in order. */\n    public void forEach(IntConsumer consumer)\n    {\n        checkNotNull(consumer);\n        for (int i = start; i < end; i++)\n        {\n            consumer.accept(array[i]);\n        }\n    }\n\n    /** Returns a stream over the values in this array, in order. */\n    public IntStream stream()\n    {\n        return Arrays.stream(array, start, end);\n    }\n\n    /** Returns a new, mutable copy of this array's values, as a primitive {@code int[]}. */\n    public int[] toArray()\n    {\n        return Arrays.copyOfRange(array, start, end);\n    }\n\n    /**\n     * Returns a new immutable array containing the values in the specified range.\n     *\n     * <p><b>Performance note:</b> The returned array has the same full memory footprint as this one\n     * does (no actual copying is performed). To reduce memory usage, use {@code subArray(start,\n     * end).trimmed()}.\n     */\n    public ImmutableIntArray subArray(int startIndex, int endIndex)\n    {\n        Preconditions.checkPositionIndexes(startIndex, endIndex, length());\n        return startIndex == endIndex\n               ? EMPTY\n               : new ImmutableIntArray(array, start + startIndex, start + endIndex);\n    }\n\n    private Spliterator.OfInt spliterator()\n    {\n        return Spliterators.spliterator(array, start, end, Spliterator.IMMUTABLE | Spliterator.ORDERED);\n    }\n\n    /**\n     * Returns an immutable <i>view</i> of this array's values as a {@code List}; note that {@code\n     * int} values are boxed into {@link Integer} instances on demand, which can be very expensive.\n     * The returned list should be used once and discarded. For any usages beyond that, pass the\n     * returned list to {@link com.google.common.collect.ImmutableList#copyOf(Collection)\n     * ImmutableList.copyOf} and use that list instead.\n     */\n    public List<Integer> asList()\n    {\n        /*\n         * Typically we cache this kind of thing, but much repeated use of this view is a performance\n         * anti-pattern anyway. If we cache, then everyone pays a price in memory footprint even if\n         * they never use this method.\n         */\n        return new AsList(this);\n    }\n\n    static class AsList extends AbstractList<Integer> implements RandomAccess, Serializable\n    {\n        private final ImmutableIntArray parent;\n\n        private AsList(ImmutableIntArray parent)\n        {\n            this.parent = parent;\n        }\n\n        // inherit: isEmpty, containsAll, toArray x2, iterator, listIterator, stream, forEach, mutations\n\n        @Override\n        public int size()\n        {\n            return parent.length();\n        }\n\n        @Override\n        public Integer get(int index)\n        {\n            return parent.get(index);\n        }\n\n        @Override\n        public boolean contains(Object target)\n        {\n            return indexOf(target) >= 0;\n        }\n\n        @Override\n        public int indexOf(Object target)\n        {\n            return target instanceof Integer ? parent.indexOf((Integer) target) : -1;\n        }\n\n        @Override\n        public int lastIndexOf(Object target)\n        {\n            return target instanceof Integer ? parent.lastIndexOf((Integer) target) : -1;\n        }\n\n        @Override\n        public List<Integer> subList(int fromIndex, int toIndex)\n        {\n            return parent.subArray(fromIndex, toIndex).asList();\n        }\n\n        // The default List spliterator is not efficiently splittable\n        @Override\n        public Spliterator<Integer> spliterator()\n        {\n            return parent.spliterator();\n        }\n\n        @Override\n        public boolean equals(@Nullable Object object)\n        {\n            if (object instanceof AsList)\n            {\n                AsList that = (AsList) object;\n                return this.parent.equals(that.parent);\n            }\n            // We could delegate to super now but it would still box too much\n            if (!(object instanceof List))\n            {\n                return false;\n            }\n            List<?> that = (List<?>) object;\n            if (this.size() != that.size())\n            {\n                return false;\n            }\n            int i = parent.start;\n            // Since `that` is very likely RandomAccess we could avoid allocating this iterator...\n            for (Object element : that)\n            {\n                if (!(element instanceof Integer) || parent.array[i++] != (Integer) element)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        // Because we happen to use the same formula. If that changes, just don't override this.\n        @Override\n        public int hashCode()\n        {\n            return parent.hashCode();\n        }\n\n        @Override\n        public String toString()\n        {\n            return parent.toString();\n        }\n    }\n\n    /**\n     * Returns {@code true} if {@code object} is an {@code ImmutableIntArray} containing the same\n     * values as this one, in the same order.\n     */\n    @Override\n    public boolean equals(@Nullable Object object)\n    {\n        if (object == this)\n        {\n            return true;\n        }\n        if (!(object instanceof ImmutableIntArray))\n        {\n            return false;\n        }\n        ImmutableIntArray that = (ImmutableIntArray) object;\n        if (this.length() != that.length())\n        {\n            return false;\n        }\n        for (int i = 0; i < length(); i++)\n        {\n            if (this.get(i) != that.get(i))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /** Returns an unspecified hash code for the contents of this immutable array. */\n    @Override\n    public int hashCode()\n    {\n        int hash = 1;\n        for (int i = start; i < end; i++)\n        {\n            hash *= 31;\n            hash += Ints.hashCode(array[i]);\n        }\n        return hash;\n    }\n\n    /**\n     * Returns a string representation of this array in the same form as {@link\n     * Arrays#toString(int[])}, for example {@code \"[1, 2, 3]\"}.\n     */\n    @Override\n    public String toString()\n    {\n        if (isEmpty())\n        {\n            return \"[]\";\n        }\n        StringBuilder builder = new StringBuilder(length() * 5); // rough estimate is fine\n        builder.append('[').append(array[start]);\n\n        for (int i = start + 1; i < end; i++)\n        {\n            builder.append(\", \").append(array[i]);\n        }\n        builder.append(']');\n        return builder.toString();\n    }\n\n    /**\n     * Returns an immutable array containing the same values as {@code this} array. This is logically\n     * a no-op, and in some circumstances {@code this} itself is returned. However, if this instance\n     * is a {@link #subArray} view of a larger array, this method will copy only the appropriate range\n     * of values, resulting in an equivalent array with a smaller memory footprint.\n     */\n    public ImmutableIntArray trimmed()\n    {\n        return isPartialView() ? new ImmutableIntArray(toArray()) : this;\n    }\n\n    private boolean isPartialView()\n    {\n        return start > 0 || end < array.length;\n    }\n\n    Object writeReplace()\n    {\n        return trimmed();\n    }\n\n    Object readResolve()\n    {\n        return isEmpty() ? EMPTY : this;\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/primitives/ImmutableIntArray.java", "func_name": "ImmutableIntArray.subArray", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns a new immutable array containing the values in the specified range.\n\n<p><b>Performance note:</b> The returned array has the same full memory footprint as this one\ndoes (no actual copying is performed). To reduce memory usage, use {@code subArray(start,\nend).trimmed()}.", "docstring_tokens": ["Returns", "a", "new", "immutable", "array", "containing", "the", "values", "in", "the", "specified", "range", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/primitives/ImmutableIntArray.java#L436-L441", "partition": "valid", "up_fun_num": 25, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.base.Preconditions;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import com.google.errorprone.annotations.CheckReturnValue;", "import com.google.errorprone.annotations.Immutable;", "import java.io.Serializable;", "import java.util.AbstractList;", "import java.util.Arrays;", "import java.util.Collection;", "import java.util.List;", "import java.util.RandomAccess;", "import java.util.Spliterator;", "import java.util.Spliterators;", "import java.util.function.IntConsumer;", "import java.util.stream.IntStream;", "import org.checkerframework.checker.nullness.qual.Nullable;"], "function": ["public final class ImmutableIntArray implements Serializable\n", "    public static ImmutableIntArray of()\n", "    public static ImmutableIntArray of(int e0)\n", "    public static ImmutableIntArray of(int e0, int e1)\n", "    public static ImmutableIntArray of(int e0, int e1, int e2)\n", "    public static ImmutableIntArray of(int e0, int e1, int e2, int e3)\n", "    public static ImmutableIntArray of(int e0, int e1, int e2, int e3, int e4)\n", "    public static ImmutableIntArray of(int e0, int e1, int e2, int e3, int e4, int e5)\n", "    public static ImmutableIntArray of(int first, int... rest)\n", "    public static ImmutableIntArray copyOf(int[] values)\n", "    public static ImmutableIntArray copyOf(Collection<Integer> values)\n", "    public static ImmutableIntArray copyOf(Iterable<Integer> values)\n", "    public static ImmutableIntArray copyOf(IntStream stream)\n", "    public static Builder builder(int initialCapacity)\n", "    public static Builder builder()\n", "    public int length()\n", "    public boolean isEmpty()\n", "    public int get(int index)\n", "    public int indexOf(int target)\n", "    public int lastIndexOf(int target)\n", "    public boolean contains(int target)\n", "    public void forEach(IntConsumer consumer)\n", "    public IntStream stream()\n", "    public int[] toArray()\n", "    private Spliterator.OfInt spliterator()\n", "    public List<Integer> asList()\n", "    public boolean equals(@Nullable Object object)\n", "    public int hashCode()\n", "    public String toString()\n", "    public ImmutableIntArray trimmed()\n", "    private boolean isPartialView()\n", "    Object writeReplace()\n", "    Object readResolve()\n"], "context": "/*\n * Copyright (C) 2017 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.primitives;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.base.Preconditions;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.google.errorprone.annotations.CheckReturnValue;\nimport com.google.errorprone.annotations.Immutable;\nimport java.io.Serializable;\nimport java.util.AbstractList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.RandomAccess;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.function.IntConsumer;\nimport java.util.stream.IntStream;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\n/**\n * An immutable array of {@code int} values, with an API resembling {@link List}.\n *\n * <p>Advantages compared to {@code int[]}:\n *\n * <ul>\n *   <li>All the many well-known advantages of immutability (read <i>Effective Java</i>, third\n *       edition, Item 17).\n *   <li>Has the value-based (not identity-based) {@link #equals}, {@link #hashCode}, and {@link\n *       #toString} behavior you expect.\n *   <li>Offers useful operations beyond just {@code get} and {@code length}, so you don't have to\n *       hunt through classes like {@link Arrays} and {@link Ints} for them.\n *   <li>Supports a copy-free {@link #subArray} view, so methods that accept this type don't need to\n *       add overloads that accept start and end indexes.\n *   <li>Can be streamed without \"breaking the chain\": {@code foo.getBarInts().stream()...}.\n *   <li>Access to all collection-based utilities via {@link #asList} (though at the cost of\n *       allocating garbage).\n * </ul>\n *\n * <p>Disadvantages compared to {@code int[]}:\n *\n * <ul>\n *   <li>Memory footprint has a fixed overhead (about 24 bytes per instance).\n *   <li><i>Some</i> construction use cases force the data to be copied (though several construction\n *       APIs are offered that don't).\n *   <li>Can't be passed directly to methods that expect {@code int[]} (though the most common\n *       utilities do have replacements here).\n *   <li>Dependency on {@code com.google.common} / Guava.\n * </ul>\n *\n * <p>Advantages compared to {@link com.google.common.collect.ImmutableList ImmutableList}{@code\n * <Integer>}:\n *\n * <ul>\n *   <li>Improved memory compactness and locality.\n *   <li>Can be queried without allocating garbage.\n *   <li>Access to {@code IntStream} features (like {@link IntStream#sum}) using {@code stream()}\n *       instead of the awkward {@code stream().mapToInt(v -> v)}.\n * </ul>\n *\n * <p>Disadvantages compared to {@code ImmutableList<Integer>}:\n *\n * <ul>\n *   <li>Can't be passed directly to methods that expect {@code Iterable}, {@code Collection}, or\n *       {@code List} (though the most common utilities do have replacements here, and there is a\n *       lazy {@link #asList} view).\n * </ul>\n *\n * @since 22.0\n */\n@Beta\n@GwtCompatible\n@Immutable\npublic final class ImmutableIntArray implements Serializable\n{\n    private static final ImmutableIntArray EMPTY = new ImmutableIntArray(new int[0]);\n\n    /** Returns the empty array. */\n    public static ImmutableIntArray of()\n    {\n        return EMPTY;\n    }\n\n    /** Returns an immutable array containing a single value. */\n    public static ImmutableIntArray of(int e0)\n    {\n        return new ImmutableIntArray(new int[] {e0});\n    }\n\n    /** Returns an immutable array containing the given values, in order. */\n    public static ImmutableIntArray of(int e0, int e1)\n    {\n        return new ImmutableIntArray(new int[] {e0, e1});\n    }\n\n    /** Returns an immutable array containing the given values, in order. */\n    public static ImmutableIntArray of(int e0, int e1, int e2)\n    {\n        return new ImmutableIntArray(new int[] {e0, e1, e2});\n    }\n\n    /** Returns an immutable array containing the given values, in order. */\n    public static ImmutableIntArray of(int e0, int e1, int e2, int e3)\n    {\n        return new ImmutableIntArray(new int[] {e0, e1, e2, e3});\n    }\n\n    /** Returns an immutable array containing the given values, in order. */\n    public static ImmutableIntArray of(int e0, int e1, int e2, int e3, int e4)\n    {\n        return new ImmutableIntArray(new int[] {e0, e1, e2, e3, e4});\n    }\n\n    /** Returns an immutable array containing the given values, in order. */\n    public static ImmutableIntArray of(int e0, int e1, int e2, int e3, int e4, int e5)\n    {\n        return new ImmutableIntArray(new int[] {e0, e1, e2, e3, e4, e5});\n    }\n\n    // TODO(kevinb): go up to 11?\n\n    /**\n     * Returns an immutable array containing the given values, in order.\n     *\n     * <p>The array {@code rest} must not be longer than {@code Integer.MAX_VALUE - 1}.\n     */\n    // Use (first, rest) so that `of(someIntArray)` won't compile (they should use copyOf), which is\n    // okay since we have to copy the just-created array anyway.\n    public static ImmutableIntArray of(int first, int... rest)\n    {\n        checkArgument(\n            rest.length <= Integer.MAX_VALUE - 1, \"the total number of elements must fit in an int\");\n        int[] array = new int[rest.length + 1];\n        array[0] = first;\n        System.arraycopy(rest, 0, array, 1, rest.length);\n        return new ImmutableIntArray(array);\n    }\n\n    /** Returns an immutable array containing the given values, in order. */\n    public static ImmutableIntArray copyOf(int[] values)\n    {\n        return values.length == 0 ? EMPTY : new ImmutableIntArray(Arrays.copyOf(values, values.length));\n    }\n\n    /** Returns an immutable array containing the given values, in order. */\n    public static ImmutableIntArray copyOf(Collection<Integer> values)\n    {\n        return values.isEmpty() ? EMPTY : new ImmutableIntArray(Ints.toArray(values));\n    }\n\n    /**\n     * Returns an immutable array containing the given values, in order.\n     *\n     * <p><b>Performance note:</b> this method delegates to {@link #copyOf(Collection)} if {@code\n     * values} is a {@link Collection}. Otherwise it creates a {@link #builder} and uses {@link\n     * Builder#addAll(Iterable)}, with all the performance implications associated with that.\n     */\n    public static ImmutableIntArray copyOf(Iterable<Integer> values)\n    {\n        if (values instanceof Collection)\n        {\n            return copyOf((Collection<Integer>) values);\n        }\n        return builder().addAll(values).build();\n    }\n\n    /** Returns an immutable array containing all the values from {@code stream}, in order. */\n    public static ImmutableIntArray copyOf(IntStream stream)\n    {\n        // Note this uses very different growth behavior from copyOf(Iterable) and the builder.\n        int[] array = stream.toArray();\n        return (array.length == 0) ? EMPTY : new ImmutableIntArray(array);\n    }\n\n    /**\n     * Returns a new, empty builder for {@link ImmutableIntArray} instances, sized to hold up to\n     * {@code initialCapacity} values without resizing. The returned builder is not thread-safe.\n     *\n     * <p><b>Performance note:</b> When feasible, {@code initialCapacity} should be the exact number\n     * of values that will be added, if that knowledge is readily available. It is better to guess a\n     * value slightly too high than slightly too low. If the value is not exact, the {@link\n     * ImmutableIntArray} that is built will very likely occupy more memory than strictly necessary;\n     * to trim memory usage, build using {@code builder.build().trimmed()}.\n     */\n    public static Builder builder(int initialCapacity)\n    {\n        checkArgument(initialCapacity >= 0, \"Invalid initialCapacity: %s\", initialCapacity);\n        return new Builder(initialCapacity);\n    }\n\n    /**\n     * Returns a new, empty builder for {@link ImmutableIntArray} instances, with a default initial\n     * capacity. The returned builder is not thread-safe.\n     *\n     * <p><b>Performance note:</b> The {@link ImmutableIntArray} that is built will very likely occupy\n     * more memory than necessary; to trim memory usage, build using {@code\n     * builder.build().trimmed()}.\n     */\n    public static Builder builder()\n    {\n        return new Builder(10);\n    }\n\n    /**\n     * A builder for {@link ImmutableIntArray} instances; obtained using {@link\n     * ImmutableIntArray#builder}.\n     */\n    @CanIgnoreReturnValue\n    public static final class Builder\n    {\n        private int[] array;\n        private int count = 0; // <= array.length\n\n        Builder(int initialCapacity)\n        {\n            array = new int[initialCapacity];\n        }\n\n        /**\n         * Appends {@code value} to the end of the values the built {@link ImmutableIntArray} will\n         * contain.\n         */\n        public Builder add(int value)\n        {\n            ensureRoomFor(1);\n            array[count] = value;\n            count += 1;\n            return this;\n        }\n\n        /**\n         * Appends {@code values}, in order, to the end of the values the built {@link\n         * ImmutableIntArray} will contain.\n         */\n        public Builder addAll(int[] values)\n        {\n            ensureRoomFor(values.length);\n            System.arraycopy(values, 0, array, count, values.length);\n            count += values.length;\n            return this;\n        }\n\n        /**\n         * Appends {@code values}, in order, to the end of the values the built {@link\n         * ImmutableIntArray} will contain.\n         */\n        public Builder addAll(Iterable<Integer> values)\n        {\n            if (values instanceof Collection)\n            {\n                return addAll((Collection<Integer>) values);\n            }\n            for (Integer value : values)\n            {\n                add(value);\n            }\n            return this;\n        }\n\n        /**\n         * Appends {@code values}, in order, to the end of the values the built {@link\n         * ImmutableIntArray} will contain.\n         */\n        public Builder addAll(Collection<Integer> values)\n        {\n            ensureRoomFor(values.size());\n            for (Integer value : values)\n            {\n                array[count++] = value;\n            }\n            return this;\n        }\n\n        /**\n         * Appends all values from {@code stream}, in order, to the end of the values the built {@link\n         * ImmutableIntArray} will contain.\n         */\n        public Builder addAll(IntStream stream)\n        {\n            Spliterator.OfInt spliterator = stream.spliterator();\n            long size = spliterator.getExactSizeIfKnown();\n            if (size > 0)   // known *and* nonempty\n            {\n                ensureRoomFor(Ints.saturatedCast(size));\n            }\n            spliterator.forEachRemaining((IntConsumer) this::add);\n            return this;\n        }\n\n        /**\n         * Appends {@code values}, in order, to the end of the values the built {@link\n         * ImmutableIntArray} will contain.\n         */\n        public Builder addAll(ImmutableIntArray values)\n        {\n            ensureRoomFor(values.length());\n            System.arraycopy(values.array, values.start, array, count, values.length());\n            count += values.length();\n            return this;\n        }\n\n        private void ensureRoomFor(int numberToAdd)\n        {\n            int newCount = count + numberToAdd; // TODO(kevinb): check overflow now?\n            if (newCount > array.length)\n            {\n                int[] newArray = new int[expandedCapacity(array.length, newCount)];\n                System.arraycopy(array, 0, newArray, 0, count);\n                this.array = newArray;\n            }\n        }\n\n        // Unfortunately this is pasted from ImmutableCollection.Builder.\n        private static int expandedCapacity(int oldCapacity, int minCapacity)\n        {\n            if (minCapacity < 0)\n            {\n                throw new AssertionError(\"cannot store more than MAX_VALUE elements\");\n            }\n            // careful of overflow!\n            int newCapacity = oldCapacity + (oldCapacity >> 1) + 1;\n            if (newCapacity < minCapacity)\n            {\n                newCapacity = Integer.highestOneBit(minCapacity - 1) << 1;\n            }\n            if (newCapacity < 0)\n            {\n                newCapacity = Integer.MAX_VALUE; // guaranteed to be >= newCapacity\n            }\n            return newCapacity;\n        }\n\n        /**\n         * Returns a new immutable array. The builder can continue to be used after this call, to append\n         * more values and build again.\n         *\n         * <p><b>Performance note:</b> the returned array is backed by the same array as the builder, so\n         * no data is copied as part of this step, but this may occupy more memory than strictly\n         * necessary. To copy the data to a right-sized backing array, use {@code .build().trimmed()}.\n         */\n        @CheckReturnValue\n        public ImmutableIntArray build()\n        {\n            return count == 0 ? EMPTY : new ImmutableIntArray(array, 0, count);\n        }\n    }\n\n    // Instance stuff here\n\n    // The array is never mutated after storing in this field and the construction strategies ensure\n    // it doesn't escape this class\n    @SuppressWarnings(\"Immutable\")\n    private final int[] array;\n\n    /*\n     * TODO(kevinb): evaluate the trade-offs of going bimorphic to save these two fields from most\n     * instances. Note that the instances that would get smaller are the right set to care about\n     * optimizing, because the rest have the option of calling `trimmed`.\n     */\n\n    private final transient int start; // it happens that we only serialize instances where this is 0\n    private final int end; // exclusive\n\n    private ImmutableIntArray(int[] array)\n    {\n        this(array, 0, array.length);\n    }\n\n    private ImmutableIntArray(int[] array, int start, int end)\n    {\n        this.array = array;\n        this.start = start;\n        this.end = end;\n    }\n\n    /** Returns the number of values in this array. */\n    public int length()\n    {\n        return end - start;\n    }\n\n    /** Returns {@code true} if there are no values in this array ({@link #length} is zero). */\n    public boolean isEmpty()\n    {\n        return end == start;\n    }\n\n    /**\n     * Returns the {@code int} value present at the given index.\n     *\n     * @throws IndexOutOfBoundsException if {@code index} is negative, or greater than or equal to\n     *     {@link #length}\n     */\n    public int get(int index)\n    {\n        Preconditions.checkElementIndex(index, length());\n        return array[start + index];\n    }\n\n    /**\n     * Returns the smallest index for which {@link #get} returns {@code target}, or {@code -1} if no\n     * such index exists. Equivalent to {@code asList().indexOf(target)}.\n     */\n    public int indexOf(int target)\n    {\n        for (int i = start; i < end; i++)\n        {\n            if (array[i] == target)\n            {\n                return i - start;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the largest index for which {@link #get} returns {@code target}, or {@code -1} if no\n     * such index exists. Equivalent to {@code asList().lastIndexOf(target)}.\n     */\n    public int lastIndexOf(int target)\n    {\n        for (int i = end - 1; i >= start; i--)\n        {\n            if (array[i] == target)\n            {\n                return i - start;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns {@code true} if {@code target} is present at any index in this array. Equivalent to\n     * {@code asList().contains(target)}.\n     */\n    public boolean contains(int target)\n    {\n        return indexOf(target) >= 0;\n    }\n\n    /** Invokes {@code consumer} for each value contained in this array, in order. */\n    public void forEach(IntConsumer consumer)\n    {\n        checkNotNull(consumer);\n        for (int i = start; i < end; i++)\n        {\n            consumer.accept(array[i]);\n        }\n    }\n\n    /** Returns a stream over the values in this array, in order. */\n    public IntStream stream()\n    {\n        return Arrays.stream(array, start, end);\n    }\n\n    /** Returns a new, mutable copy of this array's values, as a primitive {@code int[]}. */\n    public int[] toArray()\n    {\n        return Arrays.copyOfRange(array, start, end);\n    }\n\n    /**\n     * Returns a new immutable array containing the values in the specified range.\n     *\n     * <p><b>Performance note:</b> The returned array has the same full memory footprint as this one\n     * does (no actual copying is performed). To reduce memory usage, use {@code subArray(start,\n     * end).trimmed()}.\n     */\n\n    private Spliterator.OfInt spliterator()\n    {\n        return Spliterators.spliterator(array, start, end, Spliterator.IMMUTABLE | Spliterator.ORDERED);\n    }\n\n    /**\n     * Returns an immutable <i>view</i> of this array's values as a {@code List}; note that {@code\n     * int} values are boxed into {@link Integer} instances on demand, which can be very expensive.\n     * The returned list should be used once and discarded. For any usages beyond that, pass the\n     * returned list to {@link com.google.common.collect.ImmutableList#copyOf(Collection)\n     * ImmutableList.copyOf} and use that list instead.\n     */\n    public List<Integer> asList()\n    {\n        /*\n         * Typically we cache this kind of thing, but much repeated use of this view is a performance\n         * anti-pattern anyway. If we cache, then everyone pays a price in memory footprint even if\n         * they never use this method.\n         */\n        return new AsList(this);\n    }\n\n    static class AsList extends AbstractList<Integer> implements RandomAccess, Serializable\n    {\n        private final ImmutableIntArray parent;\n\n        private AsList(ImmutableIntArray parent)\n        {\n            this.parent = parent;\n        }\n\n        // inherit: isEmpty, containsAll, toArray x2, iterator, listIterator, stream, forEach, mutations\n\n        @Override\n        public int size()\n        {\n            return parent.length();\n        }\n\n        @Override\n        public Integer get(int index)\n        {\n            return parent.get(index);\n        }\n\n        @Override\n        public boolean contains(Object target)\n        {\n            return indexOf(target) >= 0;\n        }\n\n        @Override\n        public int indexOf(Object target)\n        {\n            return target instanceof Integer ? parent.indexOf((Integer) target) : -1;\n        }\n\n        @Override\n        public int lastIndexOf(Object target)\n        {\n            return target instanceof Integer ? parent.lastIndexOf((Integer) target) : -1;\n        }\n\n        @Override\n        public List<Integer> subList(int fromIndex, int toIndex)\n        {\n            return parent.subArray(fromIndex, toIndex).asList();\n        }\n\n        // The default List spliterator is not efficiently splittable\n        @Override\n        public Spliterator<Integer> spliterator()\n        {\n            return parent.spliterator();\n        }\n\n        @Override\n        public boolean equals(@Nullable Object object)\n        {\n            if (object instanceof AsList)\n            {\n                AsList that = (AsList) object;\n                return this.parent.equals(that.parent);\n            }\n            // We could delegate to super now but it would still box too much\n            if (!(object instanceof List))\n            {\n                return false;\n            }\n            List<?> that = (List<?>) object;\n            if (this.size() != that.size())\n            {\n                return false;\n            }\n            int i = parent.start;\n            // Since `that` is very likely RandomAccess we could avoid allocating this iterator...\n            for (Object element : that)\n            {\n                if (!(element instanceof Integer) || parent.array[i++] != (Integer) element)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        // Because we happen to use the same formula. If that changes, just don't override this.\n        @Override\n        public int hashCode()\n        {\n            return parent.hashCode();\n        }\n\n        @Override\n        public String toString()\n        {\n            return parent.toString();\n        }\n    }\n\n    /**\n     * Returns {@code true} if {@code object} is an {@code ImmutableIntArray} containing the same\n     * values as this one, in the same order.\n     */\n    @Override\n    public boolean equals(@Nullable Object object)\n    {\n        if (object == this)\n        {\n            return true;\n        }\n        if (!(object instanceof ImmutableIntArray))\n        {\n            return false;\n        }\n        ImmutableIntArray that = (ImmutableIntArray) object;\n        if (this.length() != that.length())\n        {\n            return false;\n        }\n        for (int i = 0; i < length(); i++)\n        {\n            if (this.get(i) != that.get(i))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /** Returns an unspecified hash code for the contents of this immutable array. */\n    @Override\n    public int hashCode()\n    {\n        int hash = 1;\n        for (int i = start; i < end; i++)\n        {\n            hash *= 31;\n            hash += Ints.hashCode(array[i]);\n        }\n        return hash;\n    }\n\n    /**\n     * Returns a string representation of this array in the same form as {@link\n     * Arrays#toString(int[])}, for example {@code \"[1, 2, 3]\"}.\n     */\n    @Override\n    public String toString()\n    {\n        if (isEmpty())\n        {\n            return \"[]\";\n        }\n        StringBuilder builder = new StringBuilder(length() * 5); // rough estimate is fine\n        builder.append('[').append(array[start]);\n\n        for (int i = start + 1; i < end; i++)\n        {\n            builder.append(\", \").append(array[i]);\n        }\n        builder.append(']');\n        return builder.toString();\n    }\n\n    /**\n     * Returns an immutable array containing the same values as {@code this} array. This is logically\n     * a no-op, and in some circumstances {@code this} itself is returned. However, if this instance\n     * is a {@link #subArray} view of a larger array, this method will copy only the appropriate range\n     * of values, resulting in an equivalent array with a smaller memory footprint.\n     */\n    public ImmutableIntArray trimmed()\n    {\n        return isPartialView() ? new ImmutableIntArray(toArray()) : this;\n    }\n\n    private boolean isPartialView()\n    {\n        return start > 0 || end < array.length;\n    }\n\n    Object writeReplace()\n    {\n        return trimmed();\n    }\n\n    Object readResolve()\n    {\n        return isEmpty() ? EMPTY : this;\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/hash/HashingInputStream.java", "func_name": "HashingInputStream.read", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Reads the next byte of data from the underlying input stream and updates the hasher with the\nbyte read.", "docstring_tokens": ["Reads", "the", "next", "byte", "of", "data", "from", "the", "underlying", "input", "stream", "and", "updates", "the", "hasher", "with", "the", "byte", "read", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/hash/HashingInputStream.java#L50-L58", "partition": "valid", "up_fun_num": 1, "levels": [0, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.io.FilterInputStream;", "import java.io.IOException;", "import java.io.InputStream;"], "function": ["public final class HashingInputStream extends FilterInputStream\n", "    public int read(byte[] bytes, int off, int len) throws IOException\n", "    public boolean markSupported()\n", "    public void mark(int readlimit) {}\n", "    public void reset() throws IOException\n", "    public HashCode hash()\n"], "context": "/*\n * Copyright (C) 2013 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.hash;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.FilterInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * An {@link InputStream} that maintains a hash of the data read from it.\n *\n * @author Qian Huang\n * @since 16.0\n */\n@Beta\npublic final class HashingInputStream extends FilterInputStream\n{\n    private final Hasher hasher;\n\n    /**\n     * Creates an input stream that hashes using the given {@link HashFunction} and delegates all data\n     * read from it to the underlying {@link InputStream}.\n     *\n     * <p>The {@link InputStream} should not be read from before or after the hand-off.\n     */\n    public HashingInputStream(HashFunction hashFunction, InputStream in)\n    {\n        super(checkNotNull(in));\n        this.hasher = checkNotNull(hashFunction.newHasher());\n    }\n\n    /**\n     * Reads the next byte of data from the underlying input stream and updates the hasher with the\n     * byte read.\n     */\n\n    /**\n     * Reads the specified bytes of data from the underlying input stream and updates the hasher with\n     * the bytes read.\n     */\n    @Override\n    @CanIgnoreReturnValue\n    public int read(byte[] bytes, int off, int len) throws IOException\n    {\n        int numOfBytesRead = in.read(bytes, off, len);\n        if (numOfBytesRead != -1)\n        {\n            hasher.putBytes(bytes, off, numOfBytesRead);\n        }\n        return numOfBytesRead;\n    }\n\n    /**\n     * mark() is not supported for HashingInputStream\n     *\n     * @return {@code false} always\n     */\n    @Override\n    public boolean markSupported()\n    {\n        return false;\n    }\n\n    /** mark() is not supported for HashingInputStream */\n    @Override\n    public void mark(int readlimit) {}\n\n    /**\n     * reset() is not supported for HashingInputStream.\n     *\n     * @throws IOException this operation is not supported\n     */\n    @Override\n    public void reset() throws IOException\n    {\n        throw new IOException(\"reset not supported\");\n    }\n\n    /**\n     * Returns the {@link HashCode} based on the data read from this stream. The result is unspecified\n     * if this method is called more than once on the same instance.\n     */\n    public HashCode hash()\n    {\n        return hasher.hash();\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/hash/HashingInputStream.java", "func_name": "HashingInputStream.read", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Reads the specified bytes of data from the underlying input stream and updates the hasher with\nthe bytes read.", "docstring_tokens": ["Reads", "the", "specified", "bytes", "of", "data", "from", "the", "underlying", "input", "stream", "and", "updates", "the", "hasher", "with", "the", "bytes", "read", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/hash/HashingInputStream.java#L64-L72", "partition": "valid", "up_fun_num": 2, "levels": [0, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.io.FilterInputStream;", "import java.io.IOException;", "import java.io.InputStream;"], "function": ["public final class HashingInputStream extends FilterInputStream\n", "    public int read() throws IOException\n", "    public boolean markSupported()\n", "    public void mark(int readlimit) {}\n", "    public void reset() throws IOException\n", "    public HashCode hash()\n"], "context": "/*\n * Copyright (C) 2013 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.hash;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.FilterInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * An {@link InputStream} that maintains a hash of the data read from it.\n *\n * @author Qian Huang\n * @since 16.0\n */\n@Beta\npublic final class HashingInputStream extends FilterInputStream\n{\n    private final Hasher hasher;\n\n    /**\n     * Creates an input stream that hashes using the given {@link HashFunction} and delegates all data\n     * read from it to the underlying {@link InputStream}.\n     *\n     * <p>The {@link InputStream} should not be read from before or after the hand-off.\n     */\n    public HashingInputStream(HashFunction hashFunction, InputStream in)\n    {\n        super(checkNotNull(in));\n        this.hasher = checkNotNull(hashFunction.newHasher());\n    }\n\n    /**\n     * Reads the next byte of data from the underlying input stream and updates the hasher with the\n     * byte read.\n     */\n    @Override\n    @CanIgnoreReturnValue\n    public int read() throws IOException\n    {\n        int b = in.read();\n        if (b != -1)\n        {\n            hasher.putByte((byte) b);\n        }\n        return b;\n    }\n\n    /**\n     * Reads the specified bytes of data from the underlying input stream and updates the hasher with\n     * the bytes read.\n     */\n\n    /**\n     * mark() is not supported for HashingInputStream\n     *\n     * @return {@code false} always\n     */\n    @Override\n    public boolean markSupported()\n    {\n        return false;\n    }\n\n    /** mark() is not supported for HashingInputStream */\n    @Override\n    public void mark(int readlimit) {}\n\n    /**\n     * reset() is not supported for HashingInputStream.\n     *\n     * @throws IOException this operation is not supported\n     */\n    @Override\n    public void reset() throws IOException\n    {\n        throw new IOException(\"reset not supported\");\n    }\n\n    /**\n     * Returns the {@link HashCode} based on the data read from this stream. The result is unspecified\n     * if this method is called more than once on the same instance.\n     */\n    public HashCode hash()\n    {\n        return hasher.hash();\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/collect/Serialization.java", "func_name": "Serialization.writeMap", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Stores the contents of a map in an output stream, as part of serialization. It does not support\nconcurrent maps whose content may change while the method is running.\n\n<p>The serialized output consists of the number of entries, first key, first value, second key,\nsecond value, and so on.", "docstring_tokens": ["Stores", "the", "contents", "of", "a", "map", "in", "an", "output", "stream", "as", "part", "of", "serialization", ".", "It", "does", "not", "support", "concurrent", "maps", "whose", "content", "may", "change", "while", "the", "method", "is", "running", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/collect/Serialization.java#L57-L63", "partition": "valid", "up_fun_num": 3, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.google.common.annotations.GwtIncompatible;", "import java.io.IOException;", "import java.io.ObjectInputStream;", "import java.io.ObjectOutputStream;", "import java.lang.reflect.Field;", "import java.util.Collection;", "import java.util.Map;"], "function": ["final class Serialization\n", "    static int readCount(ObjectInputStream stream) throws IOException\n", "    static <K, V> void populateMap(Map<K, V> map, ObjectInputStream stream)\n", "    static <K, V> void populateMap(Map<K, V> map, ObjectInputStream stream, int size)\n", "    static <E> void writeMultiset(Multiset<E> multiset, ObjectOutputStream stream)\n", "    static <E> void populateMultiset(Multiset<E> multiset, ObjectInputStream stream)\n", "    static <E> void populateMultiset(\n", "    static <K, V> void writeMultimap(Multimap<K, V> multimap, ObjectOutputStream stream)\n", "    static <K, V> void populateMultimap(Multimap<K, V> multimap, ObjectInputStream stream)\n", "    static <K, V> void populateMultimap(\n", "    static <T> FieldSetter<T> getFieldSetter(final Class<T> clazz, String fieldName)\n"], "context": "/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport com.google.common.annotations.GwtIncompatible;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.Collection;\nimport java.util.Map;\n\n/**\n * Provides static methods for serializing collection classes.\n *\n * <p>This class assists the implementation of collection classes. Do not use this class to\n * serialize collections that are defined elsewhere.\n *\n * @author Jared Levy\n */\n@GwtIncompatible\nfinal class Serialization\n{\n    private Serialization() {}\n\n    /**\n     * Reads a count corresponding to a serialized map, multiset, or multimap. It returns the size of\n     * a map serialized by {@link #writeMap(Map, ObjectOutputStream)}, the number of distinct elements\n     * in a multiset serialized by {@link #writeMultiset(Multiset, ObjectOutputStream)}, or the number\n     * of distinct keys in a multimap serialized by {@link #writeMultimap(Multimap,\n     * ObjectOutputStream)}.\n     */\n    static int readCount(ObjectInputStream stream) throws IOException\n    {\n        return stream.readInt();\n    }\n\n    /**\n     * Stores the contents of a map in an output stream, as part of serialization. It does not support\n     * concurrent maps whose content may change while the method is running.\n     *\n     * <p>The serialized output consists of the number of entries, first key, first value, second key,\n     * second value, and so on.\n     */\n\n    /**\n     * Populates a map by reading an input stream, as part of deserialization. See {@link #writeMap}\n     * for the data format.\n     */\n    static <K, V> void populateMap(Map<K, V> map, ObjectInputStream stream)\n    throws IOException, ClassNotFoundException\n    {\n        int size = stream.readInt();\n        populateMap(map, stream, size);\n    }\n\n    /**\n     * Populates a map by reading an input stream, as part of deserialization. See {@link #writeMap}\n     * for the data format. The size is determined by a prior call to {@link #readCount}.\n     */\n    static <K, V> void populateMap(Map<K, V> map, ObjectInputStream stream, int size)\n    throws IOException, ClassNotFoundException\n    {\n        for (int i = 0; i < size; i++)\n        {\n            @SuppressWarnings(\"unchecked\") // reading data stored by writeMap\n            K key = (K) stream.readObject();\n            @SuppressWarnings(\"unchecked\") // reading data stored by writeMap\n            V value = (V) stream.readObject();\n            map.put(key, value);\n        }\n    }\n\n    /**\n     * Stores the contents of a multiset in an output stream, as part of serialization. It does not\n     * support concurrent multisets whose content may change while the method is running.\n     *\n     * <p>The serialized output consists of the number of distinct elements, the first element, its\n     * count, the second element, its count, and so on.\n     */\n    static <E> void writeMultiset(Multiset<E> multiset, ObjectOutputStream stream)\n    throws IOException\n    {\n        int entryCount = multiset.entrySet().size();\n        stream.writeInt(entryCount);\n        for (Multiset.Entry<E> entry : multiset.entrySet())\n        {\n            stream.writeObject(entry.getElement());\n            stream.writeInt(entry.getCount());\n        }\n    }\n\n    /**\n     * Populates a multiset by reading an input stream, as part of deserialization. See {@link\n     * #writeMultiset} for the data format.\n     */\n    static <E> void populateMultiset(Multiset<E> multiset, ObjectInputStream stream)\n    throws IOException, ClassNotFoundException\n    {\n        int distinctElements = stream.readInt();\n        populateMultiset(multiset, stream, distinctElements);\n    }\n\n    /**\n     * Populates a multiset by reading an input stream, as part of deserialization. See {@link\n     * #writeMultiset} for the data format. The number of distinct elements is determined by a prior\n     * call to {@link #readCount}.\n     */\n    static <E> void populateMultiset(\n        Multiset<E> multiset, ObjectInputStream stream, int distinctElements)\n    throws IOException, ClassNotFoundException\n    {\n        for (int i = 0; i < distinctElements; i++)\n        {\n            @SuppressWarnings(\"unchecked\") // reading data stored by writeMultiset\n            E element = (E) stream.readObject();\n            int count = stream.readInt();\n            multiset.add(element, count);\n        }\n    }\n\n    /**\n     * Stores the contents of a multimap in an output stream, as part of serialization. It does not\n     * support concurrent multimaps whose content may change while the method is running. The {@link\n     * Multimap#asMap} view determines the ordering in which data is written to the stream.\n     *\n     * <p>The serialized output consists of the number of distinct keys, and then for each distinct\n     * key: the key, the number of values for that key, and the key's values.\n     */\n    static <K, V> void writeMultimap(Multimap<K, V> multimap, ObjectOutputStream stream)\n    throws IOException\n    {\n        stream.writeInt(multimap.asMap().size());\n        for (Map.Entry<K, Collection<V>> entry : multimap.asMap().entrySet())\n        {\n            stream.writeObject(entry.getKey());\n            stream.writeInt(entry.getValue().size());\n            for (V value : entry.getValue())\n            {\n                stream.writeObject(value);\n            }\n        }\n    }\n\n    /**\n     * Populates a multimap by reading an input stream, as part of deserialization. See {@link\n     * #writeMultimap} for the data format.\n     */\n    static <K, V> void populateMultimap(Multimap<K, V> multimap, ObjectInputStream stream)\n    throws IOException, ClassNotFoundException\n    {\n        int distinctKeys = stream.readInt();\n        populateMultimap(multimap, stream, distinctKeys);\n    }\n\n    /**\n     * Populates a multimap by reading an input stream, as part of deserialization. See {@link\n     * #writeMultimap} for the data format. The number of distinct keys is determined by a prior call\n     * to {@link #readCount}.\n     */\n    static <K, V> void populateMultimap(\n        Multimap<K, V> multimap, ObjectInputStream stream, int distinctKeys)\n    throws IOException, ClassNotFoundException\n    {\n        for (int i = 0; i < distinctKeys; i++)\n        {\n            @SuppressWarnings(\"unchecked\") // reading data stored by writeMultimap\n            K key = (K) stream.readObject();\n            Collection<V> values = multimap.get(key);\n            int valueCount = stream.readInt();\n            for (int j = 0; j < valueCount; j++)\n            {\n                @SuppressWarnings(\"unchecked\") // reading data stored by writeMultimap\n                V value = (V) stream.readObject();\n                values.add(value);\n            }\n        }\n    }\n\n    // Secret sauce for setting final fields; don't make it public.\n    static <T> FieldSetter<T> getFieldSetter(final Class<T> clazz, String fieldName)\n    {\n        try\n        {\n            Field field = clazz.getDeclaredField(fieldName);\n            return new FieldSetter<T>(field);\n        }\n        catch (NoSuchFieldException e)\n        {\n            throw new AssertionError(e); // programmer error\n        }\n    }\n\n    // Secret sauce for setting final fields; don't make it public.\n    static final class FieldSetter<T>\n    {\n        private final Field field;\n\n        private FieldSetter(Field field)\n        {\n            this.field = field;\n            field.setAccessible(true);\n        }\n\n        void set(T instance, Object value)\n        {\n            try\n            {\n                field.set(instance, value);\n            }\n            catch (IllegalAccessException impossible)\n            {\n                throw new AssertionError(impossible);\n            }\n        }\n\n        void set(T instance, int value)\n        {\n            try\n            {\n                field.set(instance, value);\n            }\n            catch (IllegalAccessException impossible)\n            {\n                throw new AssertionError(impossible);\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/collect/Serialization.java", "func_name": "Serialization.writeMultiset", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Stores the contents of a multiset in an output stream, as part of serialization. It does not\nsupport concurrent multisets whose content may change while the method is running.\n\n<p>The serialized output consists of the number of distinct elements, the first element, its\ncount, the second element, its count, and so on.", "docstring_tokens": ["Stores", "the", "contents", "of", "a", "multiset", "in", "an", "output", "stream", "as", "part", "of", "serialization", ".", "It", "does", "not", "support", "concurrent", "multisets", "whose", "content", "may", "change", "while", "the", "method", "is", "running", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/collect/Serialization.java#L97-L105", "partition": "valid", "up_fun_num": 6, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.google.common.annotations.GwtIncompatible;", "import java.io.IOException;", "import java.io.ObjectInputStream;", "import java.io.ObjectOutputStream;", "import java.lang.reflect.Field;", "import java.util.Collection;", "import java.util.Map;"], "function": ["final class Serialization\n", "    static int readCount(ObjectInputStream stream) throws IOException\n", "    static <K, V> void writeMap(Map<K, V> map, ObjectOutputStream stream) throws IOException\n", "    static <K, V> void populateMap(Map<K, V> map, ObjectInputStream stream)\n", "    static <K, V> void populateMap(Map<K, V> map, ObjectInputStream stream, int size)\n", "    static <E> void populateMultiset(Multiset<E> multiset, ObjectInputStream stream)\n", "    static <E> void populateMultiset(\n", "    static <K, V> void writeMultimap(Multimap<K, V> multimap, ObjectOutputStream stream)\n", "    static <K, V> void populateMultimap(Multimap<K, V> multimap, ObjectInputStream stream)\n", "    static <K, V> void populateMultimap(\n", "    static <T> FieldSetter<T> getFieldSetter(final Class<T> clazz, String fieldName)\n"], "context": "/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport com.google.common.annotations.GwtIncompatible;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.Collection;\nimport java.util.Map;\n\n/**\n * Provides static methods for serializing collection classes.\n *\n * <p>This class assists the implementation of collection classes. Do not use this class to\n * serialize collections that are defined elsewhere.\n *\n * @author Jared Levy\n */\n@GwtIncompatible\nfinal class Serialization\n{\n    private Serialization() {}\n\n    /**\n     * Reads a count corresponding to a serialized map, multiset, or multimap. It returns the size of\n     * a map serialized by {@link #writeMap(Map, ObjectOutputStream)}, the number of distinct elements\n     * in a multiset serialized by {@link #writeMultiset(Multiset, ObjectOutputStream)}, or the number\n     * of distinct keys in a multimap serialized by {@link #writeMultimap(Multimap,\n     * ObjectOutputStream)}.\n     */\n    static int readCount(ObjectInputStream stream) throws IOException\n    {\n        return stream.readInt();\n    }\n\n    /**\n     * Stores the contents of a map in an output stream, as part of serialization. It does not support\n     * concurrent maps whose content may change while the method is running.\n     *\n     * <p>The serialized output consists of the number of entries, first key, first value, second key,\n     * second value, and so on.\n     */\n    static <K, V> void writeMap(Map<K, V> map, ObjectOutputStream stream) throws IOException\n    {\n        stream.writeInt(map.size());\n        for (Map.Entry<K, V> entry : map.entrySet())\n        {\n            stream.writeObject(entry.getKey());\n            stream.writeObject(entry.getValue());\n        }\n    }\n\n    /**\n     * Populates a map by reading an input stream, as part of deserialization. See {@link #writeMap}\n     * for the data format.\n     */\n    static <K, V> void populateMap(Map<K, V> map, ObjectInputStream stream)\n    throws IOException, ClassNotFoundException\n    {\n        int size = stream.readInt();\n        populateMap(map, stream, size);\n    }\n\n    /**\n     * Populates a map by reading an input stream, as part of deserialization. See {@link #writeMap}\n     * for the data format. The size is determined by a prior call to {@link #readCount}.\n     */\n    static <K, V> void populateMap(Map<K, V> map, ObjectInputStream stream, int size)\n    throws IOException, ClassNotFoundException\n    {\n        for (int i = 0; i < size; i++)\n        {\n            @SuppressWarnings(\"unchecked\") // reading data stored by writeMap\n            K key = (K) stream.readObject();\n            @SuppressWarnings(\"unchecked\") // reading data stored by writeMap\n            V value = (V) stream.readObject();\n            map.put(key, value);\n        }\n    }\n\n    /**\n     * Stores the contents of a multiset in an output stream, as part of serialization. It does not\n     * support concurrent multisets whose content may change while the method is running.\n     *\n     * <p>The serialized output consists of the number of distinct elements, the first element, its\n     * count, the second element, its count, and so on.\n     */\n\n    /**\n     * Populates a multiset by reading an input stream, as part of deserialization. See {@link\n     * #writeMultiset} for the data format.\n     */\n    static <E> void populateMultiset(Multiset<E> multiset, ObjectInputStream stream)\n    throws IOException, ClassNotFoundException\n    {\n        int distinctElements = stream.readInt();\n        populateMultiset(multiset, stream, distinctElements);\n    }\n\n    /**\n     * Populates a multiset by reading an input stream, as part of deserialization. See {@link\n     * #writeMultiset} for the data format. The number of distinct elements is determined by a prior\n     * call to {@link #readCount}.\n     */\n    static <E> void populateMultiset(\n        Multiset<E> multiset, ObjectInputStream stream, int distinctElements)\n    throws IOException, ClassNotFoundException\n    {\n        for (int i = 0; i < distinctElements; i++)\n        {\n            @SuppressWarnings(\"unchecked\") // reading data stored by writeMultiset\n            E element = (E) stream.readObject();\n            int count = stream.readInt();\n            multiset.add(element, count);\n        }\n    }\n\n    /**\n     * Stores the contents of a multimap in an output stream, as part of serialization. It does not\n     * support concurrent multimaps whose content may change while the method is running. The {@link\n     * Multimap#asMap} view determines the ordering in which data is written to the stream.\n     *\n     * <p>The serialized output consists of the number of distinct keys, and then for each distinct\n     * key: the key, the number of values for that key, and the key's values.\n     */\n    static <K, V> void writeMultimap(Multimap<K, V> multimap, ObjectOutputStream stream)\n    throws IOException\n    {\n        stream.writeInt(multimap.asMap().size());\n        for (Map.Entry<K, Collection<V>> entry : multimap.asMap().entrySet())\n        {\n            stream.writeObject(entry.getKey());\n            stream.writeInt(entry.getValue().size());\n            for (V value : entry.getValue())\n            {\n                stream.writeObject(value);\n            }\n        }\n    }\n\n    /**\n     * Populates a multimap by reading an input stream, as part of deserialization. See {@link\n     * #writeMultimap} for the data format.\n     */\n    static <K, V> void populateMultimap(Multimap<K, V> multimap, ObjectInputStream stream)\n    throws IOException, ClassNotFoundException\n    {\n        int distinctKeys = stream.readInt();\n        populateMultimap(multimap, stream, distinctKeys);\n    }\n\n    /**\n     * Populates a multimap by reading an input stream, as part of deserialization. See {@link\n     * #writeMultimap} for the data format. The number of distinct keys is determined by a prior call\n     * to {@link #readCount}.\n     */\n    static <K, V> void populateMultimap(\n        Multimap<K, V> multimap, ObjectInputStream stream, int distinctKeys)\n    throws IOException, ClassNotFoundException\n    {\n        for (int i = 0; i < distinctKeys; i++)\n        {\n            @SuppressWarnings(\"unchecked\") // reading data stored by writeMultimap\n            K key = (K) stream.readObject();\n            Collection<V> values = multimap.get(key);\n            int valueCount = stream.readInt();\n            for (int j = 0; j < valueCount; j++)\n            {\n                @SuppressWarnings(\"unchecked\") // reading data stored by writeMultimap\n                V value = (V) stream.readObject();\n                values.add(value);\n            }\n        }\n    }\n\n    // Secret sauce for setting final fields; don't make it public.\n    static <T> FieldSetter<T> getFieldSetter(final Class<T> clazz, String fieldName)\n    {\n        try\n        {\n            Field field = clazz.getDeclaredField(fieldName);\n            return new FieldSetter<T>(field);\n        }\n        catch (NoSuchFieldException e)\n        {\n            throw new AssertionError(e); // programmer error\n        }\n    }\n\n    // Secret sauce for setting final fields; don't make it public.\n    static final class FieldSetter<T>\n    {\n        private final Field field;\n\n        private FieldSetter(Field field)\n        {\n            this.field = field;\n            field.setAccessible(true);\n        }\n\n        void set(T instance, Object value)\n        {\n            try\n            {\n                field.set(instance, value);\n            }\n            catch (IllegalAccessException impossible)\n            {\n                throw new AssertionError(impossible);\n            }\n        }\n\n        void set(T instance, int value)\n        {\n            try\n            {\n                field.set(instance, value);\n            }\n            catch (IllegalAccessException impossible)\n            {\n                throw new AssertionError(impossible);\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/collect/Serialization.java", "func_name": "Serialization.getFieldSetter", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Secret sauce for setting final fields; don't make it public.", "docstring_tokens": ["Secret", "sauce", "for", "setting", "final", "fields", ";", "don", "t", "make", "it", "public", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/collect/Serialization.java#L185-L192", "partition": "valid", "up_fun_num": 11, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.google.common.annotations.GwtIncompatible;", "import java.io.IOException;", "import java.io.ObjectInputStream;", "import java.io.ObjectOutputStream;", "import java.lang.reflect.Field;", "import java.util.Collection;", "import java.util.Map;"], "function": ["final class Serialization\n", "    static int readCount(ObjectInputStream stream) throws IOException\n", "    static <K, V> void writeMap(Map<K, V> map, ObjectOutputStream stream) throws IOException\n", "    static <K, V> void populateMap(Map<K, V> map, ObjectInputStream stream)\n", "    static <K, V> void populateMap(Map<K, V> map, ObjectInputStream stream, int size)\n", "    static <E> void writeMultiset(Multiset<E> multiset, ObjectOutputStream stream)\n", "    static <E> void populateMultiset(Multiset<E> multiset, ObjectInputStream stream)\n", "    static <E> void populateMultiset(\n", "    static <K, V> void writeMultimap(Multimap<K, V> multimap, ObjectOutputStream stream)\n", "    static <K, V> void populateMultimap(Multimap<K, V> multimap, ObjectInputStream stream)\n", "    static <K, V> void populateMultimap(\n"], "context": "/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport com.google.common.annotations.GwtIncompatible;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.Collection;\nimport java.util.Map;\n\n/**\n * Provides static methods for serializing collection classes.\n *\n * <p>This class assists the implementation of collection classes. Do not use this class to\n * serialize collections that are defined elsewhere.\n *\n * @author Jared Levy\n */\n@GwtIncompatible\nfinal class Serialization\n{\n    private Serialization() {}\n\n    /**\n     * Reads a count corresponding to a serialized map, multiset, or multimap. It returns the size of\n     * a map serialized by {@link #writeMap(Map, ObjectOutputStream)}, the number of distinct elements\n     * in a multiset serialized by {@link #writeMultiset(Multiset, ObjectOutputStream)}, or the number\n     * of distinct keys in a multimap serialized by {@link #writeMultimap(Multimap,\n     * ObjectOutputStream)}.\n     */\n    static int readCount(ObjectInputStream stream) throws IOException\n    {\n        return stream.readInt();\n    }\n\n    /**\n     * Stores the contents of a map in an output stream, as part of serialization. It does not support\n     * concurrent maps whose content may change while the method is running.\n     *\n     * <p>The serialized output consists of the number of entries, first key, first value, second key,\n     * second value, and so on.\n     */\n    static <K, V> void writeMap(Map<K, V> map, ObjectOutputStream stream) throws IOException\n    {\n        stream.writeInt(map.size());\n        for (Map.Entry<K, V> entry : map.entrySet())\n        {\n            stream.writeObject(entry.getKey());\n            stream.writeObject(entry.getValue());\n        }\n    }\n\n    /**\n     * Populates a map by reading an input stream, as part of deserialization. See {@link #writeMap}\n     * for the data format.\n     */\n    static <K, V> void populateMap(Map<K, V> map, ObjectInputStream stream)\n    throws IOException, ClassNotFoundException\n    {\n        int size = stream.readInt();\n        populateMap(map, stream, size);\n    }\n\n    /**\n     * Populates a map by reading an input stream, as part of deserialization. See {@link #writeMap}\n     * for the data format. The size is determined by a prior call to {@link #readCount}.\n     */\n    static <K, V> void populateMap(Map<K, V> map, ObjectInputStream stream, int size)\n    throws IOException, ClassNotFoundException\n    {\n        for (int i = 0; i < size; i++)\n        {\n            @SuppressWarnings(\"unchecked\") // reading data stored by writeMap\n            K key = (K) stream.readObject();\n            @SuppressWarnings(\"unchecked\") // reading data stored by writeMap\n            V value = (V) stream.readObject();\n            map.put(key, value);\n        }\n    }\n\n    /**\n     * Stores the contents of a multiset in an output stream, as part of serialization. It does not\n     * support concurrent multisets whose content may change while the method is running.\n     *\n     * <p>The serialized output consists of the number of distinct elements, the first element, its\n     * count, the second element, its count, and so on.\n     */\n    static <E> void writeMultiset(Multiset<E> multiset, ObjectOutputStream stream)\n    throws IOException\n    {\n        int entryCount = multiset.entrySet().size();\n        stream.writeInt(entryCount);\n        for (Multiset.Entry<E> entry : multiset.entrySet())\n        {\n            stream.writeObject(entry.getElement());\n            stream.writeInt(entry.getCount());\n        }\n    }\n\n    /**\n     * Populates a multiset by reading an input stream, as part of deserialization. See {@link\n     * #writeMultiset} for the data format.\n     */\n    static <E> void populateMultiset(Multiset<E> multiset, ObjectInputStream stream)\n    throws IOException, ClassNotFoundException\n    {\n        int distinctElements = stream.readInt();\n        populateMultiset(multiset, stream, distinctElements);\n    }\n\n    /**\n     * Populates a multiset by reading an input stream, as part of deserialization. See {@link\n     * #writeMultiset} for the data format. The number of distinct elements is determined by a prior\n     * call to {@link #readCount}.\n     */\n    static <E> void populateMultiset(\n        Multiset<E> multiset, ObjectInputStream stream, int distinctElements)\n    throws IOException, ClassNotFoundException\n    {\n        for (int i = 0; i < distinctElements; i++)\n        {\n            @SuppressWarnings(\"unchecked\") // reading data stored by writeMultiset\n            E element = (E) stream.readObject();\n            int count = stream.readInt();\n            multiset.add(element, count);\n        }\n    }\n\n    /**\n     * Stores the contents of a multimap in an output stream, as part of serialization. It does not\n     * support concurrent multimaps whose content may change while the method is running. The {@link\n     * Multimap#asMap} view determines the ordering in which data is written to the stream.\n     *\n     * <p>The serialized output consists of the number of distinct keys, and then for each distinct\n     * key: the key, the number of values for that key, and the key's values.\n     */\n    static <K, V> void writeMultimap(Multimap<K, V> multimap, ObjectOutputStream stream)\n    throws IOException\n    {\n        stream.writeInt(multimap.asMap().size());\n        for (Map.Entry<K, Collection<V>> entry : multimap.asMap().entrySet())\n        {\n            stream.writeObject(entry.getKey());\n            stream.writeInt(entry.getValue().size());\n            for (V value : entry.getValue())\n            {\n                stream.writeObject(value);\n            }\n        }\n    }\n\n    /**\n     * Populates a multimap by reading an input stream, as part of deserialization. See {@link\n     * #writeMultimap} for the data format.\n     */\n    static <K, V> void populateMultimap(Multimap<K, V> multimap, ObjectInputStream stream)\n    throws IOException, ClassNotFoundException\n    {\n        int distinctKeys = stream.readInt();\n        populateMultimap(multimap, stream, distinctKeys);\n    }\n\n    /**\n     * Populates a multimap by reading an input stream, as part of deserialization. See {@link\n     * #writeMultimap} for the data format. The number of distinct keys is determined by a prior call\n     * to {@link #readCount}.\n     */\n    static <K, V> void populateMultimap(\n        Multimap<K, V> multimap, ObjectInputStream stream, int distinctKeys)\n    throws IOException, ClassNotFoundException\n    {\n        for (int i = 0; i < distinctKeys; i++)\n        {\n            @SuppressWarnings(\"unchecked\") // reading data stored by writeMultimap\n            K key = (K) stream.readObject();\n            Collection<V> values = multimap.get(key);\n            int valueCount = stream.readInt();\n            for (int j = 0; j < valueCount; j++)\n            {\n                @SuppressWarnings(\"unchecked\") // reading data stored by writeMultimap\n                V value = (V) stream.readObject();\n                values.add(value);\n            }\n        }\n    }\n\n    // Secret sauce for setting final fields; don't make it public.\n\n    // Secret sauce for setting final fields; don't make it public.\n    static final class FieldSetter<T>\n    {\n        private final Field field;\n\n        private FieldSetter(Field field)\n        {\n            this.field = field;\n            field.setAccessible(true);\n        }\n\n        void set(T instance, Object value)\n        {\n            try\n            {\n                field.set(instance, value);\n            }\n            catch (IllegalAccessException impossible)\n            {\n                throw new AssertionError(impossible);\n            }\n        }\n\n        void set(T instance, int value)\n        {\n            try\n            {\n                field.set(instance, value);\n            }\n            catch (IllegalAccessException impossible)\n            {\n                throw new AssertionError(impossible);\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/base/Stopwatch.java", "func_name": "Stopwatch.start", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Starts the stopwatch.\n\n@return this {@code Stopwatch} instance\n@throws IllegalStateException if the stopwatch is already running.", "docstring_tokens": ["Starts", "the", "stopwatch", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/base/Stopwatch.java#L148-L154", "partition": "valid", "up_fun_num": 6, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.base.Preconditions.checkState;", "import static java.util.concurrent.TimeUnit.DAYS;", "import static java.util.concurrent.TimeUnit.HOURS;", "import static java.util.concurrent.TimeUnit.MICROSECONDS;", "import static java.util.concurrent.TimeUnit.MILLISECONDS;", "import static java.util.concurrent.TimeUnit.MINUTES;", "import static java.util.concurrent.TimeUnit.NANOSECONDS;", "import static java.util.concurrent.TimeUnit.SECONDS;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import com.google.j2objc.annotations.J2ObjCIncompatible;", "import java.time.Duration;", "import java.util.concurrent.TimeUnit;"], "function": ["public final class Stopwatch\n", "    public static Stopwatch createUnstarted()\n", "    public static Stopwatch createUnstarted(Ticker ticker)\n", "    public static Stopwatch createStarted()\n", "    public static Stopwatch createStarted(Ticker ticker)\n", "    public boolean isRunning()\n", "    public Stopwatch stop()\n", "    public Stopwatch reset()\n", "    private long elapsedNanos()\n", "    public long elapsed(TimeUnit desiredUnit)\n", "    public Duration elapsed()\n", "    public String toString()\n", "    private static TimeUnit chooseUnit(long nanos)\n", "    private static String abbreviate(TimeUnit unit)\n"], "context": "/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.base;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static java.util.concurrent.TimeUnit.DAYS;\nimport static java.util.concurrent.TimeUnit.HOURS;\nimport static java.util.concurrent.TimeUnit.MICROSECONDS;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static java.util.concurrent.TimeUnit.MINUTES;\nimport static java.util.concurrent.TimeUnit.NANOSECONDS;\nimport static java.util.concurrent.TimeUnit.SECONDS;\n\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.google.j2objc.annotations.J2ObjCIncompatible;\nimport java.time.Duration;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * An object that measures elapsed time in nanoseconds. It is useful to measure elapsed time using\n * this class instead of direct calls to {@link System#nanoTime} for a few reasons:\n *\n * <ul>\n *   <li>An alternate time source can be substituted, for testing or performance reasons.\n *   <li>As documented by {@code nanoTime}, the value returned has no absolute meaning, and can only\n *       be interpreted as relative to another timestamp returned by {@code nanoTime} at a different\n *       time. {@code Stopwatch} is a more effective abstraction because it exposes only these\n *       relative values, not the absolute ones.\n * </ul>\n *\n * <p>Basic usage:\n *\n * <pre>{@code\n * Stopwatch stopwatch = Stopwatch.createStarted();\n * doSomething();\n * stopwatch.stop(); // optional\n *\n * Duration duration = stopwatch.elapsed();\n *\n * log.info(\"time: \" + stopwatch); // formatted string like \"12.3 ms\"\n * }</pre>\n *\n * <p>Stopwatch methods are not idempotent; it is an error to start or stop a stopwatch that is\n * already in the desired state.\n *\n * <p>When testing code that uses this class, use {@link #createUnstarted(Ticker)} or {@link\n * #createStarted(Ticker)} to supply a fake or mock ticker. This allows you to simulate any valid\n * behavior of the stopwatch.\n *\n * <p><b>Note:</b> This class is not thread-safe.\n *\n * <p><b>Warning for Android users:</b> a stopwatch with default behavior may not continue to keep\n * time while the device is asleep. Instead, create one like this:\n *\n * <pre>{@code\n * Stopwatch.createStarted(\n *      new Ticker() {\n *        public long read() {\n *          return android.os.SystemClock.elapsedRealtimeNanos();\n *        }\n *      });\n * }</pre>\n *\n * @author Kevin Bourrillion\n * @since 10.0\n */\n@GwtCompatible(emulated = true)\n@SuppressWarnings(\"GoodTime\") // lots of violations\npublic final class Stopwatch\n{\n    private final Ticker ticker;\n    private boolean isRunning;\n    private long elapsedNanos;\n    private long startTick;\n\n    /**\n     * Creates (but does not start) a new stopwatch using {@link System#nanoTime} as its time source.\n     *\n     * @since 15.0\n     */\n    public static Stopwatch createUnstarted()\n    {\n        return new Stopwatch();\n    }\n\n    /**\n     * Creates (but does not start) a new stopwatch, using the specified time source.\n     *\n     * @since 15.0\n     */\n    public static Stopwatch createUnstarted(Ticker ticker)\n    {\n        return new Stopwatch(ticker);\n    }\n\n    /**\n     * Creates (and starts) a new stopwatch using {@link System#nanoTime} as its time source.\n     *\n     * @since 15.0\n     */\n    public static Stopwatch createStarted()\n    {\n        return new Stopwatch().start();\n    }\n\n    /**\n     * Creates (and starts) a new stopwatch, using the specified time source.\n     *\n     * @since 15.0\n     */\n    public static Stopwatch createStarted(Ticker ticker)\n    {\n        return new Stopwatch(ticker).start();\n    }\n\n    Stopwatch()\n    {\n        this.ticker = Ticker.systemTicker();\n    }\n\n    Stopwatch(Ticker ticker)\n    {\n        this.ticker = checkNotNull(ticker, \"ticker\");\n    }\n\n    /**\n     * Returns {@code true} if {@link #start()} has been called on this stopwatch, and {@link #stop()}\n     * has not been called since the last call to {@code start()}.\n     */\n    public boolean isRunning()\n    {\n        return isRunning;\n    }\n\n    /**\n     * Starts the stopwatch.\n     *\n     * @return this {@code Stopwatch} instance\n     * @throws IllegalStateException if the stopwatch is already running.\n     */\n\n    /**\n     * Stops the stopwatch. Future reads will return the fixed duration that had elapsed up to this\n     * point.\n     *\n     * @return this {@code Stopwatch} instance\n     * @throws IllegalStateException if the stopwatch is already stopped.\n     */\n    @CanIgnoreReturnValue\n    public Stopwatch stop()\n    {\n        long tick = ticker.read();\n        checkState(isRunning, \"This stopwatch is already stopped.\");\n        isRunning = false;\n        elapsedNanos += tick - startTick;\n        return this;\n    }\n\n    /**\n     * Sets the elapsed time for this stopwatch to zero, and places it in a stopped state.\n     *\n     * @return this {@code Stopwatch} instance\n     */\n    @CanIgnoreReturnValue\n    public Stopwatch reset()\n    {\n        elapsedNanos = 0;\n        isRunning = false;\n        return this;\n    }\n\n    private long elapsedNanos()\n    {\n        return isRunning ? ticker.read() - startTick + elapsedNanos : elapsedNanos;\n    }\n\n    /**\n     * Returns the current elapsed time shown on this stopwatch, expressed in the desired time unit,\n     * with any fraction rounded down.\n     *\n     * <p><b>Note:</b> the overhead of measurement can be more than a microsecond, so it is generally\n     * not useful to specify {@link TimeUnit#NANOSECONDS} precision here.\n     *\n     * <p>It is generally not a good idea to use an ambiguous, unitless {@code long} to represent\n     * elapsed time. Therefore, we recommend using {@link #elapsed()} instead, which returns a\n     * strongly-typed {@link Duration} instance.\n     *\n     * @since 14.0 (since 10.0 as {@code elapsedTime()})\n     */\n    public long elapsed(TimeUnit desiredUnit)\n    {\n        return desiredUnit.convert(elapsedNanos(), NANOSECONDS);\n    }\n\n    /**\n     * Returns the current elapsed time shown on this stopwatch as a {@link Duration}. Unlike {@link\n     * #elapsed(TimeUnit)}, this method does not lose any precision due to rounding.\n     *\n     * @since 22.0\n     */\n    @GwtIncompatible\n    @J2ObjCIncompatible\n    public Duration elapsed()\n    {\n        return Duration.ofNanos(elapsedNanos());\n    }\n\n    /** Returns a string representation of the current elapsed time. */\n    @Override\n    public String toString()\n    {\n        long nanos = elapsedNanos();\n\n        TimeUnit unit = chooseUnit(nanos);\n        double value = (double) nanos / NANOSECONDS.convert(1, unit);\n\n        // Too bad this functionality is not exposed as a regular method call\n        return Platform.formatCompact4Digits(value) + \" \" + abbreviate(unit);\n    }\n\n    private static TimeUnit chooseUnit(long nanos)\n    {\n        if (DAYS.convert(nanos, NANOSECONDS) > 0)\n        {\n            return DAYS;\n        }\n        if (HOURS.convert(nanos, NANOSECONDS) > 0)\n        {\n            return HOURS;\n        }\n        if (MINUTES.convert(nanos, NANOSECONDS) > 0)\n        {\n            return MINUTES;\n        }\n        if (SECONDS.convert(nanos, NANOSECONDS) > 0)\n        {\n            return SECONDS;\n        }\n        if (MILLISECONDS.convert(nanos, NANOSECONDS) > 0)\n        {\n            return MILLISECONDS;\n        }\n        if (MICROSECONDS.convert(nanos, NANOSECONDS) > 0)\n        {\n            return MICROSECONDS;\n        }\n        return NANOSECONDS;\n    }\n\n    private static String abbreviate(TimeUnit unit)\n    {\n        switch (unit)\n        {\n        case NANOSECONDS:\n            return \"ns\";\n        case MICROSECONDS:\n            return \"\\u03bcs\"; // \u03bcs\n        case MILLISECONDS:\n            return \"ms\";\n        case SECONDS:\n            return \"s\";\n        case MINUTES:\n            return \"min\";\n        case HOURS:\n            return \"h\";\n        case DAYS:\n            return \"d\";\n        default:\n            throw new AssertionError();\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/ConcurrentHashMultiset.java", "func_name": "ConcurrentHashMultiset.add", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Adds a number of occurrences of the specified element to this multiset.\n\n@param element the element to add\n@param occurrences the number of occurrences to add\n@return the previous count of the element before the operation; possibly zero\n@throws IllegalArgumentException if {@code occurrences} is negative, or if the resulting amount\nwould exceed {@link Integer#MAX_VALUE}", "docstring_tokens": ["Adds", "a", "number", "of", "occurrences", "of", "the", "specified", "element", "to", "this", "multiset", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/ConcurrentHashMultiset.java#L201-L248", "partition": "valid", "up_fun_num": 9, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.collect.CollectPreconditions.checkNonnegative;", "import static com.google.common.collect.CollectPreconditions.checkRemove;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.annotations.VisibleForTesting;", "import com.google.common.collect.Serialization.FieldSetter;", "import com.google.common.math.IntMath;", "import com.google.common.primitives.Ints;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import com.google.j2objc.annotations.WeakOuter;", "import java.io.IOException;", "import java.io.ObjectInputStream;", "import java.io.ObjectOutputStream;", "import java.io.Serializable;", "import java.util.Collection;", "import java.util.Iterator;", "import java.util.List;", "import java.util.Map;", "import java.util.Set;", "import java.util.concurrent.ConcurrentHashMap;", "import java.util.concurrent.ConcurrentMap;", "import java.util.concurrent.atomic.AtomicInteger;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class ConcurrentHashMultiset<E> extends AbstractMultiset<E> implements Serializable\n", "    public static <E> ConcurrentHashMultiset<E> create()\n", "    public static <E> ConcurrentHashMultiset<E> create(Iterable<? extends E> elements)\n", "    public static <E> ConcurrentHashMultiset<E> create(ConcurrentMap<E, AtomicInteger> countMap)\n", "    public int count(@NullableDecl Object element)\n", "    public int size()\n", "    public Object[] toArray()\n", "    public <T> T[] toArray(T[] array)\n", "    private List<E> snapshot()\n", "    public int remove(@NullableDecl Object element, int occurrences)\n", "    public boolean removeExactly(@NullableDecl Object element, int occurrences)\n", "    public int setCount(E element, int count)\n", "    public boolean setCount(E element, int expectedOldCount, int newCount)\n", "    Set<E> createElementSet()\n", "    Iterator<E> elementIterator()\n", "    public Set<Multiset.Entry<E>> createEntrySet()\n", "    int distinctElements()\n", "    public boolean isEmpty()\n", "    Iterator<Entry<E>> entryIterator()\n", "    public Iterator<E> iterator()\n", "    public void clear()\n", "    private void writeObject(ObjectOutputStream stream) throws IOException\n", "    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException\n"], "context": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.collect.CollectPreconditions.checkNonnegative;\nimport static com.google.common.collect.CollectPreconditions.checkRemove;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.Serialization.FieldSetter;\nimport com.google.common.math.IntMath;\nimport com.google.common.primitives.Ints;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.google.j2objc.annotations.WeakOuter;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A multiset that supports concurrent modifications and that provides atomic versions of most\n * {@code Multiset} operations (exceptions where noted). Null elements are not supported.\n *\n * <p>See the Guava User Guide article on <a href=\n * \"https://github.com/google/guava/wiki/NewCollectionTypesExplained#multiset\"> {@code\n * Multiset}</a>.\n *\n * @author Cliff L. Biffle\n * @author mike nonemacher\n * @since 2.0\n */\n@GwtIncompatible\npublic final class ConcurrentHashMultiset<E> extends AbstractMultiset<E> implements Serializable\n{\n\n    /*\n     * The ConcurrentHashMultiset's atomic operations are implemented primarily in terms of\n     * AtomicInteger's atomic operations, with some help from ConcurrentMap's atomic operations on\n     * creation and removal (including automatic removal of zeroes). If the modification of an\n     * AtomicInteger results in zero, we compareAndSet the value to zero; if that succeeds, we remove\n     * the entry from the Map. If another operation sees a zero in the map, it knows that the entry is\n     * about to be removed, so this operation may remove it (often by replacing it with a new\n     * AtomicInteger).\n     */\n\n    /** The number of occurrences of each element. */\n    private final transient ConcurrentMap<E, AtomicInteger> countMap;\n\n    // This constant allows the deserialization code to set a final field. This holder class\n    // makes sure it is not initialized unless an instance is deserialized.\n    private static class FieldSettersHolder\n    {\n        static final FieldSetter<ConcurrentHashMultiset> COUNT_MAP_FIELD_SETTER =\n            Serialization.getFieldSetter(ConcurrentHashMultiset.class, \"countMap\");\n    }\n\n    /**\n     * Creates a new, empty {@code ConcurrentHashMultiset} using the default initial capacity, load\n     * factor, and concurrency settings.\n     */\n    public static <E> ConcurrentHashMultiset<E> create()\n    {\n        // TODO(schmoe): provide a way to use this class with other (possibly arbitrary)\n        // ConcurrentMap implementors. One possibility is to extract most of this class into\n        // an AbstractConcurrentMapMultiset.\n        return new ConcurrentHashMultiset<E>(new ConcurrentHashMap<E, AtomicInteger>());\n    }\n\n    /**\n     * Creates a new {@code ConcurrentHashMultiset} containing the specified elements, using the\n     * default initial capacity, load factor, and concurrency settings.\n     *\n     * <p>This implementation is highly efficient when {@code elements} is itself a {@link Multiset}.\n     *\n     * @param elements the elements that the multiset should contain\n     */\n    public static <E> ConcurrentHashMultiset<E> create(Iterable<? extends E> elements)\n    {\n        ConcurrentHashMultiset<E> multiset = ConcurrentHashMultiset.create();\n        Iterables.addAll(multiset, elements);\n        return multiset;\n    }\n\n    /**\n     * Creates a new, empty {@code ConcurrentHashMultiset} using {@code countMap} as the internal\n     * backing map.\n     *\n     * <p>This instance will assume ownership of {@code countMap}, and other code should not maintain\n     * references to the map or modify it in any way.\n     *\n     * <p>The returned multiset is serializable if the input map is.\n     *\n     * @param countMap backing map for storing the elements in the multiset and their counts. It must\n     *     be empty.\n     * @throws IllegalArgumentException if {@code countMap} is not empty\n     * @since 20.0\n     */\n    @Beta\n    public static <E> ConcurrentHashMultiset<E> create(ConcurrentMap<E, AtomicInteger> countMap)\n    {\n        return new ConcurrentHashMultiset<E>(countMap);\n    }\n\n    @VisibleForTesting\n    ConcurrentHashMultiset(ConcurrentMap<E, AtomicInteger> countMap)\n    {\n        checkArgument(countMap.isEmpty(), \"the backing map (%s) must be empty\", countMap);\n        this.countMap = countMap;\n    }\n\n    // Query Operations\n\n    /**\n     * Returns the number of occurrences of {@code element} in this multiset.\n     *\n     * @param element the element to look for\n     * @return the nonnegative number of occurrences of the element\n     */\n    @Override\n    public int count(@NullableDecl Object element)\n    {\n        AtomicInteger existingCounter = Maps.safeGet(countMap, element);\n        return (existingCounter == null) ? 0 : existingCounter.get();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>If the data in the multiset is modified by any other threads during this method, it is\n     * undefined which (if any) of these modifications will be reflected in the result.\n     */\n    @Override\n    public int size()\n    {\n        long sum = 0L;\n        for (AtomicInteger value : countMap.values())\n        {\n            sum += value.get();\n        }\n        return Ints.saturatedCast(sum);\n    }\n\n    /*\n     * Note: the superclass toArray() methods assume that size() gives a correct\n     * answer, which ours does not.\n     */\n\n    @Override\n    public Object[] toArray()\n    {\n        return snapshot().toArray();\n    }\n\n    @Override\n    public <T> T[] toArray(T[] array)\n    {\n        return snapshot().toArray(array);\n    }\n\n    /*\n     * We'd love to use 'new ArrayList(this)' or 'list.addAll(this)', but\n     * either of these would recurse back to us again!\n     */\n    private List<E> snapshot()\n    {\n        List<E> list = Lists.newArrayListWithExpectedSize(size());\n        for (Multiset.Entry<E> entry : entrySet())\n        {\n            E element = entry.getElement();\n            for (int i = entry.getCount(); i > 0; i--)\n            {\n                list.add(element);\n            }\n        }\n        return list;\n    }\n\n    // Modification Operations\n\n    /**\n     * Adds a number of occurrences of the specified element to this multiset.\n     *\n     * @param element the element to add\n     * @param occurrences the number of occurrences to add\n     * @return the previous count of the element before the operation; possibly zero\n     * @throws IllegalArgumentException if {@code occurrences} is negative, or if the resulting amount\n     *     would exceed {@link Integer#MAX_VALUE}\n     */\n\n    /**\n     * Removes a number of occurrences of the specified element from this multiset. If the multiset\n     * contains fewer than this number of occurrences to begin with, all occurrences will be removed.\n     *\n     * @param element the element whose occurrences should be removed\n     * @param occurrences the number of occurrences of the element to remove\n     * @return the count of the element before the operation; possibly zero\n     * @throws IllegalArgumentException if {@code occurrences} is negative\n     */\n    /*\n     * TODO(cpovirk): remove and removeExactly currently accept null inputs only\n     * if occurrences == 0. This satisfies both NullPointerTester and\n     * CollectionRemoveTester.testRemove_nullAllowed, but it's not clear that it's\n     * a good policy, especially because, in order for the test to pass, the\n     * parameter must be misleadingly annotated as @NullableDecl. I suspect that\n     * we'll want to remove @NullableDecl, add an eager checkNotNull, and loosen up\n     * testRemove_nullAllowed.\n     */\n    @CanIgnoreReturnValue\n    @Override\n    public int remove(@NullableDecl Object element, int occurrences)\n    {\n        if (occurrences == 0)\n        {\n            return count(element);\n        }\n        CollectPreconditions.checkPositive(occurrences, \"occurences\");\n\n        AtomicInteger existingCounter = Maps.safeGet(countMap, element);\n        if (existingCounter == null)\n        {\n            return 0;\n        }\n        while (true)\n        {\n            int oldValue = existingCounter.get();\n            if (oldValue != 0)\n            {\n                int newValue = Math.max(0, oldValue - occurrences);\n                if (existingCounter.compareAndSet(oldValue, newValue))\n                {\n                    if (newValue == 0)\n                    {\n                        // Just CASed to 0; remove the entry to clean up the map. If the removal fails,\n                        // another thread has already replaced it with a new counter, which is fine.\n                        countMap.remove(element, existingCounter);\n                    }\n                    return oldValue;\n                }\n            }\n            else\n            {\n                return 0;\n            }\n        }\n    }\n\n    /**\n     * Removes exactly the specified number of occurrences of {@code element}, or makes no change if\n     * this is not possible.\n     *\n     * <p>This method, in contrast to {@link #remove(Object, int)}, has no effect when the element\n     * count is smaller than {@code occurrences}.\n     *\n     * @param element the element to remove\n     * @param occurrences the number of occurrences of {@code element} to remove\n     * @return {@code true} if the removal was possible (including if {@code occurrences} is zero)\n     * @throws IllegalArgumentException if {@code occurrences} is negative\n     */\n    @CanIgnoreReturnValue\n    public boolean removeExactly(@NullableDecl Object element, int occurrences)\n    {\n        if (occurrences == 0)\n        {\n            return true;\n        }\n        CollectPreconditions.checkPositive(occurrences, \"occurences\");\n\n        AtomicInteger existingCounter = Maps.safeGet(countMap, element);\n        if (existingCounter == null)\n        {\n            return false;\n        }\n        while (true)\n        {\n            int oldValue = existingCounter.get();\n            if (oldValue < occurrences)\n            {\n                return false;\n            }\n            int newValue = oldValue - occurrences;\n            if (existingCounter.compareAndSet(oldValue, newValue))\n            {\n                if (newValue == 0)\n                {\n                    // Just CASed to 0; remove the entry to clean up the map. If the removal fails,\n                    // another thread has already replaced it with a new counter, which is fine.\n                    countMap.remove(element, existingCounter);\n                }\n                return true;\n            }\n        }\n    }\n\n    /**\n     * Adds or removes occurrences of {@code element} such that the {@link #count} of the element\n     * becomes {@code count}.\n     *\n     * @return the count of {@code element} in the multiset before this call\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    @CanIgnoreReturnValue\n    @Override\n    public int setCount(E element, int count)\n    {\n        checkNotNull(element);\n        checkNonnegative(count, \"count\");\n        while (true)\n        {\n            AtomicInteger existingCounter = Maps.safeGet(countMap, element);\n            if (existingCounter == null)\n            {\n                if (count == 0)\n                {\n                    return 0;\n                }\n                else\n                {\n                    existingCounter = countMap.putIfAbsent(element, new AtomicInteger(count));\n                    if (existingCounter == null)\n                    {\n                        return 0;\n                    }\n                    // existingCounter != null: fall through\n                }\n            }\n\n            while (true)\n            {\n                int oldValue = existingCounter.get();\n                if (oldValue == 0)\n                {\n                    if (count == 0)\n                    {\n                        return 0;\n                    }\n                    else\n                    {\n                        AtomicInteger newCounter = new AtomicInteger(count);\n                        if ((countMap.putIfAbsent(element, newCounter) == null)\n                                || countMap.replace(element, existingCounter, newCounter))\n                        {\n                            return 0;\n                        }\n                    }\n                    break;\n                }\n                else\n                {\n                    if (existingCounter.compareAndSet(oldValue, count))\n                    {\n                        if (count == 0)\n                        {\n                            // Just CASed to 0; remove the entry to clean up the map. If the removal fails,\n                            // another thread has already replaced it with a new counter, which is fine.\n                            countMap.remove(element, existingCounter);\n                        }\n                        return oldValue;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Sets the number of occurrences of {@code element} to {@code newCount}, but only if the count is\n     * currently {@code expectedOldCount}. If {@code element} does not appear in the multiset exactly\n     * {@code expectedOldCount} times, no changes will be made.\n     *\n     * @return {@code true} if the change was successful. This usually indicates that the multiset has\n     *     been modified, but not always: in the case that {@code expectedOldCount == newCount}, the\n     *     method will return {@code true} if the condition was met.\n     * @throws IllegalArgumentException if {@code expectedOldCount} or {@code newCount} is negative\n     */\n    @CanIgnoreReturnValue\n    @Override\n    public boolean setCount(E element, int expectedOldCount, int newCount)\n    {\n        checkNotNull(element);\n        checkNonnegative(expectedOldCount, \"oldCount\");\n        checkNonnegative(newCount, \"newCount\");\n\n        AtomicInteger existingCounter = Maps.safeGet(countMap, element);\n        if (existingCounter == null)\n        {\n            if (expectedOldCount != 0)\n            {\n                return false;\n            }\n            else if (newCount == 0)\n            {\n                return true;\n            }\n            else\n            {\n                // if our write lost the race, it must have lost to a nonzero value, so we can stop\n                return countMap.putIfAbsent(element, new AtomicInteger(newCount)) == null;\n            }\n        }\n        int oldValue = existingCounter.get();\n        if (oldValue == expectedOldCount)\n        {\n            if (oldValue == 0)\n            {\n                if (newCount == 0)\n                {\n                    // Just observed a 0; try to remove the entry to clean up the map\n                    countMap.remove(element, existingCounter);\n                    return true;\n                }\n                else\n                {\n                    AtomicInteger newCounter = new AtomicInteger(newCount);\n                    return (countMap.putIfAbsent(element, newCounter) == null)\n                           || countMap.replace(element, existingCounter, newCounter);\n                }\n            }\n            else\n            {\n                if (existingCounter.compareAndSet(oldValue, newCount))\n                {\n                    if (newCount == 0)\n                    {\n                        // Just CASed to 0; remove the entry to clean up the map. If the removal fails,\n                        // another thread has already replaced it with a new counter, which is fine.\n                        countMap.remove(element, existingCounter);\n                    }\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    // Views\n\n    @Override\n    Set<E> createElementSet()\n    {\n        final Set<E> delegate = countMap.keySet();\n        return new ForwardingSet<E>()\n        {\n            @Override\n            protected Set<E> delegate()\n            {\n                return delegate;\n            }\n\n            @Override\n            public boolean contains(@NullableDecl Object object)\n            {\n                return object != null && Collections2.safeContains(delegate, object);\n            }\n\n            @Override\n            public boolean containsAll(Collection<?> collection)\n            {\n                return standardContainsAll(collection);\n            }\n\n            @Override\n            public boolean remove(Object object)\n            {\n                return object != null && Collections2.safeRemove(delegate, object);\n            }\n\n            @Override\n            public boolean removeAll(Collection<?> c)\n            {\n                return standardRemoveAll(c);\n            }\n        };\n    }\n\n    @Override\n    Iterator<E> elementIterator()\n    {\n        throw new AssertionError(\"should never be called\");\n    }\n\n    /** @deprecated Internal method, use {@link #entrySet()}. */\n    @Deprecated\n    @Override\n    public Set<Multiset.Entry<E>> createEntrySet()\n    {\n        return new EntrySet();\n    }\n\n    @Override\n    int distinctElements()\n    {\n        return countMap.size();\n    }\n\n    @Override\n    public boolean isEmpty()\n    {\n        return countMap.isEmpty();\n    }\n\n    @Override\n    Iterator<Entry<E>> entryIterator()\n    {\n        // AbstractIterator makes this fairly clean, but it doesn't support remove(). To support\n        // remove(), we create an AbstractIterator, and then use ForwardingIterator to delegate to it.\n        final Iterator<Entry<E>> readOnlyIterator =\n            new AbstractIterator<Entry<E>>()\n        {\n            private final Iterator<Map.Entry<E, AtomicInteger>> mapEntries =\n                countMap.entrySet().iterator();\n\n            @Override\n            protected Entry<E> computeNext()\n            {\n                while (true)\n                {\n                    if (!mapEntries.hasNext())\n                    {\n                        return endOfData();\n                    }\n                    Map.Entry<E, AtomicInteger> mapEntry = mapEntries.next();\n                    int count = mapEntry.getValue().get();\n                    if (count != 0)\n                    {\n                        return Multisets.immutableEntry(mapEntry.getKey(), count);\n                    }\n                }\n            }\n        };\n\n        return new ForwardingIterator<Entry<E>>()\n        {\n            @NullableDecl private Entry<E> last;\n\n            @Override\n            protected Iterator<Entry<E>> delegate()\n            {\n                return readOnlyIterator;\n            }\n\n            @Override\n            public Entry<E> next()\n            {\n                last = super.next();\n                return last;\n            }\n\n            @Override\n            public void remove()\n            {\n                checkRemove(last != null);\n                ConcurrentHashMultiset.this.setCount(last.getElement(), 0);\n                last = null;\n            }\n        };\n    }\n\n    @Override\n    public Iterator<E> iterator()\n    {\n        return Multisets.iteratorImpl(this);\n    }\n\n    @Override\n    public void clear()\n    {\n        countMap.clear();\n    }\n\n    @WeakOuter\n    private class EntrySet extends AbstractMultiset<E>.EntrySet\n    {\n        @Override\n        ConcurrentHashMultiset<E> multiset()\n        {\n            return ConcurrentHashMultiset.this;\n        }\n\n        /*\n         * Note: the superclass toArray() methods assume that size() gives a correct\n         * answer, which ours does not.\n         */\n\n        @Override\n        public Object[] toArray()\n        {\n            return snapshot().toArray();\n        }\n\n        @Override\n        public <T> T[] toArray(T[] array)\n        {\n            return snapshot().toArray(array);\n        }\n\n        private List<Multiset.Entry<E>> snapshot()\n        {\n            List<Multiset.Entry<E>> list = Lists.newArrayListWithExpectedSize(size());\n            // Not Iterables.addAll(list, this), because that'll forward right back here.\n            Iterators.addAll(list, iterator());\n            return list;\n        }\n    }\n\n    /** @serialData the ConcurrentMap of elements and their counts. */\n    private void writeObject(ObjectOutputStream stream) throws IOException\n    {\n        stream.defaultWriteObject();\n        stream.writeObject(countMap);\n    }\n\n    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException\n    {\n        stream.defaultReadObject();\n        @SuppressWarnings(\"unchecked\") // reading data stored by writeObject\n        ConcurrentMap<E, Integer> deserializedCountMap =\n            (ConcurrentMap<E, Integer>) stream.readObject();\n        FieldSettersHolder.COUNT_MAP_FIELD_SETTER.set(this, deserializedCountMap);\n    }\n\n    private static final long serialVersionUID = 1;\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/CompactHashSet.java", "func_name": "CompactHashSet.resizeMeMaybe", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Resizes the entries storage if necessary.", "docstring_tokens": ["Resizes", "the", "entries", "storage", "if", "necessary", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/CompactHashSet.java#L283-L294", "partition": "valid", "up_fun_num": 17, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.collect.CollectPreconditions.checkRemove;", "import static com.google.common.collect.Hashing.smearedHash;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.annotations.VisibleForTesting;", "import com.google.common.base.Objects;", "import com.google.common.base.Preconditions;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.io.IOException;", "import java.io.InvalidObjectException;", "import java.io.ObjectInputStream;", "import java.io.ObjectOutputStream;", "import java.io.Serializable;", "import java.util.AbstractSet;", "import java.util.Arrays;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.ConcurrentModificationException;", "import java.util.Iterator;", "import java.util.NoSuchElementException;", "import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["class CompactHashSet<E> extends AbstractSet<E> implements Serializable\n", "    public static <E> CompactHashSet<E> create()\n", "    public static <E> CompactHashSet<E> create(Collection<? extends E> collection)\n", "    public static <E> CompactHashSet<E> create(E... elements)\n", "    public static <E> CompactHashSet<E> createWithExpectedSize(int expectedSize)\n", "    void init(int expectedSize)\n", "    boolean needsAllocArrays()\n", "    void allocArrays()\n", "    private static int[] newTable(int size)\n", "    private static long[] newEntries(int size)\n", "    private int hashTableMask()\n", "    private static int getHash(long entry)\n", "    private static int getNext(long entry)\n", "    private static long swapNext(long entry, int newNext)\n", "    public boolean add(@NullableDecl E object)\n", "    void insertEntry(int entryIndex, E object, int hash)\n", "    void resizeEntries(int newCapacity)\n", "    private void resizeTable(int newCapacity)   // newCapacity always a power of two\n", "    public boolean contains(@NullableDecl Object object)\n", "    public boolean remove(@NullableDecl Object object)\n", "    private boolean remove(Object object, int hash)\n", "    void moveLastEntry(int dstIndex)\n", "    int firstEntryIndex()\n", "    int getSuccessor(int entryIndex)\n", "    int adjustAfterRemove(int indexBeforeRemove, @SuppressWarnings(\"unused\") int indexRemoved)\n", "    public Iterator<E> iterator()\n", "    public int size()\n", "    public boolean isEmpty()\n", "    public Object[] toArray()\n", "    public <T> T[] toArray(T[] a)\n", "    public void trimToSize()\n", "    public void clear()\n", "    private void writeObject(ObjectOutputStream stream) throws IOException\n", "    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException\n"], "context": "/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.collect.CollectPreconditions.checkRemove;\nimport static com.google.common.collect.Hashing.smearedHash;\n\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Objects;\nimport com.google.common.base.Preconditions;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.IOException;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.AbstractSet;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.ConcurrentModificationException;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * CompactHashSet is an implementation of a Set. All optional operations (adding and removing) are\n * supported. The elements can be any objects.\n *\n * <p>{@code contains(x)}, {@code add(x)} and {@code remove(x)}, are all (expected and amortized)\n * constant time operations. Expected in the hashtable sense (depends on the hash function doing a\n * good job of distributing the elements to the buckets to a distribution not far from uniform), and\n * amortized since some operations can trigger a hash table resize.\n *\n * <p>Unlike {@code java.util.HashSet}, iteration is only proportional to the actual {@code size()},\n * which is optimal, and <i>not</i> the size of the internal hashtable, which could be much larger\n * than {@code size()}. Furthermore, this structure only depends on a fixed number of arrays; {@code\n * add(x)} operations <i>do not</i> create objects for the garbage collector to deal with, and for\n * every element added, the garbage collector will have to traverse {@code 1.5} references on\n * average, in the marking phase, not {@code 5.0} as in {@code java.util.HashSet}.\n *\n * <p>If there are no removals, then {@link #iterator iteration} order is the same as insertion\n * order. Any removal invalidates any ordering guarantees.\n *\n * <p>This class should not be assumed to be universally superior to {@code java.util.HashSet}.\n * Generally speaking, this class reduces object allocation and memory consumption at the price of\n * moderately increased constant factors of CPU. Only use this class when there is a specific reason\n * to prioritize memory over CPU.\n *\n * @author Dimitris Andreou\n */\n@GwtIncompatible // not worth using in GWT for now\nclass CompactHashSet<E> extends AbstractSet<E> implements Serializable\n{\n    // TODO(user): cache all field accesses in local vars\n\n    /** Creates an empty {@code CompactHashSet} instance. */\n    public static <E> CompactHashSet<E> create()\n    {\n        return new CompactHashSet<>();\n    }\n\n    /**\n     * Creates a <i>mutable</i> {@code CompactHashSet} instance containing the elements of the given\n     * collection in unspecified order.\n     *\n     * @param collection the elements that the set should contain\n     * @return a new {@code CompactHashSet} containing those elements (minus duplicates)\n     */\n    public static <E> CompactHashSet<E> create(Collection<? extends E> collection)\n    {\n        CompactHashSet<E> set = createWithExpectedSize(collection.size());\n        set.addAll(collection);\n        return set;\n    }\n\n    /**\n     * Creates a <i>mutable</i> {@code CompactHashSet} instance containing the given elements in\n     * unspecified order.\n     *\n     * @param elements the elements that the set should contain\n     * @return a new {@code CompactHashSet} containing those elements (minus duplicates)\n     */\n    public static <E> CompactHashSet<E> create(E... elements)\n    {\n        CompactHashSet<E> set = createWithExpectedSize(elements.length);\n        Collections.addAll(set, elements);\n        return set;\n    }\n\n    /**\n     * Creates a {@code CompactHashSet} instance, with a high enough \"initial capacity\" that it\n     * <i>should</i> hold {@code expectedSize} elements without growth.\n     *\n     * @param expectedSize the number of elements you expect to add to the returned set\n     * @return a new, empty {@code CompactHashSet} with enough capacity to hold {@code expectedSize}\n     *     elements without resizing\n     * @throws IllegalArgumentException if {@code expectedSize} is negative\n     */\n    public static <E> CompactHashSet<E> createWithExpectedSize(int expectedSize)\n    {\n        return new CompactHashSet<>(expectedSize);\n    }\n\n    private static final float LOAD_FACTOR = 1.0f;\n\n    /** Bitmask that selects the low 32 bits. */\n    private static final long NEXT_MASK = (1L << 32) - 1;\n\n    /** Bitmask that selects the high 32 bits. */\n    private static final long HASH_MASK = ~NEXT_MASK;\n\n    // TODO(user): decide default size\n    @VisibleForTesting static final int DEFAULT_SIZE = 3;\n\n    // used to indicate blank table entries\n    static final int UNSET = -1;\n\n    /**\n     * The hashtable. Its values are indexes to the elements and entries arrays.\n     *\n     * <p>Currently, the UNSET value means \"null pointer\", and any non negative value x is the actual\n     * index.\n     *\n     * <p>Its size must be a power of two.\n     */\n    @MonotonicNonNullDecl private transient int[] table;\n\n    /**\n     * Contains the logical entries, in the range of [0, size()). The high 32 bits of each long is the\n     * smeared hash of the element, whereas the low 32 bits is the \"next\" pointer (pointing to the\n     * next entry in the bucket chain). The pointers in [size(), entries.length) are all \"null\"\n     * (UNSET).\n     */\n    @MonotonicNonNullDecl private transient long[] entries;\n\n    /**\n     * The elements contained in the set, in the range of [0, size()). The elements in [size(),\n     * elements.length) are all {@code null}.\n     */\n    @MonotonicNonNullDecl transient Object[] elements;\n\n    /**\n     * Keeps track of modifications of this set, to make it possible to throw\n     * ConcurrentModificationException in the iterator. Note that we choose not to make this volatile,\n     * so we do less of a \"best effort\" to track such errors, for better performance.\n     */\n    transient int modCount;\n\n    /** The number of elements contained in the set. */\n    private transient int size;\n\n    /** Constructs a new empty instance of {@code CompactHashSet}. */\n    CompactHashSet()\n    {\n        init(DEFAULT_SIZE);\n    }\n\n    /**\n     * Constructs a new instance of {@code CompactHashSet} with the specified capacity.\n     *\n     * @param expectedSize the initial capacity of this {@code CompactHashSet}.\n     */\n    CompactHashSet(int expectedSize)\n    {\n        init(expectedSize);\n    }\n\n    /** Pseudoconstructor for serialization support. */\n    void init(int expectedSize)\n    {\n        Preconditions.checkArgument(expectedSize >= 0, \"Initial capacity must be non-negative\");\n        this.modCount = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()\n    }\n\n    /** Returns whether arrays need to be allocated. */\n    boolean needsAllocArrays()\n    {\n        return table == null;\n    }\n\n    /** Handle lazy allocation of arrays. */\n    void allocArrays()\n    {\n        Preconditions.checkState(needsAllocArrays(), \"Arrays already allocated\");\n\n        int expectedSize = modCount;\n        int buckets = Hashing.closedTableSize(expectedSize, LOAD_FACTOR);\n        this.table = newTable(buckets);\n\n        this.entries = newEntries(expectedSize);\n        this.elements = new Object[expectedSize];\n    }\n\n    private static int[] newTable(int size)\n    {\n        int[] array = new int[size];\n        Arrays.fill(array, UNSET);\n        return array;\n    }\n\n    private static long[] newEntries(int size)\n    {\n        long[] array = new long[size];\n        Arrays.fill(array, UNSET);\n        return array;\n    }\n\n    private int hashTableMask()\n    {\n        return table.length - 1;\n    }\n\n    private static int getHash(long entry)\n    {\n        return (int) (entry >>> 32);\n    }\n\n    /** Returns the index, or UNSET if the pointer is \"null\" */\n    private static int getNext(long entry)\n    {\n        return (int) entry;\n    }\n\n    /** Returns a new entry value by changing the \"next\" index of an existing entry */\n    private static long swapNext(long entry, int newNext)\n    {\n        return (HASH_MASK & entry) | (NEXT_MASK & newNext);\n    }\n\n    @CanIgnoreReturnValue\n    @Override\n    public boolean add(@NullableDecl E object)\n    {\n        if (needsAllocArrays())\n        {\n            allocArrays();\n        }\n        long[] entries = this.entries;\n        Object[] elements = this.elements;\n\n        int hash = smearedHash(object);\n        int tableIndex = hash & hashTableMask();\n        int newEntryIndex = this.size; // current size, and pointer to the entry to be appended\n        int next = table[tableIndex];\n        if (next == UNSET)   // uninitialized bucket\n        {\n            table[tableIndex] = newEntryIndex;\n        }\n        else\n        {\n            int last;\n            long entry;\n            do\n            {\n                last = next;\n                entry = entries[next];\n                if (getHash(entry) == hash && Objects.equal(object, elements[next]))\n                {\n                    return false;\n                }\n                next = getNext(entry);\n            }\n            while (next != UNSET);\n            entries[last] = swapNext(entry, newEntryIndex);\n        }\n        if (newEntryIndex == Integer.MAX_VALUE)\n        {\n            throw new IllegalStateException(\"Cannot contain more than Integer.MAX_VALUE elements!\");\n        }\n        int newSize = newEntryIndex + 1;\n        resizeMeMaybe(newSize);\n        insertEntry(newEntryIndex, object, hash);\n        this.size = newSize;\n        int oldCapacity = table.length;\n        if (Hashing.needsResizing(newEntryIndex, oldCapacity, LOAD_FACTOR))\n        {\n            resizeTable(2 * oldCapacity);\n        }\n        modCount++;\n        return true;\n    }\n\n    /**\n     * Creates a fresh entry with the specified object at the specified position in the entry arrays.\n     */\n    void insertEntry(int entryIndex, E object, int hash)\n    {\n        this.entries[entryIndex] = ((long) hash << 32) | (NEXT_MASK & UNSET);\n        this.elements[entryIndex] = object;\n    }\n\n    /** Resizes the entries storage if necessary. */\n\n    /**\n     * Resizes the internal entries array to the specified capacity, which may be greater or less than\n     * the current capacity.\n     */\n    void resizeEntries(int newCapacity)\n    {\n        this.elements = Arrays.copyOf(elements, newCapacity);\n        long[] entries = this.entries;\n        int oldCapacity = entries.length;\n        entries = Arrays.copyOf(entries, newCapacity);\n        if (newCapacity > oldCapacity)\n        {\n            Arrays.fill(entries, oldCapacity, newCapacity, UNSET);\n        }\n        this.entries = entries;\n    }\n\n    private void resizeTable(int newCapacity)   // newCapacity always a power of two\n    {\n        int[] newTable = newTable(newCapacity);\n        long[] entries = this.entries;\n\n        int mask = newTable.length - 1;\n        for (int i = 0; i < size; i++)\n        {\n            long oldEntry = entries[i];\n            int hash = getHash(oldEntry);\n            int tableIndex = hash & mask;\n            int next = newTable[tableIndex];\n            newTable[tableIndex] = i;\n            entries[i] = ((long) hash << 32) | (NEXT_MASK & next);\n        }\n\n        this.table = newTable;\n    }\n\n    @Override\n    public boolean contains(@NullableDecl Object object)\n    {\n        if (needsAllocArrays())\n        {\n            return false;\n        }\n        int hash = smearedHash(object);\n        int next = table[hash & hashTableMask()];\n        while (next != UNSET)\n        {\n            long entry = entries[next];\n            if (getHash(entry) == hash && Objects.equal(object, elements[next]))\n            {\n                return true;\n            }\n            next = getNext(entry);\n        }\n        return false;\n    }\n\n    @CanIgnoreReturnValue\n    @Override\n    public boolean remove(@NullableDecl Object object)\n    {\n        if (needsAllocArrays())\n        {\n            return false;\n        }\n        return remove(object, smearedHash(object));\n    }\n\n    @CanIgnoreReturnValue\n    private boolean remove(Object object, int hash)\n    {\n        int tableIndex = hash & hashTableMask();\n        int next = table[tableIndex];\n        if (next == UNSET)\n        {\n            return false;\n        }\n        int last = UNSET;\n        do\n        {\n            if (getHash(entries[next]) == hash && Objects.equal(object, elements[next]))\n            {\n                if (last == UNSET)\n                {\n                    // we need to update the root link from table[]\n                    table[tableIndex] = getNext(entries[next]);\n                }\n                else\n                {\n                    // we need to update the link from the chain\n                    entries[last] = swapNext(entries[last], getNext(entries[next]));\n                }\n\n                moveLastEntry(next);\n                size--;\n                modCount++;\n                return true;\n            }\n            last = next;\n            next = getNext(entries[next]);\n        }\n        while (next != UNSET);\n        return false;\n    }\n\n    /**\n     * Moves the last entry in the entry array into {@code dstIndex}, and nulls out its old position.\n     */\n    void moveLastEntry(int dstIndex)\n    {\n        int srcIndex = size() - 1;\n        if (dstIndex < srcIndex)\n        {\n            // move last entry to deleted spot\n            elements[dstIndex] = elements[srcIndex];\n            elements[srcIndex] = null;\n\n            // move the last entry to the removed spot, just like we moved the element\n            long lastEntry = entries[srcIndex];\n            entries[dstIndex] = lastEntry;\n            entries[srcIndex] = UNSET;\n\n            // also need to update whoever's \"next\" pointer was pointing to the last entry place\n            // reusing \"tableIndex\" and \"next\"; these variables were no longer needed\n            int tableIndex = getHash(lastEntry) & hashTableMask();\n            int lastNext = table[tableIndex];\n            if (lastNext == srcIndex)\n            {\n                // we need to update the root pointer\n                table[tableIndex] = dstIndex;\n            }\n            else\n            {\n                // we need to update a pointer in an entry\n                int previous;\n                long entry;\n                do\n                {\n                    previous = lastNext;\n                    lastNext = getNext(entry = entries[lastNext]);\n                }\n                while (lastNext != srcIndex);\n                // here, entries[previous] points to the old entry location; update it\n                entries[previous] = swapNext(entry, dstIndex);\n            }\n        }\n        else\n        {\n            elements[dstIndex] = null;\n            entries[dstIndex] = UNSET;\n        }\n    }\n\n    int firstEntryIndex()\n    {\n        return isEmpty() ? -1 : 0;\n    }\n\n    int getSuccessor(int entryIndex)\n    {\n        return (entryIndex + 1 < size) ? entryIndex + 1 : -1;\n    }\n\n    /**\n     * Updates the index an iterator is pointing to after a call to remove: returns the index of the\n     * entry that should be looked at after a removal on indexRemoved, with indexBeforeRemove as the\n     * index that *was* the next entry that would be looked at.\n     */\n    int adjustAfterRemove(int indexBeforeRemove, @SuppressWarnings(\"unused\") int indexRemoved)\n    {\n        return indexBeforeRemove - 1;\n    }\n\n    @Override\n    public Iterator<E> iterator()\n    {\n        return new Iterator<E>()\n        {\n            int expectedModCount = modCount;\n            int currentIndex = firstEntryIndex();\n            int indexToRemove = -1;\n\n            @Override\n            public boolean hasNext()\n            {\n                return currentIndex >= 0;\n            }\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public E next()\n            {\n                checkForConcurrentModification();\n                if (!hasNext())\n                {\n                    throw new NoSuchElementException();\n                }\n                indexToRemove = currentIndex;\n                E result = (E) elements[currentIndex];\n                currentIndex = getSuccessor(currentIndex);\n                return result;\n            }\n\n            @Override\n            public void remove()\n            {\n                checkForConcurrentModification();\n                checkRemove(indexToRemove >= 0);\n                expectedModCount++;\n                CompactHashSet.this.remove(elements[indexToRemove], getHash(entries[indexToRemove]));\n                currentIndex = adjustAfterRemove(currentIndex, indexToRemove);\n                indexToRemove = -1;\n            }\n\n            private void checkForConcurrentModification()\n            {\n                if (modCount != expectedModCount)\n                {\n                    throw new ConcurrentModificationException();\n                }\n            }\n        };\n    }\n\n    @Override\n    public int size()\n    {\n        return size;\n    }\n\n    @Override\n    public boolean isEmpty()\n    {\n        return size == 0;\n    }\n\n    @Override\n    public Object[] toArray()\n    {\n        if (needsAllocArrays())\n        {\n            return new Object[0];\n        }\n        return Arrays.copyOf(elements, size);\n    }\n\n    @CanIgnoreReturnValue\n    @Override\n    public <T> T[] toArray(T[] a)\n    {\n        if (needsAllocArrays())\n        {\n            if (a.length > 0)\n            {\n                a[0] = null;\n            }\n            return a;\n        }\n        return ObjectArrays.toArrayImpl(elements, 0, size, a);\n    }\n\n    /**\n     * Ensures that this {@code CompactHashSet} has the smallest representation in memory, given its\n     * current size.\n     */\n    public void trimToSize()\n    {\n        if (needsAllocArrays())\n        {\n            return;\n        }\n        int size = this.size;\n        if (size < entries.length)\n        {\n            resizeEntries(size);\n        }\n        int minimumTableSize = Hashing.closedTableSize(size, LOAD_FACTOR);\n        if (minimumTableSize < table.length)\n        {\n            resizeTable(minimumTableSize);\n        }\n    }\n\n    @Override\n    public void clear()\n    {\n        if (needsAllocArrays())\n        {\n            return;\n        }\n        modCount++;\n        Arrays.fill(elements, 0, size, null);\n        Arrays.fill(table, UNSET);\n        Arrays.fill(entries, 0, size, UNSET);\n        this.size = 0;\n    }\n\n    /**\n     * The serial form currently mimics Android's java.util.HashSet version, e.g. see\n     * http://omapzoom.org/?p=platform/libcore.git;a=blob;f=luni/src/main/java/java/util/HashSet.java\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException\n    {\n        stream.defaultWriteObject();\n        stream.writeInt(size);\n        for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i))\n        {\n            stream.writeObject(elements[i]);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException\n    {\n        stream.defaultReadObject();\n        int elementCount = stream.readInt();\n        if (elementCount < 0)\n        {\n            throw new InvalidObjectException(\"Invalid size: \" + elementCount);\n        }\n        init(elementCount);\n        for (int i = 0; i < elementCount; i++)\n        {\n            E element = (E) stream.readObject();\n            add(element);\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.bytesToInetAddress", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Convert a byte array into an InetAddress.\n\n<p>{@link InetAddress#getByAddress} is documented as throwing a checked exception \"if IP\naddress is of illegal length.\" We replace it with an unchecked exception, for use by callers\nwho already know that addr is an array of length 4 or 16.\n\n@param addr the raw 4-byte or 16-byte IP address in big-endian order\n@return an InetAddress object created from the raw IP address", "docstring_tokens": ["Convert", "a", "byte", "array", "into", "an", "InetAddress", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L317-L323", "partition": "valid", "up_fun_num": 11, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.MoreObjects;", "import com.google.common.base.Splitter;", "import com.google.common.collect.Iterables;", "import com.google.common.hash.Hashing;", "import com.google.common.io.ByteStreams;", "import com.google.common.primitives.Ints;", "import java.net.Inet4Address;", "import java.net.Inet6Address;", "import java.net.InetAddress;", "import java.net.UnknownHostException;", "import java.nio.ByteBuffer;", "import java.util.Arrays;", "import java.util.List;", "import java.util.Locale;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class InetAddresses\n", "    private static Inet4Address getInet4Address(byte[] bytes)\n", "    public static InetAddress forString(String ipString)\n", "    public static boolean isInetAddress(String ipString)\n", "    private static byte[] ipStringToBytes(String ipString)\n", "    private static byte[] textToNumericFormatV4(String ipString)\n", "    private static byte[] textToNumericFormatV6(String ipString)\n", "    private static String convertDottedQuadToHex(String ipString)\n", "    private static byte parseOctet(String ipPart)\n", "    private static short parseHextet(String ipPart)\n", "    public static String toAddrString(InetAddress ip)\n", "    private static void compressLongestRunOfZeroes(int[] hextets)\n", "    private static String hextetsToIPv6String(int[] hextets)\n", "    public static String toUriString(InetAddress ip)\n", "    public static InetAddress forUriString(String hostAddr)\n", "    private static InetAddress forUriStringNoThrow(String hostAddr)\n", "    public static boolean isUriInetAddress(String ipString)\n", "    public static boolean isCompatIPv4Address(Inet6Address ip)\n", "    public static Inet4Address getCompatIPv4Address(Inet6Address ip)\n", "    public static boolean is6to4Address(Inet6Address ip)\n", "    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n", "    public static boolean isTeredoAddress(Inet6Address ip)\n", "    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n", "    public static boolean isIsatapAddress(Inet6Address ip)\n", "    public static Inet4Address getIsatapIPv4Address(Inet6Address ip)\n", "    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static boolean isMappedIPv4Address(String ipString)\n", "    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n", "    public static int coerceToInteger(InetAddress ip)\n", "    public static Inet4Address fromInteger(int address)\n", "    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n", "    public static InetAddress decrement(InetAddress address)\n", "    public static InetAddress increment(InetAddress address)\n", "    public static boolean isMaximum(InetAddress address)\n", "    private static IllegalArgumentException formatIllegalArgumentException(\n"], "context": "/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.net;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.Iterables;\nimport com.google.common.hash.Hashing;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.primitives.Ints;\nimport java.net.Inet4Address;\nimport java.net.Inet6Address;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * Static utility methods pertaining to {@link InetAddress} instances.\n *\n * <p><b>Important note:</b> Unlike {@code InetAddress.getByName()}, the methods of this class never\n * cause DNS services to be accessed. For this reason, you should prefer these methods as much as\n * possible over their JDK equivalents whenever you are expecting to handle only IP address string\n * literals -- there is no blocking DNS penalty for a malformed string.\n *\n * <p>When dealing with {@link Inet4Address} and {@link Inet6Address} objects as byte arrays (vis.\n * {@code InetAddress.getAddress()}) they are 4 and 16 bytes in length, respectively, and represent\n * the address in network byte order.\n *\n * <p>Examples of IP addresses and their byte representations:\n *\n * <dl>\n *   <dt>The IPv4 loopback address, {@code \"127.0.0.1\"}.\n *   <dd>{@code 7f 00 00 01}\n *   <dt>The IPv6 loopback address, {@code \"::1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>From the IPv6 reserved documentation prefix ({@code 2001:db8::/32}), {@code \"2001:db8::1\"}.\n *   <dd>{@code 20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>An IPv6 \"IPv4 compatible\" (or \"compat\") address, {@code \"::192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 c0 a8 00 01}\n *   <dt>An IPv6 \"IPv4 mapped\" address, {@code \"::ffff:192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 ff ff c0 a8 00 01}\n * </dl>\n *\n * <p>A few notes about IPv6 \"IPv4 mapped\" addresses and their observed use in Java.\n *\n * <p>\"IPv4 mapped\" addresses were originally a representation of IPv4 addresses for use on an IPv6\n * socket that could receive both IPv4 and IPv6 connections (by disabling the {@code IPV6_V6ONLY}\n * socket option on an IPv6 socket). Yes, it's confusing. Nevertheless, these \"mapped\" addresses\n * were never supposed to be seen on the wire. That assumption was dropped, some say mistakenly, in\n * later RFCs with the apparent aim of making IPv4-to-IPv6 transition simpler.\n *\n * <p>Technically one <i>can</i> create a 128bit IPv6 address with the wire format of a \"mapped\"\n * address, as shown above, and transmit it in an IPv6 packet header. However, Java's InetAddress\n * creation methods appear to adhere doggedly to the original intent of the \"mapped\" address: all\n * \"mapped\" addresses return {@link Inet4Address} objects.\n *\n * <p>For added safety, it is common for IPv6 network operators to filter all packets where either\n * the source or destination address appears to be a \"compat\" or \"mapped\" address. Filtering\n * suggestions usually recommend discarding any packets with source or destination addresses in the\n * invalid range {@code ::/3}, which includes both of these bizarre address formats. For more\n * information on \"bogons\", including lists of IPv6 bogon space, see:\n *\n * <ul>\n *   <li><a target=\"_parent\"\n *       href=\"http://en.wikipedia.org/wiki/Bogon_filtering\">http://en.wikipedia.\n *       org/wiki/Bogon_filtering</a>\n *   <li><a target=\"_parent\"\n *       href=\"http://www.cymru.com/Bogons/ipv6.txt\">http://www.cymru.com/Bogons/ ipv6.txt</a>\n *   <li><a target=\"_parent\" href=\"http://www.cymru.com/Bogons/v6bogon.html\">http://www.cymru.com/\n *       Bogons/v6bogon.html</a>\n *   <li><a target=\"_parent\" href=\"http://www.space.net/~gert/RIPE/ipv6-filters.html\">http://www.\n *       space.net/~gert/RIPE/ipv6-filters.html</a>\n * </ul>\n *\n * @author Erik Kline\n * @since 5.0\n */\n@Beta\n@GwtIncompatible\npublic final class InetAddresses\n{\n    private static final int IPV4_PART_COUNT = 4;\n    private static final int IPV6_PART_COUNT = 8;\n    private static final Splitter IPV4_SPLITTER = Splitter.on('.').limit(IPV4_PART_COUNT);\n    private static final Splitter IPV6_SPLITTER = Splitter.on(':').limit(IPV6_PART_COUNT + 2);\n    private static final Inet4Address LOOPBACK4 = (Inet4Address) forString(\"127.0.0.1\");\n    private static final Inet4Address ANY4 = (Inet4Address) forString(\"0.0.0.0\");\n\n    private InetAddresses() {}\n\n    /**\n     * Returns an {@link Inet4Address}, given a byte array representation of the IPv4 address.\n     *\n     * @param bytes byte array representing an IPv4 address (should be of length 4)\n     * @return {@link Inet4Address} corresponding to the supplied byte array\n     * @throws IllegalArgumentException if a valid {@link Inet4Address} can not be created\n     */\n    private static Inet4Address getInet4Address(byte[] bytes)\n    {\n        checkArgument(\n            bytes.length == 4,\n            \"Byte array has invalid length for an IPv4 address: %s != 4.\",\n            bytes.length);\n\n        // Given a 4-byte array, this cast should always succeed.\n        return (Inet4Address) bytesToInetAddress(bytes);\n    }\n\n    /**\n     * Returns the {@link InetAddress} having the given string representation.\n     *\n     * <p>This deliberately avoids all nameservice lookups (e.g. no DNS).\n     *\n     * @param ipString {@code String} containing an IPv4 or IPv6 string literal, e.g. {@code\n     *     \"192.168.0.1\"} or {@code \"2001:db8::1\"}\n     * @return {@link InetAddress} representing the argument\n     * @throws IllegalArgumentException if the argument is not a valid IP string literal\n     */\n    public static InetAddress forString(String ipString)\n    {\n        byte[] addr = ipStringToBytes(ipString);\n\n        // The argument was malformed, i.e. not an IP string literal.\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"'%s' is not an IP string literal.\", ipString);\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP string literal\n     * @return {@code true} if the argument is a valid IP string literal\n     */\n    public static boolean isInetAddress(String ipString)\n    {\n        return ipStringToBytes(ipString) != null;\n    }\n\n    @NullableDecl\n    private static byte[] ipStringToBytes(String ipString)\n    {\n        // Make a first pass to categorize the characters in this string.\n        boolean hasColon = false;\n        boolean hasDot = false;\n        for (int i = 0; i < ipString.length(); i++)\n        {\n            char c = ipString.charAt(i);\n            if (c == '.')\n            {\n                hasDot = true;\n            }\n            else if (c == ':')\n            {\n                if (hasDot)\n                {\n                    return null; // Colons must not appear after dots.\n                }\n                hasColon = true;\n            }\n            else if (Character.digit(c, 16) == -1)\n            {\n                return null; // Everything else must be a decimal or hex digit.\n            }\n        }\n\n        // Now decide which address family to parse.\n        if (hasColon)\n        {\n            if (hasDot)\n            {\n                ipString = convertDottedQuadToHex(ipString);\n                if (ipString == null)\n                {\n                    return null;\n                }\n            }\n            return textToNumericFormatV6(ipString);\n        }\n        else if (hasDot)\n        {\n            return textToNumericFormatV4(ipString);\n        }\n        return null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV4(String ipString)\n    {\n        byte[] bytes = new byte[IPV4_PART_COUNT];\n        int i = 0;\n        try\n        {\n            for (String octet : IPV4_SPLITTER.split(ipString))\n            {\n                bytes[i++] = parseOctet(octet);\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n\n        return i == IPV4_PART_COUNT ? bytes : null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV6(String ipString)\n    {\n        // An address can have [2..8] colons, and N colons make N+1 parts.\n        List<String> parts = IPV6_SPLITTER.splitToList(ipString);\n        if (parts.size() < 3 || parts.size() > IPV6_PART_COUNT + 1)\n        {\n            return null;\n        }\n\n        // Disregarding the endpoints, find \"::\" with nothing in between.\n        // This indicates that a run of zeroes has been skipped.\n        int skipIndex = -1;\n        for (int i = 1; i < parts.size() - 1; i++)\n        {\n            if (parts.get(i).length() == 0)\n            {\n                if (skipIndex >= 0)\n                {\n                    return null; // Can't have more than one ::\n                }\n                skipIndex = i;\n            }\n        }\n\n        int partsHi; // Number of parts to copy from above/before the \"::\"\n        int partsLo; // Number of parts to copy from below/after the \"::\"\n        if (skipIndex >= 0)\n        {\n            // If we found a \"::\", then check if it also covers the endpoints.\n            partsHi = skipIndex;\n            partsLo = parts.size() - skipIndex - 1;\n            if (parts.get(0).length() == 0 && --partsHi != 0)\n            {\n                return null; // ^: requires ^::\n            }\n            if (Iterables.getLast(parts).length() == 0 && --partsLo != 0)\n            {\n                return null; // :$ requires ::$\n            }\n        }\n        else\n        {\n            // Otherwise, allocate the entire address to partsHi. The endpoints\n            // could still be empty, but parseHextet() will check for that.\n            partsHi = parts.size();\n            partsLo = 0;\n        }\n\n        // If we found a ::, then we must have skipped at least one part.\n        // Otherwise, we must have exactly the right number of parts.\n        int partsSkipped = IPV6_PART_COUNT - (partsHi + partsLo);\n        if (!(skipIndex >= 0 ? partsSkipped >= 1 : partsSkipped == 0))\n        {\n            return null;\n        }\n\n        // Now parse the hextets into a byte array.\n        ByteBuffer rawBytes = ByteBuffer.allocate(2 * IPV6_PART_COUNT);\n        try\n        {\n            for (int i = 0; i < partsHi; i++)\n            {\n                rawBytes.putShort(parseHextet(parts.get(i)));\n            }\n            for (int i = 0; i < partsSkipped; i++)\n            {\n                rawBytes.putShort((short) 0);\n            }\n            for (int i = partsLo; i > 0; i--)\n            {\n                rawBytes.putShort(parseHextet(parts.get(parts.size() - i)));\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n        return rawBytes.array();\n    }\n\n    @NullableDecl\n    private static String convertDottedQuadToHex(String ipString)\n    {\n        int lastColon = ipString.lastIndexOf(':');\n        String initialPart = ipString.substring(0, lastColon + 1);\n        String dottedQuad = ipString.substring(lastColon + 1);\n        byte[] quad = textToNumericFormatV4(dottedQuad);\n        if (quad == null)\n        {\n            return null;\n        }\n        String penultimate = Integer.toHexString(((quad[0] & 0xff) << 8) | (quad[1] & 0xff));\n        String ultimate = Integer.toHexString(((quad[2] & 0xff) << 8) | (quad[3] & 0xff));\n        return initialPart + penultimate + \":\" + ultimate;\n    }\n\n    private static byte parseOctet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int octet = Integer.parseInt(ipPart);\n        // Disallow leading zeroes, because no clear standard exists on\n        // whether these should be interpreted as decimal or octal.\n        if (octet > 255 || (ipPart.startsWith(\"0\") && ipPart.length() > 1))\n        {\n            throw new NumberFormatException();\n        }\n        return (byte) octet;\n    }\n\n    private static short parseHextet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int hextet = Integer.parseInt(ipPart, 16);\n        if (hextet > 0xffff)\n        {\n            throw new NumberFormatException();\n        }\n        return (short) hextet;\n    }\n\n    /**\n     * Convert a byte array into an InetAddress.\n     *\n     * <p>{@link InetAddress#getByAddress} is documented as throwing a checked exception \"if IP\n     * address is of illegal length.\" We replace it with an unchecked exception, for use by callers\n     * who already know that addr is an array of length 4 or 16.\n     *\n     * @param addr the raw 4-byte or 16-byte IP address in big-endian order\n     * @return an InetAddress object created from the raw IP address\n     */\n\n    /**\n     * Returns the string representation of an {@link InetAddress}.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses, the output follows <a href=\"http://tools.ietf.org/html/rfc5952\">RFC 5952</a> section\n     * 4. The main difference is that this method uses \"::\" for zero compression, while Java's version\n     * uses the uncompressed form.\n     *\n     * <p>This method uses hexadecimal for all IPv6 addresses, including IPv4-mapped IPv6 addresses\n     * such as \"::c000:201\". The output does not include a Scope ID.\n     *\n     * @param ip {@link InetAddress} to be converted to an address string\n     * @return {@code String} containing the text-formatted IP address\n     * @since 10.0\n     */\n    public static String toAddrString(InetAddress ip)\n    {\n        checkNotNull(ip);\n        if (ip instanceof Inet4Address)\n        {\n            // For IPv4, Java's formatting is good enough.\n            return ip.getHostAddress();\n        }\n        checkArgument(ip instanceof Inet6Address);\n        byte[] bytes = ip.getAddress();\n        int[] hextets = new int[IPV6_PART_COUNT];\n        for (int i = 0; i < hextets.length; i++)\n        {\n            hextets[i] = Ints.fromBytes((byte) 0, (byte) 0, bytes[2 * i], bytes[2 * i + 1]);\n        }\n        compressLongestRunOfZeroes(hextets);\n        return hextetsToIPv6String(hextets);\n    }\n\n    /**\n     * Identify and mark the longest run of zeroes in an IPv6 address.\n     *\n     * <p>Only runs of two or more hextets are considered. In case of a tie, the leftmost run wins. If\n     * a qualifying run is found, its hextets are replaced by the sentinel value -1.\n     *\n     * @param hextets {@code int[]} mutable array of eight 16-bit hextets\n     */\n    private static void compressLongestRunOfZeroes(int[] hextets)\n    {\n        int bestRunStart = -1;\n        int bestRunLength = -1;\n        int runStart = -1;\n        for (int i = 0; i < hextets.length + 1; i++)\n        {\n            if (i < hextets.length && hextets[i] == 0)\n            {\n                if (runStart < 0)\n                {\n                    runStart = i;\n                }\n            }\n            else if (runStart >= 0)\n            {\n                int runLength = i - runStart;\n                if (runLength > bestRunLength)\n                {\n                    bestRunStart = runStart;\n                    bestRunLength = runLength;\n                }\n                runStart = -1;\n            }\n        }\n        if (bestRunLength >= 2)\n        {\n            Arrays.fill(hextets, bestRunStart, bestRunStart + bestRunLength, -1);\n        }\n    }\n\n    /**\n     * Convert a list of hextets into a human-readable IPv6 address.\n     *\n     * <p>In order for \"::\" compression to work, the input should contain negative sentinel values in\n     * place of the elided zeroes.\n     *\n     * @param hextets {@code int[]} array of eight 16-bit hextets, or -1s\n     */\n    private static String hextetsToIPv6String(int[] hextets)\n    {\n        // While scanning the array, handle these state transitions:\n        //   start->num => \"num\"     start->gap => \"::\"\n        //   num->num   => \":num\"    num->gap   => \"::\"\n        //   gap->num   => \"num\"     gap->gap   => \"\"\n        StringBuilder buf = new StringBuilder(39);\n        boolean lastWasNumber = false;\n        for (int i = 0; i < hextets.length; i++)\n        {\n            boolean thisIsNumber = hextets[i] >= 0;\n            if (thisIsNumber)\n            {\n                if (lastWasNumber)\n                {\n                    buf.append(':');\n                }\n                buf.append(Integer.toHexString(hextets[i]));\n            }\n            else\n            {\n                if (i == 0 || lastWasNumber)\n                {\n                    buf.append(\"::\");\n                }\n            }\n            lastWasNumber = thisIsNumber;\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Returns the string representation of an {@link InetAddress} suitable for inclusion in a URI.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses it compresses zeroes and surrounds the text with square brackets; for example {@code\n     * \"[2001:db8::1]\"}.\n     *\n     * <p>Per section 3.2.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3986#section-3.2.2\">RFC 3986</a>, a URI containing an IPv6\n     * string literal is of the form {@code \"http://[2001:db8::1]:8888/index.html\"}.\n     *\n     * <p>Use of either {@link InetAddresses#toAddrString}, {@link InetAddress#getHostAddress()}, or\n     * this method is recommended over {@link InetAddress#toString()} when an IP address string\n     * literal is desired. This is because {@link InetAddress#toString()} prints the hostname and the\n     * IP address string joined by a \"/\".\n     *\n     * @param ip {@link InetAddress} to be converted to URI string literal\n     * @return {@code String} containing URI-safe string literal\n     */\n    public static String toUriString(InetAddress ip)\n    {\n        if (ip instanceof Inet6Address)\n        {\n            return \"[\" + toAddrString(ip) + \"]\";\n        }\n        return toAddrString(ip);\n    }\n\n    /**\n     * Returns an InetAddress representing the literal IPv4 or IPv6 host portion of a URL, encoded in\n     * the format specified by RFC 3986 section 3.2.2.\n     *\n     * <p>This function is similar to {@link InetAddresses#forString(String)}, however, it requires\n     * that IPv6 addresses are surrounded by square brackets.\n     *\n     * <p>This function is the inverse of {@link InetAddresses#toUriString(java.net.InetAddress)}.\n     *\n     * @param hostAddr A RFC 3986 section 3.2.2 encoded IPv4 or IPv6 address\n     * @return an InetAddress representing the address in {@code hostAddr}\n     * @throws IllegalArgumentException if {@code hostAddr} is not a valid IPv4 address, or IPv6\n     *     address surrounded by square brackets\n     */\n    public static InetAddress forUriString(String hostAddr)\n    {\n        InetAddress addr = forUriStringNoThrow(hostAddr);\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"Not a valid URI IP literal: '%s'\", hostAddr);\n        }\n\n        return addr;\n    }\n\n    @NullableDecl\n    private static InetAddress forUriStringNoThrow(String hostAddr)\n    {\n        checkNotNull(hostAddr);\n\n        // Decide if this should be an IPv6 or IPv4 address.\n        String ipString;\n        int expectBytes;\n        if (hostAddr.startsWith(\"[\") && hostAddr.endsWith(\"]\"))\n        {\n            ipString = hostAddr.substring(1, hostAddr.length() - 1);\n            expectBytes = 16;\n        }\n        else\n        {\n            ipString = hostAddr;\n            expectBytes = 4;\n        }\n\n        // Parse the address, and make sure the length/version is correct.\n        byte[] addr = ipStringToBytes(ipString);\n        if (addr == null || addr.length != expectBytes)\n        {\n            return null;\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid URI IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP URI host string literal\n     * @return {@code true} if the argument is a valid IP URI host\n     */\n    public static boolean isUriInetAddress(String ipString)\n    {\n        return forUriStringNoThrow(ipString) != null;\n    }\n\n    /**\n     * Evaluates whether the argument is an IPv6 \"compat\" address.\n     *\n     * <p>An \"IPv4 compatible\", or \"compat\", address is one with 96 leading bits of zero, with the\n     * remaining 32 bits interpreted as an IPv4 address. These are conventionally represented in\n     * string literals as {@code \"::192.168.0.1\"}, though {@code \"::c0a8:1\"} is also considered an\n     * IPv4 compatible address (and equivalent to {@code \"::192.168.0.1\"}).\n     *\n     * <p>For more on IPv4 compatible addresses see section 2.5.5.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.1\">RFC 4291</a>.\n     *\n     * <p>NOTE: This method is different from {@link Inet6Address#isIPv4CompatibleAddress} in that it\n     * more correctly classifies {@code \"::\"} and {@code \"::1\"} as proper IPv6 addresses (which they\n     * are), NOT IPv4 compatible addresses (which they are generally NOT considered to be).\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 compatible address format\n     * @return {@code true} if the argument is a valid \"compat\" address\n     */\n    public static boolean isCompatIPv4Address(Inet6Address ip)\n    {\n        if (!ip.isIPv4CompatibleAddress())\n        {\n            return false;\n        }\n\n        byte[] bytes = ip.getAddress();\n        if ((bytes[12] == 0)\n                && (bytes[13] == 0)\n                && (bytes[14] == 0)\n                && ((bytes[15] == 0) || (bytes[15] == 1)))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the IPv4 address embedded in an IPv4 compatible address.\n     *\n     * @param ip {@link Inet6Address} to be examined for an embedded IPv4 address\n     * @return {@link Inet4Address} of the embedded IPv4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv4 compatible address\n     */\n    public static Inet4Address getCompatIPv4Address(Inet6Address ip)\n    {\n        checkArgument(\n            isCompatIPv4Address(ip), \"Address '%s' is not IPv4-compatible.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n    }\n\n    /**\n     * Evaluates whether the argument is a 6to4 address.\n     *\n     * <p>6to4 addresses begin with the {@code \"2002::/16\"} prefix. The next 32 bits are the IPv4\n     * address of the host to which IPv6-in-IPv4 tunneled packets should be routed.\n     *\n     * <p>For more on 6to4 addresses see section 2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3056#section-2\">RFC 3056</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for 6to4 address format\n     * @return {@code true} if the argument is a 6to4 address\n     */\n    public static boolean is6to4Address(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20) && (bytes[1] == (byte) 0x02);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in a 6to4 address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in 6to4 address\n     * @return {@link Inet4Address} of embedded IPv4 in 6to4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 6to4 address\n     */\n    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n    {\n        checkArgument(is6to4Address(ip), \"Address '%s' is not a 6to4 address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 2, 6));\n    }\n\n    /**\n     * A simple immutable data class to encapsulate the information to be found in a Teredo address.\n     *\n     * <p>All of the fields in this class are encoded in various portions of the IPv6 address as part\n     * of the protocol. More protocols details can be found at: <a target=\"_parent\"\n     * href=\"http://en.wikipedia.org/wiki/Teredo_tunneling\">http://en.wikipedia.\n     * org/wiki/Teredo_tunneling</a>.\n     *\n     * <p>The RFC can be found here: <a target=\"_parent\" href=\"http://tools.ietf.org/html/rfc4380\">RFC\n     * 4380</a>.\n     *\n     * @since 5.0\n     */\n    @Beta\n    public static final class TeredoInfo\n    {\n        private final Inet4Address server;\n        private final Inet4Address client;\n        private final int port;\n        private final int flags;\n\n        /**\n         * Constructs a TeredoInfo instance.\n         *\n         * <p>Both server and client can be {@code null}, in which case the value {@code \"0.0.0.0\"} will\n         * be assumed.\n         *\n         * @throws IllegalArgumentException if either of the {@code port} or the {@code flags} arguments\n         *     are out of range of an unsigned short\n         */\n        // TODO: why is this public?\n        public TeredoInfo(\n            @NullableDecl Inet4Address server, @NullableDecl Inet4Address client, int port, int flags)\n        {\n            checkArgument(\n                (port >= 0) && (port <= 0xffff), \"port '%s' is out of range (0 <= port <= 0xffff)\", port);\n            checkArgument(\n                (flags >= 0) && (flags <= 0xffff),\n                \"flags '%s' is out of range (0 <= flags <= 0xffff)\",\n                flags);\n\n            this.server = MoreObjects.firstNonNull(server, ANY4);\n            this.client = MoreObjects.firstNonNull(client, ANY4);\n            this.port = port;\n            this.flags = flags;\n        }\n\n        public Inet4Address getServer()\n        {\n            return server;\n        }\n\n        public Inet4Address getClient()\n        {\n            return client;\n        }\n\n        public int getPort()\n        {\n            return port;\n        }\n\n        public int getFlags()\n        {\n            return flags;\n        }\n    }\n\n    /**\n     * Evaluates whether the argument is a Teredo address.\n     *\n     * <p>Teredo addresses begin with the {@code \"2001::/32\"} prefix.\n     *\n     * @param ip {@link Inet6Address} to be examined for Teredo address format\n     * @return {@code true} if the argument is a Teredo address\n     */\n    public static boolean isTeredoAddress(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20)\n               && (bytes[1] == (byte) 0x01)\n               && (bytes[2] == 0)\n               && (bytes[3] == 0);\n    }\n\n    /**\n     * Returns the Teredo information embedded in a Teredo address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded Teredo information\n     * @return extracted {@code TeredoInfo}\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 Teredo address\n     */\n    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n    {\n        checkArgument(isTeredoAddress(ip), \"Address '%s' is not a Teredo address.\", toAddrString(ip));\n\n        byte[] bytes = ip.getAddress();\n        Inet4Address server = getInet4Address(Arrays.copyOfRange(bytes, 4, 8));\n\n        int flags = ByteStreams.newDataInput(bytes, 8).readShort() & 0xffff;\n\n        // Teredo obfuscates the mapped client port, per section 4 of the RFC.\n        int port = ~ByteStreams.newDataInput(bytes, 10).readShort() & 0xffff;\n\n        byte[] clientBytes = Arrays.copyOfRange(bytes, 12, 16);\n        for (int i = 0; i < clientBytes.length; i++)\n        {\n            // Teredo obfuscates the mapped client IP, per section 4 of the RFC.\n            clientBytes[i] = (byte) ~clientBytes[i];\n        }\n        Inet4Address client = getInet4Address(clientBytes);\n\n        return new TeredoInfo(server, client, port, flags);\n    }\n\n    /**\n     * Evaluates whether the argument is an ISATAP address.\n     *\n     * <p>From RFC 5214: \"ISATAP interface identifiers are constructed in Modified EUI-64 format [...]\n     * by concatenating the 24-bit IANA OUI (00-00-5E), the 8-bit hexadecimal value 0xFE, and a 32-bit\n     * IPv4 address in network byte order [...]\"\n     *\n     * <p>For more on ISATAP addresses see section 6.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc5214#section-6.1\">RFC 5214</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for ISATAP address format\n     * @return {@code true} if the argument is an ISATAP address\n     */\n    public static boolean isIsatapAddress(Inet6Address ip)\n    {\n\n        // If it's a Teredo address with the right port (41217, or 0xa101)\n        // which would be encoded as 0x5efe then it can't be an ISATAP address.\n        if (isTeredoAddress(ip))\n        {\n            return false;\n        }\n\n        byte[] bytes = ip.getAddress();\n\n        if ((bytes[8] | (byte) 0x03) != (byte) 0x03)\n        {\n\n            // Verify that high byte of the 64 bit identifier is zero, modulo\n            // the U/L and G bits, with which we are not concerned.\n            return false;\n        }\n\n        return (bytes[9] == (byte) 0x00) && (bytes[10] == (byte) 0x5e) && (bytes[11] == (byte) 0xfe);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in an ISATAP address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in ISATAP address\n     * @return {@link Inet4Address} of embedded IPv4 in an ISATAP address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 ISATAP address\n     */\n    public static Inet4Address getIsatapIPv4Address(Inet6Address ip)\n    {\n        checkArgument(isIsatapAddress(ip), \"Address '%s' is not an ISATAP address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n    }\n\n    /**\n     * Examines the Inet6Address to determine if it is an IPv6 address of one of the specified address\n     * types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@code true} if there is an embedded IPv4 client address\n     * @since 7.0\n     */\n    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        return isCompatIPv4Address(ip) || is6to4Address(ip) || isTeredoAddress(ip);\n    }\n\n    /**\n     * Examines the Inet6Address to extract the embedded IPv4 client address if the InetAddress is an\n     * IPv6 address of one of the specified address types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@link Inet4Address} of embedded IPv4 client address\n     * @throws IllegalArgumentException if the argument does not have a valid embedded IPv4 address\n     */\n    public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        if (isCompatIPv4Address(ip))\n        {\n            return getCompatIPv4Address(ip);\n        }\n\n        if (is6to4Address(ip))\n        {\n            return get6to4IPv4Address(ip);\n        }\n\n        if (isTeredoAddress(ip))\n        {\n            return getTeredoInfo(ip).getClient();\n        }\n\n        throw formatIllegalArgumentException(\"'%s' has no embedded IPv4 address.\", toAddrString(ip));\n    }\n\n    /**\n     * Evaluates whether the argument is an \"IPv4 mapped\" IPv6 address.\n     *\n     * <p>An \"IPv4 mapped\" address is anything in the range ::ffff:0:0/96 (sometimes written as\n     * ::ffff:0.0.0.0/96), with the last 32 bits interpreted as an IPv4 address.\n     *\n     * <p>For more on IPv4 mapped addresses see section 2.5.5.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.2\">RFC 4291</a>.\n     *\n     * <p>Note: This method takes a {@code String} argument because {@link InetAddress} automatically\n     * collapses mapped addresses to IPv4. (It is actually possible to avoid this using one of the\n     * obscure {@link Inet6Address} methods, but it would be unwise to depend on such a\n     * poorly-documented feature.)\n     *\n     * @param ipString {@code String} to be examined for embedded IPv4-mapped IPv6 address format\n     * @return {@code true} if the argument is a valid \"mapped\" address\n     * @since 10.0\n     */\n    public static boolean isMappedIPv4Address(String ipString)\n    {\n        byte[] bytes = ipStringToBytes(ipString);\n        if (bytes != null && bytes.length == 16)\n        {\n            for (int i = 0; i < 10; i++)\n            {\n                if (bytes[i] != 0)\n                {\n                    return false;\n                }\n            }\n            for (int i = 10; i < 12; i++)\n            {\n                if (bytes[i] != (byte) 0xff)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Coerces an IPv6 address into an IPv4 address.\n     *\n     * <p>HACK: As long as applications continue to use IPv4 addresses for indexing into tables,\n     * accounting, et cetera, it may be necessary to <b>coerce</b> IPv6 addresses into IPv4 addresses.\n     * This function does so by hashing the upper 64 bits into {@code 224.0.0.0/3} (64 bits into 29\n     * bits).\n     *\n     * <p>A \"coerced\" IPv4 address is equivalent to itself.\n     *\n     * <p>NOTE: This function is failsafe for security purposes: ALL IPv6 addresses (except localhost\n     * (::1)) are hashed to avoid the security risk associated with extracting an embedded IPv4\n     * address that might permit elevated privileges.\n     *\n     * @param ip {@link InetAddress} to \"coerce\"\n     * @return {@link Inet4Address} represented \"coerced\" address\n     * @since 7.0\n     */\n    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n    {\n        if (ip instanceof Inet4Address)\n        {\n            return (Inet4Address) ip;\n        }\n\n        // Special cases:\n        byte[] bytes = ip.getAddress();\n        boolean leadingBytesOfZero = true;\n        for (int i = 0; i < 15; ++i)\n        {\n            if (bytes[i] != 0)\n            {\n                leadingBytesOfZero = false;\n                break;\n            }\n        }\n        if (leadingBytesOfZero && (bytes[15] == 1))\n        {\n            return LOOPBACK4; // ::1\n        }\n        else if (leadingBytesOfZero && (bytes[15] == 0))\n        {\n            return ANY4; // ::0\n        }\n\n        Inet6Address ip6 = (Inet6Address) ip;\n        long addressAsLong = 0;\n        if (hasEmbeddedIPv4ClientAddress(ip6))\n        {\n            addressAsLong = getEmbeddedIPv4ClientAddress(ip6).hashCode();\n        }\n        else\n        {\n\n            // Just extract the high 64 bits (assuming the rest is user-modifiable).\n            addressAsLong = ByteBuffer.wrap(ip6.getAddress(), 0, 8).getLong();\n        }\n\n        // Many strategies for hashing are possible. This might suffice for now.\n        int coercedHash = Hashing.murmur3_32().hashLong(addressAsLong).asInt();\n\n        // Squash into 224/4 Multicast and 240/4 Reserved space (i.e. 224/3).\n        coercedHash |= 0xe0000000;\n\n        // Fixup to avoid some \"illegal\" values. Currently the only potential\n        // illegal value is 255.255.255.255.\n        if (coercedHash == 0xffffffff)\n        {\n            coercedHash = 0xfffffffe;\n        }\n\n        return getInet4Address(Ints.toByteArray(coercedHash));\n    }\n\n    /**\n     * Returns an integer representing an IPv4 address regardless of whether the supplied argument is\n     * an IPv4 address or not.\n     *\n     * <p>IPv6 addresses are <b>coerced</b> to IPv4 addresses before being converted to integers.\n     *\n     * <p>As long as there are applications that assume that all IP addresses are IPv4 addresses and\n     * can therefore be converted safely to integers (for whatever purpose) this function can be used\n     * to handle IPv6 addresses as well until the application is suitably fixed.\n     *\n     * <p>NOTE: an IPv6 address coerced to an IPv4 address can only be used for such purposes as\n     * rudimentary identification or indexing into a collection of real {@link InetAddress}es. They\n     * cannot be used as real addresses for the purposes of network communication.\n     *\n     * @param ip {@link InetAddress} to convert\n     * @return {@code int}, \"coerced\" if ip is not an IPv4 address\n     * @since 7.0\n     */\n    public static int coerceToInteger(InetAddress ip)\n    {\n        return ByteStreams.newDataInput(getCoercedIPv4Address(ip).getAddress()).readInt();\n    }\n\n    /**\n     * Returns an Inet4Address having the integer value specified by the argument.\n     *\n     * @param address {@code int}, the 32bit integer address to be converted\n     * @return {@link Inet4Address} equivalent of the argument\n     */\n    public static Inet4Address fromInteger(int address)\n    {\n        return getInet4Address(Ints.toByteArray(address));\n    }\n\n    /**\n     * Returns an address from a <b>little-endian ordered</b> byte array (the opposite of what {@link\n     * InetAddress#getByAddress} expects).\n     *\n     * <p>IPv4 address byte array must be 4 bytes long and IPv6 byte array must be 16 bytes long.\n     *\n     * @param addr the raw IP address in little-endian byte order\n     * @return an InetAddress object created from the raw IP address\n     * @throws UnknownHostException if IP address is of illegal length\n     */\n    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n    {\n        byte[] reversed = new byte[addr.length];\n        for (int i = 0; i < addr.length; i++)\n        {\n            reversed[i] = addr[addr.length - i - 1];\n        }\n        return InetAddress.getByAddress(reversed);\n    }\n\n    /**\n     * Returns a new InetAddress that is one less than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to decrement\n     * @return a new InetAddress that is one less than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the beginning of its range\n     * @since 18.0\n     */\n    public static InetAddress decrement(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0x00)\n        {\n            addr[i] = (byte) 0xff;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Decrementing %s would wrap.\", address);\n\n        addr[i]--;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns a new InetAddress that is one more than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to increment\n     * @return a new InetAddress that is one more than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the end of its range\n     * @since 10.0\n     */\n    public static InetAddress increment(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0xff)\n        {\n            addr[i] = 0;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Incrementing %s would wrap.\", address);\n\n        addr[i]++;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns true if the InetAddress is either 255.255.255.255 for IPv4 or\n     * ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6.\n     *\n     * @return true if the InetAddress is either 255.255.255.255 for IPv4 or\n     *     ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6\n     * @since 10.0\n     */\n    public static boolean isMaximum(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        for (int i = 0; i < addr.length; i++)\n        {\n            if (addr[i] != (byte) 0xff)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static IllegalArgumentException formatIllegalArgumentException(\n        String format, Object... args)\n    {\n        return new IllegalArgumentException(String.format(Locale.ROOT, format, args));\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.compressLongestRunOfZeroes", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Identify and mark the longest run of zeroes in an IPv6 address.\n\n<p>Only runs of two or more hextets are considered. In case of a tie, the leftmost run wins. If\na qualifying run is found, its hextets are replaced by the sentinel value -1.\n\n@param hextets {@code int[]} mutable array of eight 16-bit hextets", "docstring_tokens": ["Identify", "and", "mark", "the", "longest", "run", "of", "zeroes", "in", "an", "IPv6", "address", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L364-L385", "partition": "valid", "up_fun_num": 13, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.MoreObjects;", "import com.google.common.base.Splitter;", "import com.google.common.collect.Iterables;", "import com.google.common.hash.Hashing;", "import com.google.common.io.ByteStreams;", "import com.google.common.primitives.Ints;", "import java.net.Inet4Address;", "import java.net.Inet6Address;", "import java.net.InetAddress;", "import java.net.UnknownHostException;", "import java.nio.ByteBuffer;", "import java.util.Arrays;", "import java.util.List;", "import java.util.Locale;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class InetAddresses\n", "    private static Inet4Address getInet4Address(byte[] bytes)\n", "    public static InetAddress forString(String ipString)\n", "    public static boolean isInetAddress(String ipString)\n", "    private static byte[] ipStringToBytes(String ipString)\n", "    private static byte[] textToNumericFormatV4(String ipString)\n", "    private static byte[] textToNumericFormatV6(String ipString)\n", "    private static String convertDottedQuadToHex(String ipString)\n", "    private static byte parseOctet(String ipPart)\n", "    private static short parseHextet(String ipPart)\n", "    private static InetAddress bytesToInetAddress(byte[] addr)\n", "    public static String toAddrString(InetAddress ip)\n", "    private static String hextetsToIPv6String(int[] hextets)\n", "    public static String toUriString(InetAddress ip)\n", "    public static InetAddress forUriString(String hostAddr)\n", "    private static InetAddress forUriStringNoThrow(String hostAddr)\n", "    public static boolean isUriInetAddress(String ipString)\n", "    public static boolean isCompatIPv4Address(Inet6Address ip)\n", "    public static Inet4Address getCompatIPv4Address(Inet6Address ip)\n", "    public static boolean is6to4Address(Inet6Address ip)\n", "    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n", "    public static boolean isTeredoAddress(Inet6Address ip)\n", "    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n", "    public static boolean isIsatapAddress(Inet6Address ip)\n", "    public static Inet4Address getIsatapIPv4Address(Inet6Address ip)\n", "    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static boolean isMappedIPv4Address(String ipString)\n", "    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n", "    public static int coerceToInteger(InetAddress ip)\n", "    public static Inet4Address fromInteger(int address)\n", "    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n", "    public static InetAddress decrement(InetAddress address)\n", "    public static InetAddress increment(InetAddress address)\n", "    public static boolean isMaximum(InetAddress address)\n", "    private static IllegalArgumentException formatIllegalArgumentException(\n"], "context": "/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.net;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.Iterables;\nimport com.google.common.hash.Hashing;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.primitives.Ints;\nimport java.net.Inet4Address;\nimport java.net.Inet6Address;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * Static utility methods pertaining to {@link InetAddress} instances.\n *\n * <p><b>Important note:</b> Unlike {@code InetAddress.getByName()}, the methods of this class never\n * cause DNS services to be accessed. For this reason, you should prefer these methods as much as\n * possible over their JDK equivalents whenever you are expecting to handle only IP address string\n * literals -- there is no blocking DNS penalty for a malformed string.\n *\n * <p>When dealing with {@link Inet4Address} and {@link Inet6Address} objects as byte arrays (vis.\n * {@code InetAddress.getAddress()}) they are 4 and 16 bytes in length, respectively, and represent\n * the address in network byte order.\n *\n * <p>Examples of IP addresses and their byte representations:\n *\n * <dl>\n *   <dt>The IPv4 loopback address, {@code \"127.0.0.1\"}.\n *   <dd>{@code 7f 00 00 01}\n *   <dt>The IPv6 loopback address, {@code \"::1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>From the IPv6 reserved documentation prefix ({@code 2001:db8::/32}), {@code \"2001:db8::1\"}.\n *   <dd>{@code 20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>An IPv6 \"IPv4 compatible\" (or \"compat\") address, {@code \"::192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 c0 a8 00 01}\n *   <dt>An IPv6 \"IPv4 mapped\" address, {@code \"::ffff:192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 ff ff c0 a8 00 01}\n * </dl>\n *\n * <p>A few notes about IPv6 \"IPv4 mapped\" addresses and their observed use in Java.\n *\n * <p>\"IPv4 mapped\" addresses were originally a representation of IPv4 addresses for use on an IPv6\n * socket that could receive both IPv4 and IPv6 connections (by disabling the {@code IPV6_V6ONLY}\n * socket option on an IPv6 socket). Yes, it's confusing. Nevertheless, these \"mapped\" addresses\n * were never supposed to be seen on the wire. That assumption was dropped, some say mistakenly, in\n * later RFCs with the apparent aim of making IPv4-to-IPv6 transition simpler.\n *\n * <p>Technically one <i>can</i> create a 128bit IPv6 address with the wire format of a \"mapped\"\n * address, as shown above, and transmit it in an IPv6 packet header. However, Java's InetAddress\n * creation methods appear to adhere doggedly to the original intent of the \"mapped\" address: all\n * \"mapped\" addresses return {@link Inet4Address} objects.\n *\n * <p>For added safety, it is common for IPv6 network operators to filter all packets where either\n * the source or destination address appears to be a \"compat\" or \"mapped\" address. Filtering\n * suggestions usually recommend discarding any packets with source or destination addresses in the\n * invalid range {@code ::/3}, which includes both of these bizarre address formats. For more\n * information on \"bogons\", including lists of IPv6 bogon space, see:\n *\n * <ul>\n *   <li><a target=\"_parent\"\n *       href=\"http://en.wikipedia.org/wiki/Bogon_filtering\">http://en.wikipedia.\n *       org/wiki/Bogon_filtering</a>\n *   <li><a target=\"_parent\"\n *       href=\"http://www.cymru.com/Bogons/ipv6.txt\">http://www.cymru.com/Bogons/ ipv6.txt</a>\n *   <li><a target=\"_parent\" href=\"http://www.cymru.com/Bogons/v6bogon.html\">http://www.cymru.com/\n *       Bogons/v6bogon.html</a>\n *   <li><a target=\"_parent\" href=\"http://www.space.net/~gert/RIPE/ipv6-filters.html\">http://www.\n *       space.net/~gert/RIPE/ipv6-filters.html</a>\n * </ul>\n *\n * @author Erik Kline\n * @since 5.0\n */\n@Beta\n@GwtIncompatible\npublic final class InetAddresses\n{\n    private static final int IPV4_PART_COUNT = 4;\n    private static final int IPV6_PART_COUNT = 8;\n    private static final Splitter IPV4_SPLITTER = Splitter.on('.').limit(IPV4_PART_COUNT);\n    private static final Splitter IPV6_SPLITTER = Splitter.on(':').limit(IPV6_PART_COUNT + 2);\n    private static final Inet4Address LOOPBACK4 = (Inet4Address) forString(\"127.0.0.1\");\n    private static final Inet4Address ANY4 = (Inet4Address) forString(\"0.0.0.0\");\n\n    private InetAddresses() {}\n\n    /**\n     * Returns an {@link Inet4Address}, given a byte array representation of the IPv4 address.\n     *\n     * @param bytes byte array representing an IPv4 address (should be of length 4)\n     * @return {@link Inet4Address} corresponding to the supplied byte array\n     * @throws IllegalArgumentException if a valid {@link Inet4Address} can not be created\n     */\n    private static Inet4Address getInet4Address(byte[] bytes)\n    {\n        checkArgument(\n            bytes.length == 4,\n            \"Byte array has invalid length for an IPv4 address: %s != 4.\",\n            bytes.length);\n\n        // Given a 4-byte array, this cast should always succeed.\n        return (Inet4Address) bytesToInetAddress(bytes);\n    }\n\n    /**\n     * Returns the {@link InetAddress} having the given string representation.\n     *\n     * <p>This deliberately avoids all nameservice lookups (e.g. no DNS).\n     *\n     * @param ipString {@code String} containing an IPv4 or IPv6 string literal, e.g. {@code\n     *     \"192.168.0.1\"} or {@code \"2001:db8::1\"}\n     * @return {@link InetAddress} representing the argument\n     * @throws IllegalArgumentException if the argument is not a valid IP string literal\n     */\n    public static InetAddress forString(String ipString)\n    {\n        byte[] addr = ipStringToBytes(ipString);\n\n        // The argument was malformed, i.e. not an IP string literal.\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"'%s' is not an IP string literal.\", ipString);\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP string literal\n     * @return {@code true} if the argument is a valid IP string literal\n     */\n    public static boolean isInetAddress(String ipString)\n    {\n        return ipStringToBytes(ipString) != null;\n    }\n\n    @NullableDecl\n    private static byte[] ipStringToBytes(String ipString)\n    {\n        // Make a first pass to categorize the characters in this string.\n        boolean hasColon = false;\n        boolean hasDot = false;\n        for (int i = 0; i < ipString.length(); i++)\n        {\n            char c = ipString.charAt(i);\n            if (c == '.')\n            {\n                hasDot = true;\n            }\n            else if (c == ':')\n            {\n                if (hasDot)\n                {\n                    return null; // Colons must not appear after dots.\n                }\n                hasColon = true;\n            }\n            else if (Character.digit(c, 16) == -1)\n            {\n                return null; // Everything else must be a decimal or hex digit.\n            }\n        }\n\n        // Now decide which address family to parse.\n        if (hasColon)\n        {\n            if (hasDot)\n            {\n                ipString = convertDottedQuadToHex(ipString);\n                if (ipString == null)\n                {\n                    return null;\n                }\n            }\n            return textToNumericFormatV6(ipString);\n        }\n        else if (hasDot)\n        {\n            return textToNumericFormatV4(ipString);\n        }\n        return null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV4(String ipString)\n    {\n        byte[] bytes = new byte[IPV4_PART_COUNT];\n        int i = 0;\n        try\n        {\n            for (String octet : IPV4_SPLITTER.split(ipString))\n            {\n                bytes[i++] = parseOctet(octet);\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n\n        return i == IPV4_PART_COUNT ? bytes : null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV6(String ipString)\n    {\n        // An address can have [2..8] colons, and N colons make N+1 parts.\n        List<String> parts = IPV6_SPLITTER.splitToList(ipString);\n        if (parts.size() < 3 || parts.size() > IPV6_PART_COUNT + 1)\n        {\n            return null;\n        }\n\n        // Disregarding the endpoints, find \"::\" with nothing in between.\n        // This indicates that a run of zeroes has been skipped.\n        int skipIndex = -1;\n        for (int i = 1; i < parts.size() - 1; i++)\n        {\n            if (parts.get(i).length() == 0)\n            {\n                if (skipIndex >= 0)\n                {\n                    return null; // Can't have more than one ::\n                }\n                skipIndex = i;\n            }\n        }\n\n        int partsHi; // Number of parts to copy from above/before the \"::\"\n        int partsLo; // Number of parts to copy from below/after the \"::\"\n        if (skipIndex >= 0)\n        {\n            // If we found a \"::\", then check if it also covers the endpoints.\n            partsHi = skipIndex;\n            partsLo = parts.size() - skipIndex - 1;\n            if (parts.get(0).length() == 0 && --partsHi != 0)\n            {\n                return null; // ^: requires ^::\n            }\n            if (Iterables.getLast(parts).length() == 0 && --partsLo != 0)\n            {\n                return null; // :$ requires ::$\n            }\n        }\n        else\n        {\n            // Otherwise, allocate the entire address to partsHi. The endpoints\n            // could still be empty, but parseHextet() will check for that.\n            partsHi = parts.size();\n            partsLo = 0;\n        }\n\n        // If we found a ::, then we must have skipped at least one part.\n        // Otherwise, we must have exactly the right number of parts.\n        int partsSkipped = IPV6_PART_COUNT - (partsHi + partsLo);\n        if (!(skipIndex >= 0 ? partsSkipped >= 1 : partsSkipped == 0))\n        {\n            return null;\n        }\n\n        // Now parse the hextets into a byte array.\n        ByteBuffer rawBytes = ByteBuffer.allocate(2 * IPV6_PART_COUNT);\n        try\n        {\n            for (int i = 0; i < partsHi; i++)\n            {\n                rawBytes.putShort(parseHextet(parts.get(i)));\n            }\n            for (int i = 0; i < partsSkipped; i++)\n            {\n                rawBytes.putShort((short) 0);\n            }\n            for (int i = partsLo; i > 0; i--)\n            {\n                rawBytes.putShort(parseHextet(parts.get(parts.size() - i)));\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n        return rawBytes.array();\n    }\n\n    @NullableDecl\n    private static String convertDottedQuadToHex(String ipString)\n    {\n        int lastColon = ipString.lastIndexOf(':');\n        String initialPart = ipString.substring(0, lastColon + 1);\n        String dottedQuad = ipString.substring(lastColon + 1);\n        byte[] quad = textToNumericFormatV4(dottedQuad);\n        if (quad == null)\n        {\n            return null;\n        }\n        String penultimate = Integer.toHexString(((quad[0] & 0xff) << 8) | (quad[1] & 0xff));\n        String ultimate = Integer.toHexString(((quad[2] & 0xff) << 8) | (quad[3] & 0xff));\n        return initialPart + penultimate + \":\" + ultimate;\n    }\n\n    private static byte parseOctet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int octet = Integer.parseInt(ipPart);\n        // Disallow leading zeroes, because no clear standard exists on\n        // whether these should be interpreted as decimal or octal.\n        if (octet > 255 || (ipPart.startsWith(\"0\") && ipPart.length() > 1))\n        {\n            throw new NumberFormatException();\n        }\n        return (byte) octet;\n    }\n\n    private static short parseHextet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int hextet = Integer.parseInt(ipPart, 16);\n        if (hextet > 0xffff)\n        {\n            throw new NumberFormatException();\n        }\n        return (short) hextet;\n    }\n\n    /**\n     * Convert a byte array into an InetAddress.\n     *\n     * <p>{@link InetAddress#getByAddress} is documented as throwing a checked exception \"if IP\n     * address is of illegal length.\" We replace it with an unchecked exception, for use by callers\n     * who already know that addr is an array of length 4 or 16.\n     *\n     * @param addr the raw 4-byte or 16-byte IP address in big-endian order\n     * @return an InetAddress object created from the raw IP address\n     */\n    private static InetAddress bytesToInetAddress(byte[] addr)\n    {\n        try\n        {\n            return InetAddress.getByAddress(addr);\n        }\n        catch (UnknownHostException e)\n        {\n            throw new AssertionError(e);\n        }\n    }\n\n    /**\n     * Returns the string representation of an {@link InetAddress}.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses, the output follows <a href=\"http://tools.ietf.org/html/rfc5952\">RFC 5952</a> section\n     * 4. The main difference is that this method uses \"::\" for zero compression, while Java's version\n     * uses the uncompressed form.\n     *\n     * <p>This method uses hexadecimal for all IPv6 addresses, including IPv4-mapped IPv6 addresses\n     * such as \"::c000:201\". The output does not include a Scope ID.\n     *\n     * @param ip {@link InetAddress} to be converted to an address string\n     * @return {@code String} containing the text-formatted IP address\n     * @since 10.0\n     */\n    public static String toAddrString(InetAddress ip)\n    {\n        checkNotNull(ip);\n        if (ip instanceof Inet4Address)\n        {\n            // For IPv4, Java's formatting is good enough.\n            return ip.getHostAddress();\n        }\n        checkArgument(ip instanceof Inet6Address);\n        byte[] bytes = ip.getAddress();\n        int[] hextets = new int[IPV6_PART_COUNT];\n        for (int i = 0; i < hextets.length; i++)\n        {\n            hextets[i] = Ints.fromBytes((byte) 0, (byte) 0, bytes[2 * i], bytes[2 * i + 1]);\n        }\n        compressLongestRunOfZeroes(hextets);\n        return hextetsToIPv6String(hextets);\n    }\n\n    /**\n     * Identify and mark the longest run of zeroes in an IPv6 address.\n     *\n     * <p>Only runs of two or more hextets are considered. In case of a tie, the leftmost run wins. If\n     * a qualifying run is found, its hextets are replaced by the sentinel value -1.\n     *\n     * @param hextets {@code int[]} mutable array of eight 16-bit hextets\n     */\n\n    /**\n     * Convert a list of hextets into a human-readable IPv6 address.\n     *\n     * <p>In order for \"::\" compression to work, the input should contain negative sentinel values in\n     * place of the elided zeroes.\n     *\n     * @param hextets {@code int[]} array of eight 16-bit hextets, or -1s\n     */\n    private static String hextetsToIPv6String(int[] hextets)\n    {\n        // While scanning the array, handle these state transitions:\n        //   start->num => \"num\"     start->gap => \"::\"\n        //   num->num   => \":num\"    num->gap   => \"::\"\n        //   gap->num   => \"num\"     gap->gap   => \"\"\n        StringBuilder buf = new StringBuilder(39);\n        boolean lastWasNumber = false;\n        for (int i = 0; i < hextets.length; i++)\n        {\n            boolean thisIsNumber = hextets[i] >= 0;\n            if (thisIsNumber)\n            {\n                if (lastWasNumber)\n                {\n                    buf.append(':');\n                }\n                buf.append(Integer.toHexString(hextets[i]));\n            }\n            else\n            {\n                if (i == 0 || lastWasNumber)\n                {\n                    buf.append(\"::\");\n                }\n            }\n            lastWasNumber = thisIsNumber;\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Returns the string representation of an {@link InetAddress} suitable for inclusion in a URI.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses it compresses zeroes and surrounds the text with square brackets; for example {@code\n     * \"[2001:db8::1]\"}.\n     *\n     * <p>Per section 3.2.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3986#section-3.2.2\">RFC 3986</a>, a URI containing an IPv6\n     * string literal is of the form {@code \"http://[2001:db8::1]:8888/index.html\"}.\n     *\n     * <p>Use of either {@link InetAddresses#toAddrString}, {@link InetAddress#getHostAddress()}, or\n     * this method is recommended over {@link InetAddress#toString()} when an IP address string\n     * literal is desired. This is because {@link InetAddress#toString()} prints the hostname and the\n     * IP address string joined by a \"/\".\n     *\n     * @param ip {@link InetAddress} to be converted to URI string literal\n     * @return {@code String} containing URI-safe string literal\n     */\n    public static String toUriString(InetAddress ip)\n    {\n        if (ip instanceof Inet6Address)\n        {\n            return \"[\" + toAddrString(ip) + \"]\";\n        }\n        return toAddrString(ip);\n    }\n\n    /**\n     * Returns an InetAddress representing the literal IPv4 or IPv6 host portion of a URL, encoded in\n     * the format specified by RFC 3986 section 3.2.2.\n     *\n     * <p>This function is similar to {@link InetAddresses#forString(String)}, however, it requires\n     * that IPv6 addresses are surrounded by square brackets.\n     *\n     * <p>This function is the inverse of {@link InetAddresses#toUriString(java.net.InetAddress)}.\n     *\n     * @param hostAddr A RFC 3986 section 3.2.2 encoded IPv4 or IPv6 address\n     * @return an InetAddress representing the address in {@code hostAddr}\n     * @throws IllegalArgumentException if {@code hostAddr} is not a valid IPv4 address, or IPv6\n     *     address surrounded by square brackets\n     */\n    public static InetAddress forUriString(String hostAddr)\n    {\n        InetAddress addr = forUriStringNoThrow(hostAddr);\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"Not a valid URI IP literal: '%s'\", hostAddr);\n        }\n\n        return addr;\n    }\n\n    @NullableDecl\n    private static InetAddress forUriStringNoThrow(String hostAddr)\n    {\n        checkNotNull(hostAddr);\n\n        // Decide if this should be an IPv6 or IPv4 address.\n        String ipString;\n        int expectBytes;\n        if (hostAddr.startsWith(\"[\") && hostAddr.endsWith(\"]\"))\n        {\n            ipString = hostAddr.substring(1, hostAddr.length() - 1);\n            expectBytes = 16;\n        }\n        else\n        {\n            ipString = hostAddr;\n            expectBytes = 4;\n        }\n\n        // Parse the address, and make sure the length/version is correct.\n        byte[] addr = ipStringToBytes(ipString);\n        if (addr == null || addr.length != expectBytes)\n        {\n            return null;\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid URI IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP URI host string literal\n     * @return {@code true} if the argument is a valid IP URI host\n     */\n    public static boolean isUriInetAddress(String ipString)\n    {\n        return forUriStringNoThrow(ipString) != null;\n    }\n\n    /**\n     * Evaluates whether the argument is an IPv6 \"compat\" address.\n     *\n     * <p>An \"IPv4 compatible\", or \"compat\", address is one with 96 leading bits of zero, with the\n     * remaining 32 bits interpreted as an IPv4 address. These are conventionally represented in\n     * string literals as {@code \"::192.168.0.1\"}, though {@code \"::c0a8:1\"} is also considered an\n     * IPv4 compatible address (and equivalent to {@code \"::192.168.0.1\"}).\n     *\n     * <p>For more on IPv4 compatible addresses see section 2.5.5.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.1\">RFC 4291</a>.\n     *\n     * <p>NOTE: This method is different from {@link Inet6Address#isIPv4CompatibleAddress} in that it\n     * more correctly classifies {@code \"::\"} and {@code \"::1\"} as proper IPv6 addresses (which they\n     * are), NOT IPv4 compatible addresses (which they are generally NOT considered to be).\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 compatible address format\n     * @return {@code true} if the argument is a valid \"compat\" address\n     */\n    public static boolean isCompatIPv4Address(Inet6Address ip)\n    {\n        if (!ip.isIPv4CompatibleAddress())\n        {\n            return false;\n        }\n\n        byte[] bytes = ip.getAddress();\n        if ((bytes[12] == 0)\n                && (bytes[13] == 0)\n                && (bytes[14] == 0)\n                && ((bytes[15] == 0) || (bytes[15] == 1)))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the IPv4 address embedded in an IPv4 compatible address.\n     *\n     * @param ip {@link Inet6Address} to be examined for an embedded IPv4 address\n     * @return {@link Inet4Address} of the embedded IPv4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv4 compatible address\n     */\n    public static Inet4Address getCompatIPv4Address(Inet6Address ip)\n    {\n        checkArgument(\n            isCompatIPv4Address(ip), \"Address '%s' is not IPv4-compatible.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n    }\n\n    /**\n     * Evaluates whether the argument is a 6to4 address.\n     *\n     * <p>6to4 addresses begin with the {@code \"2002::/16\"} prefix. The next 32 bits are the IPv4\n     * address of the host to which IPv6-in-IPv4 tunneled packets should be routed.\n     *\n     * <p>For more on 6to4 addresses see section 2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3056#section-2\">RFC 3056</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for 6to4 address format\n     * @return {@code true} if the argument is a 6to4 address\n     */\n    public static boolean is6to4Address(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20) && (bytes[1] == (byte) 0x02);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in a 6to4 address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in 6to4 address\n     * @return {@link Inet4Address} of embedded IPv4 in 6to4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 6to4 address\n     */\n    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n    {\n        checkArgument(is6to4Address(ip), \"Address '%s' is not a 6to4 address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 2, 6));\n    }\n\n    /**\n     * A simple immutable data class to encapsulate the information to be found in a Teredo address.\n     *\n     * <p>All of the fields in this class are encoded in various portions of the IPv6 address as part\n     * of the protocol. More protocols details can be found at: <a target=\"_parent\"\n     * href=\"http://en.wikipedia.org/wiki/Teredo_tunneling\">http://en.wikipedia.\n     * org/wiki/Teredo_tunneling</a>.\n     *\n     * <p>The RFC can be found here: <a target=\"_parent\" href=\"http://tools.ietf.org/html/rfc4380\">RFC\n     * 4380</a>.\n     *\n     * @since 5.0\n     */\n    @Beta\n    public static final class TeredoInfo\n    {\n        private final Inet4Address server;\n        private final Inet4Address client;\n        private final int port;\n        private final int flags;\n\n        /**\n         * Constructs a TeredoInfo instance.\n         *\n         * <p>Both server and client can be {@code null}, in which case the value {@code \"0.0.0.0\"} will\n         * be assumed.\n         *\n         * @throws IllegalArgumentException if either of the {@code port} or the {@code flags} arguments\n         *     are out of range of an unsigned short\n         */\n        // TODO: why is this public?\n        public TeredoInfo(\n            @NullableDecl Inet4Address server, @NullableDecl Inet4Address client, int port, int flags)\n        {\n            checkArgument(\n                (port >= 0) && (port <= 0xffff), \"port '%s' is out of range (0 <= port <= 0xffff)\", port);\n            checkArgument(\n                (flags >= 0) && (flags <= 0xffff),\n                \"flags '%s' is out of range (0 <= flags <= 0xffff)\",\n                flags);\n\n            this.server = MoreObjects.firstNonNull(server, ANY4);\n            this.client = MoreObjects.firstNonNull(client, ANY4);\n            this.port = port;\n            this.flags = flags;\n        }\n\n        public Inet4Address getServer()\n        {\n            return server;\n        }\n\n        public Inet4Address getClient()\n        {\n            return client;\n        }\n\n        public int getPort()\n        {\n            return port;\n        }\n\n        public int getFlags()\n        {\n            return flags;\n        }\n    }\n\n    /**\n     * Evaluates whether the argument is a Teredo address.\n     *\n     * <p>Teredo addresses begin with the {@code \"2001::/32\"} prefix.\n     *\n     * @param ip {@link Inet6Address} to be examined for Teredo address format\n     * @return {@code true} if the argument is a Teredo address\n     */\n    public static boolean isTeredoAddress(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20)\n               && (bytes[1] == (byte) 0x01)\n               && (bytes[2] == 0)\n               && (bytes[3] == 0);\n    }\n\n    /**\n     * Returns the Teredo information embedded in a Teredo address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded Teredo information\n     * @return extracted {@code TeredoInfo}\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 Teredo address\n     */\n    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n    {\n        checkArgument(isTeredoAddress(ip), \"Address '%s' is not a Teredo address.\", toAddrString(ip));\n\n        byte[] bytes = ip.getAddress();\n        Inet4Address server = getInet4Address(Arrays.copyOfRange(bytes, 4, 8));\n\n        int flags = ByteStreams.newDataInput(bytes, 8).readShort() & 0xffff;\n\n        // Teredo obfuscates the mapped client port, per section 4 of the RFC.\n        int port = ~ByteStreams.newDataInput(bytes, 10).readShort() & 0xffff;\n\n        byte[] clientBytes = Arrays.copyOfRange(bytes, 12, 16);\n        for (int i = 0; i < clientBytes.length; i++)\n        {\n            // Teredo obfuscates the mapped client IP, per section 4 of the RFC.\n            clientBytes[i] = (byte) ~clientBytes[i];\n        }\n        Inet4Address client = getInet4Address(clientBytes);\n\n        return new TeredoInfo(server, client, port, flags);\n    }\n\n    /**\n     * Evaluates whether the argument is an ISATAP address.\n     *\n     * <p>From RFC 5214: \"ISATAP interface identifiers are constructed in Modified EUI-64 format [...]\n     * by concatenating the 24-bit IANA OUI (00-00-5E), the 8-bit hexadecimal value 0xFE, and a 32-bit\n     * IPv4 address in network byte order [...]\"\n     *\n     * <p>For more on ISATAP addresses see section 6.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc5214#section-6.1\">RFC 5214</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for ISATAP address format\n     * @return {@code true} if the argument is an ISATAP address\n     */\n    public static boolean isIsatapAddress(Inet6Address ip)\n    {\n\n        // If it's a Teredo address with the right port (41217, or 0xa101)\n        // which would be encoded as 0x5efe then it can't be an ISATAP address.\n        if (isTeredoAddress(ip))\n        {\n            return false;\n        }\n\n        byte[] bytes = ip.getAddress();\n\n        if ((bytes[8] | (byte) 0x03) != (byte) 0x03)\n        {\n\n            // Verify that high byte of the 64 bit identifier is zero, modulo\n            // the U/L and G bits, with which we are not concerned.\n            return false;\n        }\n\n        return (bytes[9] == (byte) 0x00) && (bytes[10] == (byte) 0x5e) && (bytes[11] == (byte) 0xfe);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in an ISATAP address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in ISATAP address\n     * @return {@link Inet4Address} of embedded IPv4 in an ISATAP address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 ISATAP address\n     */\n    public static Inet4Address getIsatapIPv4Address(Inet6Address ip)\n    {\n        checkArgument(isIsatapAddress(ip), \"Address '%s' is not an ISATAP address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n    }\n\n    /**\n     * Examines the Inet6Address to determine if it is an IPv6 address of one of the specified address\n     * types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@code true} if there is an embedded IPv4 client address\n     * @since 7.0\n     */\n    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        return isCompatIPv4Address(ip) || is6to4Address(ip) || isTeredoAddress(ip);\n    }\n\n    /**\n     * Examines the Inet6Address to extract the embedded IPv4 client address if the InetAddress is an\n     * IPv6 address of one of the specified address types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@link Inet4Address} of embedded IPv4 client address\n     * @throws IllegalArgumentException if the argument does not have a valid embedded IPv4 address\n     */\n    public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        if (isCompatIPv4Address(ip))\n        {\n            return getCompatIPv4Address(ip);\n        }\n\n        if (is6to4Address(ip))\n        {\n            return get6to4IPv4Address(ip);\n        }\n\n        if (isTeredoAddress(ip))\n        {\n            return getTeredoInfo(ip).getClient();\n        }\n\n        throw formatIllegalArgumentException(\"'%s' has no embedded IPv4 address.\", toAddrString(ip));\n    }\n\n    /**\n     * Evaluates whether the argument is an \"IPv4 mapped\" IPv6 address.\n     *\n     * <p>An \"IPv4 mapped\" address is anything in the range ::ffff:0:0/96 (sometimes written as\n     * ::ffff:0.0.0.0/96), with the last 32 bits interpreted as an IPv4 address.\n     *\n     * <p>For more on IPv4 mapped addresses see section 2.5.5.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.2\">RFC 4291</a>.\n     *\n     * <p>Note: This method takes a {@code String} argument because {@link InetAddress} automatically\n     * collapses mapped addresses to IPv4. (It is actually possible to avoid this using one of the\n     * obscure {@link Inet6Address} methods, but it would be unwise to depend on such a\n     * poorly-documented feature.)\n     *\n     * @param ipString {@code String} to be examined for embedded IPv4-mapped IPv6 address format\n     * @return {@code true} if the argument is a valid \"mapped\" address\n     * @since 10.0\n     */\n    public static boolean isMappedIPv4Address(String ipString)\n    {\n        byte[] bytes = ipStringToBytes(ipString);\n        if (bytes != null && bytes.length == 16)\n        {\n            for (int i = 0; i < 10; i++)\n            {\n                if (bytes[i] != 0)\n                {\n                    return false;\n                }\n            }\n            for (int i = 10; i < 12; i++)\n            {\n                if (bytes[i] != (byte) 0xff)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Coerces an IPv6 address into an IPv4 address.\n     *\n     * <p>HACK: As long as applications continue to use IPv4 addresses for indexing into tables,\n     * accounting, et cetera, it may be necessary to <b>coerce</b> IPv6 addresses into IPv4 addresses.\n     * This function does so by hashing the upper 64 bits into {@code 224.0.0.0/3} (64 bits into 29\n     * bits).\n     *\n     * <p>A \"coerced\" IPv4 address is equivalent to itself.\n     *\n     * <p>NOTE: This function is failsafe for security purposes: ALL IPv6 addresses (except localhost\n     * (::1)) are hashed to avoid the security risk associated with extracting an embedded IPv4\n     * address that might permit elevated privileges.\n     *\n     * @param ip {@link InetAddress} to \"coerce\"\n     * @return {@link Inet4Address} represented \"coerced\" address\n     * @since 7.0\n     */\n    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n    {\n        if (ip instanceof Inet4Address)\n        {\n            return (Inet4Address) ip;\n        }\n\n        // Special cases:\n        byte[] bytes = ip.getAddress();\n        boolean leadingBytesOfZero = true;\n        for (int i = 0; i < 15; ++i)\n        {\n            if (bytes[i] != 0)\n            {\n                leadingBytesOfZero = false;\n                break;\n            }\n        }\n        if (leadingBytesOfZero && (bytes[15] == 1))\n        {\n            return LOOPBACK4; // ::1\n        }\n        else if (leadingBytesOfZero && (bytes[15] == 0))\n        {\n            return ANY4; // ::0\n        }\n\n        Inet6Address ip6 = (Inet6Address) ip;\n        long addressAsLong = 0;\n        if (hasEmbeddedIPv4ClientAddress(ip6))\n        {\n            addressAsLong = getEmbeddedIPv4ClientAddress(ip6).hashCode();\n        }\n        else\n        {\n\n            // Just extract the high 64 bits (assuming the rest is user-modifiable).\n            addressAsLong = ByteBuffer.wrap(ip6.getAddress(), 0, 8).getLong();\n        }\n\n        // Many strategies for hashing are possible. This might suffice for now.\n        int coercedHash = Hashing.murmur3_32().hashLong(addressAsLong).asInt();\n\n        // Squash into 224/4 Multicast and 240/4 Reserved space (i.e. 224/3).\n        coercedHash |= 0xe0000000;\n\n        // Fixup to avoid some \"illegal\" values. Currently the only potential\n        // illegal value is 255.255.255.255.\n        if (coercedHash == 0xffffffff)\n        {\n            coercedHash = 0xfffffffe;\n        }\n\n        return getInet4Address(Ints.toByteArray(coercedHash));\n    }\n\n    /**\n     * Returns an integer representing an IPv4 address regardless of whether the supplied argument is\n     * an IPv4 address or not.\n     *\n     * <p>IPv6 addresses are <b>coerced</b> to IPv4 addresses before being converted to integers.\n     *\n     * <p>As long as there are applications that assume that all IP addresses are IPv4 addresses and\n     * can therefore be converted safely to integers (for whatever purpose) this function can be used\n     * to handle IPv6 addresses as well until the application is suitably fixed.\n     *\n     * <p>NOTE: an IPv6 address coerced to an IPv4 address can only be used for such purposes as\n     * rudimentary identification or indexing into a collection of real {@link InetAddress}es. They\n     * cannot be used as real addresses for the purposes of network communication.\n     *\n     * @param ip {@link InetAddress} to convert\n     * @return {@code int}, \"coerced\" if ip is not an IPv4 address\n     * @since 7.0\n     */\n    public static int coerceToInteger(InetAddress ip)\n    {\n        return ByteStreams.newDataInput(getCoercedIPv4Address(ip).getAddress()).readInt();\n    }\n\n    /**\n     * Returns an Inet4Address having the integer value specified by the argument.\n     *\n     * @param address {@code int}, the 32bit integer address to be converted\n     * @return {@link Inet4Address} equivalent of the argument\n     */\n    public static Inet4Address fromInteger(int address)\n    {\n        return getInet4Address(Ints.toByteArray(address));\n    }\n\n    /**\n     * Returns an address from a <b>little-endian ordered</b> byte array (the opposite of what {@link\n     * InetAddress#getByAddress} expects).\n     *\n     * <p>IPv4 address byte array must be 4 bytes long and IPv6 byte array must be 16 bytes long.\n     *\n     * @param addr the raw IP address in little-endian byte order\n     * @return an InetAddress object created from the raw IP address\n     * @throws UnknownHostException if IP address is of illegal length\n     */\n    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n    {\n        byte[] reversed = new byte[addr.length];\n        for (int i = 0; i < addr.length; i++)\n        {\n            reversed[i] = addr[addr.length - i - 1];\n        }\n        return InetAddress.getByAddress(reversed);\n    }\n\n    /**\n     * Returns a new InetAddress that is one less than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to decrement\n     * @return a new InetAddress that is one less than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the beginning of its range\n     * @since 18.0\n     */\n    public static InetAddress decrement(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0x00)\n        {\n            addr[i] = (byte) 0xff;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Decrementing %s would wrap.\", address);\n\n        addr[i]--;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns a new InetAddress that is one more than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to increment\n     * @return a new InetAddress that is one more than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the end of its range\n     * @since 10.0\n     */\n    public static InetAddress increment(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0xff)\n        {\n            addr[i] = 0;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Incrementing %s would wrap.\", address);\n\n        addr[i]++;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns true if the InetAddress is either 255.255.255.255 for IPv4 or\n     * ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6.\n     *\n     * @return true if the InetAddress is either 255.255.255.255 for IPv4 or\n     *     ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6\n     * @since 10.0\n     */\n    public static boolean isMaximum(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        for (int i = 0; i < addr.length; i++)\n        {\n            if (addr[i] != (byte) 0xff)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static IllegalArgumentException formatIllegalArgumentException(\n        String format, Object... args)\n    {\n        return new IllegalArgumentException(String.format(Locale.ROOT, format, args));\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.hextetsToIPv6String", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Convert a list of hextets into a human-readable IPv6 address.\n\n<p>In order for \"::\" compression to work, the input should contain negative sentinel values in\nplace of the elided zeroes.\n\n@param hextets {@code int[]} array of eight 16-bit hextets, or -1s", "docstring_tokens": ["Convert", "a", "list", "of", "hextets", "into", "a", "human", "-", "readable", "IPv6", "address", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L395-L417", "partition": "valid", "up_fun_num": 14, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.MoreObjects;", "import com.google.common.base.Splitter;", "import com.google.common.collect.Iterables;", "import com.google.common.hash.Hashing;", "import com.google.common.io.ByteStreams;", "import com.google.common.primitives.Ints;", "import java.net.Inet4Address;", "import java.net.Inet6Address;", "import java.net.InetAddress;", "import java.net.UnknownHostException;", "import java.nio.ByteBuffer;", "import java.util.Arrays;", "import java.util.List;", "import java.util.Locale;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class InetAddresses\n", "    private static Inet4Address getInet4Address(byte[] bytes)\n", "    public static InetAddress forString(String ipString)\n", "    public static boolean isInetAddress(String ipString)\n", "    private static byte[] ipStringToBytes(String ipString)\n", "    private static byte[] textToNumericFormatV4(String ipString)\n", "    private static byte[] textToNumericFormatV6(String ipString)\n", "    private static String convertDottedQuadToHex(String ipString)\n", "    private static byte parseOctet(String ipPart)\n", "    private static short parseHextet(String ipPart)\n", "    private static InetAddress bytesToInetAddress(byte[] addr)\n", "    public static String toAddrString(InetAddress ip)\n", "    private static void compressLongestRunOfZeroes(int[] hextets)\n", "    public static String toUriString(InetAddress ip)\n", "    public static InetAddress forUriString(String hostAddr)\n", "    private static InetAddress forUriStringNoThrow(String hostAddr)\n", "    public static boolean isUriInetAddress(String ipString)\n", "    public static boolean isCompatIPv4Address(Inet6Address ip)\n", "    public static Inet4Address getCompatIPv4Address(Inet6Address ip)\n", "    public static boolean is6to4Address(Inet6Address ip)\n", "    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n", "    public static boolean isTeredoAddress(Inet6Address ip)\n", "    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n", "    public static boolean isIsatapAddress(Inet6Address ip)\n", "    public static Inet4Address getIsatapIPv4Address(Inet6Address ip)\n", "    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static boolean isMappedIPv4Address(String ipString)\n", "    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n", "    public static int coerceToInteger(InetAddress ip)\n", "    public static Inet4Address fromInteger(int address)\n", "    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n", "    public static InetAddress decrement(InetAddress address)\n", "    public static InetAddress increment(InetAddress address)\n", "    public static boolean isMaximum(InetAddress address)\n", "    private static IllegalArgumentException formatIllegalArgumentException(\n"], "context": "/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.net;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.Iterables;\nimport com.google.common.hash.Hashing;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.primitives.Ints;\nimport java.net.Inet4Address;\nimport java.net.Inet6Address;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * Static utility methods pertaining to {@link InetAddress} instances.\n *\n * <p><b>Important note:</b> Unlike {@code InetAddress.getByName()}, the methods of this class never\n * cause DNS services to be accessed. For this reason, you should prefer these methods as much as\n * possible over their JDK equivalents whenever you are expecting to handle only IP address string\n * literals -- there is no blocking DNS penalty for a malformed string.\n *\n * <p>When dealing with {@link Inet4Address} and {@link Inet6Address} objects as byte arrays (vis.\n * {@code InetAddress.getAddress()}) they are 4 and 16 bytes in length, respectively, and represent\n * the address in network byte order.\n *\n * <p>Examples of IP addresses and their byte representations:\n *\n * <dl>\n *   <dt>The IPv4 loopback address, {@code \"127.0.0.1\"}.\n *   <dd>{@code 7f 00 00 01}\n *   <dt>The IPv6 loopback address, {@code \"::1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>From the IPv6 reserved documentation prefix ({@code 2001:db8::/32}), {@code \"2001:db8::1\"}.\n *   <dd>{@code 20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>An IPv6 \"IPv4 compatible\" (or \"compat\") address, {@code \"::192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 c0 a8 00 01}\n *   <dt>An IPv6 \"IPv4 mapped\" address, {@code \"::ffff:192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 ff ff c0 a8 00 01}\n * </dl>\n *\n * <p>A few notes about IPv6 \"IPv4 mapped\" addresses and their observed use in Java.\n *\n * <p>\"IPv4 mapped\" addresses were originally a representation of IPv4 addresses for use on an IPv6\n * socket that could receive both IPv4 and IPv6 connections (by disabling the {@code IPV6_V6ONLY}\n * socket option on an IPv6 socket). Yes, it's confusing. Nevertheless, these \"mapped\" addresses\n * were never supposed to be seen on the wire. That assumption was dropped, some say mistakenly, in\n * later RFCs with the apparent aim of making IPv4-to-IPv6 transition simpler.\n *\n * <p>Technically one <i>can</i> create a 128bit IPv6 address with the wire format of a \"mapped\"\n * address, as shown above, and transmit it in an IPv6 packet header. However, Java's InetAddress\n * creation methods appear to adhere doggedly to the original intent of the \"mapped\" address: all\n * \"mapped\" addresses return {@link Inet4Address} objects.\n *\n * <p>For added safety, it is common for IPv6 network operators to filter all packets where either\n * the source or destination address appears to be a \"compat\" or \"mapped\" address. Filtering\n * suggestions usually recommend discarding any packets with source or destination addresses in the\n * invalid range {@code ::/3}, which includes both of these bizarre address formats. For more\n * information on \"bogons\", including lists of IPv6 bogon space, see:\n *\n * <ul>\n *   <li><a target=\"_parent\"\n *       href=\"http://en.wikipedia.org/wiki/Bogon_filtering\">http://en.wikipedia.\n *       org/wiki/Bogon_filtering</a>\n *   <li><a target=\"_parent\"\n *       href=\"http://www.cymru.com/Bogons/ipv6.txt\">http://www.cymru.com/Bogons/ ipv6.txt</a>\n *   <li><a target=\"_parent\" href=\"http://www.cymru.com/Bogons/v6bogon.html\">http://www.cymru.com/\n *       Bogons/v6bogon.html</a>\n *   <li><a target=\"_parent\" href=\"http://www.space.net/~gert/RIPE/ipv6-filters.html\">http://www.\n *       space.net/~gert/RIPE/ipv6-filters.html</a>\n * </ul>\n *\n * @author Erik Kline\n * @since 5.0\n */\n@Beta\n@GwtIncompatible\npublic final class InetAddresses\n{\n    private static final int IPV4_PART_COUNT = 4;\n    private static final int IPV6_PART_COUNT = 8;\n    private static final Splitter IPV4_SPLITTER = Splitter.on('.').limit(IPV4_PART_COUNT);\n    private static final Splitter IPV6_SPLITTER = Splitter.on(':').limit(IPV6_PART_COUNT + 2);\n    private static final Inet4Address LOOPBACK4 = (Inet4Address) forString(\"127.0.0.1\");\n    private static final Inet4Address ANY4 = (Inet4Address) forString(\"0.0.0.0\");\n\n    private InetAddresses() {}\n\n    /**\n     * Returns an {@link Inet4Address}, given a byte array representation of the IPv4 address.\n     *\n     * @param bytes byte array representing an IPv4 address (should be of length 4)\n     * @return {@link Inet4Address} corresponding to the supplied byte array\n     * @throws IllegalArgumentException if a valid {@link Inet4Address} can not be created\n     */\n    private static Inet4Address getInet4Address(byte[] bytes)\n    {\n        checkArgument(\n            bytes.length == 4,\n            \"Byte array has invalid length for an IPv4 address: %s != 4.\",\n            bytes.length);\n\n        // Given a 4-byte array, this cast should always succeed.\n        return (Inet4Address) bytesToInetAddress(bytes);\n    }\n\n    /**\n     * Returns the {@link InetAddress} having the given string representation.\n     *\n     * <p>This deliberately avoids all nameservice lookups (e.g. no DNS).\n     *\n     * @param ipString {@code String} containing an IPv4 or IPv6 string literal, e.g. {@code\n     *     \"192.168.0.1\"} or {@code \"2001:db8::1\"}\n     * @return {@link InetAddress} representing the argument\n     * @throws IllegalArgumentException if the argument is not a valid IP string literal\n     */\n    public static InetAddress forString(String ipString)\n    {\n        byte[] addr = ipStringToBytes(ipString);\n\n        // The argument was malformed, i.e. not an IP string literal.\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"'%s' is not an IP string literal.\", ipString);\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP string literal\n     * @return {@code true} if the argument is a valid IP string literal\n     */\n    public static boolean isInetAddress(String ipString)\n    {\n        return ipStringToBytes(ipString) != null;\n    }\n\n    @NullableDecl\n    private static byte[] ipStringToBytes(String ipString)\n    {\n        // Make a first pass to categorize the characters in this string.\n        boolean hasColon = false;\n        boolean hasDot = false;\n        for (int i = 0; i < ipString.length(); i++)\n        {\n            char c = ipString.charAt(i);\n            if (c == '.')\n            {\n                hasDot = true;\n            }\n            else if (c == ':')\n            {\n                if (hasDot)\n                {\n                    return null; // Colons must not appear after dots.\n                }\n                hasColon = true;\n            }\n            else if (Character.digit(c, 16) == -1)\n            {\n                return null; // Everything else must be a decimal or hex digit.\n            }\n        }\n\n        // Now decide which address family to parse.\n        if (hasColon)\n        {\n            if (hasDot)\n            {\n                ipString = convertDottedQuadToHex(ipString);\n                if (ipString == null)\n                {\n                    return null;\n                }\n            }\n            return textToNumericFormatV6(ipString);\n        }\n        else if (hasDot)\n        {\n            return textToNumericFormatV4(ipString);\n        }\n        return null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV4(String ipString)\n    {\n        byte[] bytes = new byte[IPV4_PART_COUNT];\n        int i = 0;\n        try\n        {\n            for (String octet : IPV4_SPLITTER.split(ipString))\n            {\n                bytes[i++] = parseOctet(octet);\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n\n        return i == IPV4_PART_COUNT ? bytes : null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV6(String ipString)\n    {\n        // An address can have [2..8] colons, and N colons make N+1 parts.\n        List<String> parts = IPV6_SPLITTER.splitToList(ipString);\n        if (parts.size() < 3 || parts.size() > IPV6_PART_COUNT + 1)\n        {\n            return null;\n        }\n\n        // Disregarding the endpoints, find \"::\" with nothing in between.\n        // This indicates that a run of zeroes has been skipped.\n        int skipIndex = -1;\n        for (int i = 1; i < parts.size() - 1; i++)\n        {\n            if (parts.get(i).length() == 0)\n            {\n                if (skipIndex >= 0)\n                {\n                    return null; // Can't have more than one ::\n                }\n                skipIndex = i;\n            }\n        }\n\n        int partsHi; // Number of parts to copy from above/before the \"::\"\n        int partsLo; // Number of parts to copy from below/after the \"::\"\n        if (skipIndex >= 0)\n        {\n            // If we found a \"::\", then check if it also covers the endpoints.\n            partsHi = skipIndex;\n            partsLo = parts.size() - skipIndex - 1;\n            if (parts.get(0).length() == 0 && --partsHi != 0)\n            {\n                return null; // ^: requires ^::\n            }\n            if (Iterables.getLast(parts).length() == 0 && --partsLo != 0)\n            {\n                return null; // :$ requires ::$\n            }\n        }\n        else\n        {\n            // Otherwise, allocate the entire address to partsHi. The endpoints\n            // could still be empty, but parseHextet() will check for that.\n            partsHi = parts.size();\n            partsLo = 0;\n        }\n\n        // If we found a ::, then we must have skipped at least one part.\n        // Otherwise, we must have exactly the right number of parts.\n        int partsSkipped = IPV6_PART_COUNT - (partsHi + partsLo);\n        if (!(skipIndex >= 0 ? partsSkipped >= 1 : partsSkipped == 0))\n        {\n            return null;\n        }\n\n        // Now parse the hextets into a byte array.\n        ByteBuffer rawBytes = ByteBuffer.allocate(2 * IPV6_PART_COUNT);\n        try\n        {\n            for (int i = 0; i < partsHi; i++)\n            {\n                rawBytes.putShort(parseHextet(parts.get(i)));\n            }\n            for (int i = 0; i < partsSkipped; i++)\n            {\n                rawBytes.putShort((short) 0);\n            }\n            for (int i = partsLo; i > 0; i--)\n            {\n                rawBytes.putShort(parseHextet(parts.get(parts.size() - i)));\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n        return rawBytes.array();\n    }\n\n    @NullableDecl\n    private static String convertDottedQuadToHex(String ipString)\n    {\n        int lastColon = ipString.lastIndexOf(':');\n        String initialPart = ipString.substring(0, lastColon + 1);\n        String dottedQuad = ipString.substring(lastColon + 1);\n        byte[] quad = textToNumericFormatV4(dottedQuad);\n        if (quad == null)\n        {\n            return null;\n        }\n        String penultimate = Integer.toHexString(((quad[0] & 0xff) << 8) | (quad[1] & 0xff));\n        String ultimate = Integer.toHexString(((quad[2] & 0xff) << 8) | (quad[3] & 0xff));\n        return initialPart + penultimate + \":\" + ultimate;\n    }\n\n    private static byte parseOctet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int octet = Integer.parseInt(ipPart);\n        // Disallow leading zeroes, because no clear standard exists on\n        // whether these should be interpreted as decimal or octal.\n        if (octet > 255 || (ipPart.startsWith(\"0\") && ipPart.length() > 1))\n        {\n            throw new NumberFormatException();\n        }\n        return (byte) octet;\n    }\n\n    private static short parseHextet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int hextet = Integer.parseInt(ipPart, 16);\n        if (hextet > 0xffff)\n        {\n            throw new NumberFormatException();\n        }\n        return (short) hextet;\n    }\n\n    /**\n     * Convert a byte array into an InetAddress.\n     *\n     * <p>{@link InetAddress#getByAddress} is documented as throwing a checked exception \"if IP\n     * address is of illegal length.\" We replace it with an unchecked exception, for use by callers\n     * who already know that addr is an array of length 4 or 16.\n     *\n     * @param addr the raw 4-byte or 16-byte IP address in big-endian order\n     * @return an InetAddress object created from the raw IP address\n     */\n    private static InetAddress bytesToInetAddress(byte[] addr)\n    {\n        try\n        {\n            return InetAddress.getByAddress(addr);\n        }\n        catch (UnknownHostException e)\n        {\n            throw new AssertionError(e);\n        }\n    }\n\n    /**\n     * Returns the string representation of an {@link InetAddress}.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses, the output follows <a href=\"http://tools.ietf.org/html/rfc5952\">RFC 5952</a> section\n     * 4. The main difference is that this method uses \"::\" for zero compression, while Java's version\n     * uses the uncompressed form.\n     *\n     * <p>This method uses hexadecimal for all IPv6 addresses, including IPv4-mapped IPv6 addresses\n     * such as \"::c000:201\". The output does not include a Scope ID.\n     *\n     * @param ip {@link InetAddress} to be converted to an address string\n     * @return {@code String} containing the text-formatted IP address\n     * @since 10.0\n     */\n    public static String toAddrString(InetAddress ip)\n    {\n        checkNotNull(ip);\n        if (ip instanceof Inet4Address)\n        {\n            // For IPv4, Java's formatting is good enough.\n            return ip.getHostAddress();\n        }\n        checkArgument(ip instanceof Inet6Address);\n        byte[] bytes = ip.getAddress();\n        int[] hextets = new int[IPV6_PART_COUNT];\n        for (int i = 0; i < hextets.length; i++)\n        {\n            hextets[i] = Ints.fromBytes((byte) 0, (byte) 0, bytes[2 * i], bytes[2 * i + 1]);\n        }\n        compressLongestRunOfZeroes(hextets);\n        return hextetsToIPv6String(hextets);\n    }\n\n    /**\n     * Identify and mark the longest run of zeroes in an IPv6 address.\n     *\n     * <p>Only runs of two or more hextets are considered. In case of a tie, the leftmost run wins. If\n     * a qualifying run is found, its hextets are replaced by the sentinel value -1.\n     *\n     * @param hextets {@code int[]} mutable array of eight 16-bit hextets\n     */\n    private static void compressLongestRunOfZeroes(int[] hextets)\n    {\n        int bestRunStart = -1;\n        int bestRunLength = -1;\n        int runStart = -1;\n        for (int i = 0; i < hextets.length + 1; i++)\n        {\n            if (i < hextets.length && hextets[i] == 0)\n            {\n                if (runStart < 0)\n                {\n                    runStart = i;\n                }\n            }\n            else if (runStart >= 0)\n            {\n                int runLength = i - runStart;\n                if (runLength > bestRunLength)\n                {\n                    bestRunStart = runStart;\n                    bestRunLength = runLength;\n                }\n                runStart = -1;\n            }\n        }\n        if (bestRunLength >= 2)\n        {\n            Arrays.fill(hextets, bestRunStart, bestRunStart + bestRunLength, -1);\n        }\n    }\n\n    /**\n     * Convert a list of hextets into a human-readable IPv6 address.\n     *\n     * <p>In order for \"::\" compression to work, the input should contain negative sentinel values in\n     * place of the elided zeroes.\n     *\n     * @param hextets {@code int[]} array of eight 16-bit hextets, or -1s\n     */\n\n    /**\n     * Returns the string representation of an {@link InetAddress} suitable for inclusion in a URI.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses it compresses zeroes and surrounds the text with square brackets; for example {@code\n     * \"[2001:db8::1]\"}.\n     *\n     * <p>Per section 3.2.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3986#section-3.2.2\">RFC 3986</a>, a URI containing an IPv6\n     * string literal is of the form {@code \"http://[2001:db8::1]:8888/index.html\"}.\n     *\n     * <p>Use of either {@link InetAddresses#toAddrString}, {@link InetAddress#getHostAddress()}, or\n     * this method is recommended over {@link InetAddress#toString()} when an IP address string\n     * literal is desired. This is because {@link InetAddress#toString()} prints the hostname and the\n     * IP address string joined by a \"/\".\n     *\n     * @param ip {@link InetAddress} to be converted to URI string literal\n     * @return {@code String} containing URI-safe string literal\n     */\n    public static String toUriString(InetAddress ip)\n    {\n        if (ip instanceof Inet6Address)\n        {\n            return \"[\" + toAddrString(ip) + \"]\";\n        }\n        return toAddrString(ip);\n    }\n\n    /**\n     * Returns an InetAddress representing the literal IPv4 or IPv6 host portion of a URL, encoded in\n     * the format specified by RFC 3986 section 3.2.2.\n     *\n     * <p>This function is similar to {@link InetAddresses#forString(String)}, however, it requires\n     * that IPv6 addresses are surrounded by square brackets.\n     *\n     * <p>This function is the inverse of {@link InetAddresses#toUriString(java.net.InetAddress)}.\n     *\n     * @param hostAddr A RFC 3986 section 3.2.2 encoded IPv4 or IPv6 address\n     * @return an InetAddress representing the address in {@code hostAddr}\n     * @throws IllegalArgumentException if {@code hostAddr} is not a valid IPv4 address, or IPv6\n     *     address surrounded by square brackets\n     */\n    public static InetAddress forUriString(String hostAddr)\n    {\n        InetAddress addr = forUriStringNoThrow(hostAddr);\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"Not a valid URI IP literal: '%s'\", hostAddr);\n        }\n\n        return addr;\n    }\n\n    @NullableDecl\n    private static InetAddress forUriStringNoThrow(String hostAddr)\n    {\n        checkNotNull(hostAddr);\n\n        // Decide if this should be an IPv6 or IPv4 address.\n        String ipString;\n        int expectBytes;\n        if (hostAddr.startsWith(\"[\") && hostAddr.endsWith(\"]\"))\n        {\n            ipString = hostAddr.substring(1, hostAddr.length() - 1);\n            expectBytes = 16;\n        }\n        else\n        {\n            ipString = hostAddr;\n            expectBytes = 4;\n        }\n\n        // Parse the address, and make sure the length/version is correct.\n        byte[] addr = ipStringToBytes(ipString);\n        if (addr == null || addr.length != expectBytes)\n        {\n            return null;\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid URI IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP URI host string literal\n     * @return {@code true} if the argument is a valid IP URI host\n     */\n    public static boolean isUriInetAddress(String ipString)\n    {\n        return forUriStringNoThrow(ipString) != null;\n    }\n\n    /**\n     * Evaluates whether the argument is an IPv6 \"compat\" address.\n     *\n     * <p>An \"IPv4 compatible\", or \"compat\", address is one with 96 leading bits of zero, with the\n     * remaining 32 bits interpreted as an IPv4 address. These are conventionally represented in\n     * string literals as {@code \"::192.168.0.1\"}, though {@code \"::c0a8:1\"} is also considered an\n     * IPv4 compatible address (and equivalent to {@code \"::192.168.0.1\"}).\n     *\n     * <p>For more on IPv4 compatible addresses see section 2.5.5.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.1\">RFC 4291</a>.\n     *\n     * <p>NOTE: This method is different from {@link Inet6Address#isIPv4CompatibleAddress} in that it\n     * more correctly classifies {@code \"::\"} and {@code \"::1\"} as proper IPv6 addresses (which they\n     * are), NOT IPv4 compatible addresses (which they are generally NOT considered to be).\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 compatible address format\n     * @return {@code true} if the argument is a valid \"compat\" address\n     */\n    public static boolean isCompatIPv4Address(Inet6Address ip)\n    {\n        if (!ip.isIPv4CompatibleAddress())\n        {\n            return false;\n        }\n\n        byte[] bytes = ip.getAddress();\n        if ((bytes[12] == 0)\n                && (bytes[13] == 0)\n                && (bytes[14] == 0)\n                && ((bytes[15] == 0) || (bytes[15] == 1)))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the IPv4 address embedded in an IPv4 compatible address.\n     *\n     * @param ip {@link Inet6Address} to be examined for an embedded IPv4 address\n     * @return {@link Inet4Address} of the embedded IPv4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv4 compatible address\n     */\n    public static Inet4Address getCompatIPv4Address(Inet6Address ip)\n    {\n        checkArgument(\n            isCompatIPv4Address(ip), \"Address '%s' is not IPv4-compatible.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n    }\n\n    /**\n     * Evaluates whether the argument is a 6to4 address.\n     *\n     * <p>6to4 addresses begin with the {@code \"2002::/16\"} prefix. The next 32 bits are the IPv4\n     * address of the host to which IPv6-in-IPv4 tunneled packets should be routed.\n     *\n     * <p>For more on 6to4 addresses see section 2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3056#section-2\">RFC 3056</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for 6to4 address format\n     * @return {@code true} if the argument is a 6to4 address\n     */\n    public static boolean is6to4Address(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20) && (bytes[1] == (byte) 0x02);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in a 6to4 address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in 6to4 address\n     * @return {@link Inet4Address} of embedded IPv4 in 6to4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 6to4 address\n     */\n    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n    {\n        checkArgument(is6to4Address(ip), \"Address '%s' is not a 6to4 address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 2, 6));\n    }\n\n    /**\n     * A simple immutable data class to encapsulate the information to be found in a Teredo address.\n     *\n     * <p>All of the fields in this class are encoded in various portions of the IPv6 address as part\n     * of the protocol. More protocols details can be found at: <a target=\"_parent\"\n     * href=\"http://en.wikipedia.org/wiki/Teredo_tunneling\">http://en.wikipedia.\n     * org/wiki/Teredo_tunneling</a>.\n     *\n     * <p>The RFC can be found here: <a target=\"_parent\" href=\"http://tools.ietf.org/html/rfc4380\">RFC\n     * 4380</a>.\n     *\n     * @since 5.0\n     */\n    @Beta\n    public static final class TeredoInfo\n    {\n        private final Inet4Address server;\n        private final Inet4Address client;\n        private final int port;\n        private final int flags;\n\n        /**\n         * Constructs a TeredoInfo instance.\n         *\n         * <p>Both server and client can be {@code null}, in which case the value {@code \"0.0.0.0\"} will\n         * be assumed.\n         *\n         * @throws IllegalArgumentException if either of the {@code port} or the {@code flags} arguments\n         *     are out of range of an unsigned short\n         */\n        // TODO: why is this public?\n        public TeredoInfo(\n            @NullableDecl Inet4Address server, @NullableDecl Inet4Address client, int port, int flags)\n        {\n            checkArgument(\n                (port >= 0) && (port <= 0xffff), \"port '%s' is out of range (0 <= port <= 0xffff)\", port);\n            checkArgument(\n                (flags >= 0) && (flags <= 0xffff),\n                \"flags '%s' is out of range (0 <= flags <= 0xffff)\",\n                flags);\n\n            this.server = MoreObjects.firstNonNull(server, ANY4);\n            this.client = MoreObjects.firstNonNull(client, ANY4);\n            this.port = port;\n            this.flags = flags;\n        }\n\n        public Inet4Address getServer()\n        {\n            return server;\n        }\n\n        public Inet4Address getClient()\n        {\n            return client;\n        }\n\n        public int getPort()\n        {\n            return port;\n        }\n\n        public int getFlags()\n        {\n            return flags;\n        }\n    }\n\n    /**\n     * Evaluates whether the argument is a Teredo address.\n     *\n     * <p>Teredo addresses begin with the {@code \"2001::/32\"} prefix.\n     *\n     * @param ip {@link Inet6Address} to be examined for Teredo address format\n     * @return {@code true} if the argument is a Teredo address\n     */\n    public static boolean isTeredoAddress(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20)\n               && (bytes[1] == (byte) 0x01)\n               && (bytes[2] == 0)\n               && (bytes[3] == 0);\n    }\n\n    /**\n     * Returns the Teredo information embedded in a Teredo address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded Teredo information\n     * @return extracted {@code TeredoInfo}\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 Teredo address\n     */\n    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n    {\n        checkArgument(isTeredoAddress(ip), \"Address '%s' is not a Teredo address.\", toAddrString(ip));\n\n        byte[] bytes = ip.getAddress();\n        Inet4Address server = getInet4Address(Arrays.copyOfRange(bytes, 4, 8));\n\n        int flags = ByteStreams.newDataInput(bytes, 8).readShort() & 0xffff;\n\n        // Teredo obfuscates the mapped client port, per section 4 of the RFC.\n        int port = ~ByteStreams.newDataInput(bytes, 10).readShort() & 0xffff;\n\n        byte[] clientBytes = Arrays.copyOfRange(bytes, 12, 16);\n        for (int i = 0; i < clientBytes.length; i++)\n        {\n            // Teredo obfuscates the mapped client IP, per section 4 of the RFC.\n            clientBytes[i] = (byte) ~clientBytes[i];\n        }\n        Inet4Address client = getInet4Address(clientBytes);\n\n        return new TeredoInfo(server, client, port, flags);\n    }\n\n    /**\n     * Evaluates whether the argument is an ISATAP address.\n     *\n     * <p>From RFC 5214: \"ISATAP interface identifiers are constructed in Modified EUI-64 format [...]\n     * by concatenating the 24-bit IANA OUI (00-00-5E), the 8-bit hexadecimal value 0xFE, and a 32-bit\n     * IPv4 address in network byte order [...]\"\n     *\n     * <p>For more on ISATAP addresses see section 6.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc5214#section-6.1\">RFC 5214</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for ISATAP address format\n     * @return {@code true} if the argument is an ISATAP address\n     */\n    public static boolean isIsatapAddress(Inet6Address ip)\n    {\n\n        // If it's a Teredo address with the right port (41217, or 0xa101)\n        // which would be encoded as 0x5efe then it can't be an ISATAP address.\n        if (isTeredoAddress(ip))\n        {\n            return false;\n        }\n\n        byte[] bytes = ip.getAddress();\n\n        if ((bytes[8] | (byte) 0x03) != (byte) 0x03)\n        {\n\n            // Verify that high byte of the 64 bit identifier is zero, modulo\n            // the U/L and G bits, with which we are not concerned.\n            return false;\n        }\n\n        return (bytes[9] == (byte) 0x00) && (bytes[10] == (byte) 0x5e) && (bytes[11] == (byte) 0xfe);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in an ISATAP address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in ISATAP address\n     * @return {@link Inet4Address} of embedded IPv4 in an ISATAP address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 ISATAP address\n     */\n    public static Inet4Address getIsatapIPv4Address(Inet6Address ip)\n    {\n        checkArgument(isIsatapAddress(ip), \"Address '%s' is not an ISATAP address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n    }\n\n    /**\n     * Examines the Inet6Address to determine if it is an IPv6 address of one of the specified address\n     * types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@code true} if there is an embedded IPv4 client address\n     * @since 7.0\n     */\n    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        return isCompatIPv4Address(ip) || is6to4Address(ip) || isTeredoAddress(ip);\n    }\n\n    /**\n     * Examines the Inet6Address to extract the embedded IPv4 client address if the InetAddress is an\n     * IPv6 address of one of the specified address types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@link Inet4Address} of embedded IPv4 client address\n     * @throws IllegalArgumentException if the argument does not have a valid embedded IPv4 address\n     */\n    public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        if (isCompatIPv4Address(ip))\n        {\n            return getCompatIPv4Address(ip);\n        }\n\n        if (is6to4Address(ip))\n        {\n            return get6to4IPv4Address(ip);\n        }\n\n        if (isTeredoAddress(ip))\n        {\n            return getTeredoInfo(ip).getClient();\n        }\n\n        throw formatIllegalArgumentException(\"'%s' has no embedded IPv4 address.\", toAddrString(ip));\n    }\n\n    /**\n     * Evaluates whether the argument is an \"IPv4 mapped\" IPv6 address.\n     *\n     * <p>An \"IPv4 mapped\" address is anything in the range ::ffff:0:0/96 (sometimes written as\n     * ::ffff:0.0.0.0/96), with the last 32 bits interpreted as an IPv4 address.\n     *\n     * <p>For more on IPv4 mapped addresses see section 2.5.5.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.2\">RFC 4291</a>.\n     *\n     * <p>Note: This method takes a {@code String} argument because {@link InetAddress} automatically\n     * collapses mapped addresses to IPv4. (It is actually possible to avoid this using one of the\n     * obscure {@link Inet6Address} methods, but it would be unwise to depend on such a\n     * poorly-documented feature.)\n     *\n     * @param ipString {@code String} to be examined for embedded IPv4-mapped IPv6 address format\n     * @return {@code true} if the argument is a valid \"mapped\" address\n     * @since 10.0\n     */\n    public static boolean isMappedIPv4Address(String ipString)\n    {\n        byte[] bytes = ipStringToBytes(ipString);\n        if (bytes != null && bytes.length == 16)\n        {\n            for (int i = 0; i < 10; i++)\n            {\n                if (bytes[i] != 0)\n                {\n                    return false;\n                }\n            }\n            for (int i = 10; i < 12; i++)\n            {\n                if (bytes[i] != (byte) 0xff)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Coerces an IPv6 address into an IPv4 address.\n     *\n     * <p>HACK: As long as applications continue to use IPv4 addresses for indexing into tables,\n     * accounting, et cetera, it may be necessary to <b>coerce</b> IPv6 addresses into IPv4 addresses.\n     * This function does so by hashing the upper 64 bits into {@code 224.0.0.0/3} (64 bits into 29\n     * bits).\n     *\n     * <p>A \"coerced\" IPv4 address is equivalent to itself.\n     *\n     * <p>NOTE: This function is failsafe for security purposes: ALL IPv6 addresses (except localhost\n     * (::1)) are hashed to avoid the security risk associated with extracting an embedded IPv4\n     * address that might permit elevated privileges.\n     *\n     * @param ip {@link InetAddress} to \"coerce\"\n     * @return {@link Inet4Address} represented \"coerced\" address\n     * @since 7.0\n     */\n    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n    {\n        if (ip instanceof Inet4Address)\n        {\n            return (Inet4Address) ip;\n        }\n\n        // Special cases:\n        byte[] bytes = ip.getAddress();\n        boolean leadingBytesOfZero = true;\n        for (int i = 0; i < 15; ++i)\n        {\n            if (bytes[i] != 0)\n            {\n                leadingBytesOfZero = false;\n                break;\n            }\n        }\n        if (leadingBytesOfZero && (bytes[15] == 1))\n        {\n            return LOOPBACK4; // ::1\n        }\n        else if (leadingBytesOfZero && (bytes[15] == 0))\n        {\n            return ANY4; // ::0\n        }\n\n        Inet6Address ip6 = (Inet6Address) ip;\n        long addressAsLong = 0;\n        if (hasEmbeddedIPv4ClientAddress(ip6))\n        {\n            addressAsLong = getEmbeddedIPv4ClientAddress(ip6).hashCode();\n        }\n        else\n        {\n\n            // Just extract the high 64 bits (assuming the rest is user-modifiable).\n            addressAsLong = ByteBuffer.wrap(ip6.getAddress(), 0, 8).getLong();\n        }\n\n        // Many strategies for hashing are possible. This might suffice for now.\n        int coercedHash = Hashing.murmur3_32().hashLong(addressAsLong).asInt();\n\n        // Squash into 224/4 Multicast and 240/4 Reserved space (i.e. 224/3).\n        coercedHash |= 0xe0000000;\n\n        // Fixup to avoid some \"illegal\" values. Currently the only potential\n        // illegal value is 255.255.255.255.\n        if (coercedHash == 0xffffffff)\n        {\n            coercedHash = 0xfffffffe;\n        }\n\n        return getInet4Address(Ints.toByteArray(coercedHash));\n    }\n\n    /**\n     * Returns an integer representing an IPv4 address regardless of whether the supplied argument is\n     * an IPv4 address or not.\n     *\n     * <p>IPv6 addresses are <b>coerced</b> to IPv4 addresses before being converted to integers.\n     *\n     * <p>As long as there are applications that assume that all IP addresses are IPv4 addresses and\n     * can therefore be converted safely to integers (for whatever purpose) this function can be used\n     * to handle IPv6 addresses as well until the application is suitably fixed.\n     *\n     * <p>NOTE: an IPv6 address coerced to an IPv4 address can only be used for such purposes as\n     * rudimentary identification or indexing into a collection of real {@link InetAddress}es. They\n     * cannot be used as real addresses for the purposes of network communication.\n     *\n     * @param ip {@link InetAddress} to convert\n     * @return {@code int}, \"coerced\" if ip is not an IPv4 address\n     * @since 7.0\n     */\n    public static int coerceToInteger(InetAddress ip)\n    {\n        return ByteStreams.newDataInput(getCoercedIPv4Address(ip).getAddress()).readInt();\n    }\n\n    /**\n     * Returns an Inet4Address having the integer value specified by the argument.\n     *\n     * @param address {@code int}, the 32bit integer address to be converted\n     * @return {@link Inet4Address} equivalent of the argument\n     */\n    public static Inet4Address fromInteger(int address)\n    {\n        return getInet4Address(Ints.toByteArray(address));\n    }\n\n    /**\n     * Returns an address from a <b>little-endian ordered</b> byte array (the opposite of what {@link\n     * InetAddress#getByAddress} expects).\n     *\n     * <p>IPv4 address byte array must be 4 bytes long and IPv6 byte array must be 16 bytes long.\n     *\n     * @param addr the raw IP address in little-endian byte order\n     * @return an InetAddress object created from the raw IP address\n     * @throws UnknownHostException if IP address is of illegal length\n     */\n    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n    {\n        byte[] reversed = new byte[addr.length];\n        for (int i = 0; i < addr.length; i++)\n        {\n            reversed[i] = addr[addr.length - i - 1];\n        }\n        return InetAddress.getByAddress(reversed);\n    }\n\n    /**\n     * Returns a new InetAddress that is one less than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to decrement\n     * @return a new InetAddress that is one less than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the beginning of its range\n     * @since 18.0\n     */\n    public static InetAddress decrement(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0x00)\n        {\n            addr[i] = (byte) 0xff;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Decrementing %s would wrap.\", address);\n\n        addr[i]--;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns a new InetAddress that is one more than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to increment\n     * @return a new InetAddress that is one more than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the end of its range\n     * @since 10.0\n     */\n    public static InetAddress increment(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0xff)\n        {\n            addr[i] = 0;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Incrementing %s would wrap.\", address);\n\n        addr[i]++;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns true if the InetAddress is either 255.255.255.255 for IPv4 or\n     * ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6.\n     *\n     * @return true if the InetAddress is either 255.255.255.255 for IPv4 or\n     *     ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6\n     * @since 10.0\n     */\n    public static boolean isMaximum(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        for (int i = 0; i < addr.length; i++)\n        {\n            if (addr[i] != (byte) 0xff)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static IllegalArgumentException formatIllegalArgumentException(\n        String format, Object... args)\n    {\n        return new IllegalArgumentException(String.format(Locale.ROOT, format, args));\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.forUriString", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns an InetAddress representing the literal IPv4 or IPv6 host portion of a URL, encoded in\nthe format specified by RFC 3986 section 3.2.2.\n\n<p>This function is similar to {@link InetAddresses#forString(String)}, however, it requires\nthat IPv6 addresses are surrounded by square brackets.\n\n<p>This function is the inverse of {@link InetAddresses#toUriString(java.net.InetAddress)}.\n\n@param hostAddr A RFC 3986 section 3.2.2 encoded IPv4 or IPv6 address\n@return an InetAddress representing the address in {@code hostAddr}\n@throws IllegalArgumentException if {@code hostAddr} is not a valid IPv4 address, or IPv6\naddress surrounded by square brackets", "docstring_tokens": ["Returns", "an", "InetAddress", "representing", "the", "literal", "IPv4", "or", "IPv6", "host", "portion", "of", "a", "URL", "encoded", "in", "the", "format", "specified", "by", "RFC", "3986", "section", "3", ".", "2", ".", "2", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L459-L466", "partition": "valid", "up_fun_num": 16, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.MoreObjects;", "import com.google.common.base.Splitter;", "import com.google.common.collect.Iterables;", "import com.google.common.hash.Hashing;", "import com.google.common.io.ByteStreams;", "import com.google.common.primitives.Ints;", "import java.net.Inet4Address;", "import java.net.Inet6Address;", "import java.net.InetAddress;", "import java.net.UnknownHostException;", "import java.nio.ByteBuffer;", "import java.util.Arrays;", "import java.util.List;", "import java.util.Locale;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class InetAddresses\n", "    private static Inet4Address getInet4Address(byte[] bytes)\n", "    public static InetAddress forString(String ipString)\n", "    public static boolean isInetAddress(String ipString)\n", "    private static byte[] ipStringToBytes(String ipString)\n", "    private static byte[] textToNumericFormatV4(String ipString)\n", "    private static byte[] textToNumericFormatV6(String ipString)\n", "    private static String convertDottedQuadToHex(String ipString)\n", "    private static byte parseOctet(String ipPart)\n", "    private static short parseHextet(String ipPart)\n", "    private static InetAddress bytesToInetAddress(byte[] addr)\n", "    public static String toAddrString(InetAddress ip)\n", "    private static void compressLongestRunOfZeroes(int[] hextets)\n", "    private static String hextetsToIPv6String(int[] hextets)\n", "    public static String toUriString(InetAddress ip)\n", "    private static InetAddress forUriStringNoThrow(String hostAddr)\n", "    public static boolean isUriInetAddress(String ipString)\n", "    public static boolean isCompatIPv4Address(Inet6Address ip)\n", "    public static Inet4Address getCompatIPv4Address(Inet6Address ip)\n", "    public static boolean is6to4Address(Inet6Address ip)\n", "    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n", "    public static boolean isTeredoAddress(Inet6Address ip)\n", "    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n", "    public static boolean isIsatapAddress(Inet6Address ip)\n", "    public static Inet4Address getIsatapIPv4Address(Inet6Address ip)\n", "    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static boolean isMappedIPv4Address(String ipString)\n", "    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n", "    public static int coerceToInteger(InetAddress ip)\n", "    public static Inet4Address fromInteger(int address)\n", "    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n", "    public static InetAddress decrement(InetAddress address)\n", "    public static InetAddress increment(InetAddress address)\n", "    public static boolean isMaximum(InetAddress address)\n", "    private static IllegalArgumentException formatIllegalArgumentException(\n"], "context": "/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.net;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.Iterables;\nimport com.google.common.hash.Hashing;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.primitives.Ints;\nimport java.net.Inet4Address;\nimport java.net.Inet6Address;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * Static utility methods pertaining to {@link InetAddress} instances.\n *\n * <p><b>Important note:</b> Unlike {@code InetAddress.getByName()}, the methods of this class never\n * cause DNS services to be accessed. For this reason, you should prefer these methods as much as\n * possible over their JDK equivalents whenever you are expecting to handle only IP address string\n * literals -- there is no blocking DNS penalty for a malformed string.\n *\n * <p>When dealing with {@link Inet4Address} and {@link Inet6Address} objects as byte arrays (vis.\n * {@code InetAddress.getAddress()}) they are 4 and 16 bytes in length, respectively, and represent\n * the address in network byte order.\n *\n * <p>Examples of IP addresses and their byte representations:\n *\n * <dl>\n *   <dt>The IPv4 loopback address, {@code \"127.0.0.1\"}.\n *   <dd>{@code 7f 00 00 01}\n *   <dt>The IPv6 loopback address, {@code \"::1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>From the IPv6 reserved documentation prefix ({@code 2001:db8::/32}), {@code \"2001:db8::1\"}.\n *   <dd>{@code 20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>An IPv6 \"IPv4 compatible\" (or \"compat\") address, {@code \"::192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 c0 a8 00 01}\n *   <dt>An IPv6 \"IPv4 mapped\" address, {@code \"::ffff:192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 ff ff c0 a8 00 01}\n * </dl>\n *\n * <p>A few notes about IPv6 \"IPv4 mapped\" addresses and their observed use in Java.\n *\n * <p>\"IPv4 mapped\" addresses were originally a representation of IPv4 addresses for use on an IPv6\n * socket that could receive both IPv4 and IPv6 connections (by disabling the {@code IPV6_V6ONLY}\n * socket option on an IPv6 socket). Yes, it's confusing. Nevertheless, these \"mapped\" addresses\n * were never supposed to be seen on the wire. That assumption was dropped, some say mistakenly, in\n * later RFCs with the apparent aim of making IPv4-to-IPv6 transition simpler.\n *\n * <p>Technically one <i>can</i> create a 128bit IPv6 address with the wire format of a \"mapped\"\n * address, as shown above, and transmit it in an IPv6 packet header. However, Java's InetAddress\n * creation methods appear to adhere doggedly to the original intent of the \"mapped\" address: all\n * \"mapped\" addresses return {@link Inet4Address} objects.\n *\n * <p>For added safety, it is common for IPv6 network operators to filter all packets where either\n * the source or destination address appears to be a \"compat\" or \"mapped\" address. Filtering\n * suggestions usually recommend discarding any packets with source or destination addresses in the\n * invalid range {@code ::/3}, which includes both of these bizarre address formats. For more\n * information on \"bogons\", including lists of IPv6 bogon space, see:\n *\n * <ul>\n *   <li><a target=\"_parent\"\n *       href=\"http://en.wikipedia.org/wiki/Bogon_filtering\">http://en.wikipedia.\n *       org/wiki/Bogon_filtering</a>\n *   <li><a target=\"_parent\"\n *       href=\"http://www.cymru.com/Bogons/ipv6.txt\">http://www.cymru.com/Bogons/ ipv6.txt</a>\n *   <li><a target=\"_parent\" href=\"http://www.cymru.com/Bogons/v6bogon.html\">http://www.cymru.com/\n *       Bogons/v6bogon.html</a>\n *   <li><a target=\"_parent\" href=\"http://www.space.net/~gert/RIPE/ipv6-filters.html\">http://www.\n *       space.net/~gert/RIPE/ipv6-filters.html</a>\n * </ul>\n *\n * @author Erik Kline\n * @since 5.0\n */\n@Beta\n@GwtIncompatible\npublic final class InetAddresses\n{\n    private static final int IPV4_PART_COUNT = 4;\n    private static final int IPV6_PART_COUNT = 8;\n    private static final Splitter IPV4_SPLITTER = Splitter.on('.').limit(IPV4_PART_COUNT);\n    private static final Splitter IPV6_SPLITTER = Splitter.on(':').limit(IPV6_PART_COUNT + 2);\n    private static final Inet4Address LOOPBACK4 = (Inet4Address) forString(\"127.0.0.1\");\n    private static final Inet4Address ANY4 = (Inet4Address) forString(\"0.0.0.0\");\n\n    private InetAddresses() {}\n\n    /**\n     * Returns an {@link Inet4Address}, given a byte array representation of the IPv4 address.\n     *\n     * @param bytes byte array representing an IPv4 address (should be of length 4)\n     * @return {@link Inet4Address} corresponding to the supplied byte array\n     * @throws IllegalArgumentException if a valid {@link Inet4Address} can not be created\n     */\n    private static Inet4Address getInet4Address(byte[] bytes)\n    {\n        checkArgument(\n            bytes.length == 4,\n            \"Byte array has invalid length for an IPv4 address: %s != 4.\",\n            bytes.length);\n\n        // Given a 4-byte array, this cast should always succeed.\n        return (Inet4Address) bytesToInetAddress(bytes);\n    }\n\n    /**\n     * Returns the {@link InetAddress} having the given string representation.\n     *\n     * <p>This deliberately avoids all nameservice lookups (e.g. no DNS).\n     *\n     * @param ipString {@code String} containing an IPv4 or IPv6 string literal, e.g. {@code\n     *     \"192.168.0.1\"} or {@code \"2001:db8::1\"}\n     * @return {@link InetAddress} representing the argument\n     * @throws IllegalArgumentException if the argument is not a valid IP string literal\n     */\n    public static InetAddress forString(String ipString)\n    {\n        byte[] addr = ipStringToBytes(ipString);\n\n        // The argument was malformed, i.e. not an IP string literal.\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"'%s' is not an IP string literal.\", ipString);\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP string literal\n     * @return {@code true} if the argument is a valid IP string literal\n     */\n    public static boolean isInetAddress(String ipString)\n    {\n        return ipStringToBytes(ipString) != null;\n    }\n\n    @NullableDecl\n    private static byte[] ipStringToBytes(String ipString)\n    {\n        // Make a first pass to categorize the characters in this string.\n        boolean hasColon = false;\n        boolean hasDot = false;\n        for (int i = 0; i < ipString.length(); i++)\n        {\n            char c = ipString.charAt(i);\n            if (c == '.')\n            {\n                hasDot = true;\n            }\n            else if (c == ':')\n            {\n                if (hasDot)\n                {\n                    return null; // Colons must not appear after dots.\n                }\n                hasColon = true;\n            }\n            else if (Character.digit(c, 16) == -1)\n            {\n                return null; // Everything else must be a decimal or hex digit.\n            }\n        }\n\n        // Now decide which address family to parse.\n        if (hasColon)\n        {\n            if (hasDot)\n            {\n                ipString = convertDottedQuadToHex(ipString);\n                if (ipString == null)\n                {\n                    return null;\n                }\n            }\n            return textToNumericFormatV6(ipString);\n        }\n        else if (hasDot)\n        {\n            return textToNumericFormatV4(ipString);\n        }\n        return null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV4(String ipString)\n    {\n        byte[] bytes = new byte[IPV4_PART_COUNT];\n        int i = 0;\n        try\n        {\n            for (String octet : IPV4_SPLITTER.split(ipString))\n            {\n                bytes[i++] = parseOctet(octet);\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n\n        return i == IPV4_PART_COUNT ? bytes : null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV6(String ipString)\n    {\n        // An address can have [2..8] colons, and N colons make N+1 parts.\n        List<String> parts = IPV6_SPLITTER.splitToList(ipString);\n        if (parts.size() < 3 || parts.size() > IPV6_PART_COUNT + 1)\n        {\n            return null;\n        }\n\n        // Disregarding the endpoints, find \"::\" with nothing in between.\n        // This indicates that a run of zeroes has been skipped.\n        int skipIndex = -1;\n        for (int i = 1; i < parts.size() - 1; i++)\n        {\n            if (parts.get(i).length() == 0)\n            {\n                if (skipIndex >= 0)\n                {\n                    return null; // Can't have more than one ::\n                }\n                skipIndex = i;\n            }\n        }\n\n        int partsHi; // Number of parts to copy from above/before the \"::\"\n        int partsLo; // Number of parts to copy from below/after the \"::\"\n        if (skipIndex >= 0)\n        {\n            // If we found a \"::\", then check if it also covers the endpoints.\n            partsHi = skipIndex;\n            partsLo = parts.size() - skipIndex - 1;\n            if (parts.get(0).length() == 0 && --partsHi != 0)\n            {\n                return null; // ^: requires ^::\n            }\n            if (Iterables.getLast(parts).length() == 0 && --partsLo != 0)\n            {\n                return null; // :$ requires ::$\n            }\n        }\n        else\n        {\n            // Otherwise, allocate the entire address to partsHi. The endpoints\n            // could still be empty, but parseHextet() will check for that.\n            partsHi = parts.size();\n            partsLo = 0;\n        }\n\n        // If we found a ::, then we must have skipped at least one part.\n        // Otherwise, we must have exactly the right number of parts.\n        int partsSkipped = IPV6_PART_COUNT - (partsHi + partsLo);\n        if (!(skipIndex >= 0 ? partsSkipped >= 1 : partsSkipped == 0))\n        {\n            return null;\n        }\n\n        // Now parse the hextets into a byte array.\n        ByteBuffer rawBytes = ByteBuffer.allocate(2 * IPV6_PART_COUNT);\n        try\n        {\n            for (int i = 0; i < partsHi; i++)\n            {\n                rawBytes.putShort(parseHextet(parts.get(i)));\n            }\n            for (int i = 0; i < partsSkipped; i++)\n            {\n                rawBytes.putShort((short) 0);\n            }\n            for (int i = partsLo; i > 0; i--)\n            {\n                rawBytes.putShort(parseHextet(parts.get(parts.size() - i)));\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n        return rawBytes.array();\n    }\n\n    @NullableDecl\n    private static String convertDottedQuadToHex(String ipString)\n    {\n        int lastColon = ipString.lastIndexOf(':');\n        String initialPart = ipString.substring(0, lastColon + 1);\n        String dottedQuad = ipString.substring(lastColon + 1);\n        byte[] quad = textToNumericFormatV4(dottedQuad);\n        if (quad == null)\n        {\n            return null;\n        }\n        String penultimate = Integer.toHexString(((quad[0] & 0xff) << 8) | (quad[1] & 0xff));\n        String ultimate = Integer.toHexString(((quad[2] & 0xff) << 8) | (quad[3] & 0xff));\n        return initialPart + penultimate + \":\" + ultimate;\n    }\n\n    private static byte parseOctet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int octet = Integer.parseInt(ipPart);\n        // Disallow leading zeroes, because no clear standard exists on\n        // whether these should be interpreted as decimal or octal.\n        if (octet > 255 || (ipPart.startsWith(\"0\") && ipPart.length() > 1))\n        {\n            throw new NumberFormatException();\n        }\n        return (byte) octet;\n    }\n\n    private static short parseHextet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int hextet = Integer.parseInt(ipPart, 16);\n        if (hextet > 0xffff)\n        {\n            throw new NumberFormatException();\n        }\n        return (short) hextet;\n    }\n\n    /**\n     * Convert a byte array into an InetAddress.\n     *\n     * <p>{@link InetAddress#getByAddress} is documented as throwing a checked exception \"if IP\n     * address is of illegal length.\" We replace it with an unchecked exception, for use by callers\n     * who already know that addr is an array of length 4 or 16.\n     *\n     * @param addr the raw 4-byte or 16-byte IP address in big-endian order\n     * @return an InetAddress object created from the raw IP address\n     */\n    private static InetAddress bytesToInetAddress(byte[] addr)\n    {\n        try\n        {\n            return InetAddress.getByAddress(addr);\n        }\n        catch (UnknownHostException e)\n        {\n            throw new AssertionError(e);\n        }\n    }\n\n    /**\n     * Returns the string representation of an {@link InetAddress}.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses, the output follows <a href=\"http://tools.ietf.org/html/rfc5952\">RFC 5952</a> section\n     * 4. The main difference is that this method uses \"::\" for zero compression, while Java's version\n     * uses the uncompressed form.\n     *\n     * <p>This method uses hexadecimal for all IPv6 addresses, including IPv4-mapped IPv6 addresses\n     * such as \"::c000:201\". The output does not include a Scope ID.\n     *\n     * @param ip {@link InetAddress} to be converted to an address string\n     * @return {@code String} containing the text-formatted IP address\n     * @since 10.0\n     */\n    public static String toAddrString(InetAddress ip)\n    {\n        checkNotNull(ip);\n        if (ip instanceof Inet4Address)\n        {\n            // For IPv4, Java's formatting is good enough.\n            return ip.getHostAddress();\n        }\n        checkArgument(ip instanceof Inet6Address);\n        byte[] bytes = ip.getAddress();\n        int[] hextets = new int[IPV6_PART_COUNT];\n        for (int i = 0; i < hextets.length; i++)\n        {\n            hextets[i] = Ints.fromBytes((byte) 0, (byte) 0, bytes[2 * i], bytes[2 * i + 1]);\n        }\n        compressLongestRunOfZeroes(hextets);\n        return hextetsToIPv6String(hextets);\n    }\n\n    /**\n     * Identify and mark the longest run of zeroes in an IPv6 address.\n     *\n     * <p>Only runs of two or more hextets are considered. In case of a tie, the leftmost run wins. If\n     * a qualifying run is found, its hextets are replaced by the sentinel value -1.\n     *\n     * @param hextets {@code int[]} mutable array of eight 16-bit hextets\n     */\n    private static void compressLongestRunOfZeroes(int[] hextets)\n    {\n        int bestRunStart = -1;\n        int bestRunLength = -1;\n        int runStart = -1;\n        for (int i = 0; i < hextets.length + 1; i++)\n        {\n            if (i < hextets.length && hextets[i] == 0)\n            {\n                if (runStart < 0)\n                {\n                    runStart = i;\n                }\n            }\n            else if (runStart >= 0)\n            {\n                int runLength = i - runStart;\n                if (runLength > bestRunLength)\n                {\n                    bestRunStart = runStart;\n                    bestRunLength = runLength;\n                }\n                runStart = -1;\n            }\n        }\n        if (bestRunLength >= 2)\n        {\n            Arrays.fill(hextets, bestRunStart, bestRunStart + bestRunLength, -1);\n        }\n    }\n\n    /**\n     * Convert a list of hextets into a human-readable IPv6 address.\n     *\n     * <p>In order for \"::\" compression to work, the input should contain negative sentinel values in\n     * place of the elided zeroes.\n     *\n     * @param hextets {@code int[]} array of eight 16-bit hextets, or -1s\n     */\n    private static String hextetsToIPv6String(int[] hextets)\n    {\n        // While scanning the array, handle these state transitions:\n        //   start->num => \"num\"     start->gap => \"::\"\n        //   num->num   => \":num\"    num->gap   => \"::\"\n        //   gap->num   => \"num\"     gap->gap   => \"\"\n        StringBuilder buf = new StringBuilder(39);\n        boolean lastWasNumber = false;\n        for (int i = 0; i < hextets.length; i++)\n        {\n            boolean thisIsNumber = hextets[i] >= 0;\n            if (thisIsNumber)\n            {\n                if (lastWasNumber)\n                {\n                    buf.append(':');\n                }\n                buf.append(Integer.toHexString(hextets[i]));\n            }\n            else\n            {\n                if (i == 0 || lastWasNumber)\n                {\n                    buf.append(\"::\");\n                }\n            }\n            lastWasNumber = thisIsNumber;\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Returns the string representation of an {@link InetAddress} suitable for inclusion in a URI.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses it compresses zeroes and surrounds the text with square brackets; for example {@code\n     * \"[2001:db8::1]\"}.\n     *\n     * <p>Per section 3.2.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3986#section-3.2.2\">RFC 3986</a>, a URI containing an IPv6\n     * string literal is of the form {@code \"http://[2001:db8::1]:8888/index.html\"}.\n     *\n     * <p>Use of either {@link InetAddresses#toAddrString}, {@link InetAddress#getHostAddress()}, or\n     * this method is recommended over {@link InetAddress#toString()} when an IP address string\n     * literal is desired. This is because {@link InetAddress#toString()} prints the hostname and the\n     * IP address string joined by a \"/\".\n     *\n     * @param ip {@link InetAddress} to be converted to URI string literal\n     * @return {@code String} containing URI-safe string literal\n     */\n    public static String toUriString(InetAddress ip)\n    {\n        if (ip instanceof Inet6Address)\n        {\n            return \"[\" + toAddrString(ip) + \"]\";\n        }\n        return toAddrString(ip);\n    }\n\n    /**\n     * Returns an InetAddress representing the literal IPv4 or IPv6 host portion of a URL, encoded in\n     * the format specified by RFC 3986 section 3.2.2.\n     *\n     * <p>This function is similar to {@link InetAddresses#forString(String)}, however, it requires\n     * that IPv6 addresses are surrounded by square brackets.\n     *\n     * <p>This function is the inverse of {@link InetAddresses#toUriString(java.net.InetAddress)}.\n     *\n     * @param hostAddr A RFC 3986 section 3.2.2 encoded IPv4 or IPv6 address\n     * @return an InetAddress representing the address in {@code hostAddr}\n     * @throws IllegalArgumentException if {@code hostAddr} is not a valid IPv4 address, or IPv6\n     *     address surrounded by square brackets\n     */\n\n    @NullableDecl\n    private static InetAddress forUriStringNoThrow(String hostAddr)\n    {\n        checkNotNull(hostAddr);\n\n        // Decide if this should be an IPv6 or IPv4 address.\n        String ipString;\n        int expectBytes;\n        if (hostAddr.startsWith(\"[\") && hostAddr.endsWith(\"]\"))\n        {\n            ipString = hostAddr.substring(1, hostAddr.length() - 1);\n            expectBytes = 16;\n        }\n        else\n        {\n            ipString = hostAddr;\n            expectBytes = 4;\n        }\n\n        // Parse the address, and make sure the length/version is correct.\n        byte[] addr = ipStringToBytes(ipString);\n        if (addr == null || addr.length != expectBytes)\n        {\n            return null;\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid URI IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP URI host string literal\n     * @return {@code true} if the argument is a valid IP URI host\n     */\n    public static boolean isUriInetAddress(String ipString)\n    {\n        return forUriStringNoThrow(ipString) != null;\n    }\n\n    /**\n     * Evaluates whether the argument is an IPv6 \"compat\" address.\n     *\n     * <p>An \"IPv4 compatible\", or \"compat\", address is one with 96 leading bits of zero, with the\n     * remaining 32 bits interpreted as an IPv4 address. These are conventionally represented in\n     * string literals as {@code \"::192.168.0.1\"}, though {@code \"::c0a8:1\"} is also considered an\n     * IPv4 compatible address (and equivalent to {@code \"::192.168.0.1\"}).\n     *\n     * <p>For more on IPv4 compatible addresses see section 2.5.5.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.1\">RFC 4291</a>.\n     *\n     * <p>NOTE: This method is different from {@link Inet6Address#isIPv4CompatibleAddress} in that it\n     * more correctly classifies {@code \"::\"} and {@code \"::1\"} as proper IPv6 addresses (which they\n     * are), NOT IPv4 compatible addresses (which they are generally NOT considered to be).\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 compatible address format\n     * @return {@code true} if the argument is a valid \"compat\" address\n     */\n    public static boolean isCompatIPv4Address(Inet6Address ip)\n    {\n        if (!ip.isIPv4CompatibleAddress())\n        {\n            return false;\n        }\n\n        byte[] bytes = ip.getAddress();\n        if ((bytes[12] == 0)\n                && (bytes[13] == 0)\n                && (bytes[14] == 0)\n                && ((bytes[15] == 0) || (bytes[15] == 1)))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the IPv4 address embedded in an IPv4 compatible address.\n     *\n     * @param ip {@link Inet6Address} to be examined for an embedded IPv4 address\n     * @return {@link Inet4Address} of the embedded IPv4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv4 compatible address\n     */\n    public static Inet4Address getCompatIPv4Address(Inet6Address ip)\n    {\n        checkArgument(\n            isCompatIPv4Address(ip), \"Address '%s' is not IPv4-compatible.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n    }\n\n    /**\n     * Evaluates whether the argument is a 6to4 address.\n     *\n     * <p>6to4 addresses begin with the {@code \"2002::/16\"} prefix. The next 32 bits are the IPv4\n     * address of the host to which IPv6-in-IPv4 tunneled packets should be routed.\n     *\n     * <p>For more on 6to4 addresses see section 2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3056#section-2\">RFC 3056</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for 6to4 address format\n     * @return {@code true} if the argument is a 6to4 address\n     */\n    public static boolean is6to4Address(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20) && (bytes[1] == (byte) 0x02);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in a 6to4 address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in 6to4 address\n     * @return {@link Inet4Address} of embedded IPv4 in 6to4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 6to4 address\n     */\n    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n    {\n        checkArgument(is6to4Address(ip), \"Address '%s' is not a 6to4 address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 2, 6));\n    }\n\n    /**\n     * A simple immutable data class to encapsulate the information to be found in a Teredo address.\n     *\n     * <p>All of the fields in this class are encoded in various portions of the IPv6 address as part\n     * of the protocol. More protocols details can be found at: <a target=\"_parent\"\n     * href=\"http://en.wikipedia.org/wiki/Teredo_tunneling\">http://en.wikipedia.\n     * org/wiki/Teredo_tunneling</a>.\n     *\n     * <p>The RFC can be found here: <a target=\"_parent\" href=\"http://tools.ietf.org/html/rfc4380\">RFC\n     * 4380</a>.\n     *\n     * @since 5.0\n     */\n    @Beta\n    public static final class TeredoInfo\n    {\n        private final Inet4Address server;\n        private final Inet4Address client;\n        private final int port;\n        private final int flags;\n\n        /**\n         * Constructs a TeredoInfo instance.\n         *\n         * <p>Both server and client can be {@code null}, in which case the value {@code \"0.0.0.0\"} will\n         * be assumed.\n         *\n         * @throws IllegalArgumentException if either of the {@code port} or the {@code flags} arguments\n         *     are out of range of an unsigned short\n         */\n        // TODO: why is this public?\n        public TeredoInfo(\n            @NullableDecl Inet4Address server, @NullableDecl Inet4Address client, int port, int flags)\n        {\n            checkArgument(\n                (port >= 0) && (port <= 0xffff), \"port '%s' is out of range (0 <= port <= 0xffff)\", port);\n            checkArgument(\n                (flags >= 0) && (flags <= 0xffff),\n                \"flags '%s' is out of range (0 <= flags <= 0xffff)\",\n                flags);\n\n            this.server = MoreObjects.firstNonNull(server, ANY4);\n            this.client = MoreObjects.firstNonNull(client, ANY4);\n            this.port = port;\n            this.flags = flags;\n        }\n\n        public Inet4Address getServer()\n        {\n            return server;\n        }\n\n        public Inet4Address getClient()\n        {\n            return client;\n        }\n\n        public int getPort()\n        {\n            return port;\n        }\n\n        public int getFlags()\n        {\n            return flags;\n        }\n    }\n\n    /**\n     * Evaluates whether the argument is a Teredo address.\n     *\n     * <p>Teredo addresses begin with the {@code \"2001::/32\"} prefix.\n     *\n     * @param ip {@link Inet6Address} to be examined for Teredo address format\n     * @return {@code true} if the argument is a Teredo address\n     */\n    public static boolean isTeredoAddress(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20)\n               && (bytes[1] == (byte) 0x01)\n               && (bytes[2] == 0)\n               && (bytes[3] == 0);\n    }\n\n    /**\n     * Returns the Teredo information embedded in a Teredo address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded Teredo information\n     * @return extracted {@code TeredoInfo}\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 Teredo address\n     */\n    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n    {\n        checkArgument(isTeredoAddress(ip), \"Address '%s' is not a Teredo address.\", toAddrString(ip));\n\n        byte[] bytes = ip.getAddress();\n        Inet4Address server = getInet4Address(Arrays.copyOfRange(bytes, 4, 8));\n\n        int flags = ByteStreams.newDataInput(bytes, 8).readShort() & 0xffff;\n\n        // Teredo obfuscates the mapped client port, per section 4 of the RFC.\n        int port = ~ByteStreams.newDataInput(bytes, 10).readShort() & 0xffff;\n\n        byte[] clientBytes = Arrays.copyOfRange(bytes, 12, 16);\n        for (int i = 0; i < clientBytes.length; i++)\n        {\n            // Teredo obfuscates the mapped client IP, per section 4 of the RFC.\n            clientBytes[i] = (byte) ~clientBytes[i];\n        }\n        Inet4Address client = getInet4Address(clientBytes);\n\n        return new TeredoInfo(server, client, port, flags);\n    }\n\n    /**\n     * Evaluates whether the argument is an ISATAP address.\n     *\n     * <p>From RFC 5214: \"ISATAP interface identifiers are constructed in Modified EUI-64 format [...]\n     * by concatenating the 24-bit IANA OUI (00-00-5E), the 8-bit hexadecimal value 0xFE, and a 32-bit\n     * IPv4 address in network byte order [...]\"\n     *\n     * <p>For more on ISATAP addresses see section 6.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc5214#section-6.1\">RFC 5214</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for ISATAP address format\n     * @return {@code true} if the argument is an ISATAP address\n     */\n    public static boolean isIsatapAddress(Inet6Address ip)\n    {\n\n        // If it's a Teredo address with the right port (41217, or 0xa101)\n        // which would be encoded as 0x5efe then it can't be an ISATAP address.\n        if (isTeredoAddress(ip))\n        {\n            return false;\n        }\n\n        byte[] bytes = ip.getAddress();\n\n        if ((bytes[8] | (byte) 0x03) != (byte) 0x03)\n        {\n\n            // Verify that high byte of the 64 bit identifier is zero, modulo\n            // the U/L and G bits, with which we are not concerned.\n            return false;\n        }\n\n        return (bytes[9] == (byte) 0x00) && (bytes[10] == (byte) 0x5e) && (bytes[11] == (byte) 0xfe);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in an ISATAP address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in ISATAP address\n     * @return {@link Inet4Address} of embedded IPv4 in an ISATAP address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 ISATAP address\n     */\n    public static Inet4Address getIsatapIPv4Address(Inet6Address ip)\n    {\n        checkArgument(isIsatapAddress(ip), \"Address '%s' is not an ISATAP address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n    }\n\n    /**\n     * Examines the Inet6Address to determine if it is an IPv6 address of one of the specified address\n     * types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@code true} if there is an embedded IPv4 client address\n     * @since 7.0\n     */\n    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        return isCompatIPv4Address(ip) || is6to4Address(ip) || isTeredoAddress(ip);\n    }\n\n    /**\n     * Examines the Inet6Address to extract the embedded IPv4 client address if the InetAddress is an\n     * IPv6 address of one of the specified address types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@link Inet4Address} of embedded IPv4 client address\n     * @throws IllegalArgumentException if the argument does not have a valid embedded IPv4 address\n     */\n    public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        if (isCompatIPv4Address(ip))\n        {\n            return getCompatIPv4Address(ip);\n        }\n\n        if (is6to4Address(ip))\n        {\n            return get6to4IPv4Address(ip);\n        }\n\n        if (isTeredoAddress(ip))\n        {\n            return getTeredoInfo(ip).getClient();\n        }\n\n        throw formatIllegalArgumentException(\"'%s' has no embedded IPv4 address.\", toAddrString(ip));\n    }\n\n    /**\n     * Evaluates whether the argument is an \"IPv4 mapped\" IPv6 address.\n     *\n     * <p>An \"IPv4 mapped\" address is anything in the range ::ffff:0:0/96 (sometimes written as\n     * ::ffff:0.0.0.0/96), with the last 32 bits interpreted as an IPv4 address.\n     *\n     * <p>For more on IPv4 mapped addresses see section 2.5.5.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.2\">RFC 4291</a>.\n     *\n     * <p>Note: This method takes a {@code String} argument because {@link InetAddress} automatically\n     * collapses mapped addresses to IPv4. (It is actually possible to avoid this using one of the\n     * obscure {@link Inet6Address} methods, but it would be unwise to depend on such a\n     * poorly-documented feature.)\n     *\n     * @param ipString {@code String} to be examined for embedded IPv4-mapped IPv6 address format\n     * @return {@code true} if the argument is a valid \"mapped\" address\n     * @since 10.0\n     */\n    public static boolean isMappedIPv4Address(String ipString)\n    {\n        byte[] bytes = ipStringToBytes(ipString);\n        if (bytes != null && bytes.length == 16)\n        {\n            for (int i = 0; i < 10; i++)\n            {\n                if (bytes[i] != 0)\n                {\n                    return false;\n                }\n            }\n            for (int i = 10; i < 12; i++)\n            {\n                if (bytes[i] != (byte) 0xff)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Coerces an IPv6 address into an IPv4 address.\n     *\n     * <p>HACK: As long as applications continue to use IPv4 addresses for indexing into tables,\n     * accounting, et cetera, it may be necessary to <b>coerce</b> IPv6 addresses into IPv4 addresses.\n     * This function does so by hashing the upper 64 bits into {@code 224.0.0.0/3} (64 bits into 29\n     * bits).\n     *\n     * <p>A \"coerced\" IPv4 address is equivalent to itself.\n     *\n     * <p>NOTE: This function is failsafe for security purposes: ALL IPv6 addresses (except localhost\n     * (::1)) are hashed to avoid the security risk associated with extracting an embedded IPv4\n     * address that might permit elevated privileges.\n     *\n     * @param ip {@link InetAddress} to \"coerce\"\n     * @return {@link Inet4Address} represented \"coerced\" address\n     * @since 7.0\n     */\n    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n    {\n        if (ip instanceof Inet4Address)\n        {\n            return (Inet4Address) ip;\n        }\n\n        // Special cases:\n        byte[] bytes = ip.getAddress();\n        boolean leadingBytesOfZero = true;\n        for (int i = 0; i < 15; ++i)\n        {\n            if (bytes[i] != 0)\n            {\n                leadingBytesOfZero = false;\n                break;\n            }\n        }\n        if (leadingBytesOfZero && (bytes[15] == 1))\n        {\n            return LOOPBACK4; // ::1\n        }\n        else if (leadingBytesOfZero && (bytes[15] == 0))\n        {\n            return ANY4; // ::0\n        }\n\n        Inet6Address ip6 = (Inet6Address) ip;\n        long addressAsLong = 0;\n        if (hasEmbeddedIPv4ClientAddress(ip6))\n        {\n            addressAsLong = getEmbeddedIPv4ClientAddress(ip6).hashCode();\n        }\n        else\n        {\n\n            // Just extract the high 64 bits (assuming the rest is user-modifiable).\n            addressAsLong = ByteBuffer.wrap(ip6.getAddress(), 0, 8).getLong();\n        }\n\n        // Many strategies for hashing are possible. This might suffice for now.\n        int coercedHash = Hashing.murmur3_32().hashLong(addressAsLong).asInt();\n\n        // Squash into 224/4 Multicast and 240/4 Reserved space (i.e. 224/3).\n        coercedHash |= 0xe0000000;\n\n        // Fixup to avoid some \"illegal\" values. Currently the only potential\n        // illegal value is 255.255.255.255.\n        if (coercedHash == 0xffffffff)\n        {\n            coercedHash = 0xfffffffe;\n        }\n\n        return getInet4Address(Ints.toByteArray(coercedHash));\n    }\n\n    /**\n     * Returns an integer representing an IPv4 address regardless of whether the supplied argument is\n     * an IPv4 address or not.\n     *\n     * <p>IPv6 addresses are <b>coerced</b> to IPv4 addresses before being converted to integers.\n     *\n     * <p>As long as there are applications that assume that all IP addresses are IPv4 addresses and\n     * can therefore be converted safely to integers (for whatever purpose) this function can be used\n     * to handle IPv6 addresses as well until the application is suitably fixed.\n     *\n     * <p>NOTE: an IPv6 address coerced to an IPv4 address can only be used for such purposes as\n     * rudimentary identification or indexing into a collection of real {@link InetAddress}es. They\n     * cannot be used as real addresses for the purposes of network communication.\n     *\n     * @param ip {@link InetAddress} to convert\n     * @return {@code int}, \"coerced\" if ip is not an IPv4 address\n     * @since 7.0\n     */\n    public static int coerceToInteger(InetAddress ip)\n    {\n        return ByteStreams.newDataInput(getCoercedIPv4Address(ip).getAddress()).readInt();\n    }\n\n    /**\n     * Returns an Inet4Address having the integer value specified by the argument.\n     *\n     * @param address {@code int}, the 32bit integer address to be converted\n     * @return {@link Inet4Address} equivalent of the argument\n     */\n    public static Inet4Address fromInteger(int address)\n    {\n        return getInet4Address(Ints.toByteArray(address));\n    }\n\n    /**\n     * Returns an address from a <b>little-endian ordered</b> byte array (the opposite of what {@link\n     * InetAddress#getByAddress} expects).\n     *\n     * <p>IPv4 address byte array must be 4 bytes long and IPv6 byte array must be 16 bytes long.\n     *\n     * @param addr the raw IP address in little-endian byte order\n     * @return an InetAddress object created from the raw IP address\n     * @throws UnknownHostException if IP address is of illegal length\n     */\n    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n    {\n        byte[] reversed = new byte[addr.length];\n        for (int i = 0; i < addr.length; i++)\n        {\n            reversed[i] = addr[addr.length - i - 1];\n        }\n        return InetAddress.getByAddress(reversed);\n    }\n\n    /**\n     * Returns a new InetAddress that is one less than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to decrement\n     * @return a new InetAddress that is one less than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the beginning of its range\n     * @since 18.0\n     */\n    public static InetAddress decrement(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0x00)\n        {\n            addr[i] = (byte) 0xff;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Decrementing %s would wrap.\", address);\n\n        addr[i]--;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns a new InetAddress that is one more than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to increment\n     * @return a new InetAddress that is one more than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the end of its range\n     * @since 10.0\n     */\n    public static InetAddress increment(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0xff)\n        {\n            addr[i] = 0;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Incrementing %s would wrap.\", address);\n\n        addr[i]++;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns true if the InetAddress is either 255.255.255.255 for IPv4 or\n     * ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6.\n     *\n     * @return true if the InetAddress is either 255.255.255.255 for IPv4 or\n     *     ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6\n     * @since 10.0\n     */\n    public static boolean isMaximum(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        for (int i = 0; i < addr.length; i++)\n        {\n            if (addr[i] != (byte) 0xff)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static IllegalArgumentException formatIllegalArgumentException(\n        String format, Object... args)\n    {\n        return new IllegalArgumentException(String.format(Locale.ROOT, format, args));\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.isCompatIPv4Address", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Evaluates whether the argument is an IPv6 \"compat\" address.\n\n<p>An \"IPv4 compatible\", or \"compat\", address is one with 96 leading bits of zero, with the\nremaining 32 bits interpreted as an IPv4 address. These are conventionally represented in\nstring literals as {@code \"::192.168.0.1\"}, though {@code \"::c0a8:1\"} is also considered an\nIPv4 compatible address (and equivalent to {@code \"::192.168.0.1\"}).\n\n<p>For more on IPv4 compatible addresses see section 2.5.5.1 of <a target=\"_parent\"\nhref=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.1\">RFC 4291</a>.\n\n<p>NOTE: This method is different from {@link Inet6Address#isIPv4CompatibleAddress} in that it\nmore correctly classifies {@code \"::\"} and {@code \"::1\"} as proper IPv6 addresses (which they\nare), NOT IPv4 compatible addresses (which they are generally NOT considered to be).\n\n@param ip {@link Inet6Address} to be examined for embedded IPv4 compatible address format\n@return {@code true} if the argument is a valid \"compat\" address", "docstring_tokens": ["Evaluates", "whether", "the", "argument", "is", "an", "IPv6", "compat", "address", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L521-L535", "partition": "valid", "up_fun_num": 19, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.MoreObjects;", "import com.google.common.base.Splitter;", "import com.google.common.collect.Iterables;", "import com.google.common.hash.Hashing;", "import com.google.common.io.ByteStreams;", "import com.google.common.primitives.Ints;", "import java.net.Inet4Address;", "import java.net.Inet6Address;", "import java.net.InetAddress;", "import java.net.UnknownHostException;", "import java.nio.ByteBuffer;", "import java.util.Arrays;", "import java.util.List;", "import java.util.Locale;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class InetAddresses\n", "    private static Inet4Address getInet4Address(byte[] bytes)\n", "    public static InetAddress forString(String ipString)\n", "    public static boolean isInetAddress(String ipString)\n", "    private static byte[] ipStringToBytes(String ipString)\n", "    private static byte[] textToNumericFormatV4(String ipString)\n", "    private static byte[] textToNumericFormatV6(String ipString)\n", "    private static String convertDottedQuadToHex(String ipString)\n", "    private static byte parseOctet(String ipPart)\n", "    private static short parseHextet(String ipPart)\n", "    private static InetAddress bytesToInetAddress(byte[] addr)\n", "    public static String toAddrString(InetAddress ip)\n", "    private static void compressLongestRunOfZeroes(int[] hextets)\n", "    private static String hextetsToIPv6String(int[] hextets)\n", "    public static String toUriString(InetAddress ip)\n", "    public static InetAddress forUriString(String hostAddr)\n", "    private static InetAddress forUriStringNoThrow(String hostAddr)\n", "    public static boolean isUriInetAddress(String ipString)\n", "    public static Inet4Address getCompatIPv4Address(Inet6Address ip)\n", "    public static boolean is6to4Address(Inet6Address ip)\n", "    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n", "    public static boolean isTeredoAddress(Inet6Address ip)\n", "    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n", "    public static boolean isIsatapAddress(Inet6Address ip)\n", "    public static Inet4Address getIsatapIPv4Address(Inet6Address ip)\n", "    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static boolean isMappedIPv4Address(String ipString)\n", "    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n", "    public static int coerceToInteger(InetAddress ip)\n", "    public static Inet4Address fromInteger(int address)\n", "    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n", "    public static InetAddress decrement(InetAddress address)\n", "    public static InetAddress increment(InetAddress address)\n", "    public static boolean isMaximum(InetAddress address)\n", "    private static IllegalArgumentException formatIllegalArgumentException(\n"], "context": "/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.net;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.Iterables;\nimport com.google.common.hash.Hashing;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.primitives.Ints;\nimport java.net.Inet4Address;\nimport java.net.Inet6Address;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * Static utility methods pertaining to {@link InetAddress} instances.\n *\n * <p><b>Important note:</b> Unlike {@code InetAddress.getByName()}, the methods of this class never\n * cause DNS services to be accessed. For this reason, you should prefer these methods as much as\n * possible over their JDK equivalents whenever you are expecting to handle only IP address string\n * literals -- there is no blocking DNS penalty for a malformed string.\n *\n * <p>When dealing with {@link Inet4Address} and {@link Inet6Address} objects as byte arrays (vis.\n * {@code InetAddress.getAddress()}) they are 4 and 16 bytes in length, respectively, and represent\n * the address in network byte order.\n *\n * <p>Examples of IP addresses and their byte representations:\n *\n * <dl>\n *   <dt>The IPv4 loopback address, {@code \"127.0.0.1\"}.\n *   <dd>{@code 7f 00 00 01}\n *   <dt>The IPv6 loopback address, {@code \"::1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>From the IPv6 reserved documentation prefix ({@code 2001:db8::/32}), {@code \"2001:db8::1\"}.\n *   <dd>{@code 20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>An IPv6 \"IPv4 compatible\" (or \"compat\") address, {@code \"::192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 c0 a8 00 01}\n *   <dt>An IPv6 \"IPv4 mapped\" address, {@code \"::ffff:192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 ff ff c0 a8 00 01}\n * </dl>\n *\n * <p>A few notes about IPv6 \"IPv4 mapped\" addresses and their observed use in Java.\n *\n * <p>\"IPv4 mapped\" addresses were originally a representation of IPv4 addresses for use on an IPv6\n * socket that could receive both IPv4 and IPv6 connections (by disabling the {@code IPV6_V6ONLY}\n * socket option on an IPv6 socket). Yes, it's confusing. Nevertheless, these \"mapped\" addresses\n * were never supposed to be seen on the wire. That assumption was dropped, some say mistakenly, in\n * later RFCs with the apparent aim of making IPv4-to-IPv6 transition simpler.\n *\n * <p>Technically one <i>can</i> create a 128bit IPv6 address with the wire format of a \"mapped\"\n * address, as shown above, and transmit it in an IPv6 packet header. However, Java's InetAddress\n * creation methods appear to adhere doggedly to the original intent of the \"mapped\" address: all\n * \"mapped\" addresses return {@link Inet4Address} objects.\n *\n * <p>For added safety, it is common for IPv6 network operators to filter all packets where either\n * the source or destination address appears to be a \"compat\" or \"mapped\" address. Filtering\n * suggestions usually recommend discarding any packets with source or destination addresses in the\n * invalid range {@code ::/3}, which includes both of these bizarre address formats. For more\n * information on \"bogons\", including lists of IPv6 bogon space, see:\n *\n * <ul>\n *   <li><a target=\"_parent\"\n *       href=\"http://en.wikipedia.org/wiki/Bogon_filtering\">http://en.wikipedia.\n *       org/wiki/Bogon_filtering</a>\n *   <li><a target=\"_parent\"\n *       href=\"http://www.cymru.com/Bogons/ipv6.txt\">http://www.cymru.com/Bogons/ ipv6.txt</a>\n *   <li><a target=\"_parent\" href=\"http://www.cymru.com/Bogons/v6bogon.html\">http://www.cymru.com/\n *       Bogons/v6bogon.html</a>\n *   <li><a target=\"_parent\" href=\"http://www.space.net/~gert/RIPE/ipv6-filters.html\">http://www.\n *       space.net/~gert/RIPE/ipv6-filters.html</a>\n * </ul>\n *\n * @author Erik Kline\n * @since 5.0\n */\n@Beta\n@GwtIncompatible\npublic final class InetAddresses\n{\n    private static final int IPV4_PART_COUNT = 4;\n    private static final int IPV6_PART_COUNT = 8;\n    private static final Splitter IPV4_SPLITTER = Splitter.on('.').limit(IPV4_PART_COUNT);\n    private static final Splitter IPV6_SPLITTER = Splitter.on(':').limit(IPV6_PART_COUNT + 2);\n    private static final Inet4Address LOOPBACK4 = (Inet4Address) forString(\"127.0.0.1\");\n    private static final Inet4Address ANY4 = (Inet4Address) forString(\"0.0.0.0\");\n\n    private InetAddresses() {}\n\n    /**\n     * Returns an {@link Inet4Address}, given a byte array representation of the IPv4 address.\n     *\n     * @param bytes byte array representing an IPv4 address (should be of length 4)\n     * @return {@link Inet4Address} corresponding to the supplied byte array\n     * @throws IllegalArgumentException if a valid {@link Inet4Address} can not be created\n     */\n    private static Inet4Address getInet4Address(byte[] bytes)\n    {\n        checkArgument(\n            bytes.length == 4,\n            \"Byte array has invalid length for an IPv4 address: %s != 4.\",\n            bytes.length);\n\n        // Given a 4-byte array, this cast should always succeed.\n        return (Inet4Address) bytesToInetAddress(bytes);\n    }\n\n    /**\n     * Returns the {@link InetAddress} having the given string representation.\n     *\n     * <p>This deliberately avoids all nameservice lookups (e.g. no DNS).\n     *\n     * @param ipString {@code String} containing an IPv4 or IPv6 string literal, e.g. {@code\n     *     \"192.168.0.1\"} or {@code \"2001:db8::1\"}\n     * @return {@link InetAddress} representing the argument\n     * @throws IllegalArgumentException if the argument is not a valid IP string literal\n     */\n    public static InetAddress forString(String ipString)\n    {\n        byte[] addr = ipStringToBytes(ipString);\n\n        // The argument was malformed, i.e. not an IP string literal.\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"'%s' is not an IP string literal.\", ipString);\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP string literal\n     * @return {@code true} if the argument is a valid IP string literal\n     */\n    public static boolean isInetAddress(String ipString)\n    {\n        return ipStringToBytes(ipString) != null;\n    }\n\n    @NullableDecl\n    private static byte[] ipStringToBytes(String ipString)\n    {\n        // Make a first pass to categorize the characters in this string.\n        boolean hasColon = false;\n        boolean hasDot = false;\n        for (int i = 0; i < ipString.length(); i++)\n        {\n            char c = ipString.charAt(i);\n            if (c == '.')\n            {\n                hasDot = true;\n            }\n            else if (c == ':')\n            {\n                if (hasDot)\n                {\n                    return null; // Colons must not appear after dots.\n                }\n                hasColon = true;\n            }\n            else if (Character.digit(c, 16) == -1)\n            {\n                return null; // Everything else must be a decimal or hex digit.\n            }\n        }\n\n        // Now decide which address family to parse.\n        if (hasColon)\n        {\n            if (hasDot)\n            {\n                ipString = convertDottedQuadToHex(ipString);\n                if (ipString == null)\n                {\n                    return null;\n                }\n            }\n            return textToNumericFormatV6(ipString);\n        }\n        else if (hasDot)\n        {\n            return textToNumericFormatV4(ipString);\n        }\n        return null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV4(String ipString)\n    {\n        byte[] bytes = new byte[IPV4_PART_COUNT];\n        int i = 0;\n        try\n        {\n            for (String octet : IPV4_SPLITTER.split(ipString))\n            {\n                bytes[i++] = parseOctet(octet);\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n\n        return i == IPV4_PART_COUNT ? bytes : null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV6(String ipString)\n    {\n        // An address can have [2..8] colons, and N colons make N+1 parts.\n        List<String> parts = IPV6_SPLITTER.splitToList(ipString);\n        if (parts.size() < 3 || parts.size() > IPV6_PART_COUNT + 1)\n        {\n            return null;\n        }\n\n        // Disregarding the endpoints, find \"::\" with nothing in between.\n        // This indicates that a run of zeroes has been skipped.\n        int skipIndex = -1;\n        for (int i = 1; i < parts.size() - 1; i++)\n        {\n            if (parts.get(i).length() == 0)\n            {\n                if (skipIndex >= 0)\n                {\n                    return null; // Can't have more than one ::\n                }\n                skipIndex = i;\n            }\n        }\n\n        int partsHi; // Number of parts to copy from above/before the \"::\"\n        int partsLo; // Number of parts to copy from below/after the \"::\"\n        if (skipIndex >= 0)\n        {\n            // If we found a \"::\", then check if it also covers the endpoints.\n            partsHi = skipIndex;\n            partsLo = parts.size() - skipIndex - 1;\n            if (parts.get(0).length() == 0 && --partsHi != 0)\n            {\n                return null; // ^: requires ^::\n            }\n            if (Iterables.getLast(parts).length() == 0 && --partsLo != 0)\n            {\n                return null; // :$ requires ::$\n            }\n        }\n        else\n        {\n            // Otherwise, allocate the entire address to partsHi. The endpoints\n            // could still be empty, but parseHextet() will check for that.\n            partsHi = parts.size();\n            partsLo = 0;\n        }\n\n        // If we found a ::, then we must have skipped at least one part.\n        // Otherwise, we must have exactly the right number of parts.\n        int partsSkipped = IPV6_PART_COUNT - (partsHi + partsLo);\n        if (!(skipIndex >= 0 ? partsSkipped >= 1 : partsSkipped == 0))\n        {\n            return null;\n        }\n\n        // Now parse the hextets into a byte array.\n        ByteBuffer rawBytes = ByteBuffer.allocate(2 * IPV6_PART_COUNT);\n        try\n        {\n            for (int i = 0; i < partsHi; i++)\n            {\n                rawBytes.putShort(parseHextet(parts.get(i)));\n            }\n            for (int i = 0; i < partsSkipped; i++)\n            {\n                rawBytes.putShort((short) 0);\n            }\n            for (int i = partsLo; i > 0; i--)\n            {\n                rawBytes.putShort(parseHextet(parts.get(parts.size() - i)));\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n        return rawBytes.array();\n    }\n\n    @NullableDecl\n    private static String convertDottedQuadToHex(String ipString)\n    {\n        int lastColon = ipString.lastIndexOf(':');\n        String initialPart = ipString.substring(0, lastColon + 1);\n        String dottedQuad = ipString.substring(lastColon + 1);\n        byte[] quad = textToNumericFormatV4(dottedQuad);\n        if (quad == null)\n        {\n            return null;\n        }\n        String penultimate = Integer.toHexString(((quad[0] & 0xff) << 8) | (quad[1] & 0xff));\n        String ultimate = Integer.toHexString(((quad[2] & 0xff) << 8) | (quad[3] & 0xff));\n        return initialPart + penultimate + \":\" + ultimate;\n    }\n\n    private static byte parseOctet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int octet = Integer.parseInt(ipPart);\n        // Disallow leading zeroes, because no clear standard exists on\n        // whether these should be interpreted as decimal or octal.\n        if (octet > 255 || (ipPart.startsWith(\"0\") && ipPart.length() > 1))\n        {\n            throw new NumberFormatException();\n        }\n        return (byte) octet;\n    }\n\n    private static short parseHextet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int hextet = Integer.parseInt(ipPart, 16);\n        if (hextet > 0xffff)\n        {\n            throw new NumberFormatException();\n        }\n        return (short) hextet;\n    }\n\n    /**\n     * Convert a byte array into an InetAddress.\n     *\n     * <p>{@link InetAddress#getByAddress} is documented as throwing a checked exception \"if IP\n     * address is of illegal length.\" We replace it with an unchecked exception, for use by callers\n     * who already know that addr is an array of length 4 or 16.\n     *\n     * @param addr the raw 4-byte or 16-byte IP address in big-endian order\n     * @return an InetAddress object created from the raw IP address\n     */\n    private static InetAddress bytesToInetAddress(byte[] addr)\n    {\n        try\n        {\n            return InetAddress.getByAddress(addr);\n        }\n        catch (UnknownHostException e)\n        {\n            throw new AssertionError(e);\n        }\n    }\n\n    /**\n     * Returns the string representation of an {@link InetAddress}.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses, the output follows <a href=\"http://tools.ietf.org/html/rfc5952\">RFC 5952</a> section\n     * 4. The main difference is that this method uses \"::\" for zero compression, while Java's version\n     * uses the uncompressed form.\n     *\n     * <p>This method uses hexadecimal for all IPv6 addresses, including IPv4-mapped IPv6 addresses\n     * such as \"::c000:201\". The output does not include a Scope ID.\n     *\n     * @param ip {@link InetAddress} to be converted to an address string\n     * @return {@code String} containing the text-formatted IP address\n     * @since 10.0\n     */\n    public static String toAddrString(InetAddress ip)\n    {\n        checkNotNull(ip);\n        if (ip instanceof Inet4Address)\n        {\n            // For IPv4, Java's formatting is good enough.\n            return ip.getHostAddress();\n        }\n        checkArgument(ip instanceof Inet6Address);\n        byte[] bytes = ip.getAddress();\n        int[] hextets = new int[IPV6_PART_COUNT];\n        for (int i = 0; i < hextets.length; i++)\n        {\n            hextets[i] = Ints.fromBytes((byte) 0, (byte) 0, bytes[2 * i], bytes[2 * i + 1]);\n        }\n        compressLongestRunOfZeroes(hextets);\n        return hextetsToIPv6String(hextets);\n    }\n\n    /**\n     * Identify and mark the longest run of zeroes in an IPv6 address.\n     *\n     * <p>Only runs of two or more hextets are considered. In case of a tie, the leftmost run wins. If\n     * a qualifying run is found, its hextets are replaced by the sentinel value -1.\n     *\n     * @param hextets {@code int[]} mutable array of eight 16-bit hextets\n     */\n    private static void compressLongestRunOfZeroes(int[] hextets)\n    {\n        int bestRunStart = -1;\n        int bestRunLength = -1;\n        int runStart = -1;\n        for (int i = 0; i < hextets.length + 1; i++)\n        {\n            if (i < hextets.length && hextets[i] == 0)\n            {\n                if (runStart < 0)\n                {\n                    runStart = i;\n                }\n            }\n            else if (runStart >= 0)\n            {\n                int runLength = i - runStart;\n                if (runLength > bestRunLength)\n                {\n                    bestRunStart = runStart;\n                    bestRunLength = runLength;\n                }\n                runStart = -1;\n            }\n        }\n        if (bestRunLength >= 2)\n        {\n            Arrays.fill(hextets, bestRunStart, bestRunStart + bestRunLength, -1);\n        }\n    }\n\n    /**\n     * Convert a list of hextets into a human-readable IPv6 address.\n     *\n     * <p>In order for \"::\" compression to work, the input should contain negative sentinel values in\n     * place of the elided zeroes.\n     *\n     * @param hextets {@code int[]} array of eight 16-bit hextets, or -1s\n     */\n    private static String hextetsToIPv6String(int[] hextets)\n    {\n        // While scanning the array, handle these state transitions:\n        //   start->num => \"num\"     start->gap => \"::\"\n        //   num->num   => \":num\"    num->gap   => \"::\"\n        //   gap->num   => \"num\"     gap->gap   => \"\"\n        StringBuilder buf = new StringBuilder(39);\n        boolean lastWasNumber = false;\n        for (int i = 0; i < hextets.length; i++)\n        {\n            boolean thisIsNumber = hextets[i] >= 0;\n            if (thisIsNumber)\n            {\n                if (lastWasNumber)\n                {\n                    buf.append(':');\n                }\n                buf.append(Integer.toHexString(hextets[i]));\n            }\n            else\n            {\n                if (i == 0 || lastWasNumber)\n                {\n                    buf.append(\"::\");\n                }\n            }\n            lastWasNumber = thisIsNumber;\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Returns the string representation of an {@link InetAddress} suitable for inclusion in a URI.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses it compresses zeroes and surrounds the text with square brackets; for example {@code\n     * \"[2001:db8::1]\"}.\n     *\n     * <p>Per section 3.2.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3986#section-3.2.2\">RFC 3986</a>, a URI containing an IPv6\n     * string literal is of the form {@code \"http://[2001:db8::1]:8888/index.html\"}.\n     *\n     * <p>Use of either {@link InetAddresses#toAddrString}, {@link InetAddress#getHostAddress()}, or\n     * this method is recommended over {@link InetAddress#toString()} when an IP address string\n     * literal is desired. This is because {@link InetAddress#toString()} prints the hostname and the\n     * IP address string joined by a \"/\".\n     *\n     * @param ip {@link InetAddress} to be converted to URI string literal\n     * @return {@code String} containing URI-safe string literal\n     */\n    public static String toUriString(InetAddress ip)\n    {\n        if (ip instanceof Inet6Address)\n        {\n            return \"[\" + toAddrString(ip) + \"]\";\n        }\n        return toAddrString(ip);\n    }\n\n    /**\n     * Returns an InetAddress representing the literal IPv4 or IPv6 host portion of a URL, encoded in\n     * the format specified by RFC 3986 section 3.2.2.\n     *\n     * <p>This function is similar to {@link InetAddresses#forString(String)}, however, it requires\n     * that IPv6 addresses are surrounded by square brackets.\n     *\n     * <p>This function is the inverse of {@link InetAddresses#toUriString(java.net.InetAddress)}.\n     *\n     * @param hostAddr A RFC 3986 section 3.2.2 encoded IPv4 or IPv6 address\n     * @return an InetAddress representing the address in {@code hostAddr}\n     * @throws IllegalArgumentException if {@code hostAddr} is not a valid IPv4 address, or IPv6\n     *     address surrounded by square brackets\n     */\n    public static InetAddress forUriString(String hostAddr)\n    {\n        InetAddress addr = forUriStringNoThrow(hostAddr);\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"Not a valid URI IP literal: '%s'\", hostAddr);\n        }\n\n        return addr;\n    }\n\n    @NullableDecl\n    private static InetAddress forUriStringNoThrow(String hostAddr)\n    {\n        checkNotNull(hostAddr);\n\n        // Decide if this should be an IPv6 or IPv4 address.\n        String ipString;\n        int expectBytes;\n        if (hostAddr.startsWith(\"[\") && hostAddr.endsWith(\"]\"))\n        {\n            ipString = hostAddr.substring(1, hostAddr.length() - 1);\n            expectBytes = 16;\n        }\n        else\n        {\n            ipString = hostAddr;\n            expectBytes = 4;\n        }\n\n        // Parse the address, and make sure the length/version is correct.\n        byte[] addr = ipStringToBytes(ipString);\n        if (addr == null || addr.length != expectBytes)\n        {\n            return null;\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid URI IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP URI host string literal\n     * @return {@code true} if the argument is a valid IP URI host\n     */\n    public static boolean isUriInetAddress(String ipString)\n    {\n        return forUriStringNoThrow(ipString) != null;\n    }\n\n    /**\n     * Evaluates whether the argument is an IPv6 \"compat\" address.\n     *\n     * <p>An \"IPv4 compatible\", or \"compat\", address is one with 96 leading bits of zero, with the\n     * remaining 32 bits interpreted as an IPv4 address. These are conventionally represented in\n     * string literals as {@code \"::192.168.0.1\"}, though {@code \"::c0a8:1\"} is also considered an\n     * IPv4 compatible address (and equivalent to {@code \"::192.168.0.1\"}).\n     *\n     * <p>For more on IPv4 compatible addresses see section 2.5.5.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.1\">RFC 4291</a>.\n     *\n     * <p>NOTE: This method is different from {@link Inet6Address#isIPv4CompatibleAddress} in that it\n     * more correctly classifies {@code \"::\"} and {@code \"::1\"} as proper IPv6 addresses (which they\n     * are), NOT IPv4 compatible addresses (which they are generally NOT considered to be).\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 compatible address format\n     * @return {@code true} if the argument is a valid \"compat\" address\n     */\n\n    /**\n     * Returns the IPv4 address embedded in an IPv4 compatible address.\n     *\n     * @param ip {@link Inet6Address} to be examined for an embedded IPv4 address\n     * @return {@link Inet4Address} of the embedded IPv4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv4 compatible address\n     */\n    public static Inet4Address getCompatIPv4Address(Inet6Address ip)\n    {\n        checkArgument(\n            isCompatIPv4Address(ip), \"Address '%s' is not IPv4-compatible.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n    }\n\n    /**\n     * Evaluates whether the argument is a 6to4 address.\n     *\n     * <p>6to4 addresses begin with the {@code \"2002::/16\"} prefix. The next 32 bits are the IPv4\n     * address of the host to which IPv6-in-IPv4 tunneled packets should be routed.\n     *\n     * <p>For more on 6to4 addresses see section 2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3056#section-2\">RFC 3056</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for 6to4 address format\n     * @return {@code true} if the argument is a 6to4 address\n     */\n    public static boolean is6to4Address(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20) && (bytes[1] == (byte) 0x02);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in a 6to4 address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in 6to4 address\n     * @return {@link Inet4Address} of embedded IPv4 in 6to4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 6to4 address\n     */\n    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n    {\n        checkArgument(is6to4Address(ip), \"Address '%s' is not a 6to4 address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 2, 6));\n    }\n\n    /**\n     * A simple immutable data class to encapsulate the information to be found in a Teredo address.\n     *\n     * <p>All of the fields in this class are encoded in various portions of the IPv6 address as part\n     * of the protocol. More protocols details can be found at: <a target=\"_parent\"\n     * href=\"http://en.wikipedia.org/wiki/Teredo_tunneling\">http://en.wikipedia.\n     * org/wiki/Teredo_tunneling</a>.\n     *\n     * <p>The RFC can be found here: <a target=\"_parent\" href=\"http://tools.ietf.org/html/rfc4380\">RFC\n     * 4380</a>.\n     *\n     * @since 5.0\n     */\n    @Beta\n    public static final class TeredoInfo\n    {\n        private final Inet4Address server;\n        private final Inet4Address client;\n        private final int port;\n        private final int flags;\n\n        /**\n         * Constructs a TeredoInfo instance.\n         *\n         * <p>Both server and client can be {@code null}, in which case the value {@code \"0.0.0.0\"} will\n         * be assumed.\n         *\n         * @throws IllegalArgumentException if either of the {@code port} or the {@code flags} arguments\n         *     are out of range of an unsigned short\n         */\n        // TODO: why is this public?\n        public TeredoInfo(\n            @NullableDecl Inet4Address server, @NullableDecl Inet4Address client, int port, int flags)\n        {\n            checkArgument(\n                (port >= 0) && (port <= 0xffff), \"port '%s' is out of range (0 <= port <= 0xffff)\", port);\n            checkArgument(\n                (flags >= 0) && (flags <= 0xffff),\n                \"flags '%s' is out of range (0 <= flags <= 0xffff)\",\n                flags);\n\n            this.server = MoreObjects.firstNonNull(server, ANY4);\n            this.client = MoreObjects.firstNonNull(client, ANY4);\n            this.port = port;\n            this.flags = flags;\n        }\n\n        public Inet4Address getServer()\n        {\n            return server;\n        }\n\n        public Inet4Address getClient()\n        {\n            return client;\n        }\n\n        public int getPort()\n        {\n            return port;\n        }\n\n        public int getFlags()\n        {\n            return flags;\n        }\n    }\n\n    /**\n     * Evaluates whether the argument is a Teredo address.\n     *\n     * <p>Teredo addresses begin with the {@code \"2001::/32\"} prefix.\n     *\n     * @param ip {@link Inet6Address} to be examined for Teredo address format\n     * @return {@code true} if the argument is a Teredo address\n     */\n    public static boolean isTeredoAddress(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20)\n               && (bytes[1] == (byte) 0x01)\n               && (bytes[2] == 0)\n               && (bytes[3] == 0);\n    }\n\n    /**\n     * Returns the Teredo information embedded in a Teredo address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded Teredo information\n     * @return extracted {@code TeredoInfo}\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 Teredo address\n     */\n    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n    {\n        checkArgument(isTeredoAddress(ip), \"Address '%s' is not a Teredo address.\", toAddrString(ip));\n\n        byte[] bytes = ip.getAddress();\n        Inet4Address server = getInet4Address(Arrays.copyOfRange(bytes, 4, 8));\n\n        int flags = ByteStreams.newDataInput(bytes, 8).readShort() & 0xffff;\n\n        // Teredo obfuscates the mapped client port, per section 4 of the RFC.\n        int port = ~ByteStreams.newDataInput(bytes, 10).readShort() & 0xffff;\n\n        byte[] clientBytes = Arrays.copyOfRange(bytes, 12, 16);\n        for (int i = 0; i < clientBytes.length; i++)\n        {\n            // Teredo obfuscates the mapped client IP, per section 4 of the RFC.\n            clientBytes[i] = (byte) ~clientBytes[i];\n        }\n        Inet4Address client = getInet4Address(clientBytes);\n\n        return new TeredoInfo(server, client, port, flags);\n    }\n\n    /**\n     * Evaluates whether the argument is an ISATAP address.\n     *\n     * <p>From RFC 5214: \"ISATAP interface identifiers are constructed in Modified EUI-64 format [...]\n     * by concatenating the 24-bit IANA OUI (00-00-5E), the 8-bit hexadecimal value 0xFE, and a 32-bit\n     * IPv4 address in network byte order [...]\"\n     *\n     * <p>For more on ISATAP addresses see section 6.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc5214#section-6.1\">RFC 5214</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for ISATAP address format\n     * @return {@code true} if the argument is an ISATAP address\n     */\n    public static boolean isIsatapAddress(Inet6Address ip)\n    {\n\n        // If it's a Teredo address with the right port (41217, or 0xa101)\n        // which would be encoded as 0x5efe then it can't be an ISATAP address.\n        if (isTeredoAddress(ip))\n        {\n            return false;\n        }\n\n        byte[] bytes = ip.getAddress();\n\n        if ((bytes[8] | (byte) 0x03) != (byte) 0x03)\n        {\n\n            // Verify that high byte of the 64 bit identifier is zero, modulo\n            // the U/L and G bits, with which we are not concerned.\n            return false;\n        }\n\n        return (bytes[9] == (byte) 0x00) && (bytes[10] == (byte) 0x5e) && (bytes[11] == (byte) 0xfe);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in an ISATAP address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in ISATAP address\n     * @return {@link Inet4Address} of embedded IPv4 in an ISATAP address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 ISATAP address\n     */\n    public static Inet4Address getIsatapIPv4Address(Inet6Address ip)\n    {\n        checkArgument(isIsatapAddress(ip), \"Address '%s' is not an ISATAP address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n    }\n\n    /**\n     * Examines the Inet6Address to determine if it is an IPv6 address of one of the specified address\n     * types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@code true} if there is an embedded IPv4 client address\n     * @since 7.0\n     */\n    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        return isCompatIPv4Address(ip) || is6to4Address(ip) || isTeredoAddress(ip);\n    }\n\n    /**\n     * Examines the Inet6Address to extract the embedded IPv4 client address if the InetAddress is an\n     * IPv6 address of one of the specified address types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@link Inet4Address} of embedded IPv4 client address\n     * @throws IllegalArgumentException if the argument does not have a valid embedded IPv4 address\n     */\n    public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        if (isCompatIPv4Address(ip))\n        {\n            return getCompatIPv4Address(ip);\n        }\n\n        if (is6to4Address(ip))\n        {\n            return get6to4IPv4Address(ip);\n        }\n\n        if (isTeredoAddress(ip))\n        {\n            return getTeredoInfo(ip).getClient();\n        }\n\n        throw formatIllegalArgumentException(\"'%s' has no embedded IPv4 address.\", toAddrString(ip));\n    }\n\n    /**\n     * Evaluates whether the argument is an \"IPv4 mapped\" IPv6 address.\n     *\n     * <p>An \"IPv4 mapped\" address is anything in the range ::ffff:0:0/96 (sometimes written as\n     * ::ffff:0.0.0.0/96), with the last 32 bits interpreted as an IPv4 address.\n     *\n     * <p>For more on IPv4 mapped addresses see section 2.5.5.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.2\">RFC 4291</a>.\n     *\n     * <p>Note: This method takes a {@code String} argument because {@link InetAddress} automatically\n     * collapses mapped addresses to IPv4. (It is actually possible to avoid this using one of the\n     * obscure {@link Inet6Address} methods, but it would be unwise to depend on such a\n     * poorly-documented feature.)\n     *\n     * @param ipString {@code String} to be examined for embedded IPv4-mapped IPv6 address format\n     * @return {@code true} if the argument is a valid \"mapped\" address\n     * @since 10.0\n     */\n    public static boolean isMappedIPv4Address(String ipString)\n    {\n        byte[] bytes = ipStringToBytes(ipString);\n        if (bytes != null && bytes.length == 16)\n        {\n            for (int i = 0; i < 10; i++)\n            {\n                if (bytes[i] != 0)\n                {\n                    return false;\n                }\n            }\n            for (int i = 10; i < 12; i++)\n            {\n                if (bytes[i] != (byte) 0xff)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Coerces an IPv6 address into an IPv4 address.\n     *\n     * <p>HACK: As long as applications continue to use IPv4 addresses for indexing into tables,\n     * accounting, et cetera, it may be necessary to <b>coerce</b> IPv6 addresses into IPv4 addresses.\n     * This function does so by hashing the upper 64 bits into {@code 224.0.0.0/3} (64 bits into 29\n     * bits).\n     *\n     * <p>A \"coerced\" IPv4 address is equivalent to itself.\n     *\n     * <p>NOTE: This function is failsafe for security purposes: ALL IPv6 addresses (except localhost\n     * (::1)) are hashed to avoid the security risk associated with extracting an embedded IPv4\n     * address that might permit elevated privileges.\n     *\n     * @param ip {@link InetAddress} to \"coerce\"\n     * @return {@link Inet4Address} represented \"coerced\" address\n     * @since 7.0\n     */\n    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n    {\n        if (ip instanceof Inet4Address)\n        {\n            return (Inet4Address) ip;\n        }\n\n        // Special cases:\n        byte[] bytes = ip.getAddress();\n        boolean leadingBytesOfZero = true;\n        for (int i = 0; i < 15; ++i)\n        {\n            if (bytes[i] != 0)\n            {\n                leadingBytesOfZero = false;\n                break;\n            }\n        }\n        if (leadingBytesOfZero && (bytes[15] == 1))\n        {\n            return LOOPBACK4; // ::1\n        }\n        else if (leadingBytesOfZero && (bytes[15] == 0))\n        {\n            return ANY4; // ::0\n        }\n\n        Inet6Address ip6 = (Inet6Address) ip;\n        long addressAsLong = 0;\n        if (hasEmbeddedIPv4ClientAddress(ip6))\n        {\n            addressAsLong = getEmbeddedIPv4ClientAddress(ip6).hashCode();\n        }\n        else\n        {\n\n            // Just extract the high 64 bits (assuming the rest is user-modifiable).\n            addressAsLong = ByteBuffer.wrap(ip6.getAddress(), 0, 8).getLong();\n        }\n\n        // Many strategies for hashing are possible. This might suffice for now.\n        int coercedHash = Hashing.murmur3_32().hashLong(addressAsLong).asInt();\n\n        // Squash into 224/4 Multicast and 240/4 Reserved space (i.e. 224/3).\n        coercedHash |= 0xe0000000;\n\n        // Fixup to avoid some \"illegal\" values. Currently the only potential\n        // illegal value is 255.255.255.255.\n        if (coercedHash == 0xffffffff)\n        {\n            coercedHash = 0xfffffffe;\n        }\n\n        return getInet4Address(Ints.toByteArray(coercedHash));\n    }\n\n    /**\n     * Returns an integer representing an IPv4 address regardless of whether the supplied argument is\n     * an IPv4 address or not.\n     *\n     * <p>IPv6 addresses are <b>coerced</b> to IPv4 addresses before being converted to integers.\n     *\n     * <p>As long as there are applications that assume that all IP addresses are IPv4 addresses and\n     * can therefore be converted safely to integers (for whatever purpose) this function can be used\n     * to handle IPv6 addresses as well until the application is suitably fixed.\n     *\n     * <p>NOTE: an IPv6 address coerced to an IPv4 address can only be used for such purposes as\n     * rudimentary identification or indexing into a collection of real {@link InetAddress}es. They\n     * cannot be used as real addresses for the purposes of network communication.\n     *\n     * @param ip {@link InetAddress} to convert\n     * @return {@code int}, \"coerced\" if ip is not an IPv4 address\n     * @since 7.0\n     */\n    public static int coerceToInteger(InetAddress ip)\n    {\n        return ByteStreams.newDataInput(getCoercedIPv4Address(ip).getAddress()).readInt();\n    }\n\n    /**\n     * Returns an Inet4Address having the integer value specified by the argument.\n     *\n     * @param address {@code int}, the 32bit integer address to be converted\n     * @return {@link Inet4Address} equivalent of the argument\n     */\n    public static Inet4Address fromInteger(int address)\n    {\n        return getInet4Address(Ints.toByteArray(address));\n    }\n\n    /**\n     * Returns an address from a <b>little-endian ordered</b> byte array (the opposite of what {@link\n     * InetAddress#getByAddress} expects).\n     *\n     * <p>IPv4 address byte array must be 4 bytes long and IPv6 byte array must be 16 bytes long.\n     *\n     * @param addr the raw IP address in little-endian byte order\n     * @return an InetAddress object created from the raw IP address\n     * @throws UnknownHostException if IP address is of illegal length\n     */\n    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n    {\n        byte[] reversed = new byte[addr.length];\n        for (int i = 0; i < addr.length; i++)\n        {\n            reversed[i] = addr[addr.length - i - 1];\n        }\n        return InetAddress.getByAddress(reversed);\n    }\n\n    /**\n     * Returns a new InetAddress that is one less than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to decrement\n     * @return a new InetAddress that is one less than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the beginning of its range\n     * @since 18.0\n     */\n    public static InetAddress decrement(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0x00)\n        {\n            addr[i] = (byte) 0xff;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Decrementing %s would wrap.\", address);\n\n        addr[i]--;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns a new InetAddress that is one more than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to increment\n     * @return a new InetAddress that is one more than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the end of its range\n     * @since 10.0\n     */\n    public static InetAddress increment(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0xff)\n        {\n            addr[i] = 0;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Incrementing %s would wrap.\", address);\n\n        addr[i]++;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns true if the InetAddress is either 255.255.255.255 for IPv4 or\n     * ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6.\n     *\n     * @return true if the InetAddress is either 255.255.255.255 for IPv4 or\n     *     ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6\n     * @since 10.0\n     */\n    public static boolean isMaximum(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        for (int i = 0; i < addr.length; i++)\n        {\n            if (addr[i] != (byte) 0xff)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static IllegalArgumentException formatIllegalArgumentException(\n        String format, Object... args)\n    {\n        return new IllegalArgumentException(String.format(Locale.ROOT, format, args));\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.getCompatIPv4Address", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns the IPv4 address embedded in an IPv4 compatible address.\n\n@param ip {@link Inet6Address} to be examined for an embedded IPv4 address\n@return {@link Inet4Address} of the embedded IPv4 address\n@throws IllegalArgumentException if the argument is not a valid IPv4 compatible address", "docstring_tokens": ["Returns", "the", "IPv4", "address", "embedded", "in", "an", "IPv4", "compatible", "address", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L544-L549", "partition": "valid", "up_fun_num": 20, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.MoreObjects;", "import com.google.common.base.Splitter;", "import com.google.common.collect.Iterables;", "import com.google.common.hash.Hashing;", "import com.google.common.io.ByteStreams;", "import com.google.common.primitives.Ints;", "import java.net.Inet4Address;", "import java.net.Inet6Address;", "import java.net.InetAddress;", "import java.net.UnknownHostException;", "import java.nio.ByteBuffer;", "import java.util.Arrays;", "import java.util.List;", "import java.util.Locale;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class InetAddresses\n", "    private static Inet4Address getInet4Address(byte[] bytes)\n", "    public static InetAddress forString(String ipString)\n", "    public static boolean isInetAddress(String ipString)\n", "    private static byte[] ipStringToBytes(String ipString)\n", "    private static byte[] textToNumericFormatV4(String ipString)\n", "    private static byte[] textToNumericFormatV6(String ipString)\n", "    private static String convertDottedQuadToHex(String ipString)\n", "    private static byte parseOctet(String ipPart)\n", "    private static short parseHextet(String ipPart)\n", "    private static InetAddress bytesToInetAddress(byte[] addr)\n", "    public static String toAddrString(InetAddress ip)\n", "    private static void compressLongestRunOfZeroes(int[] hextets)\n", "    private static String hextetsToIPv6String(int[] hextets)\n", "    public static String toUriString(InetAddress ip)\n", "    public static InetAddress forUriString(String hostAddr)\n", "    private static InetAddress forUriStringNoThrow(String hostAddr)\n", "    public static boolean isUriInetAddress(String ipString)\n", "    public static boolean isCompatIPv4Address(Inet6Address ip)\n", "    public static boolean is6to4Address(Inet6Address ip)\n", "    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n", "    public static boolean isTeredoAddress(Inet6Address ip)\n", "    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n", "    public static boolean isIsatapAddress(Inet6Address ip)\n", "    public static Inet4Address getIsatapIPv4Address(Inet6Address ip)\n", "    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static boolean isMappedIPv4Address(String ipString)\n", "    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n", "    public static int coerceToInteger(InetAddress ip)\n", "    public static Inet4Address fromInteger(int address)\n", "    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n", "    public static InetAddress decrement(InetAddress address)\n", "    public static InetAddress increment(InetAddress address)\n", "    public static boolean isMaximum(InetAddress address)\n", "    private static IllegalArgumentException formatIllegalArgumentException(\n"], "context": "/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.net;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.Iterables;\nimport com.google.common.hash.Hashing;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.primitives.Ints;\nimport java.net.Inet4Address;\nimport java.net.Inet6Address;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * Static utility methods pertaining to {@link InetAddress} instances.\n *\n * <p><b>Important note:</b> Unlike {@code InetAddress.getByName()}, the methods of this class never\n * cause DNS services to be accessed. For this reason, you should prefer these methods as much as\n * possible over their JDK equivalents whenever you are expecting to handle only IP address string\n * literals -- there is no blocking DNS penalty for a malformed string.\n *\n * <p>When dealing with {@link Inet4Address} and {@link Inet6Address} objects as byte arrays (vis.\n * {@code InetAddress.getAddress()}) they are 4 and 16 bytes in length, respectively, and represent\n * the address in network byte order.\n *\n * <p>Examples of IP addresses and their byte representations:\n *\n * <dl>\n *   <dt>The IPv4 loopback address, {@code \"127.0.0.1\"}.\n *   <dd>{@code 7f 00 00 01}\n *   <dt>The IPv6 loopback address, {@code \"::1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>From the IPv6 reserved documentation prefix ({@code 2001:db8::/32}), {@code \"2001:db8::1\"}.\n *   <dd>{@code 20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>An IPv6 \"IPv4 compatible\" (or \"compat\") address, {@code \"::192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 c0 a8 00 01}\n *   <dt>An IPv6 \"IPv4 mapped\" address, {@code \"::ffff:192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 ff ff c0 a8 00 01}\n * </dl>\n *\n * <p>A few notes about IPv6 \"IPv4 mapped\" addresses and their observed use in Java.\n *\n * <p>\"IPv4 mapped\" addresses were originally a representation of IPv4 addresses for use on an IPv6\n * socket that could receive both IPv4 and IPv6 connections (by disabling the {@code IPV6_V6ONLY}\n * socket option on an IPv6 socket). Yes, it's confusing. Nevertheless, these \"mapped\" addresses\n * were never supposed to be seen on the wire. That assumption was dropped, some say mistakenly, in\n * later RFCs with the apparent aim of making IPv4-to-IPv6 transition simpler.\n *\n * <p>Technically one <i>can</i> create a 128bit IPv6 address with the wire format of a \"mapped\"\n * address, as shown above, and transmit it in an IPv6 packet header. However, Java's InetAddress\n * creation methods appear to adhere doggedly to the original intent of the \"mapped\" address: all\n * \"mapped\" addresses return {@link Inet4Address} objects.\n *\n * <p>For added safety, it is common for IPv6 network operators to filter all packets where either\n * the source or destination address appears to be a \"compat\" or \"mapped\" address. Filtering\n * suggestions usually recommend discarding any packets with source or destination addresses in the\n * invalid range {@code ::/3}, which includes both of these bizarre address formats. For more\n * information on \"bogons\", including lists of IPv6 bogon space, see:\n *\n * <ul>\n *   <li><a target=\"_parent\"\n *       href=\"http://en.wikipedia.org/wiki/Bogon_filtering\">http://en.wikipedia.\n *       org/wiki/Bogon_filtering</a>\n *   <li><a target=\"_parent\"\n *       href=\"http://www.cymru.com/Bogons/ipv6.txt\">http://www.cymru.com/Bogons/ ipv6.txt</a>\n *   <li><a target=\"_parent\" href=\"http://www.cymru.com/Bogons/v6bogon.html\">http://www.cymru.com/\n *       Bogons/v6bogon.html</a>\n *   <li><a target=\"_parent\" href=\"http://www.space.net/~gert/RIPE/ipv6-filters.html\">http://www.\n *       space.net/~gert/RIPE/ipv6-filters.html</a>\n * </ul>\n *\n * @author Erik Kline\n * @since 5.0\n */\n@Beta\n@GwtIncompatible\npublic final class InetAddresses\n{\n    private static final int IPV4_PART_COUNT = 4;\n    private static final int IPV6_PART_COUNT = 8;\n    private static final Splitter IPV4_SPLITTER = Splitter.on('.').limit(IPV4_PART_COUNT);\n    private static final Splitter IPV6_SPLITTER = Splitter.on(':').limit(IPV6_PART_COUNT + 2);\n    private static final Inet4Address LOOPBACK4 = (Inet4Address) forString(\"127.0.0.1\");\n    private static final Inet4Address ANY4 = (Inet4Address) forString(\"0.0.0.0\");\n\n    private InetAddresses() {}\n\n    /**\n     * Returns an {@link Inet4Address}, given a byte array representation of the IPv4 address.\n     *\n     * @param bytes byte array representing an IPv4 address (should be of length 4)\n     * @return {@link Inet4Address} corresponding to the supplied byte array\n     * @throws IllegalArgumentException if a valid {@link Inet4Address} can not be created\n     */\n    private static Inet4Address getInet4Address(byte[] bytes)\n    {\n        checkArgument(\n            bytes.length == 4,\n            \"Byte array has invalid length for an IPv4 address: %s != 4.\",\n            bytes.length);\n\n        // Given a 4-byte array, this cast should always succeed.\n        return (Inet4Address) bytesToInetAddress(bytes);\n    }\n\n    /**\n     * Returns the {@link InetAddress} having the given string representation.\n     *\n     * <p>This deliberately avoids all nameservice lookups (e.g. no DNS).\n     *\n     * @param ipString {@code String} containing an IPv4 or IPv6 string literal, e.g. {@code\n     *     \"192.168.0.1\"} or {@code \"2001:db8::1\"}\n     * @return {@link InetAddress} representing the argument\n     * @throws IllegalArgumentException if the argument is not a valid IP string literal\n     */\n    public static InetAddress forString(String ipString)\n    {\n        byte[] addr = ipStringToBytes(ipString);\n\n        // The argument was malformed, i.e. not an IP string literal.\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"'%s' is not an IP string literal.\", ipString);\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP string literal\n     * @return {@code true} if the argument is a valid IP string literal\n     */\n    public static boolean isInetAddress(String ipString)\n    {\n        return ipStringToBytes(ipString) != null;\n    }\n\n    @NullableDecl\n    private static byte[] ipStringToBytes(String ipString)\n    {\n        // Make a first pass to categorize the characters in this string.\n        boolean hasColon = false;\n        boolean hasDot = false;\n        for (int i = 0; i < ipString.length(); i++)\n        {\n            char c = ipString.charAt(i);\n            if (c == '.')\n            {\n                hasDot = true;\n            }\n            else if (c == ':')\n            {\n                if (hasDot)\n                {\n                    return null; // Colons must not appear after dots.\n                }\n                hasColon = true;\n            }\n            else if (Character.digit(c, 16) == -1)\n            {\n                return null; // Everything else must be a decimal or hex digit.\n            }\n        }\n\n        // Now decide which address family to parse.\n        if (hasColon)\n        {\n            if (hasDot)\n            {\n                ipString = convertDottedQuadToHex(ipString);\n                if (ipString == null)\n                {\n                    return null;\n                }\n            }\n            return textToNumericFormatV6(ipString);\n        }\n        else if (hasDot)\n        {\n            return textToNumericFormatV4(ipString);\n        }\n        return null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV4(String ipString)\n    {\n        byte[] bytes = new byte[IPV4_PART_COUNT];\n        int i = 0;\n        try\n        {\n            for (String octet : IPV4_SPLITTER.split(ipString))\n            {\n                bytes[i++] = parseOctet(octet);\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n\n        return i == IPV4_PART_COUNT ? bytes : null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV6(String ipString)\n    {\n        // An address can have [2..8] colons, and N colons make N+1 parts.\n        List<String> parts = IPV6_SPLITTER.splitToList(ipString);\n        if (parts.size() < 3 || parts.size() > IPV6_PART_COUNT + 1)\n        {\n            return null;\n        }\n\n        // Disregarding the endpoints, find \"::\" with nothing in between.\n        // This indicates that a run of zeroes has been skipped.\n        int skipIndex = -1;\n        for (int i = 1; i < parts.size() - 1; i++)\n        {\n            if (parts.get(i).length() == 0)\n            {\n                if (skipIndex >= 0)\n                {\n                    return null; // Can't have more than one ::\n                }\n                skipIndex = i;\n            }\n        }\n\n        int partsHi; // Number of parts to copy from above/before the \"::\"\n        int partsLo; // Number of parts to copy from below/after the \"::\"\n        if (skipIndex >= 0)\n        {\n            // If we found a \"::\", then check if it also covers the endpoints.\n            partsHi = skipIndex;\n            partsLo = parts.size() - skipIndex - 1;\n            if (parts.get(0).length() == 0 && --partsHi != 0)\n            {\n                return null; // ^: requires ^::\n            }\n            if (Iterables.getLast(parts).length() == 0 && --partsLo != 0)\n            {\n                return null; // :$ requires ::$\n            }\n        }\n        else\n        {\n            // Otherwise, allocate the entire address to partsHi. The endpoints\n            // could still be empty, but parseHextet() will check for that.\n            partsHi = parts.size();\n            partsLo = 0;\n        }\n\n        // If we found a ::, then we must have skipped at least one part.\n        // Otherwise, we must have exactly the right number of parts.\n        int partsSkipped = IPV6_PART_COUNT - (partsHi + partsLo);\n        if (!(skipIndex >= 0 ? partsSkipped >= 1 : partsSkipped == 0))\n        {\n            return null;\n        }\n\n        // Now parse the hextets into a byte array.\n        ByteBuffer rawBytes = ByteBuffer.allocate(2 * IPV6_PART_COUNT);\n        try\n        {\n            for (int i = 0; i < partsHi; i++)\n            {\n                rawBytes.putShort(parseHextet(parts.get(i)));\n            }\n            for (int i = 0; i < partsSkipped; i++)\n            {\n                rawBytes.putShort((short) 0);\n            }\n            for (int i = partsLo; i > 0; i--)\n            {\n                rawBytes.putShort(parseHextet(parts.get(parts.size() - i)));\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n        return rawBytes.array();\n    }\n\n    @NullableDecl\n    private static String convertDottedQuadToHex(String ipString)\n    {\n        int lastColon = ipString.lastIndexOf(':');\n        String initialPart = ipString.substring(0, lastColon + 1);\n        String dottedQuad = ipString.substring(lastColon + 1);\n        byte[] quad = textToNumericFormatV4(dottedQuad);\n        if (quad == null)\n        {\n            return null;\n        }\n        String penultimate = Integer.toHexString(((quad[0] & 0xff) << 8) | (quad[1] & 0xff));\n        String ultimate = Integer.toHexString(((quad[2] & 0xff) << 8) | (quad[3] & 0xff));\n        return initialPart + penultimate + \":\" + ultimate;\n    }\n\n    private static byte parseOctet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int octet = Integer.parseInt(ipPart);\n        // Disallow leading zeroes, because no clear standard exists on\n        // whether these should be interpreted as decimal or octal.\n        if (octet > 255 || (ipPart.startsWith(\"0\") && ipPart.length() > 1))\n        {\n            throw new NumberFormatException();\n        }\n        return (byte) octet;\n    }\n\n    private static short parseHextet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int hextet = Integer.parseInt(ipPart, 16);\n        if (hextet > 0xffff)\n        {\n            throw new NumberFormatException();\n        }\n        return (short) hextet;\n    }\n\n    /**\n     * Convert a byte array into an InetAddress.\n     *\n     * <p>{@link InetAddress#getByAddress} is documented as throwing a checked exception \"if IP\n     * address is of illegal length.\" We replace it with an unchecked exception, for use by callers\n     * who already know that addr is an array of length 4 or 16.\n     *\n     * @param addr the raw 4-byte or 16-byte IP address in big-endian order\n     * @return an InetAddress object created from the raw IP address\n     */\n    private static InetAddress bytesToInetAddress(byte[] addr)\n    {\n        try\n        {\n            return InetAddress.getByAddress(addr);\n        }\n        catch (UnknownHostException e)\n        {\n            throw new AssertionError(e);\n        }\n    }\n\n    /**\n     * Returns the string representation of an {@link InetAddress}.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses, the output follows <a href=\"http://tools.ietf.org/html/rfc5952\">RFC 5952</a> section\n     * 4. The main difference is that this method uses \"::\" for zero compression, while Java's version\n     * uses the uncompressed form.\n     *\n     * <p>This method uses hexadecimal for all IPv6 addresses, including IPv4-mapped IPv6 addresses\n     * such as \"::c000:201\". The output does not include a Scope ID.\n     *\n     * @param ip {@link InetAddress} to be converted to an address string\n     * @return {@code String} containing the text-formatted IP address\n     * @since 10.0\n     */\n    public static String toAddrString(InetAddress ip)\n    {\n        checkNotNull(ip);\n        if (ip instanceof Inet4Address)\n        {\n            // For IPv4, Java's formatting is good enough.\n            return ip.getHostAddress();\n        }\n        checkArgument(ip instanceof Inet6Address);\n        byte[] bytes = ip.getAddress();\n        int[] hextets = new int[IPV6_PART_COUNT];\n        for (int i = 0; i < hextets.length; i++)\n        {\n            hextets[i] = Ints.fromBytes((byte) 0, (byte) 0, bytes[2 * i], bytes[2 * i + 1]);\n        }\n        compressLongestRunOfZeroes(hextets);\n        return hextetsToIPv6String(hextets);\n    }\n\n    /**\n     * Identify and mark the longest run of zeroes in an IPv6 address.\n     *\n     * <p>Only runs of two or more hextets are considered. In case of a tie, the leftmost run wins. If\n     * a qualifying run is found, its hextets are replaced by the sentinel value -1.\n     *\n     * @param hextets {@code int[]} mutable array of eight 16-bit hextets\n     */\n    private static void compressLongestRunOfZeroes(int[] hextets)\n    {\n        int bestRunStart = -1;\n        int bestRunLength = -1;\n        int runStart = -1;\n        for (int i = 0; i < hextets.length + 1; i++)\n        {\n            if (i < hextets.length && hextets[i] == 0)\n            {\n                if (runStart < 0)\n                {\n                    runStart = i;\n                }\n            }\n            else if (runStart >= 0)\n            {\n                int runLength = i - runStart;\n                if (runLength > bestRunLength)\n                {\n                    bestRunStart = runStart;\n                    bestRunLength = runLength;\n                }\n                runStart = -1;\n            }\n        }\n        if (bestRunLength >= 2)\n        {\n            Arrays.fill(hextets, bestRunStart, bestRunStart + bestRunLength, -1);\n        }\n    }\n\n    /**\n     * Convert a list of hextets into a human-readable IPv6 address.\n     *\n     * <p>In order for \"::\" compression to work, the input should contain negative sentinel values in\n     * place of the elided zeroes.\n     *\n     * @param hextets {@code int[]} array of eight 16-bit hextets, or -1s\n     */\n    private static String hextetsToIPv6String(int[] hextets)\n    {\n        // While scanning the array, handle these state transitions:\n        //   start->num => \"num\"     start->gap => \"::\"\n        //   num->num   => \":num\"    num->gap   => \"::\"\n        //   gap->num   => \"num\"     gap->gap   => \"\"\n        StringBuilder buf = new StringBuilder(39);\n        boolean lastWasNumber = false;\n        for (int i = 0; i < hextets.length; i++)\n        {\n            boolean thisIsNumber = hextets[i] >= 0;\n            if (thisIsNumber)\n            {\n                if (lastWasNumber)\n                {\n                    buf.append(':');\n                }\n                buf.append(Integer.toHexString(hextets[i]));\n            }\n            else\n            {\n                if (i == 0 || lastWasNumber)\n                {\n                    buf.append(\"::\");\n                }\n            }\n            lastWasNumber = thisIsNumber;\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Returns the string representation of an {@link InetAddress} suitable for inclusion in a URI.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses it compresses zeroes and surrounds the text with square brackets; for example {@code\n     * \"[2001:db8::1]\"}.\n     *\n     * <p>Per section 3.2.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3986#section-3.2.2\">RFC 3986</a>, a URI containing an IPv6\n     * string literal is of the form {@code \"http://[2001:db8::1]:8888/index.html\"}.\n     *\n     * <p>Use of either {@link InetAddresses#toAddrString}, {@link InetAddress#getHostAddress()}, or\n     * this method is recommended over {@link InetAddress#toString()} when an IP address string\n     * literal is desired. This is because {@link InetAddress#toString()} prints the hostname and the\n     * IP address string joined by a \"/\".\n     *\n     * @param ip {@link InetAddress} to be converted to URI string literal\n     * @return {@code String} containing URI-safe string literal\n     */\n    public static String toUriString(InetAddress ip)\n    {\n        if (ip instanceof Inet6Address)\n        {\n            return \"[\" + toAddrString(ip) + \"]\";\n        }\n        return toAddrString(ip);\n    }\n\n    /**\n     * Returns an InetAddress representing the literal IPv4 or IPv6 host portion of a URL, encoded in\n     * the format specified by RFC 3986 section 3.2.2.\n     *\n     * <p>This function is similar to {@link InetAddresses#forString(String)}, however, it requires\n     * that IPv6 addresses are surrounded by square brackets.\n     *\n     * <p>This function is the inverse of {@link InetAddresses#toUriString(java.net.InetAddress)}.\n     *\n     * @param hostAddr A RFC 3986 section 3.2.2 encoded IPv4 or IPv6 address\n     * @return an InetAddress representing the address in {@code hostAddr}\n     * @throws IllegalArgumentException if {@code hostAddr} is not a valid IPv4 address, or IPv6\n     *     address surrounded by square brackets\n     */\n    public static InetAddress forUriString(String hostAddr)\n    {\n        InetAddress addr = forUriStringNoThrow(hostAddr);\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"Not a valid URI IP literal: '%s'\", hostAddr);\n        }\n\n        return addr;\n    }\n\n    @NullableDecl\n    private static InetAddress forUriStringNoThrow(String hostAddr)\n    {\n        checkNotNull(hostAddr);\n\n        // Decide if this should be an IPv6 or IPv4 address.\n        String ipString;\n        int expectBytes;\n        if (hostAddr.startsWith(\"[\") && hostAddr.endsWith(\"]\"))\n        {\n            ipString = hostAddr.substring(1, hostAddr.length() - 1);\n            expectBytes = 16;\n        }\n        else\n        {\n            ipString = hostAddr;\n            expectBytes = 4;\n        }\n\n        // Parse the address, and make sure the length/version is correct.\n        byte[] addr = ipStringToBytes(ipString);\n        if (addr == null || addr.length != expectBytes)\n        {\n            return null;\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid URI IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP URI host string literal\n     * @return {@code true} if the argument is a valid IP URI host\n     */\n    public static boolean isUriInetAddress(String ipString)\n    {\n        return forUriStringNoThrow(ipString) != null;\n    }\n\n    /**\n     * Evaluates whether the argument is an IPv6 \"compat\" address.\n     *\n     * <p>An \"IPv4 compatible\", or \"compat\", address is one with 96 leading bits of zero, with the\n     * remaining 32 bits interpreted as an IPv4 address. These are conventionally represented in\n     * string literals as {@code \"::192.168.0.1\"}, though {@code \"::c0a8:1\"} is also considered an\n     * IPv4 compatible address (and equivalent to {@code \"::192.168.0.1\"}).\n     *\n     * <p>For more on IPv4 compatible addresses see section 2.5.5.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.1\">RFC 4291</a>.\n     *\n     * <p>NOTE: This method is different from {@link Inet6Address#isIPv4CompatibleAddress} in that it\n     * more correctly classifies {@code \"::\"} and {@code \"::1\"} as proper IPv6 addresses (which they\n     * are), NOT IPv4 compatible addresses (which they are generally NOT considered to be).\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 compatible address format\n     * @return {@code true} if the argument is a valid \"compat\" address\n     */\n    public static boolean isCompatIPv4Address(Inet6Address ip)\n    {\n        if (!ip.isIPv4CompatibleAddress())\n        {\n            return false;\n        }\n\n        byte[] bytes = ip.getAddress();\n        if ((bytes[12] == 0)\n                && (bytes[13] == 0)\n                && (bytes[14] == 0)\n                && ((bytes[15] == 0) || (bytes[15] == 1)))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the IPv4 address embedded in an IPv4 compatible address.\n     *\n     * @param ip {@link Inet6Address} to be examined for an embedded IPv4 address\n     * @return {@link Inet4Address} of the embedded IPv4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv4 compatible address\n     */\n\n    /**\n     * Evaluates whether the argument is a 6to4 address.\n     *\n     * <p>6to4 addresses begin with the {@code \"2002::/16\"} prefix. The next 32 bits are the IPv4\n     * address of the host to which IPv6-in-IPv4 tunneled packets should be routed.\n     *\n     * <p>For more on 6to4 addresses see section 2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3056#section-2\">RFC 3056</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for 6to4 address format\n     * @return {@code true} if the argument is a 6to4 address\n     */\n    public static boolean is6to4Address(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20) && (bytes[1] == (byte) 0x02);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in a 6to4 address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in 6to4 address\n     * @return {@link Inet4Address} of embedded IPv4 in 6to4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 6to4 address\n     */\n    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n    {\n        checkArgument(is6to4Address(ip), \"Address '%s' is not a 6to4 address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 2, 6));\n    }\n\n    /**\n     * A simple immutable data class to encapsulate the information to be found in a Teredo address.\n     *\n     * <p>All of the fields in this class are encoded in various portions of the IPv6 address as part\n     * of the protocol. More protocols details can be found at: <a target=\"_parent\"\n     * href=\"http://en.wikipedia.org/wiki/Teredo_tunneling\">http://en.wikipedia.\n     * org/wiki/Teredo_tunneling</a>.\n     *\n     * <p>The RFC can be found here: <a target=\"_parent\" href=\"http://tools.ietf.org/html/rfc4380\">RFC\n     * 4380</a>.\n     *\n     * @since 5.0\n     */\n    @Beta\n    public static final class TeredoInfo\n    {\n        private final Inet4Address server;\n        private final Inet4Address client;\n        private final int port;\n        private final int flags;\n\n        /**\n         * Constructs a TeredoInfo instance.\n         *\n         * <p>Both server and client can be {@code null}, in which case the value {@code \"0.0.0.0\"} will\n         * be assumed.\n         *\n         * @throws IllegalArgumentException if either of the {@code port} or the {@code flags} arguments\n         *     are out of range of an unsigned short\n         */\n        // TODO: why is this public?\n        public TeredoInfo(\n            @NullableDecl Inet4Address server, @NullableDecl Inet4Address client, int port, int flags)\n        {\n            checkArgument(\n                (port >= 0) && (port <= 0xffff), \"port '%s' is out of range (0 <= port <= 0xffff)\", port);\n            checkArgument(\n                (flags >= 0) && (flags <= 0xffff),\n                \"flags '%s' is out of range (0 <= flags <= 0xffff)\",\n                flags);\n\n            this.server = MoreObjects.firstNonNull(server, ANY4);\n            this.client = MoreObjects.firstNonNull(client, ANY4);\n            this.port = port;\n            this.flags = flags;\n        }\n\n        public Inet4Address getServer()\n        {\n            return server;\n        }\n\n        public Inet4Address getClient()\n        {\n            return client;\n        }\n\n        public int getPort()\n        {\n            return port;\n        }\n\n        public int getFlags()\n        {\n            return flags;\n        }\n    }\n\n    /**\n     * Evaluates whether the argument is a Teredo address.\n     *\n     * <p>Teredo addresses begin with the {@code \"2001::/32\"} prefix.\n     *\n     * @param ip {@link Inet6Address} to be examined for Teredo address format\n     * @return {@code true} if the argument is a Teredo address\n     */\n    public static boolean isTeredoAddress(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20)\n               && (bytes[1] == (byte) 0x01)\n               && (bytes[2] == 0)\n               && (bytes[3] == 0);\n    }\n\n    /**\n     * Returns the Teredo information embedded in a Teredo address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded Teredo information\n     * @return extracted {@code TeredoInfo}\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 Teredo address\n     */\n    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n    {\n        checkArgument(isTeredoAddress(ip), \"Address '%s' is not a Teredo address.\", toAddrString(ip));\n\n        byte[] bytes = ip.getAddress();\n        Inet4Address server = getInet4Address(Arrays.copyOfRange(bytes, 4, 8));\n\n        int flags = ByteStreams.newDataInput(bytes, 8).readShort() & 0xffff;\n\n        // Teredo obfuscates the mapped client port, per section 4 of the RFC.\n        int port = ~ByteStreams.newDataInput(bytes, 10).readShort() & 0xffff;\n\n        byte[] clientBytes = Arrays.copyOfRange(bytes, 12, 16);\n        for (int i = 0; i < clientBytes.length; i++)\n        {\n            // Teredo obfuscates the mapped client IP, per section 4 of the RFC.\n            clientBytes[i] = (byte) ~clientBytes[i];\n        }\n        Inet4Address client = getInet4Address(clientBytes);\n\n        return new TeredoInfo(server, client, port, flags);\n    }\n\n    /**\n     * Evaluates whether the argument is an ISATAP address.\n     *\n     * <p>From RFC 5214: \"ISATAP interface identifiers are constructed in Modified EUI-64 format [...]\n     * by concatenating the 24-bit IANA OUI (00-00-5E), the 8-bit hexadecimal value 0xFE, and a 32-bit\n     * IPv4 address in network byte order [...]\"\n     *\n     * <p>For more on ISATAP addresses see section 6.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc5214#section-6.1\">RFC 5214</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for ISATAP address format\n     * @return {@code true} if the argument is an ISATAP address\n     */\n    public static boolean isIsatapAddress(Inet6Address ip)\n    {\n\n        // If it's a Teredo address with the right port (41217, or 0xa101)\n        // which would be encoded as 0x5efe then it can't be an ISATAP address.\n        if (isTeredoAddress(ip))\n        {\n            return false;\n        }\n\n        byte[] bytes = ip.getAddress();\n\n        if ((bytes[8] | (byte) 0x03) != (byte) 0x03)\n        {\n\n            // Verify that high byte of the 64 bit identifier is zero, modulo\n            // the U/L and G bits, with which we are not concerned.\n            return false;\n        }\n\n        return (bytes[9] == (byte) 0x00) && (bytes[10] == (byte) 0x5e) && (bytes[11] == (byte) 0xfe);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in an ISATAP address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in ISATAP address\n     * @return {@link Inet4Address} of embedded IPv4 in an ISATAP address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 ISATAP address\n     */\n    public static Inet4Address getIsatapIPv4Address(Inet6Address ip)\n    {\n        checkArgument(isIsatapAddress(ip), \"Address '%s' is not an ISATAP address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n    }\n\n    /**\n     * Examines the Inet6Address to determine if it is an IPv6 address of one of the specified address\n     * types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@code true} if there is an embedded IPv4 client address\n     * @since 7.0\n     */\n    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        return isCompatIPv4Address(ip) || is6to4Address(ip) || isTeredoAddress(ip);\n    }\n\n    /**\n     * Examines the Inet6Address to extract the embedded IPv4 client address if the InetAddress is an\n     * IPv6 address of one of the specified address types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@link Inet4Address} of embedded IPv4 client address\n     * @throws IllegalArgumentException if the argument does not have a valid embedded IPv4 address\n     */\n    public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        if (isCompatIPv4Address(ip))\n        {\n            return getCompatIPv4Address(ip);\n        }\n\n        if (is6to4Address(ip))\n        {\n            return get6to4IPv4Address(ip);\n        }\n\n        if (isTeredoAddress(ip))\n        {\n            return getTeredoInfo(ip).getClient();\n        }\n\n        throw formatIllegalArgumentException(\"'%s' has no embedded IPv4 address.\", toAddrString(ip));\n    }\n\n    /**\n     * Evaluates whether the argument is an \"IPv4 mapped\" IPv6 address.\n     *\n     * <p>An \"IPv4 mapped\" address is anything in the range ::ffff:0:0/96 (sometimes written as\n     * ::ffff:0.0.0.0/96), with the last 32 bits interpreted as an IPv4 address.\n     *\n     * <p>For more on IPv4 mapped addresses see section 2.5.5.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.2\">RFC 4291</a>.\n     *\n     * <p>Note: This method takes a {@code String} argument because {@link InetAddress} automatically\n     * collapses mapped addresses to IPv4. (It is actually possible to avoid this using one of the\n     * obscure {@link Inet6Address} methods, but it would be unwise to depend on such a\n     * poorly-documented feature.)\n     *\n     * @param ipString {@code String} to be examined for embedded IPv4-mapped IPv6 address format\n     * @return {@code true} if the argument is a valid \"mapped\" address\n     * @since 10.0\n     */\n    public static boolean isMappedIPv4Address(String ipString)\n    {\n        byte[] bytes = ipStringToBytes(ipString);\n        if (bytes != null && bytes.length == 16)\n        {\n            for (int i = 0; i < 10; i++)\n            {\n                if (bytes[i] != 0)\n                {\n                    return false;\n                }\n            }\n            for (int i = 10; i < 12; i++)\n            {\n                if (bytes[i] != (byte) 0xff)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Coerces an IPv6 address into an IPv4 address.\n     *\n     * <p>HACK: As long as applications continue to use IPv4 addresses for indexing into tables,\n     * accounting, et cetera, it may be necessary to <b>coerce</b> IPv6 addresses into IPv4 addresses.\n     * This function does so by hashing the upper 64 bits into {@code 224.0.0.0/3} (64 bits into 29\n     * bits).\n     *\n     * <p>A \"coerced\" IPv4 address is equivalent to itself.\n     *\n     * <p>NOTE: This function is failsafe for security purposes: ALL IPv6 addresses (except localhost\n     * (::1)) are hashed to avoid the security risk associated with extracting an embedded IPv4\n     * address that might permit elevated privileges.\n     *\n     * @param ip {@link InetAddress} to \"coerce\"\n     * @return {@link Inet4Address} represented \"coerced\" address\n     * @since 7.0\n     */\n    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n    {\n        if (ip instanceof Inet4Address)\n        {\n            return (Inet4Address) ip;\n        }\n\n        // Special cases:\n        byte[] bytes = ip.getAddress();\n        boolean leadingBytesOfZero = true;\n        for (int i = 0; i < 15; ++i)\n        {\n            if (bytes[i] != 0)\n            {\n                leadingBytesOfZero = false;\n                break;\n            }\n        }\n        if (leadingBytesOfZero && (bytes[15] == 1))\n        {\n            return LOOPBACK4; // ::1\n        }\n        else if (leadingBytesOfZero && (bytes[15] == 0))\n        {\n            return ANY4; // ::0\n        }\n\n        Inet6Address ip6 = (Inet6Address) ip;\n        long addressAsLong = 0;\n        if (hasEmbeddedIPv4ClientAddress(ip6))\n        {\n            addressAsLong = getEmbeddedIPv4ClientAddress(ip6).hashCode();\n        }\n        else\n        {\n\n            // Just extract the high 64 bits (assuming the rest is user-modifiable).\n            addressAsLong = ByteBuffer.wrap(ip6.getAddress(), 0, 8).getLong();\n        }\n\n        // Many strategies for hashing are possible. This might suffice for now.\n        int coercedHash = Hashing.murmur3_32().hashLong(addressAsLong).asInt();\n\n        // Squash into 224/4 Multicast and 240/4 Reserved space (i.e. 224/3).\n        coercedHash |= 0xe0000000;\n\n        // Fixup to avoid some \"illegal\" values. Currently the only potential\n        // illegal value is 255.255.255.255.\n        if (coercedHash == 0xffffffff)\n        {\n            coercedHash = 0xfffffffe;\n        }\n\n        return getInet4Address(Ints.toByteArray(coercedHash));\n    }\n\n    /**\n     * Returns an integer representing an IPv4 address regardless of whether the supplied argument is\n     * an IPv4 address or not.\n     *\n     * <p>IPv6 addresses are <b>coerced</b> to IPv4 addresses before being converted to integers.\n     *\n     * <p>As long as there are applications that assume that all IP addresses are IPv4 addresses and\n     * can therefore be converted safely to integers (for whatever purpose) this function can be used\n     * to handle IPv6 addresses as well until the application is suitably fixed.\n     *\n     * <p>NOTE: an IPv6 address coerced to an IPv4 address can only be used for such purposes as\n     * rudimentary identification or indexing into a collection of real {@link InetAddress}es. They\n     * cannot be used as real addresses for the purposes of network communication.\n     *\n     * @param ip {@link InetAddress} to convert\n     * @return {@code int}, \"coerced\" if ip is not an IPv4 address\n     * @since 7.0\n     */\n    public static int coerceToInteger(InetAddress ip)\n    {\n        return ByteStreams.newDataInput(getCoercedIPv4Address(ip).getAddress()).readInt();\n    }\n\n    /**\n     * Returns an Inet4Address having the integer value specified by the argument.\n     *\n     * @param address {@code int}, the 32bit integer address to be converted\n     * @return {@link Inet4Address} equivalent of the argument\n     */\n    public static Inet4Address fromInteger(int address)\n    {\n        return getInet4Address(Ints.toByteArray(address));\n    }\n\n    /**\n     * Returns an address from a <b>little-endian ordered</b> byte array (the opposite of what {@link\n     * InetAddress#getByAddress} expects).\n     *\n     * <p>IPv4 address byte array must be 4 bytes long and IPv6 byte array must be 16 bytes long.\n     *\n     * @param addr the raw IP address in little-endian byte order\n     * @return an InetAddress object created from the raw IP address\n     * @throws UnknownHostException if IP address is of illegal length\n     */\n    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n    {\n        byte[] reversed = new byte[addr.length];\n        for (int i = 0; i < addr.length; i++)\n        {\n            reversed[i] = addr[addr.length - i - 1];\n        }\n        return InetAddress.getByAddress(reversed);\n    }\n\n    /**\n     * Returns a new InetAddress that is one less than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to decrement\n     * @return a new InetAddress that is one less than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the beginning of its range\n     * @since 18.0\n     */\n    public static InetAddress decrement(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0x00)\n        {\n            addr[i] = (byte) 0xff;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Decrementing %s would wrap.\", address);\n\n        addr[i]--;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns a new InetAddress that is one more than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to increment\n     * @return a new InetAddress that is one more than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the end of its range\n     * @since 10.0\n     */\n    public static InetAddress increment(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0xff)\n        {\n            addr[i] = 0;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Incrementing %s would wrap.\", address);\n\n        addr[i]++;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns true if the InetAddress is either 255.255.255.255 for IPv4 or\n     * ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6.\n     *\n     * @return true if the InetAddress is either 255.255.255.255 for IPv4 or\n     *     ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6\n     * @since 10.0\n     */\n    public static boolean isMaximum(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        for (int i = 0; i < addr.length; i++)\n        {\n            if (addr[i] != (byte) 0xff)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static IllegalArgumentException formatIllegalArgumentException(\n        String format, Object... args)\n    {\n        return new IllegalArgumentException(String.format(Locale.ROOT, format, args));\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.isTeredoAddress", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Evaluates whether the argument is a Teredo address.\n\n<p>Teredo addresses begin with the {@code \"2001::/32\"} prefix.\n\n@param ip {@link Inet6Address} to be examined for Teredo address format\n@return {@code true} if the argument is a Teredo address", "docstring_tokens": ["Evaluates", "whether", "the", "argument", "is", "a", "Teredo", "address", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L651-L657", "partition": "valid", "up_fun_num": 23, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.MoreObjects;", "import com.google.common.base.Splitter;", "import com.google.common.collect.Iterables;", "import com.google.common.hash.Hashing;", "import com.google.common.io.ByteStreams;", "import com.google.common.primitives.Ints;", "import java.net.Inet4Address;", "import java.net.Inet6Address;", "import java.net.InetAddress;", "import java.net.UnknownHostException;", "import java.nio.ByteBuffer;", "import java.util.Arrays;", "import java.util.List;", "import java.util.Locale;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class InetAddresses\n", "    private static Inet4Address getInet4Address(byte[] bytes)\n", "    public static InetAddress forString(String ipString)\n", "    public static boolean isInetAddress(String ipString)\n", "    private static byte[] ipStringToBytes(String ipString)\n", "    private static byte[] textToNumericFormatV4(String ipString)\n", "    private static byte[] textToNumericFormatV6(String ipString)\n", "    private static String convertDottedQuadToHex(String ipString)\n", "    private static byte parseOctet(String ipPart)\n", "    private static short parseHextet(String ipPart)\n", "    private static InetAddress bytesToInetAddress(byte[] addr)\n", "    public static String toAddrString(InetAddress ip)\n", "    private static void compressLongestRunOfZeroes(int[] hextets)\n", "    private static String hextetsToIPv6String(int[] hextets)\n", "    public static String toUriString(InetAddress ip)\n", "    public static InetAddress forUriString(String hostAddr)\n", "    private static InetAddress forUriStringNoThrow(String hostAddr)\n", "    public static boolean isUriInetAddress(String ipString)\n", "    public static boolean isCompatIPv4Address(Inet6Address ip)\n", "    public static Inet4Address getCompatIPv4Address(Inet6Address ip)\n", "    public static boolean is6to4Address(Inet6Address ip)\n", "    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n", "    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n", "    public static boolean isIsatapAddress(Inet6Address ip)\n", "    public static Inet4Address getIsatapIPv4Address(Inet6Address ip)\n", "    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static boolean isMappedIPv4Address(String ipString)\n", "    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n", "    public static int coerceToInteger(InetAddress ip)\n", "    public static Inet4Address fromInteger(int address)\n", "    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n", "    public static InetAddress decrement(InetAddress address)\n", "    public static InetAddress increment(InetAddress address)\n", "    public static boolean isMaximum(InetAddress address)\n", "    private static IllegalArgumentException formatIllegalArgumentException(\n"], "context": "/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.net;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.Iterables;\nimport com.google.common.hash.Hashing;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.primitives.Ints;\nimport java.net.Inet4Address;\nimport java.net.Inet6Address;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * Static utility methods pertaining to {@link InetAddress} instances.\n *\n * <p><b>Important note:</b> Unlike {@code InetAddress.getByName()}, the methods of this class never\n * cause DNS services to be accessed. For this reason, you should prefer these methods as much as\n * possible over their JDK equivalents whenever you are expecting to handle only IP address string\n * literals -- there is no blocking DNS penalty for a malformed string.\n *\n * <p>When dealing with {@link Inet4Address} and {@link Inet6Address} objects as byte arrays (vis.\n * {@code InetAddress.getAddress()}) they are 4 and 16 bytes in length, respectively, and represent\n * the address in network byte order.\n *\n * <p>Examples of IP addresses and their byte representations:\n *\n * <dl>\n *   <dt>The IPv4 loopback address, {@code \"127.0.0.1\"}.\n *   <dd>{@code 7f 00 00 01}\n *   <dt>The IPv6 loopback address, {@code \"::1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>From the IPv6 reserved documentation prefix ({@code 2001:db8::/32}), {@code \"2001:db8::1\"}.\n *   <dd>{@code 20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>An IPv6 \"IPv4 compatible\" (or \"compat\") address, {@code \"::192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 c0 a8 00 01}\n *   <dt>An IPv6 \"IPv4 mapped\" address, {@code \"::ffff:192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 ff ff c0 a8 00 01}\n * </dl>\n *\n * <p>A few notes about IPv6 \"IPv4 mapped\" addresses and their observed use in Java.\n *\n * <p>\"IPv4 mapped\" addresses were originally a representation of IPv4 addresses for use on an IPv6\n * socket that could receive both IPv4 and IPv6 connections (by disabling the {@code IPV6_V6ONLY}\n * socket option on an IPv6 socket). Yes, it's confusing. Nevertheless, these \"mapped\" addresses\n * were never supposed to be seen on the wire. That assumption was dropped, some say mistakenly, in\n * later RFCs with the apparent aim of making IPv4-to-IPv6 transition simpler.\n *\n * <p>Technically one <i>can</i> create a 128bit IPv6 address with the wire format of a \"mapped\"\n * address, as shown above, and transmit it in an IPv6 packet header. However, Java's InetAddress\n * creation methods appear to adhere doggedly to the original intent of the \"mapped\" address: all\n * \"mapped\" addresses return {@link Inet4Address} objects.\n *\n * <p>For added safety, it is common for IPv6 network operators to filter all packets where either\n * the source or destination address appears to be a \"compat\" or \"mapped\" address. Filtering\n * suggestions usually recommend discarding any packets with source or destination addresses in the\n * invalid range {@code ::/3}, which includes both of these bizarre address formats. For more\n * information on \"bogons\", including lists of IPv6 bogon space, see:\n *\n * <ul>\n *   <li><a target=\"_parent\"\n *       href=\"http://en.wikipedia.org/wiki/Bogon_filtering\">http://en.wikipedia.\n *       org/wiki/Bogon_filtering</a>\n *   <li><a target=\"_parent\"\n *       href=\"http://www.cymru.com/Bogons/ipv6.txt\">http://www.cymru.com/Bogons/ ipv6.txt</a>\n *   <li><a target=\"_parent\" href=\"http://www.cymru.com/Bogons/v6bogon.html\">http://www.cymru.com/\n *       Bogons/v6bogon.html</a>\n *   <li><a target=\"_parent\" href=\"http://www.space.net/~gert/RIPE/ipv6-filters.html\">http://www.\n *       space.net/~gert/RIPE/ipv6-filters.html</a>\n * </ul>\n *\n * @author Erik Kline\n * @since 5.0\n */\n@Beta\n@GwtIncompatible\npublic final class InetAddresses\n{\n    private static final int IPV4_PART_COUNT = 4;\n    private static final int IPV6_PART_COUNT = 8;\n    private static final Splitter IPV4_SPLITTER = Splitter.on('.').limit(IPV4_PART_COUNT);\n    private static final Splitter IPV6_SPLITTER = Splitter.on(':').limit(IPV6_PART_COUNT + 2);\n    private static final Inet4Address LOOPBACK4 = (Inet4Address) forString(\"127.0.0.1\");\n    private static final Inet4Address ANY4 = (Inet4Address) forString(\"0.0.0.0\");\n\n    private InetAddresses() {}\n\n    /**\n     * Returns an {@link Inet4Address}, given a byte array representation of the IPv4 address.\n     *\n     * @param bytes byte array representing an IPv4 address (should be of length 4)\n     * @return {@link Inet4Address} corresponding to the supplied byte array\n     * @throws IllegalArgumentException if a valid {@link Inet4Address} can not be created\n     */\n    private static Inet4Address getInet4Address(byte[] bytes)\n    {\n        checkArgument(\n            bytes.length == 4,\n            \"Byte array has invalid length for an IPv4 address: %s != 4.\",\n            bytes.length);\n\n        // Given a 4-byte array, this cast should always succeed.\n        return (Inet4Address) bytesToInetAddress(bytes);\n    }\n\n    /**\n     * Returns the {@link InetAddress} having the given string representation.\n     *\n     * <p>This deliberately avoids all nameservice lookups (e.g. no DNS).\n     *\n     * @param ipString {@code String} containing an IPv4 or IPv6 string literal, e.g. {@code\n     *     \"192.168.0.1\"} or {@code \"2001:db8::1\"}\n     * @return {@link InetAddress} representing the argument\n     * @throws IllegalArgumentException if the argument is not a valid IP string literal\n     */\n    public static InetAddress forString(String ipString)\n    {\n        byte[] addr = ipStringToBytes(ipString);\n\n        // The argument was malformed, i.e. not an IP string literal.\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"'%s' is not an IP string literal.\", ipString);\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP string literal\n     * @return {@code true} if the argument is a valid IP string literal\n     */\n    public static boolean isInetAddress(String ipString)\n    {\n        return ipStringToBytes(ipString) != null;\n    }\n\n    @NullableDecl\n    private static byte[] ipStringToBytes(String ipString)\n    {\n        // Make a first pass to categorize the characters in this string.\n        boolean hasColon = false;\n        boolean hasDot = false;\n        for (int i = 0; i < ipString.length(); i++)\n        {\n            char c = ipString.charAt(i);\n            if (c == '.')\n            {\n                hasDot = true;\n            }\n            else if (c == ':')\n            {\n                if (hasDot)\n                {\n                    return null; // Colons must not appear after dots.\n                }\n                hasColon = true;\n            }\n            else if (Character.digit(c, 16) == -1)\n            {\n                return null; // Everything else must be a decimal or hex digit.\n            }\n        }\n\n        // Now decide which address family to parse.\n        if (hasColon)\n        {\n            if (hasDot)\n            {\n                ipString = convertDottedQuadToHex(ipString);\n                if (ipString == null)\n                {\n                    return null;\n                }\n            }\n            return textToNumericFormatV6(ipString);\n        }\n        else if (hasDot)\n        {\n            return textToNumericFormatV4(ipString);\n        }\n        return null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV4(String ipString)\n    {\n        byte[] bytes = new byte[IPV4_PART_COUNT];\n        int i = 0;\n        try\n        {\n            for (String octet : IPV4_SPLITTER.split(ipString))\n            {\n                bytes[i++] = parseOctet(octet);\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n\n        return i == IPV4_PART_COUNT ? bytes : null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV6(String ipString)\n    {\n        // An address can have [2..8] colons, and N colons make N+1 parts.\n        List<String> parts = IPV6_SPLITTER.splitToList(ipString);\n        if (parts.size() < 3 || parts.size() > IPV6_PART_COUNT + 1)\n        {\n            return null;\n        }\n\n        // Disregarding the endpoints, find \"::\" with nothing in between.\n        // This indicates that a run of zeroes has been skipped.\n        int skipIndex = -1;\n        for (int i = 1; i < parts.size() - 1; i++)\n        {\n            if (parts.get(i).length() == 0)\n            {\n                if (skipIndex >= 0)\n                {\n                    return null; // Can't have more than one ::\n                }\n                skipIndex = i;\n            }\n        }\n\n        int partsHi; // Number of parts to copy from above/before the \"::\"\n        int partsLo; // Number of parts to copy from below/after the \"::\"\n        if (skipIndex >= 0)\n        {\n            // If we found a \"::\", then check if it also covers the endpoints.\n            partsHi = skipIndex;\n            partsLo = parts.size() - skipIndex - 1;\n            if (parts.get(0).length() == 0 && --partsHi != 0)\n            {\n                return null; // ^: requires ^::\n            }\n            if (Iterables.getLast(parts).length() == 0 && --partsLo != 0)\n            {\n                return null; // :$ requires ::$\n            }\n        }\n        else\n        {\n            // Otherwise, allocate the entire address to partsHi. The endpoints\n            // could still be empty, but parseHextet() will check for that.\n            partsHi = parts.size();\n            partsLo = 0;\n        }\n\n        // If we found a ::, then we must have skipped at least one part.\n        // Otherwise, we must have exactly the right number of parts.\n        int partsSkipped = IPV6_PART_COUNT - (partsHi + partsLo);\n        if (!(skipIndex >= 0 ? partsSkipped >= 1 : partsSkipped == 0))\n        {\n            return null;\n        }\n\n        // Now parse the hextets into a byte array.\n        ByteBuffer rawBytes = ByteBuffer.allocate(2 * IPV6_PART_COUNT);\n        try\n        {\n            for (int i = 0; i < partsHi; i++)\n            {\n                rawBytes.putShort(parseHextet(parts.get(i)));\n            }\n            for (int i = 0; i < partsSkipped; i++)\n            {\n                rawBytes.putShort((short) 0);\n            }\n            for (int i = partsLo; i > 0; i--)\n            {\n                rawBytes.putShort(parseHextet(parts.get(parts.size() - i)));\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n        return rawBytes.array();\n    }\n\n    @NullableDecl\n    private static String convertDottedQuadToHex(String ipString)\n    {\n        int lastColon = ipString.lastIndexOf(':');\n        String initialPart = ipString.substring(0, lastColon + 1);\n        String dottedQuad = ipString.substring(lastColon + 1);\n        byte[] quad = textToNumericFormatV4(dottedQuad);\n        if (quad == null)\n        {\n            return null;\n        }\n        String penultimate = Integer.toHexString(((quad[0] & 0xff) << 8) | (quad[1] & 0xff));\n        String ultimate = Integer.toHexString(((quad[2] & 0xff) << 8) | (quad[3] & 0xff));\n        return initialPart + penultimate + \":\" + ultimate;\n    }\n\n    private static byte parseOctet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int octet = Integer.parseInt(ipPart);\n        // Disallow leading zeroes, because no clear standard exists on\n        // whether these should be interpreted as decimal or octal.\n        if (octet > 255 || (ipPart.startsWith(\"0\") && ipPart.length() > 1))\n        {\n            throw new NumberFormatException();\n        }\n        return (byte) octet;\n    }\n\n    private static short parseHextet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int hextet = Integer.parseInt(ipPart, 16);\n        if (hextet > 0xffff)\n        {\n            throw new NumberFormatException();\n        }\n        return (short) hextet;\n    }\n\n    /**\n     * Convert a byte array into an InetAddress.\n     *\n     * <p>{@link InetAddress#getByAddress} is documented as throwing a checked exception \"if IP\n     * address is of illegal length.\" We replace it with an unchecked exception, for use by callers\n     * who already know that addr is an array of length 4 or 16.\n     *\n     * @param addr the raw 4-byte or 16-byte IP address in big-endian order\n     * @return an InetAddress object created from the raw IP address\n     */\n    private static InetAddress bytesToInetAddress(byte[] addr)\n    {\n        try\n        {\n            return InetAddress.getByAddress(addr);\n        }\n        catch (UnknownHostException e)\n        {\n            throw new AssertionError(e);\n        }\n    }\n\n    /**\n     * Returns the string representation of an {@link InetAddress}.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses, the output follows <a href=\"http://tools.ietf.org/html/rfc5952\">RFC 5952</a> section\n     * 4. The main difference is that this method uses \"::\" for zero compression, while Java's version\n     * uses the uncompressed form.\n     *\n     * <p>This method uses hexadecimal for all IPv6 addresses, including IPv4-mapped IPv6 addresses\n     * such as \"::c000:201\". The output does not include a Scope ID.\n     *\n     * @param ip {@link InetAddress} to be converted to an address string\n     * @return {@code String} containing the text-formatted IP address\n     * @since 10.0\n     */\n    public static String toAddrString(InetAddress ip)\n    {\n        checkNotNull(ip);\n        if (ip instanceof Inet4Address)\n        {\n            // For IPv4, Java's formatting is good enough.\n            return ip.getHostAddress();\n        }\n        checkArgument(ip instanceof Inet6Address);\n        byte[] bytes = ip.getAddress();\n        int[] hextets = new int[IPV6_PART_COUNT];\n        for (int i = 0; i < hextets.length; i++)\n        {\n            hextets[i] = Ints.fromBytes((byte) 0, (byte) 0, bytes[2 * i], bytes[2 * i + 1]);\n        }\n        compressLongestRunOfZeroes(hextets);\n        return hextetsToIPv6String(hextets);\n    }\n\n    /**\n     * Identify and mark the longest run of zeroes in an IPv6 address.\n     *\n     * <p>Only runs of two or more hextets are considered. In case of a tie, the leftmost run wins. If\n     * a qualifying run is found, its hextets are replaced by the sentinel value -1.\n     *\n     * @param hextets {@code int[]} mutable array of eight 16-bit hextets\n     */\n    private static void compressLongestRunOfZeroes(int[] hextets)\n    {\n        int bestRunStart = -1;\n        int bestRunLength = -1;\n        int runStart = -1;\n        for (int i = 0; i < hextets.length + 1; i++)\n        {\n            if (i < hextets.length && hextets[i] == 0)\n            {\n                if (runStart < 0)\n                {\n                    runStart = i;\n                }\n            }\n            else if (runStart >= 0)\n            {\n                int runLength = i - runStart;\n                if (runLength > bestRunLength)\n                {\n                    bestRunStart = runStart;\n                    bestRunLength = runLength;\n                }\n                runStart = -1;\n            }\n        }\n        if (bestRunLength >= 2)\n        {\n            Arrays.fill(hextets, bestRunStart, bestRunStart + bestRunLength, -1);\n        }\n    }\n\n    /**\n     * Convert a list of hextets into a human-readable IPv6 address.\n     *\n     * <p>In order for \"::\" compression to work, the input should contain negative sentinel values in\n     * place of the elided zeroes.\n     *\n     * @param hextets {@code int[]} array of eight 16-bit hextets, or -1s\n     */\n    private static String hextetsToIPv6String(int[] hextets)\n    {\n        // While scanning the array, handle these state transitions:\n        //   start->num => \"num\"     start->gap => \"::\"\n        //   num->num   => \":num\"    num->gap   => \"::\"\n        //   gap->num   => \"num\"     gap->gap   => \"\"\n        StringBuilder buf = new StringBuilder(39);\n        boolean lastWasNumber = false;\n        for (int i = 0; i < hextets.length; i++)\n        {\n            boolean thisIsNumber = hextets[i] >= 0;\n            if (thisIsNumber)\n            {\n                if (lastWasNumber)\n                {\n                    buf.append(':');\n                }\n                buf.append(Integer.toHexString(hextets[i]));\n            }\n            else\n            {\n                if (i == 0 || lastWasNumber)\n                {\n                    buf.append(\"::\");\n                }\n            }\n            lastWasNumber = thisIsNumber;\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Returns the string representation of an {@link InetAddress} suitable for inclusion in a URI.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses it compresses zeroes and surrounds the text with square brackets; for example {@code\n     * \"[2001:db8::1]\"}.\n     *\n     * <p>Per section 3.2.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3986#section-3.2.2\">RFC 3986</a>, a URI containing an IPv6\n     * string literal is of the form {@code \"http://[2001:db8::1]:8888/index.html\"}.\n     *\n     * <p>Use of either {@link InetAddresses#toAddrString}, {@link InetAddress#getHostAddress()}, or\n     * this method is recommended over {@link InetAddress#toString()} when an IP address string\n     * literal is desired. This is because {@link InetAddress#toString()} prints the hostname and the\n     * IP address string joined by a \"/\".\n     *\n     * @param ip {@link InetAddress} to be converted to URI string literal\n     * @return {@code String} containing URI-safe string literal\n     */\n    public static String toUriString(InetAddress ip)\n    {\n        if (ip instanceof Inet6Address)\n        {\n            return \"[\" + toAddrString(ip) + \"]\";\n        }\n        return toAddrString(ip);\n    }\n\n    /**\n     * Returns an InetAddress representing the literal IPv4 or IPv6 host portion of a URL, encoded in\n     * the format specified by RFC 3986 section 3.2.2.\n     *\n     * <p>This function is similar to {@link InetAddresses#forString(String)}, however, it requires\n     * that IPv6 addresses are surrounded by square brackets.\n     *\n     * <p>This function is the inverse of {@link InetAddresses#toUriString(java.net.InetAddress)}.\n     *\n     * @param hostAddr A RFC 3986 section 3.2.2 encoded IPv4 or IPv6 address\n     * @return an InetAddress representing the address in {@code hostAddr}\n     * @throws IllegalArgumentException if {@code hostAddr} is not a valid IPv4 address, or IPv6\n     *     address surrounded by square brackets\n     */\n    public static InetAddress forUriString(String hostAddr)\n    {\n        InetAddress addr = forUriStringNoThrow(hostAddr);\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"Not a valid URI IP literal: '%s'\", hostAddr);\n        }\n\n        return addr;\n    }\n\n    @NullableDecl\n    private static InetAddress forUriStringNoThrow(String hostAddr)\n    {\n        checkNotNull(hostAddr);\n\n        // Decide if this should be an IPv6 or IPv4 address.\n        String ipString;\n        int expectBytes;\n        if (hostAddr.startsWith(\"[\") && hostAddr.endsWith(\"]\"))\n        {\n            ipString = hostAddr.substring(1, hostAddr.length() - 1);\n            expectBytes = 16;\n        }\n        else\n        {\n            ipString = hostAddr;\n            expectBytes = 4;\n        }\n\n        // Parse the address, and make sure the length/version is correct.\n        byte[] addr = ipStringToBytes(ipString);\n        if (addr == null || addr.length != expectBytes)\n        {\n            return null;\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid URI IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP URI host string literal\n     * @return {@code true} if the argument is a valid IP URI host\n     */\n    public static boolean isUriInetAddress(String ipString)\n    {\n        return forUriStringNoThrow(ipString) != null;\n    }\n\n    /**\n     * Evaluates whether the argument is an IPv6 \"compat\" address.\n     *\n     * <p>An \"IPv4 compatible\", or \"compat\", address is one with 96 leading bits of zero, with the\n     * remaining 32 bits interpreted as an IPv4 address. These are conventionally represented in\n     * string literals as {@code \"::192.168.0.1\"}, though {@code \"::c0a8:1\"} is also considered an\n     * IPv4 compatible address (and equivalent to {@code \"::192.168.0.1\"}).\n     *\n     * <p>For more on IPv4 compatible addresses see section 2.5.5.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.1\">RFC 4291</a>.\n     *\n     * <p>NOTE: This method is different from {@link Inet6Address#isIPv4CompatibleAddress} in that it\n     * more correctly classifies {@code \"::\"} and {@code \"::1\"} as proper IPv6 addresses (which they\n     * are), NOT IPv4 compatible addresses (which they are generally NOT considered to be).\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 compatible address format\n     * @return {@code true} if the argument is a valid \"compat\" address\n     */\n    public static boolean isCompatIPv4Address(Inet6Address ip)\n    {\n        if (!ip.isIPv4CompatibleAddress())\n        {\n            return false;\n        }\n\n        byte[] bytes = ip.getAddress();\n        if ((bytes[12] == 0)\n                && (bytes[13] == 0)\n                && (bytes[14] == 0)\n                && ((bytes[15] == 0) || (bytes[15] == 1)))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the IPv4 address embedded in an IPv4 compatible address.\n     *\n     * @param ip {@link Inet6Address} to be examined for an embedded IPv4 address\n     * @return {@link Inet4Address} of the embedded IPv4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv4 compatible address\n     */\n    public static Inet4Address getCompatIPv4Address(Inet6Address ip)\n    {\n        checkArgument(\n            isCompatIPv4Address(ip), \"Address '%s' is not IPv4-compatible.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n    }\n\n    /**\n     * Evaluates whether the argument is a 6to4 address.\n     *\n     * <p>6to4 addresses begin with the {@code \"2002::/16\"} prefix. The next 32 bits are the IPv4\n     * address of the host to which IPv6-in-IPv4 tunneled packets should be routed.\n     *\n     * <p>For more on 6to4 addresses see section 2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3056#section-2\">RFC 3056</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for 6to4 address format\n     * @return {@code true} if the argument is a 6to4 address\n     */\n    public static boolean is6to4Address(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20) && (bytes[1] == (byte) 0x02);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in a 6to4 address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in 6to4 address\n     * @return {@link Inet4Address} of embedded IPv4 in 6to4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 6to4 address\n     */\n    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n    {\n        checkArgument(is6to4Address(ip), \"Address '%s' is not a 6to4 address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 2, 6));\n    }\n\n    /**\n     * A simple immutable data class to encapsulate the information to be found in a Teredo address.\n     *\n     * <p>All of the fields in this class are encoded in various portions of the IPv6 address as part\n     * of the protocol. More protocols details can be found at: <a target=\"_parent\"\n     * href=\"http://en.wikipedia.org/wiki/Teredo_tunneling\">http://en.wikipedia.\n     * org/wiki/Teredo_tunneling</a>.\n     *\n     * <p>The RFC can be found here: <a target=\"_parent\" href=\"http://tools.ietf.org/html/rfc4380\">RFC\n     * 4380</a>.\n     *\n     * @since 5.0\n     */\n    @Beta\n    public static final class TeredoInfo\n    {\n        private final Inet4Address server;\n        private final Inet4Address client;\n        private final int port;\n        private final int flags;\n\n        /**\n         * Constructs a TeredoInfo instance.\n         *\n         * <p>Both server and client can be {@code null}, in which case the value {@code \"0.0.0.0\"} will\n         * be assumed.\n         *\n         * @throws IllegalArgumentException if either of the {@code port} or the {@code flags} arguments\n         *     are out of range of an unsigned short\n         */\n        // TODO: why is this public?\n        public TeredoInfo(\n            @NullableDecl Inet4Address server, @NullableDecl Inet4Address client, int port, int flags)\n        {\n            checkArgument(\n                (port >= 0) && (port <= 0xffff), \"port '%s' is out of range (0 <= port <= 0xffff)\", port);\n            checkArgument(\n                (flags >= 0) && (flags <= 0xffff),\n                \"flags '%s' is out of range (0 <= flags <= 0xffff)\",\n                flags);\n\n            this.server = MoreObjects.firstNonNull(server, ANY4);\n            this.client = MoreObjects.firstNonNull(client, ANY4);\n            this.port = port;\n            this.flags = flags;\n        }\n\n        public Inet4Address getServer()\n        {\n            return server;\n        }\n\n        public Inet4Address getClient()\n        {\n            return client;\n        }\n\n        public int getPort()\n        {\n            return port;\n        }\n\n        public int getFlags()\n        {\n            return flags;\n        }\n    }\n\n    /**\n     * Evaluates whether the argument is a Teredo address.\n     *\n     * <p>Teredo addresses begin with the {@code \"2001::/32\"} prefix.\n     *\n     * @param ip {@link Inet6Address} to be examined for Teredo address format\n     * @return {@code true} if the argument is a Teredo address\n     */\n\n    /**\n     * Returns the Teredo information embedded in a Teredo address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded Teredo information\n     * @return extracted {@code TeredoInfo}\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 Teredo address\n     */\n    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n    {\n        checkArgument(isTeredoAddress(ip), \"Address '%s' is not a Teredo address.\", toAddrString(ip));\n\n        byte[] bytes = ip.getAddress();\n        Inet4Address server = getInet4Address(Arrays.copyOfRange(bytes, 4, 8));\n\n        int flags = ByteStreams.newDataInput(bytes, 8).readShort() & 0xffff;\n\n        // Teredo obfuscates the mapped client port, per section 4 of the RFC.\n        int port = ~ByteStreams.newDataInput(bytes, 10).readShort() & 0xffff;\n\n        byte[] clientBytes = Arrays.copyOfRange(bytes, 12, 16);\n        for (int i = 0; i < clientBytes.length; i++)\n        {\n            // Teredo obfuscates the mapped client IP, per section 4 of the RFC.\n            clientBytes[i] = (byte) ~clientBytes[i];\n        }\n        Inet4Address client = getInet4Address(clientBytes);\n\n        return new TeredoInfo(server, client, port, flags);\n    }\n\n    /**\n     * Evaluates whether the argument is an ISATAP address.\n     *\n     * <p>From RFC 5214: \"ISATAP interface identifiers are constructed in Modified EUI-64 format [...]\n     * by concatenating the 24-bit IANA OUI (00-00-5E), the 8-bit hexadecimal value 0xFE, and a 32-bit\n     * IPv4 address in network byte order [...]\"\n     *\n     * <p>For more on ISATAP addresses see section 6.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc5214#section-6.1\">RFC 5214</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for ISATAP address format\n     * @return {@code true} if the argument is an ISATAP address\n     */\n    public static boolean isIsatapAddress(Inet6Address ip)\n    {\n\n        // If it's a Teredo address with the right port (41217, or 0xa101)\n        // which would be encoded as 0x5efe then it can't be an ISATAP address.\n        if (isTeredoAddress(ip))\n        {\n            return false;\n        }\n\n        byte[] bytes = ip.getAddress();\n\n        if ((bytes[8] | (byte) 0x03) != (byte) 0x03)\n        {\n\n            // Verify that high byte of the 64 bit identifier is zero, modulo\n            // the U/L and G bits, with which we are not concerned.\n            return false;\n        }\n\n        return (bytes[9] == (byte) 0x00) && (bytes[10] == (byte) 0x5e) && (bytes[11] == (byte) 0xfe);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in an ISATAP address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in ISATAP address\n     * @return {@link Inet4Address} of embedded IPv4 in an ISATAP address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 ISATAP address\n     */\n    public static Inet4Address getIsatapIPv4Address(Inet6Address ip)\n    {\n        checkArgument(isIsatapAddress(ip), \"Address '%s' is not an ISATAP address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n    }\n\n    /**\n     * Examines the Inet6Address to determine if it is an IPv6 address of one of the specified address\n     * types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@code true} if there is an embedded IPv4 client address\n     * @since 7.0\n     */\n    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        return isCompatIPv4Address(ip) || is6to4Address(ip) || isTeredoAddress(ip);\n    }\n\n    /**\n     * Examines the Inet6Address to extract the embedded IPv4 client address if the InetAddress is an\n     * IPv6 address of one of the specified address types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@link Inet4Address} of embedded IPv4 client address\n     * @throws IllegalArgumentException if the argument does not have a valid embedded IPv4 address\n     */\n    public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        if (isCompatIPv4Address(ip))\n        {\n            return getCompatIPv4Address(ip);\n        }\n\n        if (is6to4Address(ip))\n        {\n            return get6to4IPv4Address(ip);\n        }\n\n        if (isTeredoAddress(ip))\n        {\n            return getTeredoInfo(ip).getClient();\n        }\n\n        throw formatIllegalArgumentException(\"'%s' has no embedded IPv4 address.\", toAddrString(ip));\n    }\n\n    /**\n     * Evaluates whether the argument is an \"IPv4 mapped\" IPv6 address.\n     *\n     * <p>An \"IPv4 mapped\" address is anything in the range ::ffff:0:0/96 (sometimes written as\n     * ::ffff:0.0.0.0/96), with the last 32 bits interpreted as an IPv4 address.\n     *\n     * <p>For more on IPv4 mapped addresses see section 2.5.5.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.2\">RFC 4291</a>.\n     *\n     * <p>Note: This method takes a {@code String} argument because {@link InetAddress} automatically\n     * collapses mapped addresses to IPv4. (It is actually possible to avoid this using one of the\n     * obscure {@link Inet6Address} methods, but it would be unwise to depend on such a\n     * poorly-documented feature.)\n     *\n     * @param ipString {@code String} to be examined for embedded IPv4-mapped IPv6 address format\n     * @return {@code true} if the argument is a valid \"mapped\" address\n     * @since 10.0\n     */\n    public static boolean isMappedIPv4Address(String ipString)\n    {\n        byte[] bytes = ipStringToBytes(ipString);\n        if (bytes != null && bytes.length == 16)\n        {\n            for (int i = 0; i < 10; i++)\n            {\n                if (bytes[i] != 0)\n                {\n                    return false;\n                }\n            }\n            for (int i = 10; i < 12; i++)\n            {\n                if (bytes[i] != (byte) 0xff)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Coerces an IPv6 address into an IPv4 address.\n     *\n     * <p>HACK: As long as applications continue to use IPv4 addresses for indexing into tables,\n     * accounting, et cetera, it may be necessary to <b>coerce</b> IPv6 addresses into IPv4 addresses.\n     * This function does so by hashing the upper 64 bits into {@code 224.0.0.0/3} (64 bits into 29\n     * bits).\n     *\n     * <p>A \"coerced\" IPv4 address is equivalent to itself.\n     *\n     * <p>NOTE: This function is failsafe for security purposes: ALL IPv6 addresses (except localhost\n     * (::1)) are hashed to avoid the security risk associated with extracting an embedded IPv4\n     * address that might permit elevated privileges.\n     *\n     * @param ip {@link InetAddress} to \"coerce\"\n     * @return {@link Inet4Address} represented \"coerced\" address\n     * @since 7.0\n     */\n    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n    {\n        if (ip instanceof Inet4Address)\n        {\n            return (Inet4Address) ip;\n        }\n\n        // Special cases:\n        byte[] bytes = ip.getAddress();\n        boolean leadingBytesOfZero = true;\n        for (int i = 0; i < 15; ++i)\n        {\n            if (bytes[i] != 0)\n            {\n                leadingBytesOfZero = false;\n                break;\n            }\n        }\n        if (leadingBytesOfZero && (bytes[15] == 1))\n        {\n            return LOOPBACK4; // ::1\n        }\n        else if (leadingBytesOfZero && (bytes[15] == 0))\n        {\n            return ANY4; // ::0\n        }\n\n        Inet6Address ip6 = (Inet6Address) ip;\n        long addressAsLong = 0;\n        if (hasEmbeddedIPv4ClientAddress(ip6))\n        {\n            addressAsLong = getEmbeddedIPv4ClientAddress(ip6).hashCode();\n        }\n        else\n        {\n\n            // Just extract the high 64 bits (assuming the rest is user-modifiable).\n            addressAsLong = ByteBuffer.wrap(ip6.getAddress(), 0, 8).getLong();\n        }\n\n        // Many strategies for hashing are possible. This might suffice for now.\n        int coercedHash = Hashing.murmur3_32().hashLong(addressAsLong).asInt();\n\n        // Squash into 224/4 Multicast and 240/4 Reserved space (i.e. 224/3).\n        coercedHash |= 0xe0000000;\n\n        // Fixup to avoid some \"illegal\" values. Currently the only potential\n        // illegal value is 255.255.255.255.\n        if (coercedHash == 0xffffffff)\n        {\n            coercedHash = 0xfffffffe;\n        }\n\n        return getInet4Address(Ints.toByteArray(coercedHash));\n    }\n\n    /**\n     * Returns an integer representing an IPv4 address regardless of whether the supplied argument is\n     * an IPv4 address or not.\n     *\n     * <p>IPv6 addresses are <b>coerced</b> to IPv4 addresses before being converted to integers.\n     *\n     * <p>As long as there are applications that assume that all IP addresses are IPv4 addresses and\n     * can therefore be converted safely to integers (for whatever purpose) this function can be used\n     * to handle IPv6 addresses as well until the application is suitably fixed.\n     *\n     * <p>NOTE: an IPv6 address coerced to an IPv4 address can only be used for such purposes as\n     * rudimentary identification or indexing into a collection of real {@link InetAddress}es. They\n     * cannot be used as real addresses for the purposes of network communication.\n     *\n     * @param ip {@link InetAddress} to convert\n     * @return {@code int}, \"coerced\" if ip is not an IPv4 address\n     * @since 7.0\n     */\n    public static int coerceToInteger(InetAddress ip)\n    {\n        return ByteStreams.newDataInput(getCoercedIPv4Address(ip).getAddress()).readInt();\n    }\n\n    /**\n     * Returns an Inet4Address having the integer value specified by the argument.\n     *\n     * @param address {@code int}, the 32bit integer address to be converted\n     * @return {@link Inet4Address} equivalent of the argument\n     */\n    public static Inet4Address fromInteger(int address)\n    {\n        return getInet4Address(Ints.toByteArray(address));\n    }\n\n    /**\n     * Returns an address from a <b>little-endian ordered</b> byte array (the opposite of what {@link\n     * InetAddress#getByAddress} expects).\n     *\n     * <p>IPv4 address byte array must be 4 bytes long and IPv6 byte array must be 16 bytes long.\n     *\n     * @param addr the raw IP address in little-endian byte order\n     * @return an InetAddress object created from the raw IP address\n     * @throws UnknownHostException if IP address is of illegal length\n     */\n    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n    {\n        byte[] reversed = new byte[addr.length];\n        for (int i = 0; i < addr.length; i++)\n        {\n            reversed[i] = addr[addr.length - i - 1];\n        }\n        return InetAddress.getByAddress(reversed);\n    }\n\n    /**\n     * Returns a new InetAddress that is one less than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to decrement\n     * @return a new InetAddress that is one less than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the beginning of its range\n     * @since 18.0\n     */\n    public static InetAddress decrement(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0x00)\n        {\n            addr[i] = (byte) 0xff;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Decrementing %s would wrap.\", address);\n\n        addr[i]--;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns a new InetAddress that is one more than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to increment\n     * @return a new InetAddress that is one more than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the end of its range\n     * @since 10.0\n     */\n    public static InetAddress increment(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0xff)\n        {\n            addr[i] = 0;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Incrementing %s would wrap.\", address);\n\n        addr[i]++;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns true if the InetAddress is either 255.255.255.255 for IPv4 or\n     * ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6.\n     *\n     * @return true if the InetAddress is either 255.255.255.255 for IPv4 or\n     *     ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6\n     * @since 10.0\n     */\n    public static boolean isMaximum(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        for (int i = 0; i < addr.length; i++)\n        {\n            if (addr[i] != (byte) 0xff)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static IllegalArgumentException formatIllegalArgumentException(\n        String format, Object... args)\n    {\n        return new IllegalArgumentException(String.format(Locale.ROOT, format, args));\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.isIsatapAddress", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Evaluates whether the argument is an ISATAP address.\n\n<p>From RFC 5214: \"ISATAP interface identifiers are constructed in Modified EUI-64 format [...]\nby concatenating the 24-bit IANA OUI (00-00-5E), the 8-bit hexadecimal value 0xFE, and a 32-bit\nIPv4 address in network byte order [...]\"\n\n<p>For more on ISATAP addresses see section 6.1 of <a target=\"_parent\"\nhref=\"http://tools.ietf.org/html/rfc5214#section-6.1\">RFC 5214</a>.\n\n@param ip {@link Inet6Address} to be examined for ISATAP address format\n@return {@code true} if the argument is an ISATAP address", "docstring_tokens": ["Evaluates", "whether", "the", "argument", "is", "an", "ISATAP", "address", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L700-L718", "partition": "valid", "up_fun_num": 25, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.MoreObjects;", "import com.google.common.base.Splitter;", "import com.google.common.collect.Iterables;", "import com.google.common.hash.Hashing;", "import com.google.common.io.ByteStreams;", "import com.google.common.primitives.Ints;", "import java.net.Inet4Address;", "import java.net.Inet6Address;", "import java.net.InetAddress;", "import java.net.UnknownHostException;", "import java.nio.ByteBuffer;", "import java.util.Arrays;", "import java.util.List;", "import java.util.Locale;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class InetAddresses\n", "    private static Inet4Address getInet4Address(byte[] bytes)\n", "    public static InetAddress forString(String ipString)\n", "    public static boolean isInetAddress(String ipString)\n", "    private static byte[] ipStringToBytes(String ipString)\n", "    private static byte[] textToNumericFormatV4(String ipString)\n", "    private static byte[] textToNumericFormatV6(String ipString)\n", "    private static String convertDottedQuadToHex(String ipString)\n", "    private static byte parseOctet(String ipPart)\n", "    private static short parseHextet(String ipPart)\n", "    private static InetAddress bytesToInetAddress(byte[] addr)\n", "    public static String toAddrString(InetAddress ip)\n", "    private static void compressLongestRunOfZeroes(int[] hextets)\n", "    private static String hextetsToIPv6String(int[] hextets)\n", "    public static String toUriString(InetAddress ip)\n", "    public static InetAddress forUriString(String hostAddr)\n", "    private static InetAddress forUriStringNoThrow(String hostAddr)\n", "    public static boolean isUriInetAddress(String ipString)\n", "    public static boolean isCompatIPv4Address(Inet6Address ip)\n", "    public static Inet4Address getCompatIPv4Address(Inet6Address ip)\n", "    public static boolean is6to4Address(Inet6Address ip)\n", "    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n", "    public static boolean isTeredoAddress(Inet6Address ip)\n", "    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n", "    public static Inet4Address getIsatapIPv4Address(Inet6Address ip)\n", "    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static boolean isMappedIPv4Address(String ipString)\n", "    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n", "    public static int coerceToInteger(InetAddress ip)\n", "    public static Inet4Address fromInteger(int address)\n", "    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n", "    public static InetAddress decrement(InetAddress address)\n", "    public static InetAddress increment(InetAddress address)\n", "    public static boolean isMaximum(InetAddress address)\n", "    private static IllegalArgumentException formatIllegalArgumentException(\n"], "context": "/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.net;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.Iterables;\nimport com.google.common.hash.Hashing;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.primitives.Ints;\nimport java.net.Inet4Address;\nimport java.net.Inet6Address;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * Static utility methods pertaining to {@link InetAddress} instances.\n *\n * <p><b>Important note:</b> Unlike {@code InetAddress.getByName()}, the methods of this class never\n * cause DNS services to be accessed. For this reason, you should prefer these methods as much as\n * possible over their JDK equivalents whenever you are expecting to handle only IP address string\n * literals -- there is no blocking DNS penalty for a malformed string.\n *\n * <p>When dealing with {@link Inet4Address} and {@link Inet6Address} objects as byte arrays (vis.\n * {@code InetAddress.getAddress()}) they are 4 and 16 bytes in length, respectively, and represent\n * the address in network byte order.\n *\n * <p>Examples of IP addresses and their byte representations:\n *\n * <dl>\n *   <dt>The IPv4 loopback address, {@code \"127.0.0.1\"}.\n *   <dd>{@code 7f 00 00 01}\n *   <dt>The IPv6 loopback address, {@code \"::1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>From the IPv6 reserved documentation prefix ({@code 2001:db8::/32}), {@code \"2001:db8::1\"}.\n *   <dd>{@code 20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>An IPv6 \"IPv4 compatible\" (or \"compat\") address, {@code \"::192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 c0 a8 00 01}\n *   <dt>An IPv6 \"IPv4 mapped\" address, {@code \"::ffff:192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 ff ff c0 a8 00 01}\n * </dl>\n *\n * <p>A few notes about IPv6 \"IPv4 mapped\" addresses and their observed use in Java.\n *\n * <p>\"IPv4 mapped\" addresses were originally a representation of IPv4 addresses for use on an IPv6\n * socket that could receive both IPv4 and IPv6 connections (by disabling the {@code IPV6_V6ONLY}\n * socket option on an IPv6 socket). Yes, it's confusing. Nevertheless, these \"mapped\" addresses\n * were never supposed to be seen on the wire. That assumption was dropped, some say mistakenly, in\n * later RFCs with the apparent aim of making IPv4-to-IPv6 transition simpler.\n *\n * <p>Technically one <i>can</i> create a 128bit IPv6 address with the wire format of a \"mapped\"\n * address, as shown above, and transmit it in an IPv6 packet header. However, Java's InetAddress\n * creation methods appear to adhere doggedly to the original intent of the \"mapped\" address: all\n * \"mapped\" addresses return {@link Inet4Address} objects.\n *\n * <p>For added safety, it is common for IPv6 network operators to filter all packets where either\n * the source or destination address appears to be a \"compat\" or \"mapped\" address. Filtering\n * suggestions usually recommend discarding any packets with source or destination addresses in the\n * invalid range {@code ::/3}, which includes both of these bizarre address formats. For more\n * information on \"bogons\", including lists of IPv6 bogon space, see:\n *\n * <ul>\n *   <li><a target=\"_parent\"\n *       href=\"http://en.wikipedia.org/wiki/Bogon_filtering\">http://en.wikipedia.\n *       org/wiki/Bogon_filtering</a>\n *   <li><a target=\"_parent\"\n *       href=\"http://www.cymru.com/Bogons/ipv6.txt\">http://www.cymru.com/Bogons/ ipv6.txt</a>\n *   <li><a target=\"_parent\" href=\"http://www.cymru.com/Bogons/v6bogon.html\">http://www.cymru.com/\n *       Bogons/v6bogon.html</a>\n *   <li><a target=\"_parent\" href=\"http://www.space.net/~gert/RIPE/ipv6-filters.html\">http://www.\n *       space.net/~gert/RIPE/ipv6-filters.html</a>\n * </ul>\n *\n * @author Erik Kline\n * @since 5.0\n */\n@Beta\n@GwtIncompatible\npublic final class InetAddresses\n{\n    private static final int IPV4_PART_COUNT = 4;\n    private static final int IPV6_PART_COUNT = 8;\n    private static final Splitter IPV4_SPLITTER = Splitter.on('.').limit(IPV4_PART_COUNT);\n    private static final Splitter IPV6_SPLITTER = Splitter.on(':').limit(IPV6_PART_COUNT + 2);\n    private static final Inet4Address LOOPBACK4 = (Inet4Address) forString(\"127.0.0.1\");\n    private static final Inet4Address ANY4 = (Inet4Address) forString(\"0.0.0.0\");\n\n    private InetAddresses() {}\n\n    /**\n     * Returns an {@link Inet4Address}, given a byte array representation of the IPv4 address.\n     *\n     * @param bytes byte array representing an IPv4 address (should be of length 4)\n     * @return {@link Inet4Address} corresponding to the supplied byte array\n     * @throws IllegalArgumentException if a valid {@link Inet4Address} can not be created\n     */\n    private static Inet4Address getInet4Address(byte[] bytes)\n    {\n        checkArgument(\n            bytes.length == 4,\n            \"Byte array has invalid length for an IPv4 address: %s != 4.\",\n            bytes.length);\n\n        // Given a 4-byte array, this cast should always succeed.\n        return (Inet4Address) bytesToInetAddress(bytes);\n    }\n\n    /**\n     * Returns the {@link InetAddress} having the given string representation.\n     *\n     * <p>This deliberately avoids all nameservice lookups (e.g. no DNS).\n     *\n     * @param ipString {@code String} containing an IPv4 or IPv6 string literal, e.g. {@code\n     *     \"192.168.0.1\"} or {@code \"2001:db8::1\"}\n     * @return {@link InetAddress} representing the argument\n     * @throws IllegalArgumentException if the argument is not a valid IP string literal\n     */\n    public static InetAddress forString(String ipString)\n    {\n        byte[] addr = ipStringToBytes(ipString);\n\n        // The argument was malformed, i.e. not an IP string literal.\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"'%s' is not an IP string literal.\", ipString);\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP string literal\n     * @return {@code true} if the argument is a valid IP string literal\n     */\n    public static boolean isInetAddress(String ipString)\n    {\n        return ipStringToBytes(ipString) != null;\n    }\n\n    @NullableDecl\n    private static byte[] ipStringToBytes(String ipString)\n    {\n        // Make a first pass to categorize the characters in this string.\n        boolean hasColon = false;\n        boolean hasDot = false;\n        for (int i = 0; i < ipString.length(); i++)\n        {\n            char c = ipString.charAt(i);\n            if (c == '.')\n            {\n                hasDot = true;\n            }\n            else if (c == ':')\n            {\n                if (hasDot)\n                {\n                    return null; // Colons must not appear after dots.\n                }\n                hasColon = true;\n            }\n            else if (Character.digit(c, 16) == -1)\n            {\n                return null; // Everything else must be a decimal or hex digit.\n            }\n        }\n\n        // Now decide which address family to parse.\n        if (hasColon)\n        {\n            if (hasDot)\n            {\n                ipString = convertDottedQuadToHex(ipString);\n                if (ipString == null)\n                {\n                    return null;\n                }\n            }\n            return textToNumericFormatV6(ipString);\n        }\n        else if (hasDot)\n        {\n            return textToNumericFormatV4(ipString);\n        }\n        return null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV4(String ipString)\n    {\n        byte[] bytes = new byte[IPV4_PART_COUNT];\n        int i = 0;\n        try\n        {\n            for (String octet : IPV4_SPLITTER.split(ipString))\n            {\n                bytes[i++] = parseOctet(octet);\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n\n        return i == IPV4_PART_COUNT ? bytes : null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV6(String ipString)\n    {\n        // An address can have [2..8] colons, and N colons make N+1 parts.\n        List<String> parts = IPV6_SPLITTER.splitToList(ipString);\n        if (parts.size() < 3 || parts.size() > IPV6_PART_COUNT + 1)\n        {\n            return null;\n        }\n\n        // Disregarding the endpoints, find \"::\" with nothing in between.\n        // This indicates that a run of zeroes has been skipped.\n        int skipIndex = -1;\n        for (int i = 1; i < parts.size() - 1; i++)\n        {\n            if (parts.get(i).length() == 0)\n            {\n                if (skipIndex >= 0)\n                {\n                    return null; // Can't have more than one ::\n                }\n                skipIndex = i;\n            }\n        }\n\n        int partsHi; // Number of parts to copy from above/before the \"::\"\n        int partsLo; // Number of parts to copy from below/after the \"::\"\n        if (skipIndex >= 0)\n        {\n            // If we found a \"::\", then check if it also covers the endpoints.\n            partsHi = skipIndex;\n            partsLo = parts.size() - skipIndex - 1;\n            if (parts.get(0).length() == 0 && --partsHi != 0)\n            {\n                return null; // ^: requires ^::\n            }\n            if (Iterables.getLast(parts).length() == 0 && --partsLo != 0)\n            {\n                return null; // :$ requires ::$\n            }\n        }\n        else\n        {\n            // Otherwise, allocate the entire address to partsHi. The endpoints\n            // could still be empty, but parseHextet() will check for that.\n            partsHi = parts.size();\n            partsLo = 0;\n        }\n\n        // If we found a ::, then we must have skipped at least one part.\n        // Otherwise, we must have exactly the right number of parts.\n        int partsSkipped = IPV6_PART_COUNT - (partsHi + partsLo);\n        if (!(skipIndex >= 0 ? partsSkipped >= 1 : partsSkipped == 0))\n        {\n            return null;\n        }\n\n        // Now parse the hextets into a byte array.\n        ByteBuffer rawBytes = ByteBuffer.allocate(2 * IPV6_PART_COUNT);\n        try\n        {\n            for (int i = 0; i < partsHi; i++)\n            {\n                rawBytes.putShort(parseHextet(parts.get(i)));\n            }\n            for (int i = 0; i < partsSkipped; i++)\n            {\n                rawBytes.putShort((short) 0);\n            }\n            for (int i = partsLo; i > 0; i--)\n            {\n                rawBytes.putShort(parseHextet(parts.get(parts.size() - i)));\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n        return rawBytes.array();\n    }\n\n    @NullableDecl\n    private static String convertDottedQuadToHex(String ipString)\n    {\n        int lastColon = ipString.lastIndexOf(':');\n        String initialPart = ipString.substring(0, lastColon + 1);\n        String dottedQuad = ipString.substring(lastColon + 1);\n        byte[] quad = textToNumericFormatV4(dottedQuad);\n        if (quad == null)\n        {\n            return null;\n        }\n        String penultimate = Integer.toHexString(((quad[0] & 0xff) << 8) | (quad[1] & 0xff));\n        String ultimate = Integer.toHexString(((quad[2] & 0xff) << 8) | (quad[3] & 0xff));\n        return initialPart + penultimate + \":\" + ultimate;\n    }\n\n    private static byte parseOctet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int octet = Integer.parseInt(ipPart);\n        // Disallow leading zeroes, because no clear standard exists on\n        // whether these should be interpreted as decimal or octal.\n        if (octet > 255 || (ipPart.startsWith(\"0\") && ipPart.length() > 1))\n        {\n            throw new NumberFormatException();\n        }\n        return (byte) octet;\n    }\n\n    private static short parseHextet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int hextet = Integer.parseInt(ipPart, 16);\n        if (hextet > 0xffff)\n        {\n            throw new NumberFormatException();\n        }\n        return (short) hextet;\n    }\n\n    /**\n     * Convert a byte array into an InetAddress.\n     *\n     * <p>{@link InetAddress#getByAddress} is documented as throwing a checked exception \"if IP\n     * address is of illegal length.\" We replace it with an unchecked exception, for use by callers\n     * who already know that addr is an array of length 4 or 16.\n     *\n     * @param addr the raw 4-byte or 16-byte IP address in big-endian order\n     * @return an InetAddress object created from the raw IP address\n     */\n    private static InetAddress bytesToInetAddress(byte[] addr)\n    {\n        try\n        {\n            return InetAddress.getByAddress(addr);\n        }\n        catch (UnknownHostException e)\n        {\n            throw new AssertionError(e);\n        }\n    }\n\n    /**\n     * Returns the string representation of an {@link InetAddress}.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses, the output follows <a href=\"http://tools.ietf.org/html/rfc5952\">RFC 5952</a> section\n     * 4. The main difference is that this method uses \"::\" for zero compression, while Java's version\n     * uses the uncompressed form.\n     *\n     * <p>This method uses hexadecimal for all IPv6 addresses, including IPv4-mapped IPv6 addresses\n     * such as \"::c000:201\". The output does not include a Scope ID.\n     *\n     * @param ip {@link InetAddress} to be converted to an address string\n     * @return {@code String} containing the text-formatted IP address\n     * @since 10.0\n     */\n    public static String toAddrString(InetAddress ip)\n    {\n        checkNotNull(ip);\n        if (ip instanceof Inet4Address)\n        {\n            // For IPv4, Java's formatting is good enough.\n            return ip.getHostAddress();\n        }\n        checkArgument(ip instanceof Inet6Address);\n        byte[] bytes = ip.getAddress();\n        int[] hextets = new int[IPV6_PART_COUNT];\n        for (int i = 0; i < hextets.length; i++)\n        {\n            hextets[i] = Ints.fromBytes((byte) 0, (byte) 0, bytes[2 * i], bytes[2 * i + 1]);\n        }\n        compressLongestRunOfZeroes(hextets);\n        return hextetsToIPv6String(hextets);\n    }\n\n    /**\n     * Identify and mark the longest run of zeroes in an IPv6 address.\n     *\n     * <p>Only runs of two or more hextets are considered. In case of a tie, the leftmost run wins. If\n     * a qualifying run is found, its hextets are replaced by the sentinel value -1.\n     *\n     * @param hextets {@code int[]} mutable array of eight 16-bit hextets\n     */\n    private static void compressLongestRunOfZeroes(int[] hextets)\n    {\n        int bestRunStart = -1;\n        int bestRunLength = -1;\n        int runStart = -1;\n        for (int i = 0; i < hextets.length + 1; i++)\n        {\n            if (i < hextets.length && hextets[i] == 0)\n            {\n                if (runStart < 0)\n                {\n                    runStart = i;\n                }\n            }\n            else if (runStart >= 0)\n            {\n                int runLength = i - runStart;\n                if (runLength > bestRunLength)\n                {\n                    bestRunStart = runStart;\n                    bestRunLength = runLength;\n                }\n                runStart = -1;\n            }\n        }\n        if (bestRunLength >= 2)\n        {\n            Arrays.fill(hextets, bestRunStart, bestRunStart + bestRunLength, -1);\n        }\n    }\n\n    /**\n     * Convert a list of hextets into a human-readable IPv6 address.\n     *\n     * <p>In order for \"::\" compression to work, the input should contain negative sentinel values in\n     * place of the elided zeroes.\n     *\n     * @param hextets {@code int[]} array of eight 16-bit hextets, or -1s\n     */\n    private static String hextetsToIPv6String(int[] hextets)\n    {\n        // While scanning the array, handle these state transitions:\n        //   start->num => \"num\"     start->gap => \"::\"\n        //   num->num   => \":num\"    num->gap   => \"::\"\n        //   gap->num   => \"num\"     gap->gap   => \"\"\n        StringBuilder buf = new StringBuilder(39);\n        boolean lastWasNumber = false;\n        for (int i = 0; i < hextets.length; i++)\n        {\n            boolean thisIsNumber = hextets[i] >= 0;\n            if (thisIsNumber)\n            {\n                if (lastWasNumber)\n                {\n                    buf.append(':');\n                }\n                buf.append(Integer.toHexString(hextets[i]));\n            }\n            else\n            {\n                if (i == 0 || lastWasNumber)\n                {\n                    buf.append(\"::\");\n                }\n            }\n            lastWasNumber = thisIsNumber;\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Returns the string representation of an {@link InetAddress} suitable for inclusion in a URI.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses it compresses zeroes and surrounds the text with square brackets; for example {@code\n     * \"[2001:db8::1]\"}.\n     *\n     * <p>Per section 3.2.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3986#section-3.2.2\">RFC 3986</a>, a URI containing an IPv6\n     * string literal is of the form {@code \"http://[2001:db8::1]:8888/index.html\"}.\n     *\n     * <p>Use of either {@link InetAddresses#toAddrString}, {@link InetAddress#getHostAddress()}, or\n     * this method is recommended over {@link InetAddress#toString()} when an IP address string\n     * literal is desired. This is because {@link InetAddress#toString()} prints the hostname and the\n     * IP address string joined by a \"/\".\n     *\n     * @param ip {@link InetAddress} to be converted to URI string literal\n     * @return {@code String} containing URI-safe string literal\n     */\n    public static String toUriString(InetAddress ip)\n    {\n        if (ip instanceof Inet6Address)\n        {\n            return \"[\" + toAddrString(ip) + \"]\";\n        }\n        return toAddrString(ip);\n    }\n\n    /**\n     * Returns an InetAddress representing the literal IPv4 or IPv6 host portion of a URL, encoded in\n     * the format specified by RFC 3986 section 3.2.2.\n     *\n     * <p>This function is similar to {@link InetAddresses#forString(String)}, however, it requires\n     * that IPv6 addresses are surrounded by square brackets.\n     *\n     * <p>This function is the inverse of {@link InetAddresses#toUriString(java.net.InetAddress)}.\n     *\n     * @param hostAddr A RFC 3986 section 3.2.2 encoded IPv4 or IPv6 address\n     * @return an InetAddress representing the address in {@code hostAddr}\n     * @throws IllegalArgumentException if {@code hostAddr} is not a valid IPv4 address, or IPv6\n     *     address surrounded by square brackets\n     */\n    public static InetAddress forUriString(String hostAddr)\n    {\n        InetAddress addr = forUriStringNoThrow(hostAddr);\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"Not a valid URI IP literal: '%s'\", hostAddr);\n        }\n\n        return addr;\n    }\n\n    @NullableDecl\n    private static InetAddress forUriStringNoThrow(String hostAddr)\n    {\n        checkNotNull(hostAddr);\n\n        // Decide if this should be an IPv6 or IPv4 address.\n        String ipString;\n        int expectBytes;\n        if (hostAddr.startsWith(\"[\") && hostAddr.endsWith(\"]\"))\n        {\n            ipString = hostAddr.substring(1, hostAddr.length() - 1);\n            expectBytes = 16;\n        }\n        else\n        {\n            ipString = hostAddr;\n            expectBytes = 4;\n        }\n\n        // Parse the address, and make sure the length/version is correct.\n        byte[] addr = ipStringToBytes(ipString);\n        if (addr == null || addr.length != expectBytes)\n        {\n            return null;\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid URI IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP URI host string literal\n     * @return {@code true} if the argument is a valid IP URI host\n     */\n    public static boolean isUriInetAddress(String ipString)\n    {\n        return forUriStringNoThrow(ipString) != null;\n    }\n\n    /**\n     * Evaluates whether the argument is an IPv6 \"compat\" address.\n     *\n     * <p>An \"IPv4 compatible\", or \"compat\", address is one with 96 leading bits of zero, with the\n     * remaining 32 bits interpreted as an IPv4 address. These are conventionally represented in\n     * string literals as {@code \"::192.168.0.1\"}, though {@code \"::c0a8:1\"} is also considered an\n     * IPv4 compatible address (and equivalent to {@code \"::192.168.0.1\"}).\n     *\n     * <p>For more on IPv4 compatible addresses see section 2.5.5.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.1\">RFC 4291</a>.\n     *\n     * <p>NOTE: This method is different from {@link Inet6Address#isIPv4CompatibleAddress} in that it\n     * more correctly classifies {@code \"::\"} and {@code \"::1\"} as proper IPv6 addresses (which they\n     * are), NOT IPv4 compatible addresses (which they are generally NOT considered to be).\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 compatible address format\n     * @return {@code true} if the argument is a valid \"compat\" address\n     */\n    public static boolean isCompatIPv4Address(Inet6Address ip)\n    {\n        if (!ip.isIPv4CompatibleAddress())\n        {\n            return false;\n        }\n\n        byte[] bytes = ip.getAddress();\n        if ((bytes[12] == 0)\n                && (bytes[13] == 0)\n                && (bytes[14] == 0)\n                && ((bytes[15] == 0) || (bytes[15] == 1)))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the IPv4 address embedded in an IPv4 compatible address.\n     *\n     * @param ip {@link Inet6Address} to be examined for an embedded IPv4 address\n     * @return {@link Inet4Address} of the embedded IPv4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv4 compatible address\n     */\n    public static Inet4Address getCompatIPv4Address(Inet6Address ip)\n    {\n        checkArgument(\n            isCompatIPv4Address(ip), \"Address '%s' is not IPv4-compatible.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n    }\n\n    /**\n     * Evaluates whether the argument is a 6to4 address.\n     *\n     * <p>6to4 addresses begin with the {@code \"2002::/16\"} prefix. The next 32 bits are the IPv4\n     * address of the host to which IPv6-in-IPv4 tunneled packets should be routed.\n     *\n     * <p>For more on 6to4 addresses see section 2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3056#section-2\">RFC 3056</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for 6to4 address format\n     * @return {@code true} if the argument is a 6to4 address\n     */\n    public static boolean is6to4Address(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20) && (bytes[1] == (byte) 0x02);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in a 6to4 address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in 6to4 address\n     * @return {@link Inet4Address} of embedded IPv4 in 6to4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 6to4 address\n     */\n    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n    {\n        checkArgument(is6to4Address(ip), \"Address '%s' is not a 6to4 address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 2, 6));\n    }\n\n    /**\n     * A simple immutable data class to encapsulate the information to be found in a Teredo address.\n     *\n     * <p>All of the fields in this class are encoded in various portions of the IPv6 address as part\n     * of the protocol. More protocols details can be found at: <a target=\"_parent\"\n     * href=\"http://en.wikipedia.org/wiki/Teredo_tunneling\">http://en.wikipedia.\n     * org/wiki/Teredo_tunneling</a>.\n     *\n     * <p>The RFC can be found here: <a target=\"_parent\" href=\"http://tools.ietf.org/html/rfc4380\">RFC\n     * 4380</a>.\n     *\n     * @since 5.0\n     */\n    @Beta\n    public static final class TeredoInfo\n    {\n        private final Inet4Address server;\n        private final Inet4Address client;\n        private final int port;\n        private final int flags;\n\n        /**\n         * Constructs a TeredoInfo instance.\n         *\n         * <p>Both server and client can be {@code null}, in which case the value {@code \"0.0.0.0\"} will\n         * be assumed.\n         *\n         * @throws IllegalArgumentException if either of the {@code port} or the {@code flags} arguments\n         *     are out of range of an unsigned short\n         */\n        // TODO: why is this public?\n        public TeredoInfo(\n            @NullableDecl Inet4Address server, @NullableDecl Inet4Address client, int port, int flags)\n        {\n            checkArgument(\n                (port >= 0) && (port <= 0xffff), \"port '%s' is out of range (0 <= port <= 0xffff)\", port);\n            checkArgument(\n                (flags >= 0) && (flags <= 0xffff),\n                \"flags '%s' is out of range (0 <= flags <= 0xffff)\",\n                flags);\n\n            this.server = MoreObjects.firstNonNull(server, ANY4);\n            this.client = MoreObjects.firstNonNull(client, ANY4);\n            this.port = port;\n            this.flags = flags;\n        }\n\n        public Inet4Address getServer()\n        {\n            return server;\n        }\n\n        public Inet4Address getClient()\n        {\n            return client;\n        }\n\n        public int getPort()\n        {\n            return port;\n        }\n\n        public int getFlags()\n        {\n            return flags;\n        }\n    }\n\n    /**\n     * Evaluates whether the argument is a Teredo address.\n     *\n     * <p>Teredo addresses begin with the {@code \"2001::/32\"} prefix.\n     *\n     * @param ip {@link Inet6Address} to be examined for Teredo address format\n     * @return {@code true} if the argument is a Teredo address\n     */\n    public static boolean isTeredoAddress(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20)\n               && (bytes[1] == (byte) 0x01)\n               && (bytes[2] == 0)\n               && (bytes[3] == 0);\n    }\n\n    /**\n     * Returns the Teredo information embedded in a Teredo address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded Teredo information\n     * @return extracted {@code TeredoInfo}\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 Teredo address\n     */\n    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n    {\n        checkArgument(isTeredoAddress(ip), \"Address '%s' is not a Teredo address.\", toAddrString(ip));\n\n        byte[] bytes = ip.getAddress();\n        Inet4Address server = getInet4Address(Arrays.copyOfRange(bytes, 4, 8));\n\n        int flags = ByteStreams.newDataInput(bytes, 8).readShort() & 0xffff;\n\n        // Teredo obfuscates the mapped client port, per section 4 of the RFC.\n        int port = ~ByteStreams.newDataInput(bytes, 10).readShort() & 0xffff;\n\n        byte[] clientBytes = Arrays.copyOfRange(bytes, 12, 16);\n        for (int i = 0; i < clientBytes.length; i++)\n        {\n            // Teredo obfuscates the mapped client IP, per section 4 of the RFC.\n            clientBytes[i] = (byte) ~clientBytes[i];\n        }\n        Inet4Address client = getInet4Address(clientBytes);\n\n        return new TeredoInfo(server, client, port, flags);\n    }\n\n    /**\n     * Evaluates whether the argument is an ISATAP address.\n     *\n     * <p>From RFC 5214: \"ISATAP interface identifiers are constructed in Modified EUI-64 format [...]\n     * by concatenating the 24-bit IANA OUI (00-00-5E), the 8-bit hexadecimal value 0xFE, and a 32-bit\n     * IPv4 address in network byte order [...]\"\n     *\n     * <p>For more on ISATAP addresses see section 6.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc5214#section-6.1\">RFC 5214</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for ISATAP address format\n     * @return {@code true} if the argument is an ISATAP address\n     */\n\n    /**\n     * Returns the IPv4 address embedded in an ISATAP address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in ISATAP address\n     * @return {@link Inet4Address} of embedded IPv4 in an ISATAP address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 ISATAP address\n     */\n    public static Inet4Address getIsatapIPv4Address(Inet6Address ip)\n    {\n        checkArgument(isIsatapAddress(ip), \"Address '%s' is not an ISATAP address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n    }\n\n    /**\n     * Examines the Inet6Address to determine if it is an IPv6 address of one of the specified address\n     * types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@code true} if there is an embedded IPv4 client address\n     * @since 7.0\n     */\n    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        return isCompatIPv4Address(ip) || is6to4Address(ip) || isTeredoAddress(ip);\n    }\n\n    /**\n     * Examines the Inet6Address to extract the embedded IPv4 client address if the InetAddress is an\n     * IPv6 address of one of the specified address types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@link Inet4Address} of embedded IPv4 client address\n     * @throws IllegalArgumentException if the argument does not have a valid embedded IPv4 address\n     */\n    public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        if (isCompatIPv4Address(ip))\n        {\n            return getCompatIPv4Address(ip);\n        }\n\n        if (is6to4Address(ip))\n        {\n            return get6to4IPv4Address(ip);\n        }\n\n        if (isTeredoAddress(ip))\n        {\n            return getTeredoInfo(ip).getClient();\n        }\n\n        throw formatIllegalArgumentException(\"'%s' has no embedded IPv4 address.\", toAddrString(ip));\n    }\n\n    /**\n     * Evaluates whether the argument is an \"IPv4 mapped\" IPv6 address.\n     *\n     * <p>An \"IPv4 mapped\" address is anything in the range ::ffff:0:0/96 (sometimes written as\n     * ::ffff:0.0.0.0/96), with the last 32 bits interpreted as an IPv4 address.\n     *\n     * <p>For more on IPv4 mapped addresses see section 2.5.5.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.2\">RFC 4291</a>.\n     *\n     * <p>Note: This method takes a {@code String} argument because {@link InetAddress} automatically\n     * collapses mapped addresses to IPv4. (It is actually possible to avoid this using one of the\n     * obscure {@link Inet6Address} methods, but it would be unwise to depend on such a\n     * poorly-documented feature.)\n     *\n     * @param ipString {@code String} to be examined for embedded IPv4-mapped IPv6 address format\n     * @return {@code true} if the argument is a valid \"mapped\" address\n     * @since 10.0\n     */\n    public static boolean isMappedIPv4Address(String ipString)\n    {\n        byte[] bytes = ipStringToBytes(ipString);\n        if (bytes != null && bytes.length == 16)\n        {\n            for (int i = 0; i < 10; i++)\n            {\n                if (bytes[i] != 0)\n                {\n                    return false;\n                }\n            }\n            for (int i = 10; i < 12; i++)\n            {\n                if (bytes[i] != (byte) 0xff)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Coerces an IPv6 address into an IPv4 address.\n     *\n     * <p>HACK: As long as applications continue to use IPv4 addresses for indexing into tables,\n     * accounting, et cetera, it may be necessary to <b>coerce</b> IPv6 addresses into IPv4 addresses.\n     * This function does so by hashing the upper 64 bits into {@code 224.0.0.0/3} (64 bits into 29\n     * bits).\n     *\n     * <p>A \"coerced\" IPv4 address is equivalent to itself.\n     *\n     * <p>NOTE: This function is failsafe for security purposes: ALL IPv6 addresses (except localhost\n     * (::1)) are hashed to avoid the security risk associated with extracting an embedded IPv4\n     * address that might permit elevated privileges.\n     *\n     * @param ip {@link InetAddress} to \"coerce\"\n     * @return {@link Inet4Address} represented \"coerced\" address\n     * @since 7.0\n     */\n    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n    {\n        if (ip instanceof Inet4Address)\n        {\n            return (Inet4Address) ip;\n        }\n\n        // Special cases:\n        byte[] bytes = ip.getAddress();\n        boolean leadingBytesOfZero = true;\n        for (int i = 0; i < 15; ++i)\n        {\n            if (bytes[i] != 0)\n            {\n                leadingBytesOfZero = false;\n                break;\n            }\n        }\n        if (leadingBytesOfZero && (bytes[15] == 1))\n        {\n            return LOOPBACK4; // ::1\n        }\n        else if (leadingBytesOfZero && (bytes[15] == 0))\n        {\n            return ANY4; // ::0\n        }\n\n        Inet6Address ip6 = (Inet6Address) ip;\n        long addressAsLong = 0;\n        if (hasEmbeddedIPv4ClientAddress(ip6))\n        {\n            addressAsLong = getEmbeddedIPv4ClientAddress(ip6).hashCode();\n        }\n        else\n        {\n\n            // Just extract the high 64 bits (assuming the rest is user-modifiable).\n            addressAsLong = ByteBuffer.wrap(ip6.getAddress(), 0, 8).getLong();\n        }\n\n        // Many strategies for hashing are possible. This might suffice for now.\n        int coercedHash = Hashing.murmur3_32().hashLong(addressAsLong).asInt();\n\n        // Squash into 224/4 Multicast and 240/4 Reserved space (i.e. 224/3).\n        coercedHash |= 0xe0000000;\n\n        // Fixup to avoid some \"illegal\" values. Currently the only potential\n        // illegal value is 255.255.255.255.\n        if (coercedHash == 0xffffffff)\n        {\n            coercedHash = 0xfffffffe;\n        }\n\n        return getInet4Address(Ints.toByteArray(coercedHash));\n    }\n\n    /**\n     * Returns an integer representing an IPv4 address regardless of whether the supplied argument is\n     * an IPv4 address or not.\n     *\n     * <p>IPv6 addresses are <b>coerced</b> to IPv4 addresses before being converted to integers.\n     *\n     * <p>As long as there are applications that assume that all IP addresses are IPv4 addresses and\n     * can therefore be converted safely to integers (for whatever purpose) this function can be used\n     * to handle IPv6 addresses as well until the application is suitably fixed.\n     *\n     * <p>NOTE: an IPv6 address coerced to an IPv4 address can only be used for such purposes as\n     * rudimentary identification or indexing into a collection of real {@link InetAddress}es. They\n     * cannot be used as real addresses for the purposes of network communication.\n     *\n     * @param ip {@link InetAddress} to convert\n     * @return {@code int}, \"coerced\" if ip is not an IPv4 address\n     * @since 7.0\n     */\n    public static int coerceToInteger(InetAddress ip)\n    {\n        return ByteStreams.newDataInput(getCoercedIPv4Address(ip).getAddress()).readInt();\n    }\n\n    /**\n     * Returns an Inet4Address having the integer value specified by the argument.\n     *\n     * @param address {@code int}, the 32bit integer address to be converted\n     * @return {@link Inet4Address} equivalent of the argument\n     */\n    public static Inet4Address fromInteger(int address)\n    {\n        return getInet4Address(Ints.toByteArray(address));\n    }\n\n    /**\n     * Returns an address from a <b>little-endian ordered</b> byte array (the opposite of what {@link\n     * InetAddress#getByAddress} expects).\n     *\n     * <p>IPv4 address byte array must be 4 bytes long and IPv6 byte array must be 16 bytes long.\n     *\n     * @param addr the raw IP address in little-endian byte order\n     * @return an InetAddress object created from the raw IP address\n     * @throws UnknownHostException if IP address is of illegal length\n     */\n    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n    {\n        byte[] reversed = new byte[addr.length];\n        for (int i = 0; i < addr.length; i++)\n        {\n            reversed[i] = addr[addr.length - i - 1];\n        }\n        return InetAddress.getByAddress(reversed);\n    }\n\n    /**\n     * Returns a new InetAddress that is one less than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to decrement\n     * @return a new InetAddress that is one less than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the beginning of its range\n     * @since 18.0\n     */\n    public static InetAddress decrement(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0x00)\n        {\n            addr[i] = (byte) 0xff;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Decrementing %s would wrap.\", address);\n\n        addr[i]--;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns a new InetAddress that is one more than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to increment\n     * @return a new InetAddress that is one more than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the end of its range\n     * @since 10.0\n     */\n    public static InetAddress increment(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0xff)\n        {\n            addr[i] = 0;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Incrementing %s would wrap.\", address);\n\n        addr[i]++;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns true if the InetAddress is either 255.255.255.255 for IPv4 or\n     * ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6.\n     *\n     * @return true if the InetAddress is either 255.255.255.255 for IPv4 or\n     *     ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6\n     * @since 10.0\n     */\n    public static boolean isMaximum(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        for (int i = 0; i < addr.length; i++)\n        {\n            if (addr[i] != (byte) 0xff)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static IllegalArgumentException formatIllegalArgumentException(\n        String format, Object... args)\n    {\n        return new IllegalArgumentException(String.format(Locale.ROOT, format, args));\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.getIsatapIPv4Address", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns the IPv4 address embedded in an ISATAP address.\n\n@param ip {@link Inet6Address} to be examined for embedded IPv4 in ISATAP address\n@return {@link Inet4Address} of embedded IPv4 in an ISATAP address\n@throws IllegalArgumentException if the argument is not a valid IPv6 ISATAP address", "docstring_tokens": ["Returns", "the", "IPv4", "address", "embedded", "in", "an", "ISATAP", "address", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L727-L731", "partition": "valid", "up_fun_num": 26, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.MoreObjects;", "import com.google.common.base.Splitter;", "import com.google.common.collect.Iterables;", "import com.google.common.hash.Hashing;", "import com.google.common.io.ByteStreams;", "import com.google.common.primitives.Ints;", "import java.net.Inet4Address;", "import java.net.Inet6Address;", "import java.net.InetAddress;", "import java.net.UnknownHostException;", "import java.nio.ByteBuffer;", "import java.util.Arrays;", "import java.util.List;", "import java.util.Locale;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class InetAddresses\n", "    private static Inet4Address getInet4Address(byte[] bytes)\n", "    public static InetAddress forString(String ipString)\n", "    public static boolean isInetAddress(String ipString)\n", "    private static byte[] ipStringToBytes(String ipString)\n", "    private static byte[] textToNumericFormatV4(String ipString)\n", "    private static byte[] textToNumericFormatV6(String ipString)\n", "    private static String convertDottedQuadToHex(String ipString)\n", "    private static byte parseOctet(String ipPart)\n", "    private static short parseHextet(String ipPart)\n", "    private static InetAddress bytesToInetAddress(byte[] addr)\n", "    public static String toAddrString(InetAddress ip)\n", "    private static void compressLongestRunOfZeroes(int[] hextets)\n", "    private static String hextetsToIPv6String(int[] hextets)\n", "    public static String toUriString(InetAddress ip)\n", "    public static InetAddress forUriString(String hostAddr)\n", "    private static InetAddress forUriStringNoThrow(String hostAddr)\n", "    public static boolean isUriInetAddress(String ipString)\n", "    public static boolean isCompatIPv4Address(Inet6Address ip)\n", "    public static Inet4Address getCompatIPv4Address(Inet6Address ip)\n", "    public static boolean is6to4Address(Inet6Address ip)\n", "    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n", "    public static boolean isTeredoAddress(Inet6Address ip)\n", "    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n", "    public static boolean isIsatapAddress(Inet6Address ip)\n", "    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static boolean isMappedIPv4Address(String ipString)\n", "    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n", "    public static int coerceToInteger(InetAddress ip)\n", "    public static Inet4Address fromInteger(int address)\n", "    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n", "    public static InetAddress decrement(InetAddress address)\n", "    public static InetAddress increment(InetAddress address)\n", "    public static boolean isMaximum(InetAddress address)\n", "    private static IllegalArgumentException formatIllegalArgumentException(\n"], "context": "/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.net;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.Iterables;\nimport com.google.common.hash.Hashing;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.primitives.Ints;\nimport java.net.Inet4Address;\nimport java.net.Inet6Address;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * Static utility methods pertaining to {@link InetAddress} instances.\n *\n * <p><b>Important note:</b> Unlike {@code InetAddress.getByName()}, the methods of this class never\n * cause DNS services to be accessed. For this reason, you should prefer these methods as much as\n * possible over their JDK equivalents whenever you are expecting to handle only IP address string\n * literals -- there is no blocking DNS penalty for a malformed string.\n *\n * <p>When dealing with {@link Inet4Address} and {@link Inet6Address} objects as byte arrays (vis.\n * {@code InetAddress.getAddress()}) they are 4 and 16 bytes in length, respectively, and represent\n * the address in network byte order.\n *\n * <p>Examples of IP addresses and their byte representations:\n *\n * <dl>\n *   <dt>The IPv4 loopback address, {@code \"127.0.0.1\"}.\n *   <dd>{@code 7f 00 00 01}\n *   <dt>The IPv6 loopback address, {@code \"::1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>From the IPv6 reserved documentation prefix ({@code 2001:db8::/32}), {@code \"2001:db8::1\"}.\n *   <dd>{@code 20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>An IPv6 \"IPv4 compatible\" (or \"compat\") address, {@code \"::192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 c0 a8 00 01}\n *   <dt>An IPv6 \"IPv4 mapped\" address, {@code \"::ffff:192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 ff ff c0 a8 00 01}\n * </dl>\n *\n * <p>A few notes about IPv6 \"IPv4 mapped\" addresses and their observed use in Java.\n *\n * <p>\"IPv4 mapped\" addresses were originally a representation of IPv4 addresses for use on an IPv6\n * socket that could receive both IPv4 and IPv6 connections (by disabling the {@code IPV6_V6ONLY}\n * socket option on an IPv6 socket). Yes, it's confusing. Nevertheless, these \"mapped\" addresses\n * were never supposed to be seen on the wire. That assumption was dropped, some say mistakenly, in\n * later RFCs with the apparent aim of making IPv4-to-IPv6 transition simpler.\n *\n * <p>Technically one <i>can</i> create a 128bit IPv6 address with the wire format of a \"mapped\"\n * address, as shown above, and transmit it in an IPv6 packet header. However, Java's InetAddress\n * creation methods appear to adhere doggedly to the original intent of the \"mapped\" address: all\n * \"mapped\" addresses return {@link Inet4Address} objects.\n *\n * <p>For added safety, it is common for IPv6 network operators to filter all packets where either\n * the source or destination address appears to be a \"compat\" or \"mapped\" address. Filtering\n * suggestions usually recommend discarding any packets with source or destination addresses in the\n * invalid range {@code ::/3}, which includes both of these bizarre address formats. For more\n * information on \"bogons\", including lists of IPv6 bogon space, see:\n *\n * <ul>\n *   <li><a target=\"_parent\"\n *       href=\"http://en.wikipedia.org/wiki/Bogon_filtering\">http://en.wikipedia.\n *       org/wiki/Bogon_filtering</a>\n *   <li><a target=\"_parent\"\n *       href=\"http://www.cymru.com/Bogons/ipv6.txt\">http://www.cymru.com/Bogons/ ipv6.txt</a>\n *   <li><a target=\"_parent\" href=\"http://www.cymru.com/Bogons/v6bogon.html\">http://www.cymru.com/\n *       Bogons/v6bogon.html</a>\n *   <li><a target=\"_parent\" href=\"http://www.space.net/~gert/RIPE/ipv6-filters.html\">http://www.\n *       space.net/~gert/RIPE/ipv6-filters.html</a>\n * </ul>\n *\n * @author Erik Kline\n * @since 5.0\n */\n@Beta\n@GwtIncompatible\npublic final class InetAddresses\n{\n    private static final int IPV4_PART_COUNT = 4;\n    private static final int IPV6_PART_COUNT = 8;\n    private static final Splitter IPV4_SPLITTER = Splitter.on('.').limit(IPV4_PART_COUNT);\n    private static final Splitter IPV6_SPLITTER = Splitter.on(':').limit(IPV6_PART_COUNT + 2);\n    private static final Inet4Address LOOPBACK4 = (Inet4Address) forString(\"127.0.0.1\");\n    private static final Inet4Address ANY4 = (Inet4Address) forString(\"0.0.0.0\");\n\n    private InetAddresses() {}\n\n    /**\n     * Returns an {@link Inet4Address}, given a byte array representation of the IPv4 address.\n     *\n     * @param bytes byte array representing an IPv4 address (should be of length 4)\n     * @return {@link Inet4Address} corresponding to the supplied byte array\n     * @throws IllegalArgumentException if a valid {@link Inet4Address} can not be created\n     */\n    private static Inet4Address getInet4Address(byte[] bytes)\n    {\n        checkArgument(\n            bytes.length == 4,\n            \"Byte array has invalid length for an IPv4 address: %s != 4.\",\n            bytes.length);\n\n        // Given a 4-byte array, this cast should always succeed.\n        return (Inet4Address) bytesToInetAddress(bytes);\n    }\n\n    /**\n     * Returns the {@link InetAddress} having the given string representation.\n     *\n     * <p>This deliberately avoids all nameservice lookups (e.g. no DNS).\n     *\n     * @param ipString {@code String} containing an IPv4 or IPv6 string literal, e.g. {@code\n     *     \"192.168.0.1\"} or {@code \"2001:db8::1\"}\n     * @return {@link InetAddress} representing the argument\n     * @throws IllegalArgumentException if the argument is not a valid IP string literal\n     */\n    public static InetAddress forString(String ipString)\n    {\n        byte[] addr = ipStringToBytes(ipString);\n\n        // The argument was malformed, i.e. not an IP string literal.\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"'%s' is not an IP string literal.\", ipString);\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP string literal\n     * @return {@code true} if the argument is a valid IP string literal\n     */\n    public static boolean isInetAddress(String ipString)\n    {\n        return ipStringToBytes(ipString) != null;\n    }\n\n    @NullableDecl\n    private static byte[] ipStringToBytes(String ipString)\n    {\n        // Make a first pass to categorize the characters in this string.\n        boolean hasColon = false;\n        boolean hasDot = false;\n        for (int i = 0; i < ipString.length(); i++)\n        {\n            char c = ipString.charAt(i);\n            if (c == '.')\n            {\n                hasDot = true;\n            }\n            else if (c == ':')\n            {\n                if (hasDot)\n                {\n                    return null; // Colons must not appear after dots.\n                }\n                hasColon = true;\n            }\n            else if (Character.digit(c, 16) == -1)\n            {\n                return null; // Everything else must be a decimal or hex digit.\n            }\n        }\n\n        // Now decide which address family to parse.\n        if (hasColon)\n        {\n            if (hasDot)\n            {\n                ipString = convertDottedQuadToHex(ipString);\n                if (ipString == null)\n                {\n                    return null;\n                }\n            }\n            return textToNumericFormatV6(ipString);\n        }\n        else if (hasDot)\n        {\n            return textToNumericFormatV4(ipString);\n        }\n        return null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV4(String ipString)\n    {\n        byte[] bytes = new byte[IPV4_PART_COUNT];\n        int i = 0;\n        try\n        {\n            for (String octet : IPV4_SPLITTER.split(ipString))\n            {\n                bytes[i++] = parseOctet(octet);\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n\n        return i == IPV4_PART_COUNT ? bytes : null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV6(String ipString)\n    {\n        // An address can have [2..8] colons, and N colons make N+1 parts.\n        List<String> parts = IPV6_SPLITTER.splitToList(ipString);\n        if (parts.size() < 3 || parts.size() > IPV6_PART_COUNT + 1)\n        {\n            return null;\n        }\n\n        // Disregarding the endpoints, find \"::\" with nothing in between.\n        // This indicates that a run of zeroes has been skipped.\n        int skipIndex = -1;\n        for (int i = 1; i < parts.size() - 1; i++)\n        {\n            if (parts.get(i).length() == 0)\n            {\n                if (skipIndex >= 0)\n                {\n                    return null; // Can't have more than one ::\n                }\n                skipIndex = i;\n            }\n        }\n\n        int partsHi; // Number of parts to copy from above/before the \"::\"\n        int partsLo; // Number of parts to copy from below/after the \"::\"\n        if (skipIndex >= 0)\n        {\n            // If we found a \"::\", then check if it also covers the endpoints.\n            partsHi = skipIndex;\n            partsLo = parts.size() - skipIndex - 1;\n            if (parts.get(0).length() == 0 && --partsHi != 0)\n            {\n                return null; // ^: requires ^::\n            }\n            if (Iterables.getLast(parts).length() == 0 && --partsLo != 0)\n            {\n                return null; // :$ requires ::$\n            }\n        }\n        else\n        {\n            // Otherwise, allocate the entire address to partsHi. The endpoints\n            // could still be empty, but parseHextet() will check for that.\n            partsHi = parts.size();\n            partsLo = 0;\n        }\n\n        // If we found a ::, then we must have skipped at least one part.\n        // Otherwise, we must have exactly the right number of parts.\n        int partsSkipped = IPV6_PART_COUNT - (partsHi + partsLo);\n        if (!(skipIndex >= 0 ? partsSkipped >= 1 : partsSkipped == 0))\n        {\n            return null;\n        }\n\n        // Now parse the hextets into a byte array.\n        ByteBuffer rawBytes = ByteBuffer.allocate(2 * IPV6_PART_COUNT);\n        try\n        {\n            for (int i = 0; i < partsHi; i++)\n            {\n                rawBytes.putShort(parseHextet(parts.get(i)));\n            }\n            for (int i = 0; i < partsSkipped; i++)\n            {\n                rawBytes.putShort((short) 0);\n            }\n            for (int i = partsLo; i > 0; i--)\n            {\n                rawBytes.putShort(parseHextet(parts.get(parts.size() - i)));\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n        return rawBytes.array();\n    }\n\n    @NullableDecl\n    private static String convertDottedQuadToHex(String ipString)\n    {\n        int lastColon = ipString.lastIndexOf(':');\n        String initialPart = ipString.substring(0, lastColon + 1);\n        String dottedQuad = ipString.substring(lastColon + 1);\n        byte[] quad = textToNumericFormatV4(dottedQuad);\n        if (quad == null)\n        {\n            return null;\n        }\n        String penultimate = Integer.toHexString(((quad[0] & 0xff) << 8) | (quad[1] & 0xff));\n        String ultimate = Integer.toHexString(((quad[2] & 0xff) << 8) | (quad[3] & 0xff));\n        return initialPart + penultimate + \":\" + ultimate;\n    }\n\n    private static byte parseOctet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int octet = Integer.parseInt(ipPart);\n        // Disallow leading zeroes, because no clear standard exists on\n        // whether these should be interpreted as decimal or octal.\n        if (octet > 255 || (ipPart.startsWith(\"0\") && ipPart.length() > 1))\n        {\n            throw new NumberFormatException();\n        }\n        return (byte) octet;\n    }\n\n    private static short parseHextet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int hextet = Integer.parseInt(ipPart, 16);\n        if (hextet > 0xffff)\n        {\n            throw new NumberFormatException();\n        }\n        return (short) hextet;\n    }\n\n    /**\n     * Convert a byte array into an InetAddress.\n     *\n     * <p>{@link InetAddress#getByAddress} is documented as throwing a checked exception \"if IP\n     * address is of illegal length.\" We replace it with an unchecked exception, for use by callers\n     * who already know that addr is an array of length 4 or 16.\n     *\n     * @param addr the raw 4-byte or 16-byte IP address in big-endian order\n     * @return an InetAddress object created from the raw IP address\n     */\n    private static InetAddress bytesToInetAddress(byte[] addr)\n    {\n        try\n        {\n            return InetAddress.getByAddress(addr);\n        }\n        catch (UnknownHostException e)\n        {\n            throw new AssertionError(e);\n        }\n    }\n\n    /**\n     * Returns the string representation of an {@link InetAddress}.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses, the output follows <a href=\"http://tools.ietf.org/html/rfc5952\">RFC 5952</a> section\n     * 4. The main difference is that this method uses \"::\" for zero compression, while Java's version\n     * uses the uncompressed form.\n     *\n     * <p>This method uses hexadecimal for all IPv6 addresses, including IPv4-mapped IPv6 addresses\n     * such as \"::c000:201\". The output does not include a Scope ID.\n     *\n     * @param ip {@link InetAddress} to be converted to an address string\n     * @return {@code String} containing the text-formatted IP address\n     * @since 10.0\n     */\n    public static String toAddrString(InetAddress ip)\n    {\n        checkNotNull(ip);\n        if (ip instanceof Inet4Address)\n        {\n            // For IPv4, Java's formatting is good enough.\n            return ip.getHostAddress();\n        }\n        checkArgument(ip instanceof Inet6Address);\n        byte[] bytes = ip.getAddress();\n        int[] hextets = new int[IPV6_PART_COUNT];\n        for (int i = 0; i < hextets.length; i++)\n        {\n            hextets[i] = Ints.fromBytes((byte) 0, (byte) 0, bytes[2 * i], bytes[2 * i + 1]);\n        }\n        compressLongestRunOfZeroes(hextets);\n        return hextetsToIPv6String(hextets);\n    }\n\n    /**\n     * Identify and mark the longest run of zeroes in an IPv6 address.\n     *\n     * <p>Only runs of two or more hextets are considered. In case of a tie, the leftmost run wins. If\n     * a qualifying run is found, its hextets are replaced by the sentinel value -1.\n     *\n     * @param hextets {@code int[]} mutable array of eight 16-bit hextets\n     */\n    private static void compressLongestRunOfZeroes(int[] hextets)\n    {\n        int bestRunStart = -1;\n        int bestRunLength = -1;\n        int runStart = -1;\n        for (int i = 0; i < hextets.length + 1; i++)\n        {\n            if (i < hextets.length && hextets[i] == 0)\n            {\n                if (runStart < 0)\n                {\n                    runStart = i;\n                }\n            }\n            else if (runStart >= 0)\n            {\n                int runLength = i - runStart;\n                if (runLength > bestRunLength)\n                {\n                    bestRunStart = runStart;\n                    bestRunLength = runLength;\n                }\n                runStart = -1;\n            }\n        }\n        if (bestRunLength >= 2)\n        {\n            Arrays.fill(hextets, bestRunStart, bestRunStart + bestRunLength, -1);\n        }\n    }\n\n    /**\n     * Convert a list of hextets into a human-readable IPv6 address.\n     *\n     * <p>In order for \"::\" compression to work, the input should contain negative sentinel values in\n     * place of the elided zeroes.\n     *\n     * @param hextets {@code int[]} array of eight 16-bit hextets, or -1s\n     */\n    private static String hextetsToIPv6String(int[] hextets)\n    {\n        // While scanning the array, handle these state transitions:\n        //   start->num => \"num\"     start->gap => \"::\"\n        //   num->num   => \":num\"    num->gap   => \"::\"\n        //   gap->num   => \"num\"     gap->gap   => \"\"\n        StringBuilder buf = new StringBuilder(39);\n        boolean lastWasNumber = false;\n        for (int i = 0; i < hextets.length; i++)\n        {\n            boolean thisIsNumber = hextets[i] >= 0;\n            if (thisIsNumber)\n            {\n                if (lastWasNumber)\n                {\n                    buf.append(':');\n                }\n                buf.append(Integer.toHexString(hextets[i]));\n            }\n            else\n            {\n                if (i == 0 || lastWasNumber)\n                {\n                    buf.append(\"::\");\n                }\n            }\n            lastWasNumber = thisIsNumber;\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Returns the string representation of an {@link InetAddress} suitable for inclusion in a URI.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses it compresses zeroes and surrounds the text with square brackets; for example {@code\n     * \"[2001:db8::1]\"}.\n     *\n     * <p>Per section 3.2.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3986#section-3.2.2\">RFC 3986</a>, a URI containing an IPv6\n     * string literal is of the form {@code \"http://[2001:db8::1]:8888/index.html\"}.\n     *\n     * <p>Use of either {@link InetAddresses#toAddrString}, {@link InetAddress#getHostAddress()}, or\n     * this method is recommended over {@link InetAddress#toString()} when an IP address string\n     * literal is desired. This is because {@link InetAddress#toString()} prints the hostname and the\n     * IP address string joined by a \"/\".\n     *\n     * @param ip {@link InetAddress} to be converted to URI string literal\n     * @return {@code String} containing URI-safe string literal\n     */\n    public static String toUriString(InetAddress ip)\n    {\n        if (ip instanceof Inet6Address)\n        {\n            return \"[\" + toAddrString(ip) + \"]\";\n        }\n        return toAddrString(ip);\n    }\n\n    /**\n     * Returns an InetAddress representing the literal IPv4 or IPv6 host portion of a URL, encoded in\n     * the format specified by RFC 3986 section 3.2.2.\n     *\n     * <p>This function is similar to {@link InetAddresses#forString(String)}, however, it requires\n     * that IPv6 addresses are surrounded by square brackets.\n     *\n     * <p>This function is the inverse of {@link InetAddresses#toUriString(java.net.InetAddress)}.\n     *\n     * @param hostAddr A RFC 3986 section 3.2.2 encoded IPv4 or IPv6 address\n     * @return an InetAddress representing the address in {@code hostAddr}\n     * @throws IllegalArgumentException if {@code hostAddr} is not a valid IPv4 address, or IPv6\n     *     address surrounded by square brackets\n     */\n    public static InetAddress forUriString(String hostAddr)\n    {\n        InetAddress addr = forUriStringNoThrow(hostAddr);\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"Not a valid URI IP literal: '%s'\", hostAddr);\n        }\n\n        return addr;\n    }\n\n    @NullableDecl\n    private static InetAddress forUriStringNoThrow(String hostAddr)\n    {\n        checkNotNull(hostAddr);\n\n        // Decide if this should be an IPv6 or IPv4 address.\n        String ipString;\n        int expectBytes;\n        if (hostAddr.startsWith(\"[\") && hostAddr.endsWith(\"]\"))\n        {\n            ipString = hostAddr.substring(1, hostAddr.length() - 1);\n            expectBytes = 16;\n        }\n        else\n        {\n            ipString = hostAddr;\n            expectBytes = 4;\n        }\n\n        // Parse the address, and make sure the length/version is correct.\n        byte[] addr = ipStringToBytes(ipString);\n        if (addr == null || addr.length != expectBytes)\n        {\n            return null;\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid URI IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP URI host string literal\n     * @return {@code true} if the argument is a valid IP URI host\n     */\n    public static boolean isUriInetAddress(String ipString)\n    {\n        return forUriStringNoThrow(ipString) != null;\n    }\n\n    /**\n     * Evaluates whether the argument is an IPv6 \"compat\" address.\n     *\n     * <p>An \"IPv4 compatible\", or \"compat\", address is one with 96 leading bits of zero, with the\n     * remaining 32 bits interpreted as an IPv4 address. These are conventionally represented in\n     * string literals as {@code \"::192.168.0.1\"}, though {@code \"::c0a8:1\"} is also considered an\n     * IPv4 compatible address (and equivalent to {@code \"::192.168.0.1\"}).\n     *\n     * <p>For more on IPv4 compatible addresses see section 2.5.5.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.1\">RFC 4291</a>.\n     *\n     * <p>NOTE: This method is different from {@link Inet6Address#isIPv4CompatibleAddress} in that it\n     * more correctly classifies {@code \"::\"} and {@code \"::1\"} as proper IPv6 addresses (which they\n     * are), NOT IPv4 compatible addresses (which they are generally NOT considered to be).\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 compatible address format\n     * @return {@code true} if the argument is a valid \"compat\" address\n     */\n    public static boolean isCompatIPv4Address(Inet6Address ip)\n    {\n        if (!ip.isIPv4CompatibleAddress())\n        {\n            return false;\n        }\n\n        byte[] bytes = ip.getAddress();\n        if ((bytes[12] == 0)\n                && (bytes[13] == 0)\n                && (bytes[14] == 0)\n                && ((bytes[15] == 0) || (bytes[15] == 1)))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the IPv4 address embedded in an IPv4 compatible address.\n     *\n     * @param ip {@link Inet6Address} to be examined for an embedded IPv4 address\n     * @return {@link Inet4Address} of the embedded IPv4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv4 compatible address\n     */\n    public static Inet4Address getCompatIPv4Address(Inet6Address ip)\n    {\n        checkArgument(\n            isCompatIPv4Address(ip), \"Address '%s' is not IPv4-compatible.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n    }\n\n    /**\n     * Evaluates whether the argument is a 6to4 address.\n     *\n     * <p>6to4 addresses begin with the {@code \"2002::/16\"} prefix. The next 32 bits are the IPv4\n     * address of the host to which IPv6-in-IPv4 tunneled packets should be routed.\n     *\n     * <p>For more on 6to4 addresses see section 2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3056#section-2\">RFC 3056</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for 6to4 address format\n     * @return {@code true} if the argument is a 6to4 address\n     */\n    public static boolean is6to4Address(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20) && (bytes[1] == (byte) 0x02);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in a 6to4 address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in 6to4 address\n     * @return {@link Inet4Address} of embedded IPv4 in 6to4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 6to4 address\n     */\n    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n    {\n        checkArgument(is6to4Address(ip), \"Address '%s' is not a 6to4 address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 2, 6));\n    }\n\n    /**\n     * A simple immutable data class to encapsulate the information to be found in a Teredo address.\n     *\n     * <p>All of the fields in this class are encoded in various portions of the IPv6 address as part\n     * of the protocol. More protocols details can be found at: <a target=\"_parent\"\n     * href=\"http://en.wikipedia.org/wiki/Teredo_tunneling\">http://en.wikipedia.\n     * org/wiki/Teredo_tunneling</a>.\n     *\n     * <p>The RFC can be found here: <a target=\"_parent\" href=\"http://tools.ietf.org/html/rfc4380\">RFC\n     * 4380</a>.\n     *\n     * @since 5.0\n     */\n    @Beta\n    public static final class TeredoInfo\n    {\n        private final Inet4Address server;\n        private final Inet4Address client;\n        private final int port;\n        private final int flags;\n\n        /**\n         * Constructs a TeredoInfo instance.\n         *\n         * <p>Both server and client can be {@code null}, in which case the value {@code \"0.0.0.0\"} will\n         * be assumed.\n         *\n         * @throws IllegalArgumentException if either of the {@code port} or the {@code flags} arguments\n         *     are out of range of an unsigned short\n         */\n        // TODO: why is this public?\n        public TeredoInfo(\n            @NullableDecl Inet4Address server, @NullableDecl Inet4Address client, int port, int flags)\n        {\n            checkArgument(\n                (port >= 0) && (port <= 0xffff), \"port '%s' is out of range (0 <= port <= 0xffff)\", port);\n            checkArgument(\n                (flags >= 0) && (flags <= 0xffff),\n                \"flags '%s' is out of range (0 <= flags <= 0xffff)\",\n                flags);\n\n            this.server = MoreObjects.firstNonNull(server, ANY4);\n            this.client = MoreObjects.firstNonNull(client, ANY4);\n            this.port = port;\n            this.flags = flags;\n        }\n\n        public Inet4Address getServer()\n        {\n            return server;\n        }\n\n        public Inet4Address getClient()\n        {\n            return client;\n        }\n\n        public int getPort()\n        {\n            return port;\n        }\n\n        public int getFlags()\n        {\n            return flags;\n        }\n    }\n\n    /**\n     * Evaluates whether the argument is a Teredo address.\n     *\n     * <p>Teredo addresses begin with the {@code \"2001::/32\"} prefix.\n     *\n     * @param ip {@link Inet6Address} to be examined for Teredo address format\n     * @return {@code true} if the argument is a Teredo address\n     */\n    public static boolean isTeredoAddress(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20)\n               && (bytes[1] == (byte) 0x01)\n               && (bytes[2] == 0)\n               && (bytes[3] == 0);\n    }\n\n    /**\n     * Returns the Teredo information embedded in a Teredo address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded Teredo information\n     * @return extracted {@code TeredoInfo}\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 Teredo address\n     */\n    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n    {\n        checkArgument(isTeredoAddress(ip), \"Address '%s' is not a Teredo address.\", toAddrString(ip));\n\n        byte[] bytes = ip.getAddress();\n        Inet4Address server = getInet4Address(Arrays.copyOfRange(bytes, 4, 8));\n\n        int flags = ByteStreams.newDataInput(bytes, 8).readShort() & 0xffff;\n\n        // Teredo obfuscates the mapped client port, per section 4 of the RFC.\n        int port = ~ByteStreams.newDataInput(bytes, 10).readShort() & 0xffff;\n\n        byte[] clientBytes = Arrays.copyOfRange(bytes, 12, 16);\n        for (int i = 0; i < clientBytes.length; i++)\n        {\n            // Teredo obfuscates the mapped client IP, per section 4 of the RFC.\n            clientBytes[i] = (byte) ~clientBytes[i];\n        }\n        Inet4Address client = getInet4Address(clientBytes);\n\n        return new TeredoInfo(server, client, port, flags);\n    }\n\n    /**\n     * Evaluates whether the argument is an ISATAP address.\n     *\n     * <p>From RFC 5214: \"ISATAP interface identifiers are constructed in Modified EUI-64 format [...]\n     * by concatenating the 24-bit IANA OUI (00-00-5E), the 8-bit hexadecimal value 0xFE, and a 32-bit\n     * IPv4 address in network byte order [...]\"\n     *\n     * <p>For more on ISATAP addresses see section 6.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc5214#section-6.1\">RFC 5214</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for ISATAP address format\n     * @return {@code true} if the argument is an ISATAP address\n     */\n    public static boolean isIsatapAddress(Inet6Address ip)\n    {\n\n        // If it's a Teredo address with the right port (41217, or 0xa101)\n        // which would be encoded as 0x5efe then it can't be an ISATAP address.\n        if (isTeredoAddress(ip))\n        {\n            return false;\n        }\n\n        byte[] bytes = ip.getAddress();\n\n        if ((bytes[8] | (byte) 0x03) != (byte) 0x03)\n        {\n\n            // Verify that high byte of the 64 bit identifier is zero, modulo\n            // the U/L and G bits, with which we are not concerned.\n            return false;\n        }\n\n        return (bytes[9] == (byte) 0x00) && (bytes[10] == (byte) 0x5e) && (bytes[11] == (byte) 0xfe);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in an ISATAP address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in ISATAP address\n     * @return {@link Inet4Address} of embedded IPv4 in an ISATAP address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 ISATAP address\n     */\n\n    /**\n     * Examines the Inet6Address to determine if it is an IPv6 address of one of the specified address\n     * types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@code true} if there is an embedded IPv4 client address\n     * @since 7.0\n     */\n    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        return isCompatIPv4Address(ip) || is6to4Address(ip) || isTeredoAddress(ip);\n    }\n\n    /**\n     * Examines the Inet6Address to extract the embedded IPv4 client address if the InetAddress is an\n     * IPv6 address of one of the specified address types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@link Inet4Address} of embedded IPv4 client address\n     * @throws IllegalArgumentException if the argument does not have a valid embedded IPv4 address\n     */\n    public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        if (isCompatIPv4Address(ip))\n        {\n            return getCompatIPv4Address(ip);\n        }\n\n        if (is6to4Address(ip))\n        {\n            return get6to4IPv4Address(ip);\n        }\n\n        if (isTeredoAddress(ip))\n        {\n            return getTeredoInfo(ip).getClient();\n        }\n\n        throw formatIllegalArgumentException(\"'%s' has no embedded IPv4 address.\", toAddrString(ip));\n    }\n\n    /**\n     * Evaluates whether the argument is an \"IPv4 mapped\" IPv6 address.\n     *\n     * <p>An \"IPv4 mapped\" address is anything in the range ::ffff:0:0/96 (sometimes written as\n     * ::ffff:0.0.0.0/96), with the last 32 bits interpreted as an IPv4 address.\n     *\n     * <p>For more on IPv4 mapped addresses see section 2.5.5.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.2\">RFC 4291</a>.\n     *\n     * <p>Note: This method takes a {@code String} argument because {@link InetAddress} automatically\n     * collapses mapped addresses to IPv4. (It is actually possible to avoid this using one of the\n     * obscure {@link Inet6Address} methods, but it would be unwise to depend on such a\n     * poorly-documented feature.)\n     *\n     * @param ipString {@code String} to be examined for embedded IPv4-mapped IPv6 address format\n     * @return {@code true} if the argument is a valid \"mapped\" address\n     * @since 10.0\n     */\n    public static boolean isMappedIPv4Address(String ipString)\n    {\n        byte[] bytes = ipStringToBytes(ipString);\n        if (bytes != null && bytes.length == 16)\n        {\n            for (int i = 0; i < 10; i++)\n            {\n                if (bytes[i] != 0)\n                {\n                    return false;\n                }\n            }\n            for (int i = 10; i < 12; i++)\n            {\n                if (bytes[i] != (byte) 0xff)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Coerces an IPv6 address into an IPv4 address.\n     *\n     * <p>HACK: As long as applications continue to use IPv4 addresses for indexing into tables,\n     * accounting, et cetera, it may be necessary to <b>coerce</b> IPv6 addresses into IPv4 addresses.\n     * This function does so by hashing the upper 64 bits into {@code 224.0.0.0/3} (64 bits into 29\n     * bits).\n     *\n     * <p>A \"coerced\" IPv4 address is equivalent to itself.\n     *\n     * <p>NOTE: This function is failsafe for security purposes: ALL IPv6 addresses (except localhost\n     * (::1)) are hashed to avoid the security risk associated with extracting an embedded IPv4\n     * address that might permit elevated privileges.\n     *\n     * @param ip {@link InetAddress} to \"coerce\"\n     * @return {@link Inet4Address} represented \"coerced\" address\n     * @since 7.0\n     */\n    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n    {\n        if (ip instanceof Inet4Address)\n        {\n            return (Inet4Address) ip;\n        }\n\n        // Special cases:\n        byte[] bytes = ip.getAddress();\n        boolean leadingBytesOfZero = true;\n        for (int i = 0; i < 15; ++i)\n        {\n            if (bytes[i] != 0)\n            {\n                leadingBytesOfZero = false;\n                break;\n            }\n        }\n        if (leadingBytesOfZero && (bytes[15] == 1))\n        {\n            return LOOPBACK4; // ::1\n        }\n        else if (leadingBytesOfZero && (bytes[15] == 0))\n        {\n            return ANY4; // ::0\n        }\n\n        Inet6Address ip6 = (Inet6Address) ip;\n        long addressAsLong = 0;\n        if (hasEmbeddedIPv4ClientAddress(ip6))\n        {\n            addressAsLong = getEmbeddedIPv4ClientAddress(ip6).hashCode();\n        }\n        else\n        {\n\n            // Just extract the high 64 bits (assuming the rest is user-modifiable).\n            addressAsLong = ByteBuffer.wrap(ip6.getAddress(), 0, 8).getLong();\n        }\n\n        // Many strategies for hashing are possible. This might suffice for now.\n        int coercedHash = Hashing.murmur3_32().hashLong(addressAsLong).asInt();\n\n        // Squash into 224/4 Multicast and 240/4 Reserved space (i.e. 224/3).\n        coercedHash |= 0xe0000000;\n\n        // Fixup to avoid some \"illegal\" values. Currently the only potential\n        // illegal value is 255.255.255.255.\n        if (coercedHash == 0xffffffff)\n        {\n            coercedHash = 0xfffffffe;\n        }\n\n        return getInet4Address(Ints.toByteArray(coercedHash));\n    }\n\n    /**\n     * Returns an integer representing an IPv4 address regardless of whether the supplied argument is\n     * an IPv4 address or not.\n     *\n     * <p>IPv6 addresses are <b>coerced</b> to IPv4 addresses before being converted to integers.\n     *\n     * <p>As long as there are applications that assume that all IP addresses are IPv4 addresses and\n     * can therefore be converted safely to integers (for whatever purpose) this function can be used\n     * to handle IPv6 addresses as well until the application is suitably fixed.\n     *\n     * <p>NOTE: an IPv6 address coerced to an IPv4 address can only be used for such purposes as\n     * rudimentary identification or indexing into a collection of real {@link InetAddress}es. They\n     * cannot be used as real addresses for the purposes of network communication.\n     *\n     * @param ip {@link InetAddress} to convert\n     * @return {@code int}, \"coerced\" if ip is not an IPv4 address\n     * @since 7.0\n     */\n    public static int coerceToInteger(InetAddress ip)\n    {\n        return ByteStreams.newDataInput(getCoercedIPv4Address(ip).getAddress()).readInt();\n    }\n\n    /**\n     * Returns an Inet4Address having the integer value specified by the argument.\n     *\n     * @param address {@code int}, the 32bit integer address to be converted\n     * @return {@link Inet4Address} equivalent of the argument\n     */\n    public static Inet4Address fromInteger(int address)\n    {\n        return getInet4Address(Ints.toByteArray(address));\n    }\n\n    /**\n     * Returns an address from a <b>little-endian ordered</b> byte array (the opposite of what {@link\n     * InetAddress#getByAddress} expects).\n     *\n     * <p>IPv4 address byte array must be 4 bytes long and IPv6 byte array must be 16 bytes long.\n     *\n     * @param addr the raw IP address in little-endian byte order\n     * @return an InetAddress object created from the raw IP address\n     * @throws UnknownHostException if IP address is of illegal length\n     */\n    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n    {\n        byte[] reversed = new byte[addr.length];\n        for (int i = 0; i < addr.length; i++)\n        {\n            reversed[i] = addr[addr.length - i - 1];\n        }\n        return InetAddress.getByAddress(reversed);\n    }\n\n    /**\n     * Returns a new InetAddress that is one less than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to decrement\n     * @return a new InetAddress that is one less than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the beginning of its range\n     * @since 18.0\n     */\n    public static InetAddress decrement(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0x00)\n        {\n            addr[i] = (byte) 0xff;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Decrementing %s would wrap.\", address);\n\n        addr[i]--;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns a new InetAddress that is one more than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to increment\n     * @return a new InetAddress that is one more than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the end of its range\n     * @since 10.0\n     */\n    public static InetAddress increment(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0xff)\n        {\n            addr[i] = 0;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Incrementing %s would wrap.\", address);\n\n        addr[i]++;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns true if the InetAddress is either 255.255.255.255 for IPv4 or\n     * ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6.\n     *\n     * @return true if the InetAddress is either 255.255.255.255 for IPv4 or\n     *     ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6\n     * @since 10.0\n     */\n    public static boolean isMaximum(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        for (int i = 0; i < addr.length; i++)\n        {\n            if (addr[i] != (byte) 0xff)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static IllegalArgumentException formatIllegalArgumentException(\n        String format, Object... args)\n    {\n        return new IllegalArgumentException(String.format(Locale.ROOT, format, args));\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.getEmbeddedIPv4ClientAddress", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Examines the Inet6Address to extract the embedded IPv4 client address if the InetAddress is an\nIPv6 address of one of the specified address types that contain an embedded IPv4 address.\n\n<p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\nspoofability. With other transition addresses spoofing involves (at least) infection of one's\nBGP routing table.\n\n@param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n@return {@link Inet4Address} of embedded IPv4 client address\n@throws IllegalArgumentException if the argument does not have a valid embedded IPv4 address", "docstring_tokens": ["Examines", "the", "Inet6Address", "to", "extract", "the", "embedded", "IPv4", "client", "address", "if", "the", "InetAddress", "is", "an", "IPv6", "address", "of", "one", "of", "the", "specified", "address", "types", "that", "contain", "an", "embedded", "IPv4", "address", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L761-L775", "partition": "valid", "up_fun_num": 28, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.MoreObjects;", "import com.google.common.base.Splitter;", "import com.google.common.collect.Iterables;", "import com.google.common.hash.Hashing;", "import com.google.common.io.ByteStreams;", "import com.google.common.primitives.Ints;", "import java.net.Inet4Address;", "import java.net.Inet6Address;", "import java.net.InetAddress;", "import java.net.UnknownHostException;", "import java.nio.ByteBuffer;", "import java.util.Arrays;", "import java.util.List;", "import java.util.Locale;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class InetAddresses\n", "    private static Inet4Address getInet4Address(byte[] bytes)\n", "    public static InetAddress forString(String ipString)\n", "    public static boolean isInetAddress(String ipString)\n", "    private static byte[] ipStringToBytes(String ipString)\n", "    private static byte[] textToNumericFormatV4(String ipString)\n", "    private static byte[] textToNumericFormatV6(String ipString)\n", "    private static String convertDottedQuadToHex(String ipString)\n", "    private static byte parseOctet(String ipPart)\n", "    private static short parseHextet(String ipPart)\n", "    private static InetAddress bytesToInetAddress(byte[] addr)\n", "    public static String toAddrString(InetAddress ip)\n", "    private static void compressLongestRunOfZeroes(int[] hextets)\n", "    private static String hextetsToIPv6String(int[] hextets)\n", "    public static String toUriString(InetAddress ip)\n", "    public static InetAddress forUriString(String hostAddr)\n", "    private static InetAddress forUriStringNoThrow(String hostAddr)\n", "    public static boolean isUriInetAddress(String ipString)\n", "    public static boolean isCompatIPv4Address(Inet6Address ip)\n", "    public static Inet4Address getCompatIPv4Address(Inet6Address ip)\n", "    public static boolean is6to4Address(Inet6Address ip)\n", "    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n", "    public static boolean isTeredoAddress(Inet6Address ip)\n", "    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n", "    public static boolean isIsatapAddress(Inet6Address ip)\n", "    public static Inet4Address getIsatapIPv4Address(Inet6Address ip)\n", "    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static boolean isMappedIPv4Address(String ipString)\n", "    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n", "    public static int coerceToInteger(InetAddress ip)\n", "    public static Inet4Address fromInteger(int address)\n", "    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n", "    public static InetAddress decrement(InetAddress address)\n", "    public static InetAddress increment(InetAddress address)\n", "    public static boolean isMaximum(InetAddress address)\n", "    private static IllegalArgumentException formatIllegalArgumentException(\n"], "context": "/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.net;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.Iterables;\nimport com.google.common.hash.Hashing;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.primitives.Ints;\nimport java.net.Inet4Address;\nimport java.net.Inet6Address;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * Static utility methods pertaining to {@link InetAddress} instances.\n *\n * <p><b>Important note:</b> Unlike {@code InetAddress.getByName()}, the methods of this class never\n * cause DNS services to be accessed. For this reason, you should prefer these methods as much as\n * possible over their JDK equivalents whenever you are expecting to handle only IP address string\n * literals -- there is no blocking DNS penalty for a malformed string.\n *\n * <p>When dealing with {@link Inet4Address} and {@link Inet6Address} objects as byte arrays (vis.\n * {@code InetAddress.getAddress()}) they are 4 and 16 bytes in length, respectively, and represent\n * the address in network byte order.\n *\n * <p>Examples of IP addresses and their byte representations:\n *\n * <dl>\n *   <dt>The IPv4 loopback address, {@code \"127.0.0.1\"}.\n *   <dd>{@code 7f 00 00 01}\n *   <dt>The IPv6 loopback address, {@code \"::1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>From the IPv6 reserved documentation prefix ({@code 2001:db8::/32}), {@code \"2001:db8::1\"}.\n *   <dd>{@code 20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>An IPv6 \"IPv4 compatible\" (or \"compat\") address, {@code \"::192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 c0 a8 00 01}\n *   <dt>An IPv6 \"IPv4 mapped\" address, {@code \"::ffff:192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 ff ff c0 a8 00 01}\n * </dl>\n *\n * <p>A few notes about IPv6 \"IPv4 mapped\" addresses and their observed use in Java.\n *\n * <p>\"IPv4 mapped\" addresses were originally a representation of IPv4 addresses for use on an IPv6\n * socket that could receive both IPv4 and IPv6 connections (by disabling the {@code IPV6_V6ONLY}\n * socket option on an IPv6 socket). Yes, it's confusing. Nevertheless, these \"mapped\" addresses\n * were never supposed to be seen on the wire. That assumption was dropped, some say mistakenly, in\n * later RFCs with the apparent aim of making IPv4-to-IPv6 transition simpler.\n *\n * <p>Technically one <i>can</i> create a 128bit IPv6 address with the wire format of a \"mapped\"\n * address, as shown above, and transmit it in an IPv6 packet header. However, Java's InetAddress\n * creation methods appear to adhere doggedly to the original intent of the \"mapped\" address: all\n * \"mapped\" addresses return {@link Inet4Address} objects.\n *\n * <p>For added safety, it is common for IPv6 network operators to filter all packets where either\n * the source or destination address appears to be a \"compat\" or \"mapped\" address. Filtering\n * suggestions usually recommend discarding any packets with source or destination addresses in the\n * invalid range {@code ::/3}, which includes both of these bizarre address formats. For more\n * information on \"bogons\", including lists of IPv6 bogon space, see:\n *\n * <ul>\n *   <li><a target=\"_parent\"\n *       href=\"http://en.wikipedia.org/wiki/Bogon_filtering\">http://en.wikipedia.\n *       org/wiki/Bogon_filtering</a>\n *   <li><a target=\"_parent\"\n *       href=\"http://www.cymru.com/Bogons/ipv6.txt\">http://www.cymru.com/Bogons/ ipv6.txt</a>\n *   <li><a target=\"_parent\" href=\"http://www.cymru.com/Bogons/v6bogon.html\">http://www.cymru.com/\n *       Bogons/v6bogon.html</a>\n *   <li><a target=\"_parent\" href=\"http://www.space.net/~gert/RIPE/ipv6-filters.html\">http://www.\n *       space.net/~gert/RIPE/ipv6-filters.html</a>\n * </ul>\n *\n * @author Erik Kline\n * @since 5.0\n */\n@Beta\n@GwtIncompatible\npublic final class InetAddresses\n{\n    private static final int IPV4_PART_COUNT = 4;\n    private static final int IPV6_PART_COUNT = 8;\n    private static final Splitter IPV4_SPLITTER = Splitter.on('.').limit(IPV4_PART_COUNT);\n    private static final Splitter IPV6_SPLITTER = Splitter.on(':').limit(IPV6_PART_COUNT + 2);\n    private static final Inet4Address LOOPBACK4 = (Inet4Address) forString(\"127.0.0.1\");\n    private static final Inet4Address ANY4 = (Inet4Address) forString(\"0.0.0.0\");\n\n    private InetAddresses() {}\n\n    /**\n     * Returns an {@link Inet4Address}, given a byte array representation of the IPv4 address.\n     *\n     * @param bytes byte array representing an IPv4 address (should be of length 4)\n     * @return {@link Inet4Address} corresponding to the supplied byte array\n     * @throws IllegalArgumentException if a valid {@link Inet4Address} can not be created\n     */\n    private static Inet4Address getInet4Address(byte[] bytes)\n    {\n        checkArgument(\n            bytes.length == 4,\n            \"Byte array has invalid length for an IPv4 address: %s != 4.\",\n            bytes.length);\n\n        // Given a 4-byte array, this cast should always succeed.\n        return (Inet4Address) bytesToInetAddress(bytes);\n    }\n\n    /**\n     * Returns the {@link InetAddress} having the given string representation.\n     *\n     * <p>This deliberately avoids all nameservice lookups (e.g. no DNS).\n     *\n     * @param ipString {@code String} containing an IPv4 or IPv6 string literal, e.g. {@code\n     *     \"192.168.0.1\"} or {@code \"2001:db8::1\"}\n     * @return {@link InetAddress} representing the argument\n     * @throws IllegalArgumentException if the argument is not a valid IP string literal\n     */\n    public static InetAddress forString(String ipString)\n    {\n        byte[] addr = ipStringToBytes(ipString);\n\n        // The argument was malformed, i.e. not an IP string literal.\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"'%s' is not an IP string literal.\", ipString);\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP string literal\n     * @return {@code true} if the argument is a valid IP string literal\n     */\n    public static boolean isInetAddress(String ipString)\n    {\n        return ipStringToBytes(ipString) != null;\n    }\n\n    @NullableDecl\n    private static byte[] ipStringToBytes(String ipString)\n    {\n        // Make a first pass to categorize the characters in this string.\n        boolean hasColon = false;\n        boolean hasDot = false;\n        for (int i = 0; i < ipString.length(); i++)\n        {\n            char c = ipString.charAt(i);\n            if (c == '.')\n            {\n                hasDot = true;\n            }\n            else if (c == ':')\n            {\n                if (hasDot)\n                {\n                    return null; // Colons must not appear after dots.\n                }\n                hasColon = true;\n            }\n            else if (Character.digit(c, 16) == -1)\n            {\n                return null; // Everything else must be a decimal or hex digit.\n            }\n        }\n\n        // Now decide which address family to parse.\n        if (hasColon)\n        {\n            if (hasDot)\n            {\n                ipString = convertDottedQuadToHex(ipString);\n                if (ipString == null)\n                {\n                    return null;\n                }\n            }\n            return textToNumericFormatV6(ipString);\n        }\n        else if (hasDot)\n        {\n            return textToNumericFormatV4(ipString);\n        }\n        return null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV4(String ipString)\n    {\n        byte[] bytes = new byte[IPV4_PART_COUNT];\n        int i = 0;\n        try\n        {\n            for (String octet : IPV4_SPLITTER.split(ipString))\n            {\n                bytes[i++] = parseOctet(octet);\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n\n        return i == IPV4_PART_COUNT ? bytes : null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV6(String ipString)\n    {\n        // An address can have [2..8] colons, and N colons make N+1 parts.\n        List<String> parts = IPV6_SPLITTER.splitToList(ipString);\n        if (parts.size() < 3 || parts.size() > IPV6_PART_COUNT + 1)\n        {\n            return null;\n        }\n\n        // Disregarding the endpoints, find \"::\" with nothing in between.\n        // This indicates that a run of zeroes has been skipped.\n        int skipIndex = -1;\n        for (int i = 1; i < parts.size() - 1; i++)\n        {\n            if (parts.get(i).length() == 0)\n            {\n                if (skipIndex >= 0)\n                {\n                    return null; // Can't have more than one ::\n                }\n                skipIndex = i;\n            }\n        }\n\n        int partsHi; // Number of parts to copy from above/before the \"::\"\n        int partsLo; // Number of parts to copy from below/after the \"::\"\n        if (skipIndex >= 0)\n        {\n            // If we found a \"::\", then check if it also covers the endpoints.\n            partsHi = skipIndex;\n            partsLo = parts.size() - skipIndex - 1;\n            if (parts.get(0).length() == 0 && --partsHi != 0)\n            {\n                return null; // ^: requires ^::\n            }\n            if (Iterables.getLast(parts).length() == 0 && --partsLo != 0)\n            {\n                return null; // :$ requires ::$\n            }\n        }\n        else\n        {\n            // Otherwise, allocate the entire address to partsHi. The endpoints\n            // could still be empty, but parseHextet() will check for that.\n            partsHi = parts.size();\n            partsLo = 0;\n        }\n\n        // If we found a ::, then we must have skipped at least one part.\n        // Otherwise, we must have exactly the right number of parts.\n        int partsSkipped = IPV6_PART_COUNT - (partsHi + partsLo);\n        if (!(skipIndex >= 0 ? partsSkipped >= 1 : partsSkipped == 0))\n        {\n            return null;\n        }\n\n        // Now parse the hextets into a byte array.\n        ByteBuffer rawBytes = ByteBuffer.allocate(2 * IPV6_PART_COUNT);\n        try\n        {\n            for (int i = 0; i < partsHi; i++)\n            {\n                rawBytes.putShort(parseHextet(parts.get(i)));\n            }\n            for (int i = 0; i < partsSkipped; i++)\n            {\n                rawBytes.putShort((short) 0);\n            }\n            for (int i = partsLo; i > 0; i--)\n            {\n                rawBytes.putShort(parseHextet(parts.get(parts.size() - i)));\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n        return rawBytes.array();\n    }\n\n    @NullableDecl\n    private static String convertDottedQuadToHex(String ipString)\n    {\n        int lastColon = ipString.lastIndexOf(':');\n        String initialPart = ipString.substring(0, lastColon + 1);\n        String dottedQuad = ipString.substring(lastColon + 1);\n        byte[] quad = textToNumericFormatV4(dottedQuad);\n        if (quad == null)\n        {\n            return null;\n        }\n        String penultimate = Integer.toHexString(((quad[0] & 0xff) << 8) | (quad[1] & 0xff));\n        String ultimate = Integer.toHexString(((quad[2] & 0xff) << 8) | (quad[3] & 0xff));\n        return initialPart + penultimate + \":\" + ultimate;\n    }\n\n    private static byte parseOctet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int octet = Integer.parseInt(ipPart);\n        // Disallow leading zeroes, because no clear standard exists on\n        // whether these should be interpreted as decimal or octal.\n        if (octet > 255 || (ipPart.startsWith(\"0\") && ipPart.length() > 1))\n        {\n            throw new NumberFormatException();\n        }\n        return (byte) octet;\n    }\n\n    private static short parseHextet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int hextet = Integer.parseInt(ipPart, 16);\n        if (hextet > 0xffff)\n        {\n            throw new NumberFormatException();\n        }\n        return (short) hextet;\n    }\n\n    /**\n     * Convert a byte array into an InetAddress.\n     *\n     * <p>{@link InetAddress#getByAddress} is documented as throwing a checked exception \"if IP\n     * address is of illegal length.\" We replace it with an unchecked exception, for use by callers\n     * who already know that addr is an array of length 4 or 16.\n     *\n     * @param addr the raw 4-byte or 16-byte IP address in big-endian order\n     * @return an InetAddress object created from the raw IP address\n     */\n    private static InetAddress bytesToInetAddress(byte[] addr)\n    {\n        try\n        {\n            return InetAddress.getByAddress(addr);\n        }\n        catch (UnknownHostException e)\n        {\n            throw new AssertionError(e);\n        }\n    }\n\n    /**\n     * Returns the string representation of an {@link InetAddress}.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses, the output follows <a href=\"http://tools.ietf.org/html/rfc5952\">RFC 5952</a> section\n     * 4. The main difference is that this method uses \"::\" for zero compression, while Java's version\n     * uses the uncompressed form.\n     *\n     * <p>This method uses hexadecimal for all IPv6 addresses, including IPv4-mapped IPv6 addresses\n     * such as \"::c000:201\". The output does not include a Scope ID.\n     *\n     * @param ip {@link InetAddress} to be converted to an address string\n     * @return {@code String} containing the text-formatted IP address\n     * @since 10.0\n     */\n    public static String toAddrString(InetAddress ip)\n    {\n        checkNotNull(ip);\n        if (ip instanceof Inet4Address)\n        {\n            // For IPv4, Java's formatting is good enough.\n            return ip.getHostAddress();\n        }\n        checkArgument(ip instanceof Inet6Address);\n        byte[] bytes = ip.getAddress();\n        int[] hextets = new int[IPV6_PART_COUNT];\n        for (int i = 0; i < hextets.length; i++)\n        {\n            hextets[i] = Ints.fromBytes((byte) 0, (byte) 0, bytes[2 * i], bytes[2 * i + 1]);\n        }\n        compressLongestRunOfZeroes(hextets);\n        return hextetsToIPv6String(hextets);\n    }\n\n    /**\n     * Identify and mark the longest run of zeroes in an IPv6 address.\n     *\n     * <p>Only runs of two or more hextets are considered. In case of a tie, the leftmost run wins. If\n     * a qualifying run is found, its hextets are replaced by the sentinel value -1.\n     *\n     * @param hextets {@code int[]} mutable array of eight 16-bit hextets\n     */\n    private static void compressLongestRunOfZeroes(int[] hextets)\n    {\n        int bestRunStart = -1;\n        int bestRunLength = -1;\n        int runStart = -1;\n        for (int i = 0; i < hextets.length + 1; i++)\n        {\n            if (i < hextets.length && hextets[i] == 0)\n            {\n                if (runStart < 0)\n                {\n                    runStart = i;\n                }\n            }\n            else if (runStart >= 0)\n            {\n                int runLength = i - runStart;\n                if (runLength > bestRunLength)\n                {\n                    bestRunStart = runStart;\n                    bestRunLength = runLength;\n                }\n                runStart = -1;\n            }\n        }\n        if (bestRunLength >= 2)\n        {\n            Arrays.fill(hextets, bestRunStart, bestRunStart + bestRunLength, -1);\n        }\n    }\n\n    /**\n     * Convert a list of hextets into a human-readable IPv6 address.\n     *\n     * <p>In order for \"::\" compression to work, the input should contain negative sentinel values in\n     * place of the elided zeroes.\n     *\n     * @param hextets {@code int[]} array of eight 16-bit hextets, or -1s\n     */\n    private static String hextetsToIPv6String(int[] hextets)\n    {\n        // While scanning the array, handle these state transitions:\n        //   start->num => \"num\"     start->gap => \"::\"\n        //   num->num   => \":num\"    num->gap   => \"::\"\n        //   gap->num   => \"num\"     gap->gap   => \"\"\n        StringBuilder buf = new StringBuilder(39);\n        boolean lastWasNumber = false;\n        for (int i = 0; i < hextets.length; i++)\n        {\n            boolean thisIsNumber = hextets[i] >= 0;\n            if (thisIsNumber)\n            {\n                if (lastWasNumber)\n                {\n                    buf.append(':');\n                }\n                buf.append(Integer.toHexString(hextets[i]));\n            }\n            else\n            {\n                if (i == 0 || lastWasNumber)\n                {\n                    buf.append(\"::\");\n                }\n            }\n            lastWasNumber = thisIsNumber;\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Returns the string representation of an {@link InetAddress} suitable for inclusion in a URI.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses it compresses zeroes and surrounds the text with square brackets; for example {@code\n     * \"[2001:db8::1]\"}.\n     *\n     * <p>Per section 3.2.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3986#section-3.2.2\">RFC 3986</a>, a URI containing an IPv6\n     * string literal is of the form {@code \"http://[2001:db8::1]:8888/index.html\"}.\n     *\n     * <p>Use of either {@link InetAddresses#toAddrString}, {@link InetAddress#getHostAddress()}, or\n     * this method is recommended over {@link InetAddress#toString()} when an IP address string\n     * literal is desired. This is because {@link InetAddress#toString()} prints the hostname and the\n     * IP address string joined by a \"/\".\n     *\n     * @param ip {@link InetAddress} to be converted to URI string literal\n     * @return {@code String} containing URI-safe string literal\n     */\n    public static String toUriString(InetAddress ip)\n    {\n        if (ip instanceof Inet6Address)\n        {\n            return \"[\" + toAddrString(ip) + \"]\";\n        }\n        return toAddrString(ip);\n    }\n\n    /**\n     * Returns an InetAddress representing the literal IPv4 or IPv6 host portion of a URL, encoded in\n     * the format specified by RFC 3986 section 3.2.2.\n     *\n     * <p>This function is similar to {@link InetAddresses#forString(String)}, however, it requires\n     * that IPv6 addresses are surrounded by square brackets.\n     *\n     * <p>This function is the inverse of {@link InetAddresses#toUriString(java.net.InetAddress)}.\n     *\n     * @param hostAddr A RFC 3986 section 3.2.2 encoded IPv4 or IPv6 address\n     * @return an InetAddress representing the address in {@code hostAddr}\n     * @throws IllegalArgumentException if {@code hostAddr} is not a valid IPv4 address, or IPv6\n     *     address surrounded by square brackets\n     */\n    public static InetAddress forUriString(String hostAddr)\n    {\n        InetAddress addr = forUriStringNoThrow(hostAddr);\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"Not a valid URI IP literal: '%s'\", hostAddr);\n        }\n\n        return addr;\n    }\n\n    @NullableDecl\n    private static InetAddress forUriStringNoThrow(String hostAddr)\n    {\n        checkNotNull(hostAddr);\n\n        // Decide if this should be an IPv6 or IPv4 address.\n        String ipString;\n        int expectBytes;\n        if (hostAddr.startsWith(\"[\") && hostAddr.endsWith(\"]\"))\n        {\n            ipString = hostAddr.substring(1, hostAddr.length() - 1);\n            expectBytes = 16;\n        }\n        else\n        {\n            ipString = hostAddr;\n            expectBytes = 4;\n        }\n\n        // Parse the address, and make sure the length/version is correct.\n        byte[] addr = ipStringToBytes(ipString);\n        if (addr == null || addr.length != expectBytes)\n        {\n            return null;\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid URI IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP URI host string literal\n     * @return {@code true} if the argument is a valid IP URI host\n     */\n    public static boolean isUriInetAddress(String ipString)\n    {\n        return forUriStringNoThrow(ipString) != null;\n    }\n\n    /**\n     * Evaluates whether the argument is an IPv6 \"compat\" address.\n     *\n     * <p>An \"IPv4 compatible\", or \"compat\", address is one with 96 leading bits of zero, with the\n     * remaining 32 bits interpreted as an IPv4 address. These are conventionally represented in\n     * string literals as {@code \"::192.168.0.1\"}, though {@code \"::c0a8:1\"} is also considered an\n     * IPv4 compatible address (and equivalent to {@code \"::192.168.0.1\"}).\n     *\n     * <p>For more on IPv4 compatible addresses see section 2.5.5.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.1\">RFC 4291</a>.\n     *\n     * <p>NOTE: This method is different from {@link Inet6Address#isIPv4CompatibleAddress} in that it\n     * more correctly classifies {@code \"::\"} and {@code \"::1\"} as proper IPv6 addresses (which they\n     * are), NOT IPv4 compatible addresses (which they are generally NOT considered to be).\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 compatible address format\n     * @return {@code true} if the argument is a valid \"compat\" address\n     */\n    public static boolean isCompatIPv4Address(Inet6Address ip)\n    {\n        if (!ip.isIPv4CompatibleAddress())\n        {\n            return false;\n        }\n\n        byte[] bytes = ip.getAddress();\n        if ((bytes[12] == 0)\n                && (bytes[13] == 0)\n                && (bytes[14] == 0)\n                && ((bytes[15] == 0) || (bytes[15] == 1)))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the IPv4 address embedded in an IPv4 compatible address.\n     *\n     * @param ip {@link Inet6Address} to be examined for an embedded IPv4 address\n     * @return {@link Inet4Address} of the embedded IPv4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv4 compatible address\n     */\n    public static Inet4Address getCompatIPv4Address(Inet6Address ip)\n    {\n        checkArgument(\n            isCompatIPv4Address(ip), \"Address '%s' is not IPv4-compatible.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n    }\n\n    /**\n     * Evaluates whether the argument is a 6to4 address.\n     *\n     * <p>6to4 addresses begin with the {@code \"2002::/16\"} prefix. The next 32 bits are the IPv4\n     * address of the host to which IPv6-in-IPv4 tunneled packets should be routed.\n     *\n     * <p>For more on 6to4 addresses see section 2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3056#section-2\">RFC 3056</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for 6to4 address format\n     * @return {@code true} if the argument is a 6to4 address\n     */\n    public static boolean is6to4Address(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20) && (bytes[1] == (byte) 0x02);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in a 6to4 address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in 6to4 address\n     * @return {@link Inet4Address} of embedded IPv4 in 6to4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 6to4 address\n     */\n    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n    {\n        checkArgument(is6to4Address(ip), \"Address '%s' is not a 6to4 address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 2, 6));\n    }\n\n    /**\n     * A simple immutable data class to encapsulate the information to be found in a Teredo address.\n     *\n     * <p>All of the fields in this class are encoded in various portions of the IPv6 address as part\n     * of the protocol. More protocols details can be found at: <a target=\"_parent\"\n     * href=\"http://en.wikipedia.org/wiki/Teredo_tunneling\">http://en.wikipedia.\n     * org/wiki/Teredo_tunneling</a>.\n     *\n     * <p>The RFC can be found here: <a target=\"_parent\" href=\"http://tools.ietf.org/html/rfc4380\">RFC\n     * 4380</a>.\n     *\n     * @since 5.0\n     */\n    @Beta\n    public static final class TeredoInfo\n    {\n        private final Inet4Address server;\n        private final Inet4Address client;\n        private final int port;\n        private final int flags;\n\n        /**\n         * Constructs a TeredoInfo instance.\n         *\n         * <p>Both server and client can be {@code null}, in which case the value {@code \"0.0.0.0\"} will\n         * be assumed.\n         *\n         * @throws IllegalArgumentException if either of the {@code port} or the {@code flags} arguments\n         *     are out of range of an unsigned short\n         */\n        // TODO: why is this public?\n        public TeredoInfo(\n            @NullableDecl Inet4Address server, @NullableDecl Inet4Address client, int port, int flags)\n        {\n            checkArgument(\n                (port >= 0) && (port <= 0xffff), \"port '%s' is out of range (0 <= port <= 0xffff)\", port);\n            checkArgument(\n                (flags >= 0) && (flags <= 0xffff),\n                \"flags '%s' is out of range (0 <= flags <= 0xffff)\",\n                flags);\n\n            this.server = MoreObjects.firstNonNull(server, ANY4);\n            this.client = MoreObjects.firstNonNull(client, ANY4);\n            this.port = port;\n            this.flags = flags;\n        }\n\n        public Inet4Address getServer()\n        {\n            return server;\n        }\n\n        public Inet4Address getClient()\n        {\n            return client;\n        }\n\n        public int getPort()\n        {\n            return port;\n        }\n\n        public int getFlags()\n        {\n            return flags;\n        }\n    }\n\n    /**\n     * Evaluates whether the argument is a Teredo address.\n     *\n     * <p>Teredo addresses begin with the {@code \"2001::/32\"} prefix.\n     *\n     * @param ip {@link Inet6Address} to be examined for Teredo address format\n     * @return {@code true} if the argument is a Teredo address\n     */\n    public static boolean isTeredoAddress(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20)\n               && (bytes[1] == (byte) 0x01)\n               && (bytes[2] == 0)\n               && (bytes[3] == 0);\n    }\n\n    /**\n     * Returns the Teredo information embedded in a Teredo address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded Teredo information\n     * @return extracted {@code TeredoInfo}\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 Teredo address\n     */\n    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n    {\n        checkArgument(isTeredoAddress(ip), \"Address '%s' is not a Teredo address.\", toAddrString(ip));\n\n        byte[] bytes = ip.getAddress();\n        Inet4Address server = getInet4Address(Arrays.copyOfRange(bytes, 4, 8));\n\n        int flags = ByteStreams.newDataInput(bytes, 8).readShort() & 0xffff;\n\n        // Teredo obfuscates the mapped client port, per section 4 of the RFC.\n        int port = ~ByteStreams.newDataInput(bytes, 10).readShort() & 0xffff;\n\n        byte[] clientBytes = Arrays.copyOfRange(bytes, 12, 16);\n        for (int i = 0; i < clientBytes.length; i++)\n        {\n            // Teredo obfuscates the mapped client IP, per section 4 of the RFC.\n            clientBytes[i] = (byte) ~clientBytes[i];\n        }\n        Inet4Address client = getInet4Address(clientBytes);\n\n        return new TeredoInfo(server, client, port, flags);\n    }\n\n    /**\n     * Evaluates whether the argument is an ISATAP address.\n     *\n     * <p>From RFC 5214: \"ISATAP interface identifiers are constructed in Modified EUI-64 format [...]\n     * by concatenating the 24-bit IANA OUI (00-00-5E), the 8-bit hexadecimal value 0xFE, and a 32-bit\n     * IPv4 address in network byte order [...]\"\n     *\n     * <p>For more on ISATAP addresses see section 6.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc5214#section-6.1\">RFC 5214</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for ISATAP address format\n     * @return {@code true} if the argument is an ISATAP address\n     */\n    public static boolean isIsatapAddress(Inet6Address ip)\n    {\n\n        // If it's a Teredo address with the right port (41217, or 0xa101)\n        // which would be encoded as 0x5efe then it can't be an ISATAP address.\n        if (isTeredoAddress(ip))\n        {\n            return false;\n        }\n\n        byte[] bytes = ip.getAddress();\n\n        if ((bytes[8] | (byte) 0x03) != (byte) 0x03)\n        {\n\n            // Verify that high byte of the 64 bit identifier is zero, modulo\n            // the U/L and G bits, with which we are not concerned.\n            return false;\n        }\n\n        return (bytes[9] == (byte) 0x00) && (bytes[10] == (byte) 0x5e) && (bytes[11] == (byte) 0xfe);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in an ISATAP address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in ISATAP address\n     * @return {@link Inet4Address} of embedded IPv4 in an ISATAP address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 ISATAP address\n     */\n    public static Inet4Address getIsatapIPv4Address(Inet6Address ip)\n    {\n        checkArgument(isIsatapAddress(ip), \"Address '%s' is not an ISATAP address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n    }\n\n    /**\n     * Examines the Inet6Address to determine if it is an IPv6 address of one of the specified address\n     * types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@code true} if there is an embedded IPv4 client address\n     * @since 7.0\n     */\n    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        return isCompatIPv4Address(ip) || is6to4Address(ip) || isTeredoAddress(ip);\n    }\n\n    /**\n     * Examines the Inet6Address to extract the embedded IPv4 client address if the InetAddress is an\n     * IPv6 address of one of the specified address types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@link Inet4Address} of embedded IPv4 client address\n     * @throws IllegalArgumentException if the argument does not have a valid embedded IPv4 address\n     */\n\n    /**\n     * Evaluates whether the argument is an \"IPv4 mapped\" IPv6 address.\n     *\n     * <p>An \"IPv4 mapped\" address is anything in the range ::ffff:0:0/96 (sometimes written as\n     * ::ffff:0.0.0.0/96), with the last 32 bits interpreted as an IPv4 address.\n     *\n     * <p>For more on IPv4 mapped addresses see section 2.5.5.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.2\">RFC 4291</a>.\n     *\n     * <p>Note: This method takes a {@code String} argument because {@link InetAddress} automatically\n     * collapses mapped addresses to IPv4. (It is actually possible to avoid this using one of the\n     * obscure {@link Inet6Address} methods, but it would be unwise to depend on such a\n     * poorly-documented feature.)\n     *\n     * @param ipString {@code String} to be examined for embedded IPv4-mapped IPv6 address format\n     * @return {@code true} if the argument is a valid \"mapped\" address\n     * @since 10.0\n     */\n    public static boolean isMappedIPv4Address(String ipString)\n    {\n        byte[] bytes = ipStringToBytes(ipString);\n        if (bytes != null && bytes.length == 16)\n        {\n            for (int i = 0; i < 10; i++)\n            {\n                if (bytes[i] != 0)\n                {\n                    return false;\n                }\n            }\n            for (int i = 10; i < 12; i++)\n            {\n                if (bytes[i] != (byte) 0xff)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Coerces an IPv6 address into an IPv4 address.\n     *\n     * <p>HACK: As long as applications continue to use IPv4 addresses for indexing into tables,\n     * accounting, et cetera, it may be necessary to <b>coerce</b> IPv6 addresses into IPv4 addresses.\n     * This function does so by hashing the upper 64 bits into {@code 224.0.0.0/3} (64 bits into 29\n     * bits).\n     *\n     * <p>A \"coerced\" IPv4 address is equivalent to itself.\n     *\n     * <p>NOTE: This function is failsafe for security purposes: ALL IPv6 addresses (except localhost\n     * (::1)) are hashed to avoid the security risk associated with extracting an embedded IPv4\n     * address that might permit elevated privileges.\n     *\n     * @param ip {@link InetAddress} to \"coerce\"\n     * @return {@link Inet4Address} represented \"coerced\" address\n     * @since 7.0\n     */\n    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n    {\n        if (ip instanceof Inet4Address)\n        {\n            return (Inet4Address) ip;\n        }\n\n        // Special cases:\n        byte[] bytes = ip.getAddress();\n        boolean leadingBytesOfZero = true;\n        for (int i = 0; i < 15; ++i)\n        {\n            if (bytes[i] != 0)\n            {\n                leadingBytesOfZero = false;\n                break;\n            }\n        }\n        if (leadingBytesOfZero && (bytes[15] == 1))\n        {\n            return LOOPBACK4; // ::1\n        }\n        else if (leadingBytesOfZero && (bytes[15] == 0))\n        {\n            return ANY4; // ::0\n        }\n\n        Inet6Address ip6 = (Inet6Address) ip;\n        long addressAsLong = 0;\n        if (hasEmbeddedIPv4ClientAddress(ip6))\n        {\n            addressAsLong = getEmbeddedIPv4ClientAddress(ip6).hashCode();\n        }\n        else\n        {\n\n            // Just extract the high 64 bits (assuming the rest is user-modifiable).\n            addressAsLong = ByteBuffer.wrap(ip6.getAddress(), 0, 8).getLong();\n        }\n\n        // Many strategies for hashing are possible. This might suffice for now.\n        int coercedHash = Hashing.murmur3_32().hashLong(addressAsLong).asInt();\n\n        // Squash into 224/4 Multicast and 240/4 Reserved space (i.e. 224/3).\n        coercedHash |= 0xe0000000;\n\n        // Fixup to avoid some \"illegal\" values. Currently the only potential\n        // illegal value is 255.255.255.255.\n        if (coercedHash == 0xffffffff)\n        {\n            coercedHash = 0xfffffffe;\n        }\n\n        return getInet4Address(Ints.toByteArray(coercedHash));\n    }\n\n    /**\n     * Returns an integer representing an IPv4 address regardless of whether the supplied argument is\n     * an IPv4 address or not.\n     *\n     * <p>IPv6 addresses are <b>coerced</b> to IPv4 addresses before being converted to integers.\n     *\n     * <p>As long as there are applications that assume that all IP addresses are IPv4 addresses and\n     * can therefore be converted safely to integers (for whatever purpose) this function can be used\n     * to handle IPv6 addresses as well until the application is suitably fixed.\n     *\n     * <p>NOTE: an IPv6 address coerced to an IPv4 address can only be used for such purposes as\n     * rudimentary identification or indexing into a collection of real {@link InetAddress}es. They\n     * cannot be used as real addresses for the purposes of network communication.\n     *\n     * @param ip {@link InetAddress} to convert\n     * @return {@code int}, \"coerced\" if ip is not an IPv4 address\n     * @since 7.0\n     */\n    public static int coerceToInteger(InetAddress ip)\n    {\n        return ByteStreams.newDataInput(getCoercedIPv4Address(ip).getAddress()).readInt();\n    }\n\n    /**\n     * Returns an Inet4Address having the integer value specified by the argument.\n     *\n     * @param address {@code int}, the 32bit integer address to be converted\n     * @return {@link Inet4Address} equivalent of the argument\n     */\n    public static Inet4Address fromInteger(int address)\n    {\n        return getInet4Address(Ints.toByteArray(address));\n    }\n\n    /**\n     * Returns an address from a <b>little-endian ordered</b> byte array (the opposite of what {@link\n     * InetAddress#getByAddress} expects).\n     *\n     * <p>IPv4 address byte array must be 4 bytes long and IPv6 byte array must be 16 bytes long.\n     *\n     * @param addr the raw IP address in little-endian byte order\n     * @return an InetAddress object created from the raw IP address\n     * @throws UnknownHostException if IP address is of illegal length\n     */\n    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n    {\n        byte[] reversed = new byte[addr.length];\n        for (int i = 0; i < addr.length; i++)\n        {\n            reversed[i] = addr[addr.length - i - 1];\n        }\n        return InetAddress.getByAddress(reversed);\n    }\n\n    /**\n     * Returns a new InetAddress that is one less than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to decrement\n     * @return a new InetAddress that is one less than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the beginning of its range\n     * @since 18.0\n     */\n    public static InetAddress decrement(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0x00)\n        {\n            addr[i] = (byte) 0xff;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Decrementing %s would wrap.\", address);\n\n        addr[i]--;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns a new InetAddress that is one more than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to increment\n     * @return a new InetAddress that is one more than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the end of its range\n     * @since 10.0\n     */\n    public static InetAddress increment(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0xff)\n        {\n            addr[i] = 0;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Incrementing %s would wrap.\", address);\n\n        addr[i]++;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns true if the InetAddress is either 255.255.255.255 for IPv4 or\n     * ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6.\n     *\n     * @return true if the InetAddress is either 255.255.255.255 for IPv4 or\n     *     ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6\n     * @since 10.0\n     */\n    public static boolean isMaximum(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        for (int i = 0; i < addr.length; i++)\n        {\n            if (addr[i] != (byte) 0xff)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static IllegalArgumentException formatIllegalArgumentException(\n        String format, Object... args)\n    {\n        return new IllegalArgumentException(String.format(Locale.ROOT, format, args));\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.isMappedIPv4Address", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Evaluates whether the argument is an \"IPv4 mapped\" IPv6 address.\n\n<p>An \"IPv4 mapped\" address is anything in the range ::ffff:0:0/96 (sometimes written as\n::ffff:0.0.0.0/96), with the last 32 bits interpreted as an IPv4 address.\n\n<p>For more on IPv4 mapped addresses see section 2.5.5.2 of <a target=\"_parent\"\nhref=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.2\">RFC 4291</a>.\n\n<p>Note: This method takes a {@code String} argument because {@link InetAddress} automatically\ncollapses mapped addresses to IPv4. (It is actually possible to avoid this using one of the\nobscure {@link Inet6Address} methods, but it would be unwise to depend on such a\npoorly-documented feature.)\n\n@param ipString {@code String} to be examined for embedded IPv4-mapped IPv6 address format\n@return {@code true} if the argument is a valid \"mapped\" address\n@since 10.0", "docstring_tokens": ["Evaluates", "whether", "the", "argument", "is", "an", "IPv4", "mapped", "IPv6", "address", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L795-L811", "partition": "valid", "up_fun_num": 29, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.MoreObjects;", "import com.google.common.base.Splitter;", "import com.google.common.collect.Iterables;", "import com.google.common.hash.Hashing;", "import com.google.common.io.ByteStreams;", "import com.google.common.primitives.Ints;", "import java.net.Inet4Address;", "import java.net.Inet6Address;", "import java.net.InetAddress;", "import java.net.UnknownHostException;", "import java.nio.ByteBuffer;", "import java.util.Arrays;", "import java.util.List;", "import java.util.Locale;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class InetAddresses\n", "    private static Inet4Address getInet4Address(byte[] bytes)\n", "    public static InetAddress forString(String ipString)\n", "    public static boolean isInetAddress(String ipString)\n", "    private static byte[] ipStringToBytes(String ipString)\n", "    private static byte[] textToNumericFormatV4(String ipString)\n", "    private static byte[] textToNumericFormatV6(String ipString)\n", "    private static String convertDottedQuadToHex(String ipString)\n", "    private static byte parseOctet(String ipPart)\n", "    private static short parseHextet(String ipPart)\n", "    private static InetAddress bytesToInetAddress(byte[] addr)\n", "    public static String toAddrString(InetAddress ip)\n", "    private static void compressLongestRunOfZeroes(int[] hextets)\n", "    private static String hextetsToIPv6String(int[] hextets)\n", "    public static String toUriString(InetAddress ip)\n", "    public static InetAddress forUriString(String hostAddr)\n", "    private static InetAddress forUriStringNoThrow(String hostAddr)\n", "    public static boolean isUriInetAddress(String ipString)\n", "    public static boolean isCompatIPv4Address(Inet6Address ip)\n", "    public static Inet4Address getCompatIPv4Address(Inet6Address ip)\n", "    public static boolean is6to4Address(Inet6Address ip)\n", "    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n", "    public static boolean isTeredoAddress(Inet6Address ip)\n", "    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n", "    public static boolean isIsatapAddress(Inet6Address ip)\n", "    public static Inet4Address getIsatapIPv4Address(Inet6Address ip)\n", "    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n", "    public static int coerceToInteger(InetAddress ip)\n", "    public static Inet4Address fromInteger(int address)\n", "    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n", "    public static InetAddress decrement(InetAddress address)\n", "    public static InetAddress increment(InetAddress address)\n", "    public static boolean isMaximum(InetAddress address)\n", "    private static IllegalArgumentException formatIllegalArgumentException(\n"], "context": "/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.net;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.Iterables;\nimport com.google.common.hash.Hashing;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.primitives.Ints;\nimport java.net.Inet4Address;\nimport java.net.Inet6Address;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * Static utility methods pertaining to {@link InetAddress} instances.\n *\n * <p><b>Important note:</b> Unlike {@code InetAddress.getByName()}, the methods of this class never\n * cause DNS services to be accessed. For this reason, you should prefer these methods as much as\n * possible over their JDK equivalents whenever you are expecting to handle only IP address string\n * literals -- there is no blocking DNS penalty for a malformed string.\n *\n * <p>When dealing with {@link Inet4Address} and {@link Inet6Address} objects as byte arrays (vis.\n * {@code InetAddress.getAddress()}) they are 4 and 16 bytes in length, respectively, and represent\n * the address in network byte order.\n *\n * <p>Examples of IP addresses and their byte representations:\n *\n * <dl>\n *   <dt>The IPv4 loopback address, {@code \"127.0.0.1\"}.\n *   <dd>{@code 7f 00 00 01}\n *   <dt>The IPv6 loopback address, {@code \"::1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>From the IPv6 reserved documentation prefix ({@code 2001:db8::/32}), {@code \"2001:db8::1\"}.\n *   <dd>{@code 20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>An IPv6 \"IPv4 compatible\" (or \"compat\") address, {@code \"::192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 c0 a8 00 01}\n *   <dt>An IPv6 \"IPv4 mapped\" address, {@code \"::ffff:192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 ff ff c0 a8 00 01}\n * </dl>\n *\n * <p>A few notes about IPv6 \"IPv4 mapped\" addresses and their observed use in Java.\n *\n * <p>\"IPv4 mapped\" addresses were originally a representation of IPv4 addresses for use on an IPv6\n * socket that could receive both IPv4 and IPv6 connections (by disabling the {@code IPV6_V6ONLY}\n * socket option on an IPv6 socket). Yes, it's confusing. Nevertheless, these \"mapped\" addresses\n * were never supposed to be seen on the wire. That assumption was dropped, some say mistakenly, in\n * later RFCs with the apparent aim of making IPv4-to-IPv6 transition simpler.\n *\n * <p>Technically one <i>can</i> create a 128bit IPv6 address with the wire format of a \"mapped\"\n * address, as shown above, and transmit it in an IPv6 packet header. However, Java's InetAddress\n * creation methods appear to adhere doggedly to the original intent of the \"mapped\" address: all\n * \"mapped\" addresses return {@link Inet4Address} objects.\n *\n * <p>For added safety, it is common for IPv6 network operators to filter all packets where either\n * the source or destination address appears to be a \"compat\" or \"mapped\" address. Filtering\n * suggestions usually recommend discarding any packets with source or destination addresses in the\n * invalid range {@code ::/3}, which includes both of these bizarre address formats. For more\n * information on \"bogons\", including lists of IPv6 bogon space, see:\n *\n * <ul>\n *   <li><a target=\"_parent\"\n *       href=\"http://en.wikipedia.org/wiki/Bogon_filtering\">http://en.wikipedia.\n *       org/wiki/Bogon_filtering</a>\n *   <li><a target=\"_parent\"\n *       href=\"http://www.cymru.com/Bogons/ipv6.txt\">http://www.cymru.com/Bogons/ ipv6.txt</a>\n *   <li><a target=\"_parent\" href=\"http://www.cymru.com/Bogons/v6bogon.html\">http://www.cymru.com/\n *       Bogons/v6bogon.html</a>\n *   <li><a target=\"_parent\" href=\"http://www.space.net/~gert/RIPE/ipv6-filters.html\">http://www.\n *       space.net/~gert/RIPE/ipv6-filters.html</a>\n * </ul>\n *\n * @author Erik Kline\n * @since 5.0\n */\n@Beta\n@GwtIncompatible\npublic final class InetAddresses\n{\n    private static final int IPV4_PART_COUNT = 4;\n    private static final int IPV6_PART_COUNT = 8;\n    private static final Splitter IPV4_SPLITTER = Splitter.on('.').limit(IPV4_PART_COUNT);\n    private static final Splitter IPV6_SPLITTER = Splitter.on(':').limit(IPV6_PART_COUNT + 2);\n    private static final Inet4Address LOOPBACK4 = (Inet4Address) forString(\"127.0.0.1\");\n    private static final Inet4Address ANY4 = (Inet4Address) forString(\"0.0.0.0\");\n\n    private InetAddresses() {}\n\n    /**\n     * Returns an {@link Inet4Address}, given a byte array representation of the IPv4 address.\n     *\n     * @param bytes byte array representing an IPv4 address (should be of length 4)\n     * @return {@link Inet4Address} corresponding to the supplied byte array\n     * @throws IllegalArgumentException if a valid {@link Inet4Address} can not be created\n     */\n    private static Inet4Address getInet4Address(byte[] bytes)\n    {\n        checkArgument(\n            bytes.length == 4,\n            \"Byte array has invalid length for an IPv4 address: %s != 4.\",\n            bytes.length);\n\n        // Given a 4-byte array, this cast should always succeed.\n        return (Inet4Address) bytesToInetAddress(bytes);\n    }\n\n    /**\n     * Returns the {@link InetAddress} having the given string representation.\n     *\n     * <p>This deliberately avoids all nameservice lookups (e.g. no DNS).\n     *\n     * @param ipString {@code String} containing an IPv4 or IPv6 string literal, e.g. {@code\n     *     \"192.168.0.1\"} or {@code \"2001:db8::1\"}\n     * @return {@link InetAddress} representing the argument\n     * @throws IllegalArgumentException if the argument is not a valid IP string literal\n     */\n    public static InetAddress forString(String ipString)\n    {\n        byte[] addr = ipStringToBytes(ipString);\n\n        // The argument was malformed, i.e. not an IP string literal.\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"'%s' is not an IP string literal.\", ipString);\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP string literal\n     * @return {@code true} if the argument is a valid IP string literal\n     */\n    public static boolean isInetAddress(String ipString)\n    {\n        return ipStringToBytes(ipString) != null;\n    }\n\n    @NullableDecl\n    private static byte[] ipStringToBytes(String ipString)\n    {\n        // Make a first pass to categorize the characters in this string.\n        boolean hasColon = false;\n        boolean hasDot = false;\n        for (int i = 0; i < ipString.length(); i++)\n        {\n            char c = ipString.charAt(i);\n            if (c == '.')\n            {\n                hasDot = true;\n            }\n            else if (c == ':')\n            {\n                if (hasDot)\n                {\n                    return null; // Colons must not appear after dots.\n                }\n                hasColon = true;\n            }\n            else if (Character.digit(c, 16) == -1)\n            {\n                return null; // Everything else must be a decimal or hex digit.\n            }\n        }\n\n        // Now decide which address family to parse.\n        if (hasColon)\n        {\n            if (hasDot)\n            {\n                ipString = convertDottedQuadToHex(ipString);\n                if (ipString == null)\n                {\n                    return null;\n                }\n            }\n            return textToNumericFormatV6(ipString);\n        }\n        else if (hasDot)\n        {\n            return textToNumericFormatV4(ipString);\n        }\n        return null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV4(String ipString)\n    {\n        byte[] bytes = new byte[IPV4_PART_COUNT];\n        int i = 0;\n        try\n        {\n            for (String octet : IPV4_SPLITTER.split(ipString))\n            {\n                bytes[i++] = parseOctet(octet);\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n\n        return i == IPV4_PART_COUNT ? bytes : null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV6(String ipString)\n    {\n        // An address can have [2..8] colons, and N colons make N+1 parts.\n        List<String> parts = IPV6_SPLITTER.splitToList(ipString);\n        if (parts.size() < 3 || parts.size() > IPV6_PART_COUNT + 1)\n        {\n            return null;\n        }\n\n        // Disregarding the endpoints, find \"::\" with nothing in between.\n        // This indicates that a run of zeroes has been skipped.\n        int skipIndex = -1;\n        for (int i = 1; i < parts.size() - 1; i++)\n        {\n            if (parts.get(i).length() == 0)\n            {\n                if (skipIndex >= 0)\n                {\n                    return null; // Can't have more than one ::\n                }\n                skipIndex = i;\n            }\n        }\n\n        int partsHi; // Number of parts to copy from above/before the \"::\"\n        int partsLo; // Number of parts to copy from below/after the \"::\"\n        if (skipIndex >= 0)\n        {\n            // If we found a \"::\", then check if it also covers the endpoints.\n            partsHi = skipIndex;\n            partsLo = parts.size() - skipIndex - 1;\n            if (parts.get(0).length() == 0 && --partsHi != 0)\n            {\n                return null; // ^: requires ^::\n            }\n            if (Iterables.getLast(parts).length() == 0 && --partsLo != 0)\n            {\n                return null; // :$ requires ::$\n            }\n        }\n        else\n        {\n            // Otherwise, allocate the entire address to partsHi. The endpoints\n            // could still be empty, but parseHextet() will check for that.\n            partsHi = parts.size();\n            partsLo = 0;\n        }\n\n        // If we found a ::, then we must have skipped at least one part.\n        // Otherwise, we must have exactly the right number of parts.\n        int partsSkipped = IPV6_PART_COUNT - (partsHi + partsLo);\n        if (!(skipIndex >= 0 ? partsSkipped >= 1 : partsSkipped == 0))\n        {\n            return null;\n        }\n\n        // Now parse the hextets into a byte array.\n        ByteBuffer rawBytes = ByteBuffer.allocate(2 * IPV6_PART_COUNT);\n        try\n        {\n            for (int i = 0; i < partsHi; i++)\n            {\n                rawBytes.putShort(parseHextet(parts.get(i)));\n            }\n            for (int i = 0; i < partsSkipped; i++)\n            {\n                rawBytes.putShort((short) 0);\n            }\n            for (int i = partsLo; i > 0; i--)\n            {\n                rawBytes.putShort(parseHextet(parts.get(parts.size() - i)));\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n        return rawBytes.array();\n    }\n\n    @NullableDecl\n    private static String convertDottedQuadToHex(String ipString)\n    {\n        int lastColon = ipString.lastIndexOf(':');\n        String initialPart = ipString.substring(0, lastColon + 1);\n        String dottedQuad = ipString.substring(lastColon + 1);\n        byte[] quad = textToNumericFormatV4(dottedQuad);\n        if (quad == null)\n        {\n            return null;\n        }\n        String penultimate = Integer.toHexString(((quad[0] & 0xff) << 8) | (quad[1] & 0xff));\n        String ultimate = Integer.toHexString(((quad[2] & 0xff) << 8) | (quad[3] & 0xff));\n        return initialPart + penultimate + \":\" + ultimate;\n    }\n\n    private static byte parseOctet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int octet = Integer.parseInt(ipPart);\n        // Disallow leading zeroes, because no clear standard exists on\n        // whether these should be interpreted as decimal or octal.\n        if (octet > 255 || (ipPart.startsWith(\"0\") && ipPart.length() > 1))\n        {\n            throw new NumberFormatException();\n        }\n        return (byte) octet;\n    }\n\n    private static short parseHextet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int hextet = Integer.parseInt(ipPart, 16);\n        if (hextet > 0xffff)\n        {\n            throw new NumberFormatException();\n        }\n        return (short) hextet;\n    }\n\n    /**\n     * Convert a byte array into an InetAddress.\n     *\n     * <p>{@link InetAddress#getByAddress} is documented as throwing a checked exception \"if IP\n     * address is of illegal length.\" We replace it with an unchecked exception, for use by callers\n     * who already know that addr is an array of length 4 or 16.\n     *\n     * @param addr the raw 4-byte or 16-byte IP address in big-endian order\n     * @return an InetAddress object created from the raw IP address\n     */\n    private static InetAddress bytesToInetAddress(byte[] addr)\n    {\n        try\n        {\n            return InetAddress.getByAddress(addr);\n        }\n        catch (UnknownHostException e)\n        {\n            throw new AssertionError(e);\n        }\n    }\n\n    /**\n     * Returns the string representation of an {@link InetAddress}.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses, the output follows <a href=\"http://tools.ietf.org/html/rfc5952\">RFC 5952</a> section\n     * 4. The main difference is that this method uses \"::\" for zero compression, while Java's version\n     * uses the uncompressed form.\n     *\n     * <p>This method uses hexadecimal for all IPv6 addresses, including IPv4-mapped IPv6 addresses\n     * such as \"::c000:201\". The output does not include a Scope ID.\n     *\n     * @param ip {@link InetAddress} to be converted to an address string\n     * @return {@code String} containing the text-formatted IP address\n     * @since 10.0\n     */\n    public static String toAddrString(InetAddress ip)\n    {\n        checkNotNull(ip);\n        if (ip instanceof Inet4Address)\n        {\n            // For IPv4, Java's formatting is good enough.\n            return ip.getHostAddress();\n        }\n        checkArgument(ip instanceof Inet6Address);\n        byte[] bytes = ip.getAddress();\n        int[] hextets = new int[IPV6_PART_COUNT];\n        for (int i = 0; i < hextets.length; i++)\n        {\n            hextets[i] = Ints.fromBytes((byte) 0, (byte) 0, bytes[2 * i], bytes[2 * i + 1]);\n        }\n        compressLongestRunOfZeroes(hextets);\n        return hextetsToIPv6String(hextets);\n    }\n\n    /**\n     * Identify and mark the longest run of zeroes in an IPv6 address.\n     *\n     * <p>Only runs of two or more hextets are considered. In case of a tie, the leftmost run wins. If\n     * a qualifying run is found, its hextets are replaced by the sentinel value -1.\n     *\n     * @param hextets {@code int[]} mutable array of eight 16-bit hextets\n     */\n    private static void compressLongestRunOfZeroes(int[] hextets)\n    {\n        int bestRunStart = -1;\n        int bestRunLength = -1;\n        int runStart = -1;\n        for (int i = 0; i < hextets.length + 1; i++)\n        {\n            if (i < hextets.length && hextets[i] == 0)\n            {\n                if (runStart < 0)\n                {\n                    runStart = i;\n                }\n            }\n            else if (runStart >= 0)\n            {\n                int runLength = i - runStart;\n                if (runLength > bestRunLength)\n                {\n                    bestRunStart = runStart;\n                    bestRunLength = runLength;\n                }\n                runStart = -1;\n            }\n        }\n        if (bestRunLength >= 2)\n        {\n            Arrays.fill(hextets, bestRunStart, bestRunStart + bestRunLength, -1);\n        }\n    }\n\n    /**\n     * Convert a list of hextets into a human-readable IPv6 address.\n     *\n     * <p>In order for \"::\" compression to work, the input should contain negative sentinel values in\n     * place of the elided zeroes.\n     *\n     * @param hextets {@code int[]} array of eight 16-bit hextets, or -1s\n     */\n    private static String hextetsToIPv6String(int[] hextets)\n    {\n        // While scanning the array, handle these state transitions:\n        //   start->num => \"num\"     start->gap => \"::\"\n        //   num->num   => \":num\"    num->gap   => \"::\"\n        //   gap->num   => \"num\"     gap->gap   => \"\"\n        StringBuilder buf = new StringBuilder(39);\n        boolean lastWasNumber = false;\n        for (int i = 0; i < hextets.length; i++)\n        {\n            boolean thisIsNumber = hextets[i] >= 0;\n            if (thisIsNumber)\n            {\n                if (lastWasNumber)\n                {\n                    buf.append(':');\n                }\n                buf.append(Integer.toHexString(hextets[i]));\n            }\n            else\n            {\n                if (i == 0 || lastWasNumber)\n                {\n                    buf.append(\"::\");\n                }\n            }\n            lastWasNumber = thisIsNumber;\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Returns the string representation of an {@link InetAddress} suitable for inclusion in a URI.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses it compresses zeroes and surrounds the text with square brackets; for example {@code\n     * \"[2001:db8::1]\"}.\n     *\n     * <p>Per section 3.2.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3986#section-3.2.2\">RFC 3986</a>, a URI containing an IPv6\n     * string literal is of the form {@code \"http://[2001:db8::1]:8888/index.html\"}.\n     *\n     * <p>Use of either {@link InetAddresses#toAddrString}, {@link InetAddress#getHostAddress()}, or\n     * this method is recommended over {@link InetAddress#toString()} when an IP address string\n     * literal is desired. This is because {@link InetAddress#toString()} prints the hostname and the\n     * IP address string joined by a \"/\".\n     *\n     * @param ip {@link InetAddress} to be converted to URI string literal\n     * @return {@code String} containing URI-safe string literal\n     */\n    public static String toUriString(InetAddress ip)\n    {\n        if (ip instanceof Inet6Address)\n        {\n            return \"[\" + toAddrString(ip) + \"]\";\n        }\n        return toAddrString(ip);\n    }\n\n    /**\n     * Returns an InetAddress representing the literal IPv4 or IPv6 host portion of a URL, encoded in\n     * the format specified by RFC 3986 section 3.2.2.\n     *\n     * <p>This function is similar to {@link InetAddresses#forString(String)}, however, it requires\n     * that IPv6 addresses are surrounded by square brackets.\n     *\n     * <p>This function is the inverse of {@link InetAddresses#toUriString(java.net.InetAddress)}.\n     *\n     * @param hostAddr A RFC 3986 section 3.2.2 encoded IPv4 or IPv6 address\n     * @return an InetAddress representing the address in {@code hostAddr}\n     * @throws IllegalArgumentException if {@code hostAddr} is not a valid IPv4 address, or IPv6\n     *     address surrounded by square brackets\n     */\n    public static InetAddress forUriString(String hostAddr)\n    {\n        InetAddress addr = forUriStringNoThrow(hostAddr);\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"Not a valid URI IP literal: '%s'\", hostAddr);\n        }\n\n        return addr;\n    }\n\n    @NullableDecl\n    private static InetAddress forUriStringNoThrow(String hostAddr)\n    {\n        checkNotNull(hostAddr);\n\n        // Decide if this should be an IPv6 or IPv4 address.\n        String ipString;\n        int expectBytes;\n        if (hostAddr.startsWith(\"[\") && hostAddr.endsWith(\"]\"))\n        {\n            ipString = hostAddr.substring(1, hostAddr.length() - 1);\n            expectBytes = 16;\n        }\n        else\n        {\n            ipString = hostAddr;\n            expectBytes = 4;\n        }\n\n        // Parse the address, and make sure the length/version is correct.\n        byte[] addr = ipStringToBytes(ipString);\n        if (addr == null || addr.length != expectBytes)\n        {\n            return null;\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid URI IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP URI host string literal\n     * @return {@code true} if the argument is a valid IP URI host\n     */\n    public static boolean isUriInetAddress(String ipString)\n    {\n        return forUriStringNoThrow(ipString) != null;\n    }\n\n    /**\n     * Evaluates whether the argument is an IPv6 \"compat\" address.\n     *\n     * <p>An \"IPv4 compatible\", or \"compat\", address is one with 96 leading bits of zero, with the\n     * remaining 32 bits interpreted as an IPv4 address. These are conventionally represented in\n     * string literals as {@code \"::192.168.0.1\"}, though {@code \"::c0a8:1\"} is also considered an\n     * IPv4 compatible address (and equivalent to {@code \"::192.168.0.1\"}).\n     *\n     * <p>For more on IPv4 compatible addresses see section 2.5.5.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.1\">RFC 4291</a>.\n     *\n     * <p>NOTE: This method is different from {@link Inet6Address#isIPv4CompatibleAddress} in that it\n     * more correctly classifies {@code \"::\"} and {@code \"::1\"} as proper IPv6 addresses (which they\n     * are), NOT IPv4 compatible addresses (which they are generally NOT considered to be).\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 compatible address format\n     * @return {@code true} if the argument is a valid \"compat\" address\n     */\n    public static boolean isCompatIPv4Address(Inet6Address ip)\n    {\n        if (!ip.isIPv4CompatibleAddress())\n        {\n            return false;\n        }\n\n        byte[] bytes = ip.getAddress();\n        if ((bytes[12] == 0)\n                && (bytes[13] == 0)\n                && (bytes[14] == 0)\n                && ((bytes[15] == 0) || (bytes[15] == 1)))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the IPv4 address embedded in an IPv4 compatible address.\n     *\n     * @param ip {@link Inet6Address} to be examined for an embedded IPv4 address\n     * @return {@link Inet4Address} of the embedded IPv4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv4 compatible address\n     */\n    public static Inet4Address getCompatIPv4Address(Inet6Address ip)\n    {\n        checkArgument(\n            isCompatIPv4Address(ip), \"Address '%s' is not IPv4-compatible.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n    }\n\n    /**\n     * Evaluates whether the argument is a 6to4 address.\n     *\n     * <p>6to4 addresses begin with the {@code \"2002::/16\"} prefix. The next 32 bits are the IPv4\n     * address of the host to which IPv6-in-IPv4 tunneled packets should be routed.\n     *\n     * <p>For more on 6to4 addresses see section 2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3056#section-2\">RFC 3056</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for 6to4 address format\n     * @return {@code true} if the argument is a 6to4 address\n     */\n    public static boolean is6to4Address(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20) && (bytes[1] == (byte) 0x02);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in a 6to4 address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in 6to4 address\n     * @return {@link Inet4Address} of embedded IPv4 in 6to4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 6to4 address\n     */\n    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n    {\n        checkArgument(is6to4Address(ip), \"Address '%s' is not a 6to4 address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 2, 6));\n    }\n\n    /**\n     * A simple immutable data class to encapsulate the information to be found in a Teredo address.\n     *\n     * <p>All of the fields in this class are encoded in various portions of the IPv6 address as part\n     * of the protocol. More protocols details can be found at: <a target=\"_parent\"\n     * href=\"http://en.wikipedia.org/wiki/Teredo_tunneling\">http://en.wikipedia.\n     * org/wiki/Teredo_tunneling</a>.\n     *\n     * <p>The RFC can be found here: <a target=\"_parent\" href=\"http://tools.ietf.org/html/rfc4380\">RFC\n     * 4380</a>.\n     *\n     * @since 5.0\n     */\n    @Beta\n    public static final class TeredoInfo\n    {\n        private final Inet4Address server;\n        private final Inet4Address client;\n        private final int port;\n        private final int flags;\n\n        /**\n         * Constructs a TeredoInfo instance.\n         *\n         * <p>Both server and client can be {@code null}, in which case the value {@code \"0.0.0.0\"} will\n         * be assumed.\n         *\n         * @throws IllegalArgumentException if either of the {@code port} or the {@code flags} arguments\n         *     are out of range of an unsigned short\n         */\n        // TODO: why is this public?\n        public TeredoInfo(\n            @NullableDecl Inet4Address server, @NullableDecl Inet4Address client, int port, int flags)\n        {\n            checkArgument(\n                (port >= 0) && (port <= 0xffff), \"port '%s' is out of range (0 <= port <= 0xffff)\", port);\n            checkArgument(\n                (flags >= 0) && (flags <= 0xffff),\n                \"flags '%s' is out of range (0 <= flags <= 0xffff)\",\n                flags);\n\n            this.server = MoreObjects.firstNonNull(server, ANY4);\n            this.client = MoreObjects.firstNonNull(client, ANY4);\n            this.port = port;\n            this.flags = flags;\n        }\n\n        public Inet4Address getServer()\n        {\n            return server;\n        }\n\n        public Inet4Address getClient()\n        {\n            return client;\n        }\n\n        public int getPort()\n        {\n            return port;\n        }\n\n        public int getFlags()\n        {\n            return flags;\n        }\n    }\n\n    /**\n     * Evaluates whether the argument is a Teredo address.\n     *\n     * <p>Teredo addresses begin with the {@code \"2001::/32\"} prefix.\n     *\n     * @param ip {@link Inet6Address} to be examined for Teredo address format\n     * @return {@code true} if the argument is a Teredo address\n     */\n    public static boolean isTeredoAddress(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20)\n               && (bytes[1] == (byte) 0x01)\n               && (bytes[2] == 0)\n               && (bytes[3] == 0);\n    }\n\n    /**\n     * Returns the Teredo information embedded in a Teredo address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded Teredo information\n     * @return extracted {@code TeredoInfo}\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 Teredo address\n     */\n    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n    {\n        checkArgument(isTeredoAddress(ip), \"Address '%s' is not a Teredo address.\", toAddrString(ip));\n\n        byte[] bytes = ip.getAddress();\n        Inet4Address server = getInet4Address(Arrays.copyOfRange(bytes, 4, 8));\n\n        int flags = ByteStreams.newDataInput(bytes, 8).readShort() & 0xffff;\n\n        // Teredo obfuscates the mapped client port, per section 4 of the RFC.\n        int port = ~ByteStreams.newDataInput(bytes, 10).readShort() & 0xffff;\n\n        byte[] clientBytes = Arrays.copyOfRange(bytes, 12, 16);\n        for (int i = 0; i < clientBytes.length; i++)\n        {\n            // Teredo obfuscates the mapped client IP, per section 4 of the RFC.\n            clientBytes[i] = (byte) ~clientBytes[i];\n        }\n        Inet4Address client = getInet4Address(clientBytes);\n\n        return new TeredoInfo(server, client, port, flags);\n    }\n\n    /**\n     * Evaluates whether the argument is an ISATAP address.\n     *\n     * <p>From RFC 5214: \"ISATAP interface identifiers are constructed in Modified EUI-64 format [...]\n     * by concatenating the 24-bit IANA OUI (00-00-5E), the 8-bit hexadecimal value 0xFE, and a 32-bit\n     * IPv4 address in network byte order [...]\"\n     *\n     * <p>For more on ISATAP addresses see section 6.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc5214#section-6.1\">RFC 5214</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for ISATAP address format\n     * @return {@code true} if the argument is an ISATAP address\n     */\n    public static boolean isIsatapAddress(Inet6Address ip)\n    {\n\n        // If it's a Teredo address with the right port (41217, or 0xa101)\n        // which would be encoded as 0x5efe then it can't be an ISATAP address.\n        if (isTeredoAddress(ip))\n        {\n            return false;\n        }\n\n        byte[] bytes = ip.getAddress();\n\n        if ((bytes[8] | (byte) 0x03) != (byte) 0x03)\n        {\n\n            // Verify that high byte of the 64 bit identifier is zero, modulo\n            // the U/L and G bits, with which we are not concerned.\n            return false;\n        }\n\n        return (bytes[9] == (byte) 0x00) && (bytes[10] == (byte) 0x5e) && (bytes[11] == (byte) 0xfe);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in an ISATAP address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in ISATAP address\n     * @return {@link Inet4Address} of embedded IPv4 in an ISATAP address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 ISATAP address\n     */\n    public static Inet4Address getIsatapIPv4Address(Inet6Address ip)\n    {\n        checkArgument(isIsatapAddress(ip), \"Address '%s' is not an ISATAP address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n    }\n\n    /**\n     * Examines the Inet6Address to determine if it is an IPv6 address of one of the specified address\n     * types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@code true} if there is an embedded IPv4 client address\n     * @since 7.0\n     */\n    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        return isCompatIPv4Address(ip) || is6to4Address(ip) || isTeredoAddress(ip);\n    }\n\n    /**\n     * Examines the Inet6Address to extract the embedded IPv4 client address if the InetAddress is an\n     * IPv6 address of one of the specified address types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@link Inet4Address} of embedded IPv4 client address\n     * @throws IllegalArgumentException if the argument does not have a valid embedded IPv4 address\n     */\n    public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        if (isCompatIPv4Address(ip))\n        {\n            return getCompatIPv4Address(ip);\n        }\n\n        if (is6to4Address(ip))\n        {\n            return get6to4IPv4Address(ip);\n        }\n\n        if (isTeredoAddress(ip))\n        {\n            return getTeredoInfo(ip).getClient();\n        }\n\n        throw formatIllegalArgumentException(\"'%s' has no embedded IPv4 address.\", toAddrString(ip));\n    }\n\n    /**\n     * Evaluates whether the argument is an \"IPv4 mapped\" IPv6 address.\n     *\n     * <p>An \"IPv4 mapped\" address is anything in the range ::ffff:0:0/96 (sometimes written as\n     * ::ffff:0.0.0.0/96), with the last 32 bits interpreted as an IPv4 address.\n     *\n     * <p>For more on IPv4 mapped addresses see section 2.5.5.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.2\">RFC 4291</a>.\n     *\n     * <p>Note: This method takes a {@code String} argument because {@link InetAddress} automatically\n     * collapses mapped addresses to IPv4. (It is actually possible to avoid this using one of the\n     * obscure {@link Inet6Address} methods, but it would be unwise to depend on such a\n     * poorly-documented feature.)\n     *\n     * @param ipString {@code String} to be examined for embedded IPv4-mapped IPv6 address format\n     * @return {@code true} if the argument is a valid \"mapped\" address\n     * @since 10.0\n     */\n\n    /**\n     * Coerces an IPv6 address into an IPv4 address.\n     *\n     * <p>HACK: As long as applications continue to use IPv4 addresses for indexing into tables,\n     * accounting, et cetera, it may be necessary to <b>coerce</b> IPv6 addresses into IPv4 addresses.\n     * This function does so by hashing the upper 64 bits into {@code 224.0.0.0/3} (64 bits into 29\n     * bits).\n     *\n     * <p>A \"coerced\" IPv4 address is equivalent to itself.\n     *\n     * <p>NOTE: This function is failsafe for security purposes: ALL IPv6 addresses (except localhost\n     * (::1)) are hashed to avoid the security risk associated with extracting an embedded IPv4\n     * address that might permit elevated privileges.\n     *\n     * @param ip {@link InetAddress} to \"coerce\"\n     * @return {@link Inet4Address} represented \"coerced\" address\n     * @since 7.0\n     */\n    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n    {\n        if (ip instanceof Inet4Address)\n        {\n            return (Inet4Address) ip;\n        }\n\n        // Special cases:\n        byte[] bytes = ip.getAddress();\n        boolean leadingBytesOfZero = true;\n        for (int i = 0; i < 15; ++i)\n        {\n            if (bytes[i] != 0)\n            {\n                leadingBytesOfZero = false;\n                break;\n            }\n        }\n        if (leadingBytesOfZero && (bytes[15] == 1))\n        {\n            return LOOPBACK4; // ::1\n        }\n        else if (leadingBytesOfZero && (bytes[15] == 0))\n        {\n            return ANY4; // ::0\n        }\n\n        Inet6Address ip6 = (Inet6Address) ip;\n        long addressAsLong = 0;\n        if (hasEmbeddedIPv4ClientAddress(ip6))\n        {\n            addressAsLong = getEmbeddedIPv4ClientAddress(ip6).hashCode();\n        }\n        else\n        {\n\n            // Just extract the high 64 bits (assuming the rest is user-modifiable).\n            addressAsLong = ByteBuffer.wrap(ip6.getAddress(), 0, 8).getLong();\n        }\n\n        // Many strategies for hashing are possible. This might suffice for now.\n        int coercedHash = Hashing.murmur3_32().hashLong(addressAsLong).asInt();\n\n        // Squash into 224/4 Multicast and 240/4 Reserved space (i.e. 224/3).\n        coercedHash |= 0xe0000000;\n\n        // Fixup to avoid some \"illegal\" values. Currently the only potential\n        // illegal value is 255.255.255.255.\n        if (coercedHash == 0xffffffff)\n        {\n            coercedHash = 0xfffffffe;\n        }\n\n        return getInet4Address(Ints.toByteArray(coercedHash));\n    }\n\n    /**\n     * Returns an integer representing an IPv4 address regardless of whether the supplied argument is\n     * an IPv4 address or not.\n     *\n     * <p>IPv6 addresses are <b>coerced</b> to IPv4 addresses before being converted to integers.\n     *\n     * <p>As long as there are applications that assume that all IP addresses are IPv4 addresses and\n     * can therefore be converted safely to integers (for whatever purpose) this function can be used\n     * to handle IPv6 addresses as well until the application is suitably fixed.\n     *\n     * <p>NOTE: an IPv6 address coerced to an IPv4 address can only be used for such purposes as\n     * rudimentary identification or indexing into a collection of real {@link InetAddress}es. They\n     * cannot be used as real addresses for the purposes of network communication.\n     *\n     * @param ip {@link InetAddress} to convert\n     * @return {@code int}, \"coerced\" if ip is not an IPv4 address\n     * @since 7.0\n     */\n    public static int coerceToInteger(InetAddress ip)\n    {\n        return ByteStreams.newDataInput(getCoercedIPv4Address(ip).getAddress()).readInt();\n    }\n\n    /**\n     * Returns an Inet4Address having the integer value specified by the argument.\n     *\n     * @param address {@code int}, the 32bit integer address to be converted\n     * @return {@link Inet4Address} equivalent of the argument\n     */\n    public static Inet4Address fromInteger(int address)\n    {\n        return getInet4Address(Ints.toByteArray(address));\n    }\n\n    /**\n     * Returns an address from a <b>little-endian ordered</b> byte array (the opposite of what {@link\n     * InetAddress#getByAddress} expects).\n     *\n     * <p>IPv4 address byte array must be 4 bytes long and IPv6 byte array must be 16 bytes long.\n     *\n     * @param addr the raw IP address in little-endian byte order\n     * @return an InetAddress object created from the raw IP address\n     * @throws UnknownHostException if IP address is of illegal length\n     */\n    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n    {\n        byte[] reversed = new byte[addr.length];\n        for (int i = 0; i < addr.length; i++)\n        {\n            reversed[i] = addr[addr.length - i - 1];\n        }\n        return InetAddress.getByAddress(reversed);\n    }\n\n    /**\n     * Returns a new InetAddress that is one less than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to decrement\n     * @return a new InetAddress that is one less than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the beginning of its range\n     * @since 18.0\n     */\n    public static InetAddress decrement(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0x00)\n        {\n            addr[i] = (byte) 0xff;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Decrementing %s would wrap.\", address);\n\n        addr[i]--;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns a new InetAddress that is one more than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to increment\n     * @return a new InetAddress that is one more than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the end of its range\n     * @since 10.0\n     */\n    public static InetAddress increment(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0xff)\n        {\n            addr[i] = 0;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Incrementing %s would wrap.\", address);\n\n        addr[i]++;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns true if the InetAddress is either 255.255.255.255 for IPv4 or\n     * ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6.\n     *\n     * @return true if the InetAddress is either 255.255.255.255 for IPv4 or\n     *     ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6\n     * @since 10.0\n     */\n    public static boolean isMaximum(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        for (int i = 0; i < addr.length; i++)\n        {\n            if (addr[i] != (byte) 0xff)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static IllegalArgumentException formatIllegalArgumentException(\n        String format, Object... args)\n    {\n        return new IllegalArgumentException(String.format(Locale.ROOT, format, args));\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.decrement", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns a new InetAddress that is one less than the passed in address. This method works for\nboth IPv4 and IPv6 addresses.\n\n@param address the InetAddress to decrement\n@return a new InetAddress that is one less than the passed in address\n@throws IllegalArgumentException if InetAddress is at the beginning of its range\n@since 18.0", "docstring_tokens": ["Returns", "a", "new", "InetAddress", "that", "is", "one", "less", "than", "the", "passed", "in", "address", ".", "This", "method", "works", "for", "both", "IPv4", "and", "IPv6", "addresses", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L935-L947", "partition": "valid", "up_fun_num": 34, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.MoreObjects;", "import com.google.common.base.Splitter;", "import com.google.common.collect.Iterables;", "import com.google.common.hash.Hashing;", "import com.google.common.io.ByteStreams;", "import com.google.common.primitives.Ints;", "import java.net.Inet4Address;", "import java.net.Inet6Address;", "import java.net.InetAddress;", "import java.net.UnknownHostException;", "import java.nio.ByteBuffer;", "import java.util.Arrays;", "import java.util.List;", "import java.util.Locale;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class InetAddresses\n", "    private static Inet4Address getInet4Address(byte[] bytes)\n", "    public static InetAddress forString(String ipString)\n", "    public static boolean isInetAddress(String ipString)\n", "    private static byte[] ipStringToBytes(String ipString)\n", "    private static byte[] textToNumericFormatV4(String ipString)\n", "    private static byte[] textToNumericFormatV6(String ipString)\n", "    private static String convertDottedQuadToHex(String ipString)\n", "    private static byte parseOctet(String ipPart)\n", "    private static short parseHextet(String ipPart)\n", "    private static InetAddress bytesToInetAddress(byte[] addr)\n", "    public static String toAddrString(InetAddress ip)\n", "    private static void compressLongestRunOfZeroes(int[] hextets)\n", "    private static String hextetsToIPv6String(int[] hextets)\n", "    public static String toUriString(InetAddress ip)\n", "    public static InetAddress forUriString(String hostAddr)\n", "    private static InetAddress forUriStringNoThrow(String hostAddr)\n", "    public static boolean isUriInetAddress(String ipString)\n", "    public static boolean isCompatIPv4Address(Inet6Address ip)\n", "    public static Inet4Address getCompatIPv4Address(Inet6Address ip)\n", "    public static boolean is6to4Address(Inet6Address ip)\n", "    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n", "    public static boolean isTeredoAddress(Inet6Address ip)\n", "    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n", "    public static boolean isIsatapAddress(Inet6Address ip)\n", "    public static Inet4Address getIsatapIPv4Address(Inet6Address ip)\n", "    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip)\n", "    public static boolean isMappedIPv4Address(String ipString)\n", "    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n", "    public static int coerceToInteger(InetAddress ip)\n", "    public static Inet4Address fromInteger(int address)\n", "    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n", "    public static InetAddress increment(InetAddress address)\n", "    public static boolean isMaximum(InetAddress address)\n", "    private static IllegalArgumentException formatIllegalArgumentException(\n"], "context": "/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.net;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.Iterables;\nimport com.google.common.hash.Hashing;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.primitives.Ints;\nimport java.net.Inet4Address;\nimport java.net.Inet6Address;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * Static utility methods pertaining to {@link InetAddress} instances.\n *\n * <p><b>Important note:</b> Unlike {@code InetAddress.getByName()}, the methods of this class never\n * cause DNS services to be accessed. For this reason, you should prefer these methods as much as\n * possible over their JDK equivalents whenever you are expecting to handle only IP address string\n * literals -- there is no blocking DNS penalty for a malformed string.\n *\n * <p>When dealing with {@link Inet4Address} and {@link Inet6Address} objects as byte arrays (vis.\n * {@code InetAddress.getAddress()}) they are 4 and 16 bytes in length, respectively, and represent\n * the address in network byte order.\n *\n * <p>Examples of IP addresses and their byte representations:\n *\n * <dl>\n *   <dt>The IPv4 loopback address, {@code \"127.0.0.1\"}.\n *   <dd>{@code 7f 00 00 01}\n *   <dt>The IPv6 loopback address, {@code \"::1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>From the IPv6 reserved documentation prefix ({@code 2001:db8::/32}), {@code \"2001:db8::1\"}.\n *   <dd>{@code 20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01}\n *   <dt>An IPv6 \"IPv4 compatible\" (or \"compat\") address, {@code \"::192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 c0 a8 00 01}\n *   <dt>An IPv6 \"IPv4 mapped\" address, {@code \"::ffff:192.168.0.1\"}.\n *   <dd>{@code 00 00 00 00 00 00 00 00 00 00 ff ff c0 a8 00 01}\n * </dl>\n *\n * <p>A few notes about IPv6 \"IPv4 mapped\" addresses and their observed use in Java.\n *\n * <p>\"IPv4 mapped\" addresses were originally a representation of IPv4 addresses for use on an IPv6\n * socket that could receive both IPv4 and IPv6 connections (by disabling the {@code IPV6_V6ONLY}\n * socket option on an IPv6 socket). Yes, it's confusing. Nevertheless, these \"mapped\" addresses\n * were never supposed to be seen on the wire. That assumption was dropped, some say mistakenly, in\n * later RFCs with the apparent aim of making IPv4-to-IPv6 transition simpler.\n *\n * <p>Technically one <i>can</i> create a 128bit IPv6 address with the wire format of a \"mapped\"\n * address, as shown above, and transmit it in an IPv6 packet header. However, Java's InetAddress\n * creation methods appear to adhere doggedly to the original intent of the \"mapped\" address: all\n * \"mapped\" addresses return {@link Inet4Address} objects.\n *\n * <p>For added safety, it is common for IPv6 network operators to filter all packets where either\n * the source or destination address appears to be a \"compat\" or \"mapped\" address. Filtering\n * suggestions usually recommend discarding any packets with source or destination addresses in the\n * invalid range {@code ::/3}, which includes both of these bizarre address formats. For more\n * information on \"bogons\", including lists of IPv6 bogon space, see:\n *\n * <ul>\n *   <li><a target=\"_parent\"\n *       href=\"http://en.wikipedia.org/wiki/Bogon_filtering\">http://en.wikipedia.\n *       org/wiki/Bogon_filtering</a>\n *   <li><a target=\"_parent\"\n *       href=\"http://www.cymru.com/Bogons/ipv6.txt\">http://www.cymru.com/Bogons/ ipv6.txt</a>\n *   <li><a target=\"_parent\" href=\"http://www.cymru.com/Bogons/v6bogon.html\">http://www.cymru.com/\n *       Bogons/v6bogon.html</a>\n *   <li><a target=\"_parent\" href=\"http://www.space.net/~gert/RIPE/ipv6-filters.html\">http://www.\n *       space.net/~gert/RIPE/ipv6-filters.html</a>\n * </ul>\n *\n * @author Erik Kline\n * @since 5.0\n */\n@Beta\n@GwtIncompatible\npublic final class InetAddresses\n{\n    private static final int IPV4_PART_COUNT = 4;\n    private static final int IPV6_PART_COUNT = 8;\n    private static final Splitter IPV4_SPLITTER = Splitter.on('.').limit(IPV4_PART_COUNT);\n    private static final Splitter IPV6_SPLITTER = Splitter.on(':').limit(IPV6_PART_COUNT + 2);\n    private static final Inet4Address LOOPBACK4 = (Inet4Address) forString(\"127.0.0.1\");\n    private static final Inet4Address ANY4 = (Inet4Address) forString(\"0.0.0.0\");\n\n    private InetAddresses() {}\n\n    /**\n     * Returns an {@link Inet4Address}, given a byte array representation of the IPv4 address.\n     *\n     * @param bytes byte array representing an IPv4 address (should be of length 4)\n     * @return {@link Inet4Address} corresponding to the supplied byte array\n     * @throws IllegalArgumentException if a valid {@link Inet4Address} can not be created\n     */\n    private static Inet4Address getInet4Address(byte[] bytes)\n    {\n        checkArgument(\n            bytes.length == 4,\n            \"Byte array has invalid length for an IPv4 address: %s != 4.\",\n            bytes.length);\n\n        // Given a 4-byte array, this cast should always succeed.\n        return (Inet4Address) bytesToInetAddress(bytes);\n    }\n\n    /**\n     * Returns the {@link InetAddress} having the given string representation.\n     *\n     * <p>This deliberately avoids all nameservice lookups (e.g. no DNS).\n     *\n     * @param ipString {@code String} containing an IPv4 or IPv6 string literal, e.g. {@code\n     *     \"192.168.0.1\"} or {@code \"2001:db8::1\"}\n     * @return {@link InetAddress} representing the argument\n     * @throws IllegalArgumentException if the argument is not a valid IP string literal\n     */\n    public static InetAddress forString(String ipString)\n    {\n        byte[] addr = ipStringToBytes(ipString);\n\n        // The argument was malformed, i.e. not an IP string literal.\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"'%s' is not an IP string literal.\", ipString);\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP string literal\n     * @return {@code true} if the argument is a valid IP string literal\n     */\n    public static boolean isInetAddress(String ipString)\n    {\n        return ipStringToBytes(ipString) != null;\n    }\n\n    @NullableDecl\n    private static byte[] ipStringToBytes(String ipString)\n    {\n        // Make a first pass to categorize the characters in this string.\n        boolean hasColon = false;\n        boolean hasDot = false;\n        for (int i = 0; i < ipString.length(); i++)\n        {\n            char c = ipString.charAt(i);\n            if (c == '.')\n            {\n                hasDot = true;\n            }\n            else if (c == ':')\n            {\n                if (hasDot)\n                {\n                    return null; // Colons must not appear after dots.\n                }\n                hasColon = true;\n            }\n            else if (Character.digit(c, 16) == -1)\n            {\n                return null; // Everything else must be a decimal or hex digit.\n            }\n        }\n\n        // Now decide which address family to parse.\n        if (hasColon)\n        {\n            if (hasDot)\n            {\n                ipString = convertDottedQuadToHex(ipString);\n                if (ipString == null)\n                {\n                    return null;\n                }\n            }\n            return textToNumericFormatV6(ipString);\n        }\n        else if (hasDot)\n        {\n            return textToNumericFormatV4(ipString);\n        }\n        return null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV4(String ipString)\n    {\n        byte[] bytes = new byte[IPV4_PART_COUNT];\n        int i = 0;\n        try\n        {\n            for (String octet : IPV4_SPLITTER.split(ipString))\n            {\n                bytes[i++] = parseOctet(octet);\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n\n        return i == IPV4_PART_COUNT ? bytes : null;\n    }\n\n    @NullableDecl\n    private static byte[] textToNumericFormatV6(String ipString)\n    {\n        // An address can have [2..8] colons, and N colons make N+1 parts.\n        List<String> parts = IPV6_SPLITTER.splitToList(ipString);\n        if (parts.size() < 3 || parts.size() > IPV6_PART_COUNT + 1)\n        {\n            return null;\n        }\n\n        // Disregarding the endpoints, find \"::\" with nothing in between.\n        // This indicates that a run of zeroes has been skipped.\n        int skipIndex = -1;\n        for (int i = 1; i < parts.size() - 1; i++)\n        {\n            if (parts.get(i).length() == 0)\n            {\n                if (skipIndex >= 0)\n                {\n                    return null; // Can't have more than one ::\n                }\n                skipIndex = i;\n            }\n        }\n\n        int partsHi; // Number of parts to copy from above/before the \"::\"\n        int partsLo; // Number of parts to copy from below/after the \"::\"\n        if (skipIndex >= 0)\n        {\n            // If we found a \"::\", then check if it also covers the endpoints.\n            partsHi = skipIndex;\n            partsLo = parts.size() - skipIndex - 1;\n            if (parts.get(0).length() == 0 && --partsHi != 0)\n            {\n                return null; // ^: requires ^::\n            }\n            if (Iterables.getLast(parts).length() == 0 && --partsLo != 0)\n            {\n                return null; // :$ requires ::$\n            }\n        }\n        else\n        {\n            // Otherwise, allocate the entire address to partsHi. The endpoints\n            // could still be empty, but parseHextet() will check for that.\n            partsHi = parts.size();\n            partsLo = 0;\n        }\n\n        // If we found a ::, then we must have skipped at least one part.\n        // Otherwise, we must have exactly the right number of parts.\n        int partsSkipped = IPV6_PART_COUNT - (partsHi + partsLo);\n        if (!(skipIndex >= 0 ? partsSkipped >= 1 : partsSkipped == 0))\n        {\n            return null;\n        }\n\n        // Now parse the hextets into a byte array.\n        ByteBuffer rawBytes = ByteBuffer.allocate(2 * IPV6_PART_COUNT);\n        try\n        {\n            for (int i = 0; i < partsHi; i++)\n            {\n                rawBytes.putShort(parseHextet(parts.get(i)));\n            }\n            for (int i = 0; i < partsSkipped; i++)\n            {\n                rawBytes.putShort((short) 0);\n            }\n            for (int i = partsLo; i > 0; i--)\n            {\n                rawBytes.putShort(parseHextet(parts.get(parts.size() - i)));\n            }\n        }\n        catch (NumberFormatException ex)\n        {\n            return null;\n        }\n        return rawBytes.array();\n    }\n\n    @NullableDecl\n    private static String convertDottedQuadToHex(String ipString)\n    {\n        int lastColon = ipString.lastIndexOf(':');\n        String initialPart = ipString.substring(0, lastColon + 1);\n        String dottedQuad = ipString.substring(lastColon + 1);\n        byte[] quad = textToNumericFormatV4(dottedQuad);\n        if (quad == null)\n        {\n            return null;\n        }\n        String penultimate = Integer.toHexString(((quad[0] & 0xff) << 8) | (quad[1] & 0xff));\n        String ultimate = Integer.toHexString(((quad[2] & 0xff) << 8) | (quad[3] & 0xff));\n        return initialPart + penultimate + \":\" + ultimate;\n    }\n\n    private static byte parseOctet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int octet = Integer.parseInt(ipPart);\n        // Disallow leading zeroes, because no clear standard exists on\n        // whether these should be interpreted as decimal or octal.\n        if (octet > 255 || (ipPart.startsWith(\"0\") && ipPart.length() > 1))\n        {\n            throw new NumberFormatException();\n        }\n        return (byte) octet;\n    }\n\n    private static short parseHextet(String ipPart)\n    {\n        // Note: we already verified that this string contains only hex digits.\n        int hextet = Integer.parseInt(ipPart, 16);\n        if (hextet > 0xffff)\n        {\n            throw new NumberFormatException();\n        }\n        return (short) hextet;\n    }\n\n    /**\n     * Convert a byte array into an InetAddress.\n     *\n     * <p>{@link InetAddress#getByAddress} is documented as throwing a checked exception \"if IP\n     * address is of illegal length.\" We replace it with an unchecked exception, for use by callers\n     * who already know that addr is an array of length 4 or 16.\n     *\n     * @param addr the raw 4-byte or 16-byte IP address in big-endian order\n     * @return an InetAddress object created from the raw IP address\n     */\n    private static InetAddress bytesToInetAddress(byte[] addr)\n    {\n        try\n        {\n            return InetAddress.getByAddress(addr);\n        }\n        catch (UnknownHostException e)\n        {\n            throw new AssertionError(e);\n        }\n    }\n\n    /**\n     * Returns the string representation of an {@link InetAddress}.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses, the output follows <a href=\"http://tools.ietf.org/html/rfc5952\">RFC 5952</a> section\n     * 4. The main difference is that this method uses \"::\" for zero compression, while Java's version\n     * uses the uncompressed form.\n     *\n     * <p>This method uses hexadecimal for all IPv6 addresses, including IPv4-mapped IPv6 addresses\n     * such as \"::c000:201\". The output does not include a Scope ID.\n     *\n     * @param ip {@link InetAddress} to be converted to an address string\n     * @return {@code String} containing the text-formatted IP address\n     * @since 10.0\n     */\n    public static String toAddrString(InetAddress ip)\n    {\n        checkNotNull(ip);\n        if (ip instanceof Inet4Address)\n        {\n            // For IPv4, Java's formatting is good enough.\n            return ip.getHostAddress();\n        }\n        checkArgument(ip instanceof Inet6Address);\n        byte[] bytes = ip.getAddress();\n        int[] hextets = new int[IPV6_PART_COUNT];\n        for (int i = 0; i < hextets.length; i++)\n        {\n            hextets[i] = Ints.fromBytes((byte) 0, (byte) 0, bytes[2 * i], bytes[2 * i + 1]);\n        }\n        compressLongestRunOfZeroes(hextets);\n        return hextetsToIPv6String(hextets);\n    }\n\n    /**\n     * Identify and mark the longest run of zeroes in an IPv6 address.\n     *\n     * <p>Only runs of two or more hextets are considered. In case of a tie, the leftmost run wins. If\n     * a qualifying run is found, its hextets are replaced by the sentinel value -1.\n     *\n     * @param hextets {@code int[]} mutable array of eight 16-bit hextets\n     */\n    private static void compressLongestRunOfZeroes(int[] hextets)\n    {\n        int bestRunStart = -1;\n        int bestRunLength = -1;\n        int runStart = -1;\n        for (int i = 0; i < hextets.length + 1; i++)\n        {\n            if (i < hextets.length && hextets[i] == 0)\n            {\n                if (runStart < 0)\n                {\n                    runStart = i;\n                }\n            }\n            else if (runStart >= 0)\n            {\n                int runLength = i - runStart;\n                if (runLength > bestRunLength)\n                {\n                    bestRunStart = runStart;\n                    bestRunLength = runLength;\n                }\n                runStart = -1;\n            }\n        }\n        if (bestRunLength >= 2)\n        {\n            Arrays.fill(hextets, bestRunStart, bestRunStart + bestRunLength, -1);\n        }\n    }\n\n    /**\n     * Convert a list of hextets into a human-readable IPv6 address.\n     *\n     * <p>In order for \"::\" compression to work, the input should contain negative sentinel values in\n     * place of the elided zeroes.\n     *\n     * @param hextets {@code int[]} array of eight 16-bit hextets, or -1s\n     */\n    private static String hextetsToIPv6String(int[] hextets)\n    {\n        // While scanning the array, handle these state transitions:\n        //   start->num => \"num\"     start->gap => \"::\"\n        //   num->num   => \":num\"    num->gap   => \"::\"\n        //   gap->num   => \"num\"     gap->gap   => \"\"\n        StringBuilder buf = new StringBuilder(39);\n        boolean lastWasNumber = false;\n        for (int i = 0; i < hextets.length; i++)\n        {\n            boolean thisIsNumber = hextets[i] >= 0;\n            if (thisIsNumber)\n            {\n                if (lastWasNumber)\n                {\n                    buf.append(':');\n                }\n                buf.append(Integer.toHexString(hextets[i]));\n            }\n            else\n            {\n                if (i == 0 || lastWasNumber)\n                {\n                    buf.append(\"::\");\n                }\n            }\n            lastWasNumber = thisIsNumber;\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Returns the string representation of an {@link InetAddress} suitable for inclusion in a URI.\n     *\n     * <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6\n     * addresses it compresses zeroes and surrounds the text with square brackets; for example {@code\n     * \"[2001:db8::1]\"}.\n     *\n     * <p>Per section 3.2.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3986#section-3.2.2\">RFC 3986</a>, a URI containing an IPv6\n     * string literal is of the form {@code \"http://[2001:db8::1]:8888/index.html\"}.\n     *\n     * <p>Use of either {@link InetAddresses#toAddrString}, {@link InetAddress#getHostAddress()}, or\n     * this method is recommended over {@link InetAddress#toString()} when an IP address string\n     * literal is desired. This is because {@link InetAddress#toString()} prints the hostname and the\n     * IP address string joined by a \"/\".\n     *\n     * @param ip {@link InetAddress} to be converted to URI string literal\n     * @return {@code String} containing URI-safe string literal\n     */\n    public static String toUriString(InetAddress ip)\n    {\n        if (ip instanceof Inet6Address)\n        {\n            return \"[\" + toAddrString(ip) + \"]\";\n        }\n        return toAddrString(ip);\n    }\n\n    /**\n     * Returns an InetAddress representing the literal IPv4 or IPv6 host portion of a URL, encoded in\n     * the format specified by RFC 3986 section 3.2.2.\n     *\n     * <p>This function is similar to {@link InetAddresses#forString(String)}, however, it requires\n     * that IPv6 addresses are surrounded by square brackets.\n     *\n     * <p>This function is the inverse of {@link InetAddresses#toUriString(java.net.InetAddress)}.\n     *\n     * @param hostAddr A RFC 3986 section 3.2.2 encoded IPv4 or IPv6 address\n     * @return an InetAddress representing the address in {@code hostAddr}\n     * @throws IllegalArgumentException if {@code hostAddr} is not a valid IPv4 address, or IPv6\n     *     address surrounded by square brackets\n     */\n    public static InetAddress forUriString(String hostAddr)\n    {\n        InetAddress addr = forUriStringNoThrow(hostAddr);\n        if (addr == null)\n        {\n            throw formatIllegalArgumentException(\"Not a valid URI IP literal: '%s'\", hostAddr);\n        }\n\n        return addr;\n    }\n\n    @NullableDecl\n    private static InetAddress forUriStringNoThrow(String hostAddr)\n    {\n        checkNotNull(hostAddr);\n\n        // Decide if this should be an IPv6 or IPv4 address.\n        String ipString;\n        int expectBytes;\n        if (hostAddr.startsWith(\"[\") && hostAddr.endsWith(\"]\"))\n        {\n            ipString = hostAddr.substring(1, hostAddr.length() - 1);\n            expectBytes = 16;\n        }\n        else\n        {\n            ipString = hostAddr;\n            expectBytes = 4;\n        }\n\n        // Parse the address, and make sure the length/version is correct.\n        byte[] addr = ipStringToBytes(ipString);\n        if (addr == null || addr.length != expectBytes)\n        {\n            return null;\n        }\n\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns {@code true} if the supplied string is a valid URI IP string literal, {@code false}\n     * otherwise.\n     *\n     * @param ipString {@code String} to evaluated as an IP URI host string literal\n     * @return {@code true} if the argument is a valid IP URI host\n     */\n    public static boolean isUriInetAddress(String ipString)\n    {\n        return forUriStringNoThrow(ipString) != null;\n    }\n\n    /**\n     * Evaluates whether the argument is an IPv6 \"compat\" address.\n     *\n     * <p>An \"IPv4 compatible\", or \"compat\", address is one with 96 leading bits of zero, with the\n     * remaining 32 bits interpreted as an IPv4 address. These are conventionally represented in\n     * string literals as {@code \"::192.168.0.1\"}, though {@code \"::c0a8:1\"} is also considered an\n     * IPv4 compatible address (and equivalent to {@code \"::192.168.0.1\"}).\n     *\n     * <p>For more on IPv4 compatible addresses see section 2.5.5.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.1\">RFC 4291</a>.\n     *\n     * <p>NOTE: This method is different from {@link Inet6Address#isIPv4CompatibleAddress} in that it\n     * more correctly classifies {@code \"::\"} and {@code \"::1\"} as proper IPv6 addresses (which they\n     * are), NOT IPv4 compatible addresses (which they are generally NOT considered to be).\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 compatible address format\n     * @return {@code true} if the argument is a valid \"compat\" address\n     */\n    public static boolean isCompatIPv4Address(Inet6Address ip)\n    {\n        if (!ip.isIPv4CompatibleAddress())\n        {\n            return false;\n        }\n\n        byte[] bytes = ip.getAddress();\n        if ((bytes[12] == 0)\n                && (bytes[13] == 0)\n                && (bytes[14] == 0)\n                && ((bytes[15] == 0) || (bytes[15] == 1)))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the IPv4 address embedded in an IPv4 compatible address.\n     *\n     * @param ip {@link Inet6Address} to be examined for an embedded IPv4 address\n     * @return {@link Inet4Address} of the embedded IPv4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv4 compatible address\n     */\n    public static Inet4Address getCompatIPv4Address(Inet6Address ip)\n    {\n        checkArgument(\n            isCompatIPv4Address(ip), \"Address '%s' is not IPv4-compatible.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n    }\n\n    /**\n     * Evaluates whether the argument is a 6to4 address.\n     *\n     * <p>6to4 addresses begin with the {@code \"2002::/16\"} prefix. The next 32 bits are the IPv4\n     * address of the host to which IPv6-in-IPv4 tunneled packets should be routed.\n     *\n     * <p>For more on 6to4 addresses see section 2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc3056#section-2\">RFC 3056</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for 6to4 address format\n     * @return {@code true} if the argument is a 6to4 address\n     */\n    public static boolean is6to4Address(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20) && (bytes[1] == (byte) 0x02);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in a 6to4 address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in 6to4 address\n     * @return {@link Inet4Address} of embedded IPv4 in 6to4 address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 6to4 address\n     */\n    public static Inet4Address get6to4IPv4Address(Inet6Address ip)\n    {\n        checkArgument(is6to4Address(ip), \"Address '%s' is not a 6to4 address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 2, 6));\n    }\n\n    /**\n     * A simple immutable data class to encapsulate the information to be found in a Teredo address.\n     *\n     * <p>All of the fields in this class are encoded in various portions of the IPv6 address as part\n     * of the protocol. More protocols details can be found at: <a target=\"_parent\"\n     * href=\"http://en.wikipedia.org/wiki/Teredo_tunneling\">http://en.wikipedia.\n     * org/wiki/Teredo_tunneling</a>.\n     *\n     * <p>The RFC can be found here: <a target=\"_parent\" href=\"http://tools.ietf.org/html/rfc4380\">RFC\n     * 4380</a>.\n     *\n     * @since 5.0\n     */\n    @Beta\n    public static final class TeredoInfo\n    {\n        private final Inet4Address server;\n        private final Inet4Address client;\n        private final int port;\n        private final int flags;\n\n        /**\n         * Constructs a TeredoInfo instance.\n         *\n         * <p>Both server and client can be {@code null}, in which case the value {@code \"0.0.0.0\"} will\n         * be assumed.\n         *\n         * @throws IllegalArgumentException if either of the {@code port} or the {@code flags} arguments\n         *     are out of range of an unsigned short\n         */\n        // TODO: why is this public?\n        public TeredoInfo(\n            @NullableDecl Inet4Address server, @NullableDecl Inet4Address client, int port, int flags)\n        {\n            checkArgument(\n                (port >= 0) && (port <= 0xffff), \"port '%s' is out of range (0 <= port <= 0xffff)\", port);\n            checkArgument(\n                (flags >= 0) && (flags <= 0xffff),\n                \"flags '%s' is out of range (0 <= flags <= 0xffff)\",\n                flags);\n\n            this.server = MoreObjects.firstNonNull(server, ANY4);\n            this.client = MoreObjects.firstNonNull(client, ANY4);\n            this.port = port;\n            this.flags = flags;\n        }\n\n        public Inet4Address getServer()\n        {\n            return server;\n        }\n\n        public Inet4Address getClient()\n        {\n            return client;\n        }\n\n        public int getPort()\n        {\n            return port;\n        }\n\n        public int getFlags()\n        {\n            return flags;\n        }\n    }\n\n    /**\n     * Evaluates whether the argument is a Teredo address.\n     *\n     * <p>Teredo addresses begin with the {@code \"2001::/32\"} prefix.\n     *\n     * @param ip {@link Inet6Address} to be examined for Teredo address format\n     * @return {@code true} if the argument is a Teredo address\n     */\n    public static boolean isTeredoAddress(Inet6Address ip)\n    {\n        byte[] bytes = ip.getAddress();\n        return (bytes[0] == (byte) 0x20)\n               && (bytes[1] == (byte) 0x01)\n               && (bytes[2] == 0)\n               && (bytes[3] == 0);\n    }\n\n    /**\n     * Returns the Teredo information embedded in a Teredo address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded Teredo information\n     * @return extracted {@code TeredoInfo}\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 Teredo address\n     */\n    public static TeredoInfo getTeredoInfo(Inet6Address ip)\n    {\n        checkArgument(isTeredoAddress(ip), \"Address '%s' is not a Teredo address.\", toAddrString(ip));\n\n        byte[] bytes = ip.getAddress();\n        Inet4Address server = getInet4Address(Arrays.copyOfRange(bytes, 4, 8));\n\n        int flags = ByteStreams.newDataInput(bytes, 8).readShort() & 0xffff;\n\n        // Teredo obfuscates the mapped client port, per section 4 of the RFC.\n        int port = ~ByteStreams.newDataInput(bytes, 10).readShort() & 0xffff;\n\n        byte[] clientBytes = Arrays.copyOfRange(bytes, 12, 16);\n        for (int i = 0; i < clientBytes.length; i++)\n        {\n            // Teredo obfuscates the mapped client IP, per section 4 of the RFC.\n            clientBytes[i] = (byte) ~clientBytes[i];\n        }\n        Inet4Address client = getInet4Address(clientBytes);\n\n        return new TeredoInfo(server, client, port, flags);\n    }\n\n    /**\n     * Evaluates whether the argument is an ISATAP address.\n     *\n     * <p>From RFC 5214: \"ISATAP interface identifiers are constructed in Modified EUI-64 format [...]\n     * by concatenating the 24-bit IANA OUI (00-00-5E), the 8-bit hexadecimal value 0xFE, and a 32-bit\n     * IPv4 address in network byte order [...]\"\n     *\n     * <p>For more on ISATAP addresses see section 6.1 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc5214#section-6.1\">RFC 5214</a>.\n     *\n     * @param ip {@link Inet6Address} to be examined for ISATAP address format\n     * @return {@code true} if the argument is an ISATAP address\n     */\n    public static boolean isIsatapAddress(Inet6Address ip)\n    {\n\n        // If it's a Teredo address with the right port (41217, or 0xa101)\n        // which would be encoded as 0x5efe then it can't be an ISATAP address.\n        if (isTeredoAddress(ip))\n        {\n            return false;\n        }\n\n        byte[] bytes = ip.getAddress();\n\n        if ((bytes[8] | (byte) 0x03) != (byte) 0x03)\n        {\n\n            // Verify that high byte of the 64 bit identifier is zero, modulo\n            // the U/L and G bits, with which we are not concerned.\n            return false;\n        }\n\n        return (bytes[9] == (byte) 0x00) && (bytes[10] == (byte) 0x5e) && (bytes[11] == (byte) 0xfe);\n    }\n\n    /**\n     * Returns the IPv4 address embedded in an ISATAP address.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 in ISATAP address\n     * @return {@link Inet4Address} of embedded IPv4 in an ISATAP address\n     * @throws IllegalArgumentException if the argument is not a valid IPv6 ISATAP address\n     */\n    public static Inet4Address getIsatapIPv4Address(Inet6Address ip)\n    {\n        checkArgument(isIsatapAddress(ip), \"Address '%s' is not an ISATAP address.\", toAddrString(ip));\n\n        return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n    }\n\n    /**\n     * Examines the Inet6Address to determine if it is an IPv6 address of one of the specified address\n     * types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@code true} if there is an embedded IPv4 client address\n     * @since 7.0\n     */\n    public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        return isCompatIPv4Address(ip) || is6to4Address(ip) || isTeredoAddress(ip);\n    }\n\n    /**\n     * Examines the Inet6Address to extract the embedded IPv4 client address if the InetAddress is an\n     * IPv6 address of one of the specified address types that contain an embedded IPv4 address.\n     *\n     * <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\n     * spoofability. With other transition addresses spoofing involves (at least) infection of one's\n     * BGP routing table.\n     *\n     * @param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n     * @return {@link Inet4Address} of embedded IPv4 client address\n     * @throws IllegalArgumentException if the argument does not have a valid embedded IPv4 address\n     */\n    public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip)\n    {\n        if (isCompatIPv4Address(ip))\n        {\n            return getCompatIPv4Address(ip);\n        }\n\n        if (is6to4Address(ip))\n        {\n            return get6to4IPv4Address(ip);\n        }\n\n        if (isTeredoAddress(ip))\n        {\n            return getTeredoInfo(ip).getClient();\n        }\n\n        throw formatIllegalArgumentException(\"'%s' has no embedded IPv4 address.\", toAddrString(ip));\n    }\n\n    /**\n     * Evaluates whether the argument is an \"IPv4 mapped\" IPv6 address.\n     *\n     * <p>An \"IPv4 mapped\" address is anything in the range ::ffff:0:0/96 (sometimes written as\n     * ::ffff:0.0.0.0/96), with the last 32 bits interpreted as an IPv4 address.\n     *\n     * <p>For more on IPv4 mapped addresses see section 2.5.5.2 of <a target=\"_parent\"\n     * href=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.2\">RFC 4291</a>.\n     *\n     * <p>Note: This method takes a {@code String} argument because {@link InetAddress} automatically\n     * collapses mapped addresses to IPv4. (It is actually possible to avoid this using one of the\n     * obscure {@link Inet6Address} methods, but it would be unwise to depend on such a\n     * poorly-documented feature.)\n     *\n     * @param ipString {@code String} to be examined for embedded IPv4-mapped IPv6 address format\n     * @return {@code true} if the argument is a valid \"mapped\" address\n     * @since 10.0\n     */\n    public static boolean isMappedIPv4Address(String ipString)\n    {\n        byte[] bytes = ipStringToBytes(ipString);\n        if (bytes != null && bytes.length == 16)\n        {\n            for (int i = 0; i < 10; i++)\n            {\n                if (bytes[i] != 0)\n                {\n                    return false;\n                }\n            }\n            for (int i = 10; i < 12; i++)\n            {\n                if (bytes[i] != (byte) 0xff)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Coerces an IPv6 address into an IPv4 address.\n     *\n     * <p>HACK: As long as applications continue to use IPv4 addresses for indexing into tables,\n     * accounting, et cetera, it may be necessary to <b>coerce</b> IPv6 addresses into IPv4 addresses.\n     * This function does so by hashing the upper 64 bits into {@code 224.0.0.0/3} (64 bits into 29\n     * bits).\n     *\n     * <p>A \"coerced\" IPv4 address is equivalent to itself.\n     *\n     * <p>NOTE: This function is failsafe for security purposes: ALL IPv6 addresses (except localhost\n     * (::1)) are hashed to avoid the security risk associated with extracting an embedded IPv4\n     * address that might permit elevated privileges.\n     *\n     * @param ip {@link InetAddress} to \"coerce\"\n     * @return {@link Inet4Address} represented \"coerced\" address\n     * @since 7.0\n     */\n    public static Inet4Address getCoercedIPv4Address(InetAddress ip)\n    {\n        if (ip instanceof Inet4Address)\n        {\n            return (Inet4Address) ip;\n        }\n\n        // Special cases:\n        byte[] bytes = ip.getAddress();\n        boolean leadingBytesOfZero = true;\n        for (int i = 0; i < 15; ++i)\n        {\n            if (bytes[i] != 0)\n            {\n                leadingBytesOfZero = false;\n                break;\n            }\n        }\n        if (leadingBytesOfZero && (bytes[15] == 1))\n        {\n            return LOOPBACK4; // ::1\n        }\n        else if (leadingBytesOfZero && (bytes[15] == 0))\n        {\n            return ANY4; // ::0\n        }\n\n        Inet6Address ip6 = (Inet6Address) ip;\n        long addressAsLong = 0;\n        if (hasEmbeddedIPv4ClientAddress(ip6))\n        {\n            addressAsLong = getEmbeddedIPv4ClientAddress(ip6).hashCode();\n        }\n        else\n        {\n\n            // Just extract the high 64 bits (assuming the rest is user-modifiable).\n            addressAsLong = ByteBuffer.wrap(ip6.getAddress(), 0, 8).getLong();\n        }\n\n        // Many strategies for hashing are possible. This might suffice for now.\n        int coercedHash = Hashing.murmur3_32().hashLong(addressAsLong).asInt();\n\n        // Squash into 224/4 Multicast and 240/4 Reserved space (i.e. 224/3).\n        coercedHash |= 0xe0000000;\n\n        // Fixup to avoid some \"illegal\" values. Currently the only potential\n        // illegal value is 255.255.255.255.\n        if (coercedHash == 0xffffffff)\n        {\n            coercedHash = 0xfffffffe;\n        }\n\n        return getInet4Address(Ints.toByteArray(coercedHash));\n    }\n\n    /**\n     * Returns an integer representing an IPv4 address regardless of whether the supplied argument is\n     * an IPv4 address or not.\n     *\n     * <p>IPv6 addresses are <b>coerced</b> to IPv4 addresses before being converted to integers.\n     *\n     * <p>As long as there are applications that assume that all IP addresses are IPv4 addresses and\n     * can therefore be converted safely to integers (for whatever purpose) this function can be used\n     * to handle IPv6 addresses as well until the application is suitably fixed.\n     *\n     * <p>NOTE: an IPv6 address coerced to an IPv4 address can only be used for such purposes as\n     * rudimentary identification or indexing into a collection of real {@link InetAddress}es. They\n     * cannot be used as real addresses for the purposes of network communication.\n     *\n     * @param ip {@link InetAddress} to convert\n     * @return {@code int}, \"coerced\" if ip is not an IPv4 address\n     * @since 7.0\n     */\n    public static int coerceToInteger(InetAddress ip)\n    {\n        return ByteStreams.newDataInput(getCoercedIPv4Address(ip).getAddress()).readInt();\n    }\n\n    /**\n     * Returns an Inet4Address having the integer value specified by the argument.\n     *\n     * @param address {@code int}, the 32bit integer address to be converted\n     * @return {@link Inet4Address} equivalent of the argument\n     */\n    public static Inet4Address fromInteger(int address)\n    {\n        return getInet4Address(Ints.toByteArray(address));\n    }\n\n    /**\n     * Returns an address from a <b>little-endian ordered</b> byte array (the opposite of what {@link\n     * InetAddress#getByAddress} expects).\n     *\n     * <p>IPv4 address byte array must be 4 bytes long and IPv6 byte array must be 16 bytes long.\n     *\n     * @param addr the raw IP address in little-endian byte order\n     * @return an InetAddress object created from the raw IP address\n     * @throws UnknownHostException if IP address is of illegal length\n     */\n    public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException\n    {\n        byte[] reversed = new byte[addr.length];\n        for (int i = 0; i < addr.length; i++)\n        {\n            reversed[i] = addr[addr.length - i - 1];\n        }\n        return InetAddress.getByAddress(reversed);\n    }\n\n    /**\n     * Returns a new InetAddress that is one less than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to decrement\n     * @return a new InetAddress that is one less than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the beginning of its range\n     * @since 18.0\n     */\n\n    /**\n     * Returns a new InetAddress that is one more than the passed in address. This method works for\n     * both IPv4 and IPv6 addresses.\n     *\n     * @param address the InetAddress to increment\n     * @return a new InetAddress that is one more than the passed in address\n     * @throws IllegalArgumentException if InetAddress is at the end of its range\n     * @since 10.0\n     */\n    public static InetAddress increment(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        int i = addr.length - 1;\n        while (i >= 0 && addr[i] == (byte) 0xff)\n        {\n            addr[i] = 0;\n            i--;\n        }\n\n        checkArgument(i >= 0, \"Incrementing %s would wrap.\", address);\n\n        addr[i]++;\n        return bytesToInetAddress(addr);\n    }\n\n    /**\n     * Returns true if the InetAddress is either 255.255.255.255 for IPv4 or\n     * ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6.\n     *\n     * @return true if the InetAddress is either 255.255.255.255 for IPv4 or\n     *     ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6\n     * @since 10.0\n     */\n    public static boolean isMaximum(InetAddress address)\n    {\n        byte[] addr = address.getAddress();\n        for (int i = 0; i < addr.length; i++)\n        {\n            if (addr[i] != (byte) 0xff)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static IllegalArgumentException formatIllegalArgumentException(\n        String format, Object... args)\n    {\n        return new IllegalArgumentException(String.format(Locale.ROOT, format, args));\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/io/Files.java", "func_name": "Files.newReader", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns a buffered reader that reads from a file using the given character set.\n\n<p><b>{@link java.nio.file.Path} equivalent:</b> {@link\njava.nio.file.Files#newBufferedReader(java.nio.file.Path, Charset)}.\n\n@param file the file to read from\n@param charset the charset used to decode the input stream; see {@link StandardCharsets} for\nhelpful predefined constants\n@return the buffered reader", "docstring_tokens": ["Returns", "a", "buffered", "reader", "that", "reads", "from", "a", "file", "using", "the", "given", "character", "set", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/io/Files.java#L85-L90", "partition": "valid", "up_fun_num": 1, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.io.FileWriteMode.APPEND;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.Joiner;", "import com.google.common.base.Optional;", "import com.google.common.base.Predicate;", "import com.google.common.base.Splitter;", "import com.google.common.collect.ImmutableSet;", "import com.google.common.collect.Lists;", "import com.google.common.collect.TreeTraverser;", "import com.google.common.graph.SuccessorsFunction;", "import com.google.common.graph.Traverser;", "import com.google.common.hash.HashCode;", "import com.google.common.hash.HashFunction;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.io.BufferedReader;", "import java.io.BufferedWriter;", "import java.io.File;", "import java.io.FileInputStream;", "import java.io.FileNotFoundException;", "import java.io.FileOutputStream;", "import java.io.IOException;", "import java.io.InputStreamReader;", "import java.io.OutputStream;", "import java.io.OutputStreamWriter;", "import java.io.RandomAccessFile;", "import java.nio.MappedByteBuffer;", "import java.nio.channels.FileChannel;", "import java.nio.channels.FileChannel.MapMode;", "import java.nio.charset.Charset;", "import java.nio.charset.StandardCharsets;", "import java.util.ArrayList;", "import java.util.Arrays;", "import java.util.Collections;", "import java.util.List;"], "function": ["public final class Files\n", "    public static BufferedWriter newWriter(File file, Charset charset) throws FileNotFoundException\n", "    public static ByteSource asByteSource(File file)\n", "    public static ByteSink asByteSink(File file, FileWriteMode... modes)\n", "    public static CharSource asCharSource(File file, Charset charset)\n", "    public static CharSink asCharSink(File file, Charset charset, FileWriteMode... modes)\n", "    public static byte[] toByteArray(File file) throws IOException\n", "    public static String toString(File file, Charset charset) throws IOException\n", "    public static void write(byte[] from, File to) throws IOException\n", "    public static void write(CharSequence from, File to, Charset charset) throws IOException\n", "    public static void copy(File from, OutputStream to) throws IOException\n", "    public static void copy(File from, File to) throws IOException\n", "    static void copy(File from, Charset charset, Appendable to) throws IOException\n", "    static void append(CharSequence from, File to, Charset charset) throws IOException\n", "    public static boolean equal(File file1, File file2) throws IOException\n", "    public static File createTempDir()\n", "    public static void touch(File file) throws IOException\n", "    public static void createParentDirs(File file) throws IOException\n", "    public static void move(File from, File to) throws IOException\n", "    static String readFirstLine(File file, Charset charset) throws IOException\n", "    public static List<String> readLines(File file, Charset charset) throws IOException\n", "    static <T> T readLines(File file, Charset charset, LineProcessor<T> callback) throws IOException\n", "    static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException\n", "    static HashCode hash(File file, HashFunction hashFunction) throws IOException\n", "    public static MappedByteBuffer map(File file) throws IOException\n", "    public static MappedByteBuffer map(File file, MapMode mode) throws IOException\n", "    public static MappedByteBuffer map(File file, MapMode mode, long size) throws IOException\n", "    private static MappedByteBuffer mapInternal(File file, MapMode mode, long size)\n", "    public static String simplifyPath(String pathname)\n", "    public static String getFileExtension(String fullName)\n", "    public static String getNameWithoutExtension(String file)\n", "    static TreeTraverser<File> fileTreeTraverser()\n", "    public static Traverser<File> fileTraverser()\n", "    private static Iterable<File> fileTreeChildren(File file)\n", "    public static Predicate<File> isDirectory()\n", "    public static Predicate<File> isFile()\n"], "context": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.io.FileWriteMode.APPEND;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.TreeTraverser;\nimport com.google.common.graph.SuccessorsFunction;\nimport com.google.common.graph.Traverser;\nimport com.google.common.hash.HashCode;\nimport com.google.common.hash.HashFunction;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Provides utility methods for working with {@linkplain File files}.\n *\n * <p>{@link java.nio.file.Path} users will find similar utilities in {@link MoreFiles} and the\n * JDK's {@link java.nio.file.Files} class.\n *\n * @author Chris Nokleberg\n * @author Colin Decker\n * @since 1.0\n */\n@GwtIncompatible\npublic final class Files\n{\n\n    /** Maximum loop count when creating temp directories. */\n    private static final int TEMP_DIR_ATTEMPTS = 10000;\n\n    private Files() {}\n\n    /**\n     * Returns a buffered reader that reads from a file using the given character set.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#newBufferedReader(java.nio.file.Path, Charset)}.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return the buffered reader\n     */\n\n    /**\n     * Returns a buffered writer that writes to a file using the given character set.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#newBufferedWriter(java.nio.file.Path, Charset,\n     * java.nio.file.OpenOption...)}.\n     *\n     * @param file the file to write to\n     * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return the buffered writer\n     */\n    @Beta\n    public static BufferedWriter newWriter(File file, Charset charset) throws FileNotFoundException\n    {\n        checkNotNull(file);\n        checkNotNull(charset);\n        return new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset));\n    }\n\n    /**\n     * Returns a new {@link ByteSource} for reading bytes from the given file.\n     *\n     * @since 14.0\n     */\n    public static ByteSource asByteSource(File file)\n    {\n        return new FileByteSource(file);\n    }\n\n    private static final class FileByteSource extends ByteSource\n    {\n\n        private final File file;\n\n        private FileByteSource(File file)\n        {\n            this.file = checkNotNull(file);\n        }\n\n        @Override\n        public FileInputStream openStream() throws IOException\n        {\n            return new FileInputStream(file);\n        }\n\n        @Override\n        public Optional<Long> sizeIfKnown()\n        {\n            if (file.isFile())\n            {\n                return Optional.of(file.length());\n            }\n            else\n            {\n                return Optional.absent();\n            }\n        }\n\n        @Override\n        public long size() throws IOException\n        {\n            if (!file.isFile())\n            {\n                throw new FileNotFoundException(file.toString());\n            }\n            return file.length();\n        }\n\n        @Override\n        public byte[] read() throws IOException\n        {\n            Closer closer = Closer.create();\n            try\n            {\n                FileInputStream in = closer.register(openStream());\n                return ByteStreams.toByteArray(in, in.getChannel().size());\n            }\n            catch (Throwable e)\n            {\n                throw closer.rethrow(e);\n            }\n            finally\n            {\n                closer.close();\n            }\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"Files.asByteSource(\" + file + \")\";\n        }\n    }\n\n    /**\n     * Returns a new {@link ByteSink} for writing bytes to the given file. The given {@code modes}\n     * control how the file is opened for writing. When no mode is provided, the file will be\n     * truncated before writing. When the {@link FileWriteMode#APPEND APPEND} mode is provided, writes\n     * will append to the end of the file without truncating it.\n     *\n     * @since 14.0\n     */\n    public static ByteSink asByteSink(File file, FileWriteMode... modes)\n    {\n        return new FileByteSink(file, modes);\n    }\n\n    private static final class FileByteSink extends ByteSink\n    {\n\n        private final File file;\n        private final ImmutableSet<FileWriteMode> modes;\n\n        private FileByteSink(File file, FileWriteMode... modes)\n        {\n            this.file = checkNotNull(file);\n            this.modes = ImmutableSet.copyOf(modes);\n        }\n\n        @Override\n        public FileOutputStream openStream() throws IOException\n        {\n            return new FileOutputStream(file, modes.contains(APPEND));\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"Files.asByteSink(\" + file + \", \" + modes + \")\";\n        }\n    }\n\n    /**\n     * Returns a new {@link CharSource} for reading character data from the given file using the given\n     * character set.\n     *\n     * @since 14.0\n     */\n    public static CharSource asCharSource(File file, Charset charset)\n    {\n        return asByteSource(file).asCharSource(charset);\n    }\n\n    /**\n     * Returns a new {@link CharSink} for writing character data to the given file using the given\n     * character set. The given {@code modes} control how the file is opened for writing. When no mode\n     * is provided, the file will be truncated before writing. When the {@link FileWriteMode#APPEND\n     * APPEND} mode is provided, writes will append to the end of the file without truncating it.\n     *\n     * @since 14.0\n     */\n    public static CharSink asCharSink(File file, Charset charset, FileWriteMode... modes)\n    {\n        return asByteSink(file, modes).asCharSink(charset);\n    }\n\n    /**\n     * Reads all bytes from a file into a byte array.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#readAllBytes}.\n     *\n     * @param file the file to read from\n     * @return a byte array containing all the bytes from file\n     * @throws IllegalArgumentException if the file is bigger than the largest possible byte array\n     *     (2^31 - 1)\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static byte[] toByteArray(File file) throws IOException\n    {\n        return asByteSource(file).read();\n    }\n\n    /**\n     * Reads all characters from a file into a {@link String}, using the given character set.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return a string containing all the characters from the file\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(file, charset).read()}. This method is scheduled to be\n     *     removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public static String toString(File file, Charset charset) throws IOException\n    {\n        return asCharSource(file, charset).read();\n    }\n\n    /**\n     * Overwrites a file with the contents of a byte array.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#write(java.nio.file.Path, byte[], java.nio.file.OpenOption...)}.\n     *\n     * @param from the bytes to write\n     * @param to the destination file\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static void write(byte[] from, File to) throws IOException\n    {\n        asByteSink(to).write(from);\n    }\n\n    /**\n     * Writes a character sequence (such as a string) to a file using the given character set.\n     *\n     * @param from the character sequence to write\n     * @param to the destination file\n     * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSink(to, charset).write(from)}. This method is scheduled to be\n     *     removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public static void write(CharSequence from, File to, Charset charset) throws IOException\n    {\n        asCharSink(to, charset).write(from);\n    }\n\n    /**\n     * Copies all bytes from a file to an output stream.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#copy(java.nio.file.Path, OutputStream)}.\n     *\n     * @param from the source file\n     * @param to the output stream\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static void copy(File from, OutputStream to) throws IOException\n    {\n        asByteSource(from).copyTo(to);\n    }\n\n    /**\n     * Copies all the bytes from one file to another.\n     *\n     * <p>Copying is not an atomic operation - in the case of an I/O error, power loss, process\n     * termination, or other problems, {@code to} may not be a complete copy of {@code from}. If you\n     * need to guard against those conditions, you should employ other file-level synchronization.\n     *\n     * <p><b>Warning:</b> If {@code to} represents an existing file, that file will be overwritten\n     * with the contents of {@code from}. If {@code to} and {@code from} refer to the <i>same</i>\n     * file, the contents of that file will be deleted.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#copy(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...)}.\n     *\n     * @param from the source file\n     * @param to the destination file\n     * @throws IOException if an I/O error occurs\n     * @throws IllegalArgumentException if {@code from.equals(to)}\n     */\n    @Beta\n    public static void copy(File from, File to) throws IOException\n    {\n        checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n        asByteSource(from).copyTo(asByteSink(to));\n    }\n\n    /**\n     * Copies all characters from a file to an appendable object, using the given character set.\n     *\n     * @param from the source file\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @param to the appendable object\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(from, charset).copyTo(to)}. This method is scheduled to\n     *     be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static void copy(File from, Charset charset, Appendable to) throws IOException\n    {\n        asCharSource(from, charset).copyTo(to);\n    }\n\n    /**\n     * Appends a character sequence (such as a string) to a file using the given character set.\n     *\n     * @param from the character sequence to append\n     * @param to the destination file\n     * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSink(to, charset, FileWriteMode.APPEND).write(from)}. This\n     *     method is scheduled to be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static void append(CharSequence from, File to, Charset charset) throws IOException\n    {\n        asCharSink(to, charset, FileWriteMode.APPEND).write(from);\n    }\n\n    /**\n     * Returns true if the given files exist, are not directories, and contain the same bytes.\n     *\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static boolean equal(File file1, File file2) throws IOException\n    {\n        checkNotNull(file1);\n        checkNotNull(file2);\n        if (file1 == file2 || file1.equals(file2))\n        {\n            return true;\n        }\n\n        /*\n         * Some operating systems may return zero as the length for files denoting system-dependent\n         * entities such as devices or pipes, in which case we must fall back on comparing the bytes\n         * directly.\n         */\n        long len1 = file1.length();\n        long len2 = file2.length();\n        if (len1 != 0 && len2 != 0 && len1 != len2)\n        {\n            return false;\n        }\n        return asByteSource(file1).contentEquals(asByteSource(file2));\n    }\n\n    /**\n     * Atomically creates a new directory somewhere beneath the system's temporary directory (as\n     * defined by the {@code java.io.tmpdir} system property), and returns its name.\n     *\n     * <p>Use this method instead of {@link File#createTempFile(String, String)} when you wish to\n     * create a directory, not a regular file. A common pitfall is to call {@code createTempFile},\n     * delete the file and create a directory in its place, but this leads a race condition which can\n     * be exploited to create security vulnerabilities, especially when executable files are to be\n     * written into the directory.\n     *\n     * <p>This method assumes that the temporary volume is writable, has free inodes and free blocks,\n     * and that it will not be called thousands of times per second.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#createTempDirectory}.\n     *\n     * @return the newly-created directory\n     * @throws IllegalStateException if the directory could not be created\n     */\n    @Beta\n    public static File createTempDir()\n    {\n        File baseDir = new File(System.getProperty(\"java.io.tmpdir\"));\n        @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n        String baseName = System.currentTimeMillis() + \"-\";\n\n        for (int counter = 0; counter < TEMP_DIR_ATTEMPTS; counter++)\n        {\n            File tempDir = new File(baseDir, baseName + counter);\n            if (tempDir.mkdir())\n            {\n                return tempDir;\n            }\n        }\n        throw new IllegalStateException(\n            \"Failed to create directory within \"\n            + TEMP_DIR_ATTEMPTS\n            + \" attempts (tried \"\n            + baseName\n            + \"0 to \"\n            + baseName\n            + (TEMP_DIR_ATTEMPTS - 1)\n            + ')');\n    }\n\n    /**\n     * Creates an empty file or updates the last updated timestamp on the same as the unix command of\n     * the same name.\n     *\n     * @param file the file to create or update\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n    public static void touch(File file) throws IOException\n    {\n        checkNotNull(file);\n        if (!file.createNewFile() && !file.setLastModified(System.currentTimeMillis()))\n        {\n            throw new IOException(\"Unable to update modification time of \" + file);\n        }\n    }\n\n    /**\n     * Creates any necessary but nonexistent parent directories of the specified file. Note that if\n     * this operation fails it may have succeeded in creating some (but not all) of the necessary\n     * parent directories.\n     *\n     * @throws IOException if an I/O error occurs, or if any necessary but nonexistent parent\n     *     directories of the specified file could not be created.\n     * @since 4.0\n     */\n    @Beta\n    public static void createParentDirs(File file) throws IOException\n    {\n        checkNotNull(file);\n        File parent = file.getCanonicalFile().getParentFile();\n        if (parent == null)\n        {\n            /*\n             * The given directory is a filesystem root. All zero of its ancestors exist. This doesn't\n             * mean that the root itself exists -- consider x:\\ on a Windows machine without such a drive\n             * -- or even that the caller can create it, but this method makes no such guarantees even for\n             * non-root files.\n             */\n            return;\n        }\n        parent.mkdirs();\n        if (!parent.isDirectory())\n        {\n            throw new IOException(\"Unable to create parent directories of \" + file);\n        }\n    }\n\n    /**\n     * Moves a file from one path to another. This method can rename a file and/or move it to a\n     * different directory. In either case {@code to} must be the target path for the file itself; not\n     * just the new name for the file or the path to the new parent directory.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#move}.\n     *\n     * @param from the source file\n     * @param to the destination file\n     * @throws IOException if an I/O error occurs\n     * @throws IllegalArgumentException if {@code from.equals(to)}\n     */\n    @Beta\n    public static void move(File from, File to) throws IOException\n    {\n        checkNotNull(from);\n        checkNotNull(to);\n        checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n\n        if (!from.renameTo(to))\n        {\n            copy(from, to);\n            if (!from.delete())\n            {\n                if (!to.delete())\n                {\n                    throw new IOException(\"Unable to delete \" + to);\n                }\n                throw new IOException(\"Unable to delete \" + from);\n            }\n        }\n    }\n\n    /**\n     * Reads the first line from a file. The line does not include line-termination characters, but\n     * does include other leading and trailing whitespace.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return the first line, or null if the file is empty\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(file, charset).readFirstLine()}. This method is\n     *     scheduled to be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static String readFirstLine(File file, Charset charset) throws IOException\n    {\n        return asCharSource(file, charset).readFirstLine();\n    }\n\n    /**\n     * Reads all of the lines from a file. The lines do not include line-termination characters, but\n     * do include other leading and trailing whitespace.\n     *\n     * <p>This method returns a mutable {@code List}. For an {@code ImmutableList}, use {@code\n     * Files.asCharSource(file, charset).readLines()}.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#readAllLines(java.nio.file.Path, Charset)}.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return a mutable {@link List} containing all the lines\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static List<String> readLines(File file, Charset charset) throws IOException\n    {\n        // don't use asCharSource(file, charset).readLines() because that returns\n        // an immutable list, which would change the behavior of this method\n        return asCharSource(file, charset)\n               .readLines(\n                   new LineProcessor<List<String>>()\n        {\n            final List<String> result = Lists.newArrayList();\n\n            @Override\n            public boolean processLine(String line)\n            {\n                result.add(line);\n                return true;\n            }\n\n            @Override\n            public List<String> getResult()\n            {\n                return result;\n            }\n        });\n    }\n\n    /**\n     * Streams lines from a {@link File}, stopping when our callback returns false, or we have read\n     * all of the lines.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @param callback the {@link LineProcessor} to use to handle the lines\n     * @return the output of processing the lines\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(file, charset).readLines(callback)}. This method is\n     *     scheduled to be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    @CanIgnoreReturnValue // some processors won't return a useful result\n    public\n    static <T> T readLines(File file, Charset charset, LineProcessor<T> callback) throws IOException\n    {\n        return asCharSource(file, charset).readLines(callback);\n    }\n\n    /**\n     * Process the bytes of a file.\n     *\n     * <p>(If this seems too complicated, maybe you're looking for {@link #toByteArray}.)\n     *\n     * @param file the file to read\n     * @param processor the object to which the bytes of the file are passed.\n     * @return the result of the byte processor\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asByteSource(file).read(processor)}. This method is scheduled to be\n     *     removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    @CanIgnoreReturnValue // some processors won't return a useful result\n    public\n    static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException\n    {\n        return asByteSource(file).read(processor);\n    }\n\n    /**\n     * Computes the hash code of the {@code file} using {@code hashFunction}.\n     *\n     * @param file the file to read\n     * @param hashFunction the hash function to use to hash the data\n     * @return the {@link HashCode} of all of the bytes in the file\n     * @throws IOException if an I/O error occurs\n     * @since 12.0\n     * @deprecated Prefer {@code asByteSource(file).hash(hashFunction)}. This method is scheduled to\n     *     be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static HashCode hash(File file, HashFunction hashFunction) throws IOException\n    {\n        return asByteSource(file).hash(hashFunction);\n    }\n\n    /**\n     * Fully maps a file read-only in to memory as per {@link\n     * FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}.\n     *\n     * <p>Files are mapped from offset 0 to its length.\n     *\n     * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n     *\n     * @param file the file to map\n     * @return a read-only buffer reflecting {@code file}\n     * @throws FileNotFoundException if the {@code file} does not exist\n     * @throws IOException if an I/O error occurs\n     * @see FileChannel#map(MapMode, long, long)\n     * @since 2.0\n     */\n    @Beta\n    public static MappedByteBuffer map(File file) throws IOException\n    {\n        checkNotNull(file);\n        return map(file, MapMode.READ_ONLY);\n    }\n\n    /**\n     * Fully maps a file in to memory as per {@link\n     * FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)} using the requested {@link\n     * MapMode}.\n     *\n     * <p>Files are mapped from offset 0 to its length.\n     *\n     * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n     *\n     * @param file the file to map\n     * @param mode the mode to use when mapping {@code file}\n     * @return a buffer reflecting {@code file}\n     * @throws FileNotFoundException if the {@code file} does not exist\n     * @throws IOException if an I/O error occurs\n     * @see FileChannel#map(MapMode, long, long)\n     * @since 2.0\n     */\n    @Beta\n    public static MappedByteBuffer map(File file, MapMode mode) throws IOException\n    {\n        return mapInternal(file, mode, -1);\n    }\n\n    /**\n     * Maps a file in to memory as per {@link FileChannel#map(java.nio.channels.FileChannel.MapMode,\n     * long, long)} using the requested {@link MapMode}.\n     *\n     * <p>Files are mapped from offset 0 to {@code size}.\n     *\n     * <p>If the mode is {@link MapMode#READ_WRITE} and the file does not exist, it will be created\n     * with the requested {@code size}. Thus this method is useful for creating memory mapped files\n     * which do not yet exist.\n     *\n     * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n     *\n     * @param file the file to map\n     * @param mode the mode to use when mapping {@code file}\n     * @return a buffer reflecting {@code file}\n     * @throws IOException if an I/O error occurs\n     * @see FileChannel#map(MapMode, long, long)\n     * @since 2.0\n     */\n    @Beta\n    public static MappedByteBuffer map(File file, MapMode mode, long size) throws IOException\n    {\n        checkArgument(size >= 0, \"size (%s) may not be negative\", size);\n        return mapInternal(file, mode, size);\n    }\n\n    private static MappedByteBuffer mapInternal(File file, MapMode mode, long size)\n    throws IOException\n    {\n        checkNotNull(file);\n        checkNotNull(mode);\n\n        Closer closer = Closer.create();\n        try\n        {\n            RandomAccessFile raf =\n                closer.register(new RandomAccessFile(file, mode == MapMode.READ_ONLY ? \"r\" : \"rw\"));\n            FileChannel channel = closer.register(raf.getChannel());\n            return channel.map(mode, 0, size == -1 ? channel.size() : size);\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Returns the lexically cleaned form of the path name, <i>usually</i> (but not always) equivalent\n     * to the original. The following heuristics are used:\n     *\n     * <ul>\n     *   <li>empty string becomes .\n     *   <li>. stays as .\n     *   <li>fold out ./\n     *   <li>fold out ../ when possible\n     *   <li>collapse multiple slashes\n     *   <li>delete trailing slashes (unless the path is just \"/\")\n     * </ul>\n     *\n     * <p>These heuristics do not always match the behavior of the filesystem. In particular, consider\n     * the path {@code a/../b}, which {@code simplifyPath} will change to {@code b}. If {@code a} is a\n     * symlink to {@code x}, {@code a/../b} may refer to a sibling of {@code x}, rather than the\n     * sibling of {@code a} referred to by {@code b}.\n     *\n     * @since 11.0\n     */\n    @Beta\n    public static String simplifyPath(String pathname)\n    {\n        checkNotNull(pathname);\n        if (pathname.length() == 0)\n        {\n            return \".\";\n        }\n\n        // split the path apart\n        Iterable<String> components = Splitter.on('/').omitEmptyStrings().split(pathname);\n        List<String> path = new ArrayList<>();\n\n        // resolve ., .., and //\n        for (String component : components)\n        {\n            switch (component)\n            {\n            case \".\":\n                continue;\n            case \"..\":\n                if (path.size() > 0 && !path.get(path.size() - 1).equals(\"..\"))\n                {\n                    path.remove(path.size() - 1);\n                }\n                else\n                {\n                    path.add(\"..\");\n                }\n                break;\n            default:\n                path.add(component);\n                break;\n            }\n        }\n\n        // put it back together\n        String result = Joiner.on('/').join(path);\n        if (pathname.charAt(0) == '/')\n        {\n            result = \"/\" + result;\n        }\n\n        while (result.startsWith(\"/../\"))\n        {\n            result = result.substring(3);\n        }\n        if (result.equals(\"/..\"))\n        {\n            result = \"/\";\n        }\n        else if (\"\".equals(result))\n        {\n            result = \".\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the <a href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> for\n     * the given file name, or the empty string if the file has no extension. The result does not\n     * include the '{@code .}'.\n     *\n     * <p><b>Note:</b> This method simply returns everything after the last '{@code .}' in the file's\n     * name as determined by {@link File#getName}. It does not account for any filesystem-specific\n     * behavior that the {@link File} API does not already account for. For example, on NTFS it will\n     * report {@code \"txt\"} as the extension for the filename {@code \"foo.exe:.txt\"} even though NTFS\n     * will drop the {@code \":.txt\"} part of the name when the file is actually created on the\n     * filesystem due to NTFS's <a href=\"https://goo.gl/vTpJi4\">Alternate Data Streams</a>.\n     *\n     * @since 11.0\n     */\n    @Beta\n    public static String getFileExtension(String fullName)\n    {\n        checkNotNull(fullName);\n        String fileName = new File(fullName).getName();\n        int dotIndex = fileName.lastIndexOf('.');\n        return (dotIndex == -1) ? \"\" : fileName.substring(dotIndex + 1);\n    }\n\n    /**\n     * Returns the file name without its <a\n     * href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> or path. This is\n     * similar to the {@code basename} unix command. The result does not include the '{@code .}'.\n     *\n     * @param file The name of the file to trim the extension from. This can be either a fully\n     *     qualified file name (including a path) or just a file name.\n     * @return The file name without its path or extension.\n     * @since 14.0\n     */\n    @Beta\n    public static String getNameWithoutExtension(String file)\n    {\n        checkNotNull(file);\n        String fileName = new File(file).getName();\n        int dotIndex = fileName.lastIndexOf('.');\n        return (dotIndex == -1) ? fileName : fileName.substring(0, dotIndex);\n    }\n\n    /**\n     * Returns a {@link TreeTraverser} instance for {@link File} trees.\n     *\n     * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no\n     * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n     * this case, iterables created by this traverser could contain files that are outside of the\n     * given directory or even be infinite if there is a symbolic link loop.\n     *\n     * @since 15.0\n     * @deprecated The returned {@link TreeTraverser} type is deprecated. Use the replacement method\n     *     {@link #fileTraverser()} instead with the same semantics as this method.\n     */\n    @Deprecated\n    static TreeTraverser<File> fileTreeTraverser()\n    {\n        return FILE_TREE_TRAVERSER;\n    }\n\n    private static final TreeTraverser<File> FILE_TREE_TRAVERSER =\n        new TreeTraverser<File>()\n    {\n        @Override\n        public Iterable<File> children(File file)\n        {\n            return fileTreeChildren(file);\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"Files.fileTreeTraverser()\";\n        }\n    };\n\n    /**\n     * Returns a {@link Traverser} instance for the file and directory tree. The returned traverser\n     * starts from a {@link File} and will return all files and directories it encounters.\n     *\n     * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no\n     * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n     * this case, iterables created by this traverser could contain files that are outside of the\n     * given directory or even be infinite if there is a symbolic link loop.\n     *\n     * <p>If available, consider using {@link MoreFiles#fileTraverser()} instead. It behaves the same\n     * except that it doesn't follow symbolic links and returns {@code Path} instances.\n     *\n     * <p>If the {@link File} passed to one of the {@link Traverser} methods does not exist or is not\n     * a directory, no exception will be thrown and the returned {@link Iterable} will contain a\n     * single element: that file.\n     *\n     * <p>Example: {@code Files.fileTraverser().depthFirstPreOrder(new File(\"/\"))} may return files\n     * with the following paths: {@code [\"/\", \"/etc\", \"/etc/config.txt\", \"/etc/fonts\", \"/home\",\n     * \"/home/alice\", ...]}\n     *\n     * @since 23.5\n     */\n    @Beta\n    public static Traverser<File> fileTraverser()\n    {\n        return Traverser.forTree(FILE_TREE);\n    }\n\n    private static final SuccessorsFunction<File> FILE_TREE =\n        new SuccessorsFunction<File>()\n    {\n        @Override\n        public Iterable<File> successors(File file)\n        {\n            return fileTreeChildren(file);\n        }\n    };\n\n    private static Iterable<File> fileTreeChildren(File file)\n    {\n        // check isDirectory() just because it may be faster than listFiles() on a non-directory\n        if (file.isDirectory())\n        {\n            File[] files = file.listFiles();\n            if (files != null)\n            {\n                return Collections.unmodifiableList(Arrays.asList(files));\n            }\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * Returns a predicate that returns the result of {@link File#isDirectory} on input files.\n     *\n     * @since 15.0\n     */\n    @Beta\n    public static Predicate<File> isDirectory()\n    {\n        return FilePredicate.IS_DIRECTORY;\n    }\n\n    /**\n     * Returns a predicate that returns the result of {@link File#isFile} on input files.\n     *\n     * @since 15.0\n     */\n    @Beta\n    public static Predicate<File> isFile()\n    {\n        return FilePredicate.IS_FILE;\n    }\n\n    private enum FilePredicate implements Predicate<File>\n    {\n        IS_DIRECTORY {\n            @Override\n            public boolean apply(File file)\n            {\n                return file.isDirectory();\n            }\n\n            @Override\n            public String toString()\n            {\n                return \"Files.isDirectory()\";\n            }\n        },\n\n        IS_FILE {\n            @Override\n            public boolean apply(File file)\n            {\n                return file.isFile();\n            }\n\n            @Override\n            public String toString()\n            {\n                return \"Files.isFile()\";\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/io/Files.java", "func_name": "Files.write", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Overwrites a file with the contents of a byte array.\n\n<p><b>{@link java.nio.file.Path} equivalent:</b> {@link\njava.nio.file.Files#write(java.nio.file.Path, byte[], java.nio.file.OpenOption...)}.\n\n@param from the bytes to write\n@param to the destination file\n@throws IOException if an I/O error occurs", "docstring_tokens": ["Overwrites", "a", "file", "with", "the", "contents", "of", "a", "byte", "array", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/io/Files.java#L267-L270", "partition": "valid", "up_fun_num": 9, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.io.FileWriteMode.APPEND;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.Joiner;", "import com.google.common.base.Optional;", "import com.google.common.base.Predicate;", "import com.google.common.base.Splitter;", "import com.google.common.collect.ImmutableSet;", "import com.google.common.collect.Lists;", "import com.google.common.collect.TreeTraverser;", "import com.google.common.graph.SuccessorsFunction;", "import com.google.common.graph.Traverser;", "import com.google.common.hash.HashCode;", "import com.google.common.hash.HashFunction;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.io.BufferedReader;", "import java.io.BufferedWriter;", "import java.io.File;", "import java.io.FileInputStream;", "import java.io.FileNotFoundException;", "import java.io.FileOutputStream;", "import java.io.IOException;", "import java.io.InputStreamReader;", "import java.io.OutputStream;", "import java.io.OutputStreamWriter;", "import java.io.RandomAccessFile;", "import java.nio.MappedByteBuffer;", "import java.nio.channels.FileChannel;", "import java.nio.channels.FileChannel.MapMode;", "import java.nio.charset.Charset;", "import java.nio.charset.StandardCharsets;", "import java.util.ArrayList;", "import java.util.Arrays;", "import java.util.Collections;", "import java.util.List;"], "function": ["public final class Files\n", "    public static BufferedReader newReader(File file, Charset charset) throws FileNotFoundException\n", "    public static BufferedWriter newWriter(File file, Charset charset) throws FileNotFoundException\n", "    public static ByteSource asByteSource(File file)\n", "    public static ByteSink asByteSink(File file, FileWriteMode... modes)\n", "    public static CharSource asCharSource(File file, Charset charset)\n", "    public static CharSink asCharSink(File file, Charset charset, FileWriteMode... modes)\n", "    public static byte[] toByteArray(File file) throws IOException\n", "    public static String toString(File file, Charset charset) throws IOException\n", "    public static void write(CharSequence from, File to, Charset charset) throws IOException\n", "    public static void copy(File from, OutputStream to) throws IOException\n", "    public static void copy(File from, File to) throws IOException\n", "    static void copy(File from, Charset charset, Appendable to) throws IOException\n", "    static void append(CharSequence from, File to, Charset charset) throws IOException\n", "    public static boolean equal(File file1, File file2) throws IOException\n", "    public static File createTempDir()\n", "    public static void touch(File file) throws IOException\n", "    public static void createParentDirs(File file) throws IOException\n", "    public static void move(File from, File to) throws IOException\n", "    static String readFirstLine(File file, Charset charset) throws IOException\n", "    public static List<String> readLines(File file, Charset charset) throws IOException\n", "    static <T> T readLines(File file, Charset charset, LineProcessor<T> callback) throws IOException\n", "    static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException\n", "    static HashCode hash(File file, HashFunction hashFunction) throws IOException\n", "    public static MappedByteBuffer map(File file) throws IOException\n", "    public static MappedByteBuffer map(File file, MapMode mode) throws IOException\n", "    public static MappedByteBuffer map(File file, MapMode mode, long size) throws IOException\n", "    private static MappedByteBuffer mapInternal(File file, MapMode mode, long size)\n", "    public static String simplifyPath(String pathname)\n", "    public static String getFileExtension(String fullName)\n", "    public static String getNameWithoutExtension(String file)\n", "    static TreeTraverser<File> fileTreeTraverser()\n", "    public static Traverser<File> fileTraverser()\n", "    private static Iterable<File> fileTreeChildren(File file)\n", "    public static Predicate<File> isDirectory()\n", "    public static Predicate<File> isFile()\n"], "context": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.io.FileWriteMode.APPEND;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.TreeTraverser;\nimport com.google.common.graph.SuccessorsFunction;\nimport com.google.common.graph.Traverser;\nimport com.google.common.hash.HashCode;\nimport com.google.common.hash.HashFunction;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Provides utility methods for working with {@linkplain File files}.\n *\n * <p>{@link java.nio.file.Path} users will find similar utilities in {@link MoreFiles} and the\n * JDK's {@link java.nio.file.Files} class.\n *\n * @author Chris Nokleberg\n * @author Colin Decker\n * @since 1.0\n */\n@GwtIncompatible\npublic final class Files\n{\n\n    /** Maximum loop count when creating temp directories. */\n    private static final int TEMP_DIR_ATTEMPTS = 10000;\n\n    private Files() {}\n\n    /**\n     * Returns a buffered reader that reads from a file using the given character set.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#newBufferedReader(java.nio.file.Path, Charset)}.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return the buffered reader\n     */\n    @Beta\n    public static BufferedReader newReader(File file, Charset charset) throws FileNotFoundException\n    {\n        checkNotNull(file);\n        checkNotNull(charset);\n        return new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));\n    }\n\n    /**\n     * Returns a buffered writer that writes to a file using the given character set.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#newBufferedWriter(java.nio.file.Path, Charset,\n     * java.nio.file.OpenOption...)}.\n     *\n     * @param file the file to write to\n     * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return the buffered writer\n     */\n    @Beta\n    public static BufferedWriter newWriter(File file, Charset charset) throws FileNotFoundException\n    {\n        checkNotNull(file);\n        checkNotNull(charset);\n        return new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset));\n    }\n\n    /**\n     * Returns a new {@link ByteSource} for reading bytes from the given file.\n     *\n     * @since 14.0\n     */\n    public static ByteSource asByteSource(File file)\n    {\n        return new FileByteSource(file);\n    }\n\n    private static final class FileByteSource extends ByteSource\n    {\n\n        private final File file;\n\n        private FileByteSource(File file)\n        {\n            this.file = checkNotNull(file);\n        }\n\n        @Override\n        public FileInputStream openStream() throws IOException\n        {\n            return new FileInputStream(file);\n        }\n\n        @Override\n        public Optional<Long> sizeIfKnown()\n        {\n            if (file.isFile())\n            {\n                return Optional.of(file.length());\n            }\n            else\n            {\n                return Optional.absent();\n            }\n        }\n\n        @Override\n        public long size() throws IOException\n        {\n            if (!file.isFile())\n            {\n                throw new FileNotFoundException(file.toString());\n            }\n            return file.length();\n        }\n\n        @Override\n        public byte[] read() throws IOException\n        {\n            Closer closer = Closer.create();\n            try\n            {\n                FileInputStream in = closer.register(openStream());\n                return ByteStreams.toByteArray(in, in.getChannel().size());\n            }\n            catch (Throwable e)\n            {\n                throw closer.rethrow(e);\n            }\n            finally\n            {\n                closer.close();\n            }\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"Files.asByteSource(\" + file + \")\";\n        }\n    }\n\n    /**\n     * Returns a new {@link ByteSink} for writing bytes to the given file. The given {@code modes}\n     * control how the file is opened for writing. When no mode is provided, the file will be\n     * truncated before writing. When the {@link FileWriteMode#APPEND APPEND} mode is provided, writes\n     * will append to the end of the file without truncating it.\n     *\n     * @since 14.0\n     */\n    public static ByteSink asByteSink(File file, FileWriteMode... modes)\n    {\n        return new FileByteSink(file, modes);\n    }\n\n    private static final class FileByteSink extends ByteSink\n    {\n\n        private final File file;\n        private final ImmutableSet<FileWriteMode> modes;\n\n        private FileByteSink(File file, FileWriteMode... modes)\n        {\n            this.file = checkNotNull(file);\n            this.modes = ImmutableSet.copyOf(modes);\n        }\n\n        @Override\n        public FileOutputStream openStream() throws IOException\n        {\n            return new FileOutputStream(file, modes.contains(APPEND));\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"Files.asByteSink(\" + file + \", \" + modes + \")\";\n        }\n    }\n\n    /**\n     * Returns a new {@link CharSource} for reading character data from the given file using the given\n     * character set.\n     *\n     * @since 14.0\n     */\n    public static CharSource asCharSource(File file, Charset charset)\n    {\n        return asByteSource(file).asCharSource(charset);\n    }\n\n    /**\n     * Returns a new {@link CharSink} for writing character data to the given file using the given\n     * character set. The given {@code modes} control how the file is opened for writing. When no mode\n     * is provided, the file will be truncated before writing. When the {@link FileWriteMode#APPEND\n     * APPEND} mode is provided, writes will append to the end of the file without truncating it.\n     *\n     * @since 14.0\n     */\n    public static CharSink asCharSink(File file, Charset charset, FileWriteMode... modes)\n    {\n        return asByteSink(file, modes).asCharSink(charset);\n    }\n\n    /**\n     * Reads all bytes from a file into a byte array.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#readAllBytes}.\n     *\n     * @param file the file to read from\n     * @return a byte array containing all the bytes from file\n     * @throws IllegalArgumentException if the file is bigger than the largest possible byte array\n     *     (2^31 - 1)\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static byte[] toByteArray(File file) throws IOException\n    {\n        return asByteSource(file).read();\n    }\n\n    /**\n     * Reads all characters from a file into a {@link String}, using the given character set.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return a string containing all the characters from the file\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(file, charset).read()}. This method is scheduled to be\n     *     removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public static String toString(File file, Charset charset) throws IOException\n    {\n        return asCharSource(file, charset).read();\n    }\n\n    /**\n     * Overwrites a file with the contents of a byte array.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#write(java.nio.file.Path, byte[], java.nio.file.OpenOption...)}.\n     *\n     * @param from the bytes to write\n     * @param to the destination file\n     * @throws IOException if an I/O error occurs\n     */\n\n    /**\n     * Writes a character sequence (such as a string) to a file using the given character set.\n     *\n     * @param from the character sequence to write\n     * @param to the destination file\n     * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSink(to, charset).write(from)}. This method is scheduled to be\n     *     removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public static void write(CharSequence from, File to, Charset charset) throws IOException\n    {\n        asCharSink(to, charset).write(from);\n    }\n\n    /**\n     * Copies all bytes from a file to an output stream.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#copy(java.nio.file.Path, OutputStream)}.\n     *\n     * @param from the source file\n     * @param to the output stream\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static void copy(File from, OutputStream to) throws IOException\n    {\n        asByteSource(from).copyTo(to);\n    }\n\n    /**\n     * Copies all the bytes from one file to another.\n     *\n     * <p>Copying is not an atomic operation - in the case of an I/O error, power loss, process\n     * termination, or other problems, {@code to} may not be a complete copy of {@code from}. If you\n     * need to guard against those conditions, you should employ other file-level synchronization.\n     *\n     * <p><b>Warning:</b> If {@code to} represents an existing file, that file will be overwritten\n     * with the contents of {@code from}. If {@code to} and {@code from} refer to the <i>same</i>\n     * file, the contents of that file will be deleted.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#copy(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...)}.\n     *\n     * @param from the source file\n     * @param to the destination file\n     * @throws IOException if an I/O error occurs\n     * @throws IllegalArgumentException if {@code from.equals(to)}\n     */\n    @Beta\n    public static void copy(File from, File to) throws IOException\n    {\n        checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n        asByteSource(from).copyTo(asByteSink(to));\n    }\n\n    /**\n     * Copies all characters from a file to an appendable object, using the given character set.\n     *\n     * @param from the source file\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @param to the appendable object\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(from, charset).copyTo(to)}. This method is scheduled to\n     *     be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static void copy(File from, Charset charset, Appendable to) throws IOException\n    {\n        asCharSource(from, charset).copyTo(to);\n    }\n\n    /**\n     * Appends a character sequence (such as a string) to a file using the given character set.\n     *\n     * @param from the character sequence to append\n     * @param to the destination file\n     * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSink(to, charset, FileWriteMode.APPEND).write(from)}. This\n     *     method is scheduled to be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static void append(CharSequence from, File to, Charset charset) throws IOException\n    {\n        asCharSink(to, charset, FileWriteMode.APPEND).write(from);\n    }\n\n    /**\n     * Returns true if the given files exist, are not directories, and contain the same bytes.\n     *\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static boolean equal(File file1, File file2) throws IOException\n    {\n        checkNotNull(file1);\n        checkNotNull(file2);\n        if (file1 == file2 || file1.equals(file2))\n        {\n            return true;\n        }\n\n        /*\n         * Some operating systems may return zero as the length for files denoting system-dependent\n         * entities such as devices or pipes, in which case we must fall back on comparing the bytes\n         * directly.\n         */\n        long len1 = file1.length();\n        long len2 = file2.length();\n        if (len1 != 0 && len2 != 0 && len1 != len2)\n        {\n            return false;\n        }\n        return asByteSource(file1).contentEquals(asByteSource(file2));\n    }\n\n    /**\n     * Atomically creates a new directory somewhere beneath the system's temporary directory (as\n     * defined by the {@code java.io.tmpdir} system property), and returns its name.\n     *\n     * <p>Use this method instead of {@link File#createTempFile(String, String)} when you wish to\n     * create a directory, not a regular file. A common pitfall is to call {@code createTempFile},\n     * delete the file and create a directory in its place, but this leads a race condition which can\n     * be exploited to create security vulnerabilities, especially when executable files are to be\n     * written into the directory.\n     *\n     * <p>This method assumes that the temporary volume is writable, has free inodes and free blocks,\n     * and that it will not be called thousands of times per second.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#createTempDirectory}.\n     *\n     * @return the newly-created directory\n     * @throws IllegalStateException if the directory could not be created\n     */\n    @Beta\n    public static File createTempDir()\n    {\n        File baseDir = new File(System.getProperty(\"java.io.tmpdir\"));\n        @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n        String baseName = System.currentTimeMillis() + \"-\";\n\n        for (int counter = 0; counter < TEMP_DIR_ATTEMPTS; counter++)\n        {\n            File tempDir = new File(baseDir, baseName + counter);\n            if (tempDir.mkdir())\n            {\n                return tempDir;\n            }\n        }\n        throw new IllegalStateException(\n            \"Failed to create directory within \"\n            + TEMP_DIR_ATTEMPTS\n            + \" attempts (tried \"\n            + baseName\n            + \"0 to \"\n            + baseName\n            + (TEMP_DIR_ATTEMPTS - 1)\n            + ')');\n    }\n\n    /**\n     * Creates an empty file or updates the last updated timestamp on the same as the unix command of\n     * the same name.\n     *\n     * @param file the file to create or update\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n    public static void touch(File file) throws IOException\n    {\n        checkNotNull(file);\n        if (!file.createNewFile() && !file.setLastModified(System.currentTimeMillis()))\n        {\n            throw new IOException(\"Unable to update modification time of \" + file);\n        }\n    }\n\n    /**\n     * Creates any necessary but nonexistent parent directories of the specified file. Note that if\n     * this operation fails it may have succeeded in creating some (but not all) of the necessary\n     * parent directories.\n     *\n     * @throws IOException if an I/O error occurs, or if any necessary but nonexistent parent\n     *     directories of the specified file could not be created.\n     * @since 4.0\n     */\n    @Beta\n    public static void createParentDirs(File file) throws IOException\n    {\n        checkNotNull(file);\n        File parent = file.getCanonicalFile().getParentFile();\n        if (parent == null)\n        {\n            /*\n             * The given directory is a filesystem root. All zero of its ancestors exist. This doesn't\n             * mean that the root itself exists -- consider x:\\ on a Windows machine without such a drive\n             * -- or even that the caller can create it, but this method makes no such guarantees even for\n             * non-root files.\n             */\n            return;\n        }\n        parent.mkdirs();\n        if (!parent.isDirectory())\n        {\n            throw new IOException(\"Unable to create parent directories of \" + file);\n        }\n    }\n\n    /**\n     * Moves a file from one path to another. This method can rename a file and/or move it to a\n     * different directory. In either case {@code to} must be the target path for the file itself; not\n     * just the new name for the file or the path to the new parent directory.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#move}.\n     *\n     * @param from the source file\n     * @param to the destination file\n     * @throws IOException if an I/O error occurs\n     * @throws IllegalArgumentException if {@code from.equals(to)}\n     */\n    @Beta\n    public static void move(File from, File to) throws IOException\n    {\n        checkNotNull(from);\n        checkNotNull(to);\n        checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n\n        if (!from.renameTo(to))\n        {\n            copy(from, to);\n            if (!from.delete())\n            {\n                if (!to.delete())\n                {\n                    throw new IOException(\"Unable to delete \" + to);\n                }\n                throw new IOException(\"Unable to delete \" + from);\n            }\n        }\n    }\n\n    /**\n     * Reads the first line from a file. The line does not include line-termination characters, but\n     * does include other leading and trailing whitespace.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return the first line, or null if the file is empty\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(file, charset).readFirstLine()}. This method is\n     *     scheduled to be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static String readFirstLine(File file, Charset charset) throws IOException\n    {\n        return asCharSource(file, charset).readFirstLine();\n    }\n\n    /**\n     * Reads all of the lines from a file. The lines do not include line-termination characters, but\n     * do include other leading and trailing whitespace.\n     *\n     * <p>This method returns a mutable {@code List}. For an {@code ImmutableList}, use {@code\n     * Files.asCharSource(file, charset).readLines()}.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#readAllLines(java.nio.file.Path, Charset)}.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return a mutable {@link List} containing all the lines\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static List<String> readLines(File file, Charset charset) throws IOException\n    {\n        // don't use asCharSource(file, charset).readLines() because that returns\n        // an immutable list, which would change the behavior of this method\n        return asCharSource(file, charset)\n               .readLines(\n                   new LineProcessor<List<String>>()\n        {\n            final List<String> result = Lists.newArrayList();\n\n            @Override\n            public boolean processLine(String line)\n            {\n                result.add(line);\n                return true;\n            }\n\n            @Override\n            public List<String> getResult()\n            {\n                return result;\n            }\n        });\n    }\n\n    /**\n     * Streams lines from a {@link File}, stopping when our callback returns false, or we have read\n     * all of the lines.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @param callback the {@link LineProcessor} to use to handle the lines\n     * @return the output of processing the lines\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(file, charset).readLines(callback)}. This method is\n     *     scheduled to be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    @CanIgnoreReturnValue // some processors won't return a useful result\n    public\n    static <T> T readLines(File file, Charset charset, LineProcessor<T> callback) throws IOException\n    {\n        return asCharSource(file, charset).readLines(callback);\n    }\n\n    /**\n     * Process the bytes of a file.\n     *\n     * <p>(If this seems too complicated, maybe you're looking for {@link #toByteArray}.)\n     *\n     * @param file the file to read\n     * @param processor the object to which the bytes of the file are passed.\n     * @return the result of the byte processor\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asByteSource(file).read(processor)}. This method is scheduled to be\n     *     removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    @CanIgnoreReturnValue // some processors won't return a useful result\n    public\n    static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException\n    {\n        return asByteSource(file).read(processor);\n    }\n\n    /**\n     * Computes the hash code of the {@code file} using {@code hashFunction}.\n     *\n     * @param file the file to read\n     * @param hashFunction the hash function to use to hash the data\n     * @return the {@link HashCode} of all of the bytes in the file\n     * @throws IOException if an I/O error occurs\n     * @since 12.0\n     * @deprecated Prefer {@code asByteSource(file).hash(hashFunction)}. This method is scheduled to\n     *     be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static HashCode hash(File file, HashFunction hashFunction) throws IOException\n    {\n        return asByteSource(file).hash(hashFunction);\n    }\n\n    /**\n     * Fully maps a file read-only in to memory as per {@link\n     * FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}.\n     *\n     * <p>Files are mapped from offset 0 to its length.\n     *\n     * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n     *\n     * @param file the file to map\n     * @return a read-only buffer reflecting {@code file}\n     * @throws FileNotFoundException if the {@code file} does not exist\n     * @throws IOException if an I/O error occurs\n     * @see FileChannel#map(MapMode, long, long)\n     * @since 2.0\n     */\n    @Beta\n    public static MappedByteBuffer map(File file) throws IOException\n    {\n        checkNotNull(file);\n        return map(file, MapMode.READ_ONLY);\n    }\n\n    /**\n     * Fully maps a file in to memory as per {@link\n     * FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)} using the requested {@link\n     * MapMode}.\n     *\n     * <p>Files are mapped from offset 0 to its length.\n     *\n     * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n     *\n     * @param file the file to map\n     * @param mode the mode to use when mapping {@code file}\n     * @return a buffer reflecting {@code file}\n     * @throws FileNotFoundException if the {@code file} does not exist\n     * @throws IOException if an I/O error occurs\n     * @see FileChannel#map(MapMode, long, long)\n     * @since 2.0\n     */\n    @Beta\n    public static MappedByteBuffer map(File file, MapMode mode) throws IOException\n    {\n        return mapInternal(file, mode, -1);\n    }\n\n    /**\n     * Maps a file in to memory as per {@link FileChannel#map(java.nio.channels.FileChannel.MapMode,\n     * long, long)} using the requested {@link MapMode}.\n     *\n     * <p>Files are mapped from offset 0 to {@code size}.\n     *\n     * <p>If the mode is {@link MapMode#READ_WRITE} and the file does not exist, it will be created\n     * with the requested {@code size}. Thus this method is useful for creating memory mapped files\n     * which do not yet exist.\n     *\n     * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n     *\n     * @param file the file to map\n     * @param mode the mode to use when mapping {@code file}\n     * @return a buffer reflecting {@code file}\n     * @throws IOException if an I/O error occurs\n     * @see FileChannel#map(MapMode, long, long)\n     * @since 2.0\n     */\n    @Beta\n    public static MappedByteBuffer map(File file, MapMode mode, long size) throws IOException\n    {\n        checkArgument(size >= 0, \"size (%s) may not be negative\", size);\n        return mapInternal(file, mode, size);\n    }\n\n    private static MappedByteBuffer mapInternal(File file, MapMode mode, long size)\n    throws IOException\n    {\n        checkNotNull(file);\n        checkNotNull(mode);\n\n        Closer closer = Closer.create();\n        try\n        {\n            RandomAccessFile raf =\n                closer.register(new RandomAccessFile(file, mode == MapMode.READ_ONLY ? \"r\" : \"rw\"));\n            FileChannel channel = closer.register(raf.getChannel());\n            return channel.map(mode, 0, size == -1 ? channel.size() : size);\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Returns the lexically cleaned form of the path name, <i>usually</i> (but not always) equivalent\n     * to the original. The following heuristics are used:\n     *\n     * <ul>\n     *   <li>empty string becomes .\n     *   <li>. stays as .\n     *   <li>fold out ./\n     *   <li>fold out ../ when possible\n     *   <li>collapse multiple slashes\n     *   <li>delete trailing slashes (unless the path is just \"/\")\n     * </ul>\n     *\n     * <p>These heuristics do not always match the behavior of the filesystem. In particular, consider\n     * the path {@code a/../b}, which {@code simplifyPath} will change to {@code b}. If {@code a} is a\n     * symlink to {@code x}, {@code a/../b} may refer to a sibling of {@code x}, rather than the\n     * sibling of {@code a} referred to by {@code b}.\n     *\n     * @since 11.0\n     */\n    @Beta\n    public static String simplifyPath(String pathname)\n    {\n        checkNotNull(pathname);\n        if (pathname.length() == 0)\n        {\n            return \".\";\n        }\n\n        // split the path apart\n        Iterable<String> components = Splitter.on('/').omitEmptyStrings().split(pathname);\n        List<String> path = new ArrayList<>();\n\n        // resolve ., .., and //\n        for (String component : components)\n        {\n            switch (component)\n            {\n            case \".\":\n                continue;\n            case \"..\":\n                if (path.size() > 0 && !path.get(path.size() - 1).equals(\"..\"))\n                {\n                    path.remove(path.size() - 1);\n                }\n                else\n                {\n                    path.add(\"..\");\n                }\n                break;\n            default:\n                path.add(component);\n                break;\n            }\n        }\n\n        // put it back together\n        String result = Joiner.on('/').join(path);\n        if (pathname.charAt(0) == '/')\n        {\n            result = \"/\" + result;\n        }\n\n        while (result.startsWith(\"/../\"))\n        {\n            result = result.substring(3);\n        }\n        if (result.equals(\"/..\"))\n        {\n            result = \"/\";\n        }\n        else if (\"\".equals(result))\n        {\n            result = \".\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the <a href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> for\n     * the given file name, or the empty string if the file has no extension. The result does not\n     * include the '{@code .}'.\n     *\n     * <p><b>Note:</b> This method simply returns everything after the last '{@code .}' in the file's\n     * name as determined by {@link File#getName}. It does not account for any filesystem-specific\n     * behavior that the {@link File} API does not already account for. For example, on NTFS it will\n     * report {@code \"txt\"} as the extension for the filename {@code \"foo.exe:.txt\"} even though NTFS\n     * will drop the {@code \":.txt\"} part of the name when the file is actually created on the\n     * filesystem due to NTFS's <a href=\"https://goo.gl/vTpJi4\">Alternate Data Streams</a>.\n     *\n     * @since 11.0\n     */\n    @Beta\n    public static String getFileExtension(String fullName)\n    {\n        checkNotNull(fullName);\n        String fileName = new File(fullName).getName();\n        int dotIndex = fileName.lastIndexOf('.');\n        return (dotIndex == -1) ? \"\" : fileName.substring(dotIndex + 1);\n    }\n\n    /**\n     * Returns the file name without its <a\n     * href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> or path. This is\n     * similar to the {@code basename} unix command. The result does not include the '{@code .}'.\n     *\n     * @param file The name of the file to trim the extension from. This can be either a fully\n     *     qualified file name (including a path) or just a file name.\n     * @return The file name without its path or extension.\n     * @since 14.0\n     */\n    @Beta\n    public static String getNameWithoutExtension(String file)\n    {\n        checkNotNull(file);\n        String fileName = new File(file).getName();\n        int dotIndex = fileName.lastIndexOf('.');\n        return (dotIndex == -1) ? fileName : fileName.substring(0, dotIndex);\n    }\n\n    /**\n     * Returns a {@link TreeTraverser} instance for {@link File} trees.\n     *\n     * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no\n     * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n     * this case, iterables created by this traverser could contain files that are outside of the\n     * given directory or even be infinite if there is a symbolic link loop.\n     *\n     * @since 15.0\n     * @deprecated The returned {@link TreeTraverser} type is deprecated. Use the replacement method\n     *     {@link #fileTraverser()} instead with the same semantics as this method.\n     */\n    @Deprecated\n    static TreeTraverser<File> fileTreeTraverser()\n    {\n        return FILE_TREE_TRAVERSER;\n    }\n\n    private static final TreeTraverser<File> FILE_TREE_TRAVERSER =\n        new TreeTraverser<File>()\n    {\n        @Override\n        public Iterable<File> children(File file)\n        {\n            return fileTreeChildren(file);\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"Files.fileTreeTraverser()\";\n        }\n    };\n\n    /**\n     * Returns a {@link Traverser} instance for the file and directory tree. The returned traverser\n     * starts from a {@link File} and will return all files and directories it encounters.\n     *\n     * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no\n     * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n     * this case, iterables created by this traverser could contain files that are outside of the\n     * given directory or even be infinite if there is a symbolic link loop.\n     *\n     * <p>If available, consider using {@link MoreFiles#fileTraverser()} instead. It behaves the same\n     * except that it doesn't follow symbolic links and returns {@code Path} instances.\n     *\n     * <p>If the {@link File} passed to one of the {@link Traverser} methods does not exist or is not\n     * a directory, no exception will be thrown and the returned {@link Iterable} will contain a\n     * single element: that file.\n     *\n     * <p>Example: {@code Files.fileTraverser().depthFirstPreOrder(new File(\"/\"))} may return files\n     * with the following paths: {@code [\"/\", \"/etc\", \"/etc/config.txt\", \"/etc/fonts\", \"/home\",\n     * \"/home/alice\", ...]}\n     *\n     * @since 23.5\n     */\n    @Beta\n    public static Traverser<File> fileTraverser()\n    {\n        return Traverser.forTree(FILE_TREE);\n    }\n\n    private static final SuccessorsFunction<File> FILE_TREE =\n        new SuccessorsFunction<File>()\n    {\n        @Override\n        public Iterable<File> successors(File file)\n        {\n            return fileTreeChildren(file);\n        }\n    };\n\n    private static Iterable<File> fileTreeChildren(File file)\n    {\n        // check isDirectory() just because it may be faster than listFiles() on a non-directory\n        if (file.isDirectory())\n        {\n            File[] files = file.listFiles();\n            if (files != null)\n            {\n                return Collections.unmodifiableList(Arrays.asList(files));\n            }\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * Returns a predicate that returns the result of {@link File#isDirectory} on input files.\n     *\n     * @since 15.0\n     */\n    @Beta\n    public static Predicate<File> isDirectory()\n    {\n        return FilePredicate.IS_DIRECTORY;\n    }\n\n    /**\n     * Returns a predicate that returns the result of {@link File#isFile} on input files.\n     *\n     * @since 15.0\n     */\n    @Beta\n    public static Predicate<File> isFile()\n    {\n        return FilePredicate.IS_FILE;\n    }\n\n    private enum FilePredicate implements Predicate<File>\n    {\n        IS_DIRECTORY {\n            @Override\n            public boolean apply(File file)\n            {\n                return file.isDirectory();\n            }\n\n            @Override\n            public String toString()\n            {\n                return \"Files.isDirectory()\";\n            }\n        },\n\n        IS_FILE {\n            @Override\n            public boolean apply(File file)\n            {\n                return file.isFile();\n            }\n\n            @Override\n            public String toString()\n            {\n                return \"Files.isFile()\";\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/io/Files.java", "func_name": "Files.copy", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Copies all bytes from a file to an output stream.\n\n<p><b>{@link java.nio.file.Path} equivalent:</b> {@link\njava.nio.file.Files#copy(java.nio.file.Path, OutputStream)}.\n\n@param from the source file\n@param to the output stream\n@throws IOException if an I/O error occurs", "docstring_tokens": ["Copies", "all", "bytes", "from", "a", "file", "to", "an", "output", "stream", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/io/Files.java#L299-L302", "partition": "valid", "up_fun_num": 11, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.io.FileWriteMode.APPEND;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.Joiner;", "import com.google.common.base.Optional;", "import com.google.common.base.Predicate;", "import com.google.common.base.Splitter;", "import com.google.common.collect.ImmutableSet;", "import com.google.common.collect.Lists;", "import com.google.common.collect.TreeTraverser;", "import com.google.common.graph.SuccessorsFunction;", "import com.google.common.graph.Traverser;", "import com.google.common.hash.HashCode;", "import com.google.common.hash.HashFunction;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.io.BufferedReader;", "import java.io.BufferedWriter;", "import java.io.File;", "import java.io.FileInputStream;", "import java.io.FileNotFoundException;", "import java.io.FileOutputStream;", "import java.io.IOException;", "import java.io.InputStreamReader;", "import java.io.OutputStream;", "import java.io.OutputStreamWriter;", "import java.io.RandomAccessFile;", "import java.nio.MappedByteBuffer;", "import java.nio.channels.FileChannel;", "import java.nio.channels.FileChannel.MapMode;", "import java.nio.charset.Charset;", "import java.nio.charset.StandardCharsets;", "import java.util.ArrayList;", "import java.util.Arrays;", "import java.util.Collections;", "import java.util.List;"], "function": ["public final class Files\n", "    public static BufferedReader newReader(File file, Charset charset) throws FileNotFoundException\n", "    public static BufferedWriter newWriter(File file, Charset charset) throws FileNotFoundException\n", "    public static ByteSource asByteSource(File file)\n", "    public static ByteSink asByteSink(File file, FileWriteMode... modes)\n", "    public static CharSource asCharSource(File file, Charset charset)\n", "    public static CharSink asCharSink(File file, Charset charset, FileWriteMode... modes)\n", "    public static byte[] toByteArray(File file) throws IOException\n", "    public static String toString(File file, Charset charset) throws IOException\n", "    public static void write(byte[] from, File to) throws IOException\n", "    public static void write(CharSequence from, File to, Charset charset) throws IOException\n", "    public static void copy(File from, File to) throws IOException\n", "    static void copy(File from, Charset charset, Appendable to) throws IOException\n", "    static void append(CharSequence from, File to, Charset charset) throws IOException\n", "    public static boolean equal(File file1, File file2) throws IOException\n", "    public static File createTempDir()\n", "    public static void touch(File file) throws IOException\n", "    public static void createParentDirs(File file) throws IOException\n", "    public static void move(File from, File to) throws IOException\n", "    static String readFirstLine(File file, Charset charset) throws IOException\n", "    public static List<String> readLines(File file, Charset charset) throws IOException\n", "    static <T> T readLines(File file, Charset charset, LineProcessor<T> callback) throws IOException\n", "    static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException\n", "    static HashCode hash(File file, HashFunction hashFunction) throws IOException\n", "    public static MappedByteBuffer map(File file) throws IOException\n", "    public static MappedByteBuffer map(File file, MapMode mode) throws IOException\n", "    public static MappedByteBuffer map(File file, MapMode mode, long size) throws IOException\n", "    private static MappedByteBuffer mapInternal(File file, MapMode mode, long size)\n", "    public static String simplifyPath(String pathname)\n", "    public static String getFileExtension(String fullName)\n", "    public static String getNameWithoutExtension(String file)\n", "    static TreeTraverser<File> fileTreeTraverser()\n", "    public static Traverser<File> fileTraverser()\n", "    private static Iterable<File> fileTreeChildren(File file)\n", "    public static Predicate<File> isDirectory()\n", "    public static Predicate<File> isFile()\n"], "context": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.io.FileWriteMode.APPEND;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.TreeTraverser;\nimport com.google.common.graph.SuccessorsFunction;\nimport com.google.common.graph.Traverser;\nimport com.google.common.hash.HashCode;\nimport com.google.common.hash.HashFunction;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Provides utility methods for working with {@linkplain File files}.\n *\n * <p>{@link java.nio.file.Path} users will find similar utilities in {@link MoreFiles} and the\n * JDK's {@link java.nio.file.Files} class.\n *\n * @author Chris Nokleberg\n * @author Colin Decker\n * @since 1.0\n */\n@GwtIncompatible\npublic final class Files\n{\n\n    /** Maximum loop count when creating temp directories. */\n    private static final int TEMP_DIR_ATTEMPTS = 10000;\n\n    private Files() {}\n\n    /**\n     * Returns a buffered reader that reads from a file using the given character set.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#newBufferedReader(java.nio.file.Path, Charset)}.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return the buffered reader\n     */\n    @Beta\n    public static BufferedReader newReader(File file, Charset charset) throws FileNotFoundException\n    {\n        checkNotNull(file);\n        checkNotNull(charset);\n        return new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));\n    }\n\n    /**\n     * Returns a buffered writer that writes to a file using the given character set.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#newBufferedWriter(java.nio.file.Path, Charset,\n     * java.nio.file.OpenOption...)}.\n     *\n     * @param file the file to write to\n     * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return the buffered writer\n     */\n    @Beta\n    public static BufferedWriter newWriter(File file, Charset charset) throws FileNotFoundException\n    {\n        checkNotNull(file);\n        checkNotNull(charset);\n        return new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset));\n    }\n\n    /**\n     * Returns a new {@link ByteSource} for reading bytes from the given file.\n     *\n     * @since 14.0\n     */\n    public static ByteSource asByteSource(File file)\n    {\n        return new FileByteSource(file);\n    }\n\n    private static final class FileByteSource extends ByteSource\n    {\n\n        private final File file;\n\n        private FileByteSource(File file)\n        {\n            this.file = checkNotNull(file);\n        }\n\n        @Override\n        public FileInputStream openStream() throws IOException\n        {\n            return new FileInputStream(file);\n        }\n\n        @Override\n        public Optional<Long> sizeIfKnown()\n        {\n            if (file.isFile())\n            {\n                return Optional.of(file.length());\n            }\n            else\n            {\n                return Optional.absent();\n            }\n        }\n\n        @Override\n        public long size() throws IOException\n        {\n            if (!file.isFile())\n            {\n                throw new FileNotFoundException(file.toString());\n            }\n            return file.length();\n        }\n\n        @Override\n        public byte[] read() throws IOException\n        {\n            Closer closer = Closer.create();\n            try\n            {\n                FileInputStream in = closer.register(openStream());\n                return ByteStreams.toByteArray(in, in.getChannel().size());\n            }\n            catch (Throwable e)\n            {\n                throw closer.rethrow(e);\n            }\n            finally\n            {\n                closer.close();\n            }\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"Files.asByteSource(\" + file + \")\";\n        }\n    }\n\n    /**\n     * Returns a new {@link ByteSink} for writing bytes to the given file. The given {@code modes}\n     * control how the file is opened for writing. When no mode is provided, the file will be\n     * truncated before writing. When the {@link FileWriteMode#APPEND APPEND} mode is provided, writes\n     * will append to the end of the file without truncating it.\n     *\n     * @since 14.0\n     */\n    public static ByteSink asByteSink(File file, FileWriteMode... modes)\n    {\n        return new FileByteSink(file, modes);\n    }\n\n    private static final class FileByteSink extends ByteSink\n    {\n\n        private final File file;\n        private final ImmutableSet<FileWriteMode> modes;\n\n        private FileByteSink(File file, FileWriteMode... modes)\n        {\n            this.file = checkNotNull(file);\n            this.modes = ImmutableSet.copyOf(modes);\n        }\n\n        @Override\n        public FileOutputStream openStream() throws IOException\n        {\n            return new FileOutputStream(file, modes.contains(APPEND));\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"Files.asByteSink(\" + file + \", \" + modes + \")\";\n        }\n    }\n\n    /**\n     * Returns a new {@link CharSource} for reading character data from the given file using the given\n     * character set.\n     *\n     * @since 14.0\n     */\n    public static CharSource asCharSource(File file, Charset charset)\n    {\n        return asByteSource(file).asCharSource(charset);\n    }\n\n    /**\n     * Returns a new {@link CharSink} for writing character data to the given file using the given\n     * character set. The given {@code modes} control how the file is opened for writing. When no mode\n     * is provided, the file will be truncated before writing. When the {@link FileWriteMode#APPEND\n     * APPEND} mode is provided, writes will append to the end of the file without truncating it.\n     *\n     * @since 14.0\n     */\n    public static CharSink asCharSink(File file, Charset charset, FileWriteMode... modes)\n    {\n        return asByteSink(file, modes).asCharSink(charset);\n    }\n\n    /**\n     * Reads all bytes from a file into a byte array.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#readAllBytes}.\n     *\n     * @param file the file to read from\n     * @return a byte array containing all the bytes from file\n     * @throws IllegalArgumentException if the file is bigger than the largest possible byte array\n     *     (2^31 - 1)\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static byte[] toByteArray(File file) throws IOException\n    {\n        return asByteSource(file).read();\n    }\n\n    /**\n     * Reads all characters from a file into a {@link String}, using the given character set.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return a string containing all the characters from the file\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(file, charset).read()}. This method is scheduled to be\n     *     removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public static String toString(File file, Charset charset) throws IOException\n    {\n        return asCharSource(file, charset).read();\n    }\n\n    /**\n     * Overwrites a file with the contents of a byte array.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#write(java.nio.file.Path, byte[], java.nio.file.OpenOption...)}.\n     *\n     * @param from the bytes to write\n     * @param to the destination file\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static void write(byte[] from, File to) throws IOException\n    {\n        asByteSink(to).write(from);\n    }\n\n    /**\n     * Writes a character sequence (such as a string) to a file using the given character set.\n     *\n     * @param from the character sequence to write\n     * @param to the destination file\n     * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSink(to, charset).write(from)}. This method is scheduled to be\n     *     removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public static void write(CharSequence from, File to, Charset charset) throws IOException\n    {\n        asCharSink(to, charset).write(from);\n    }\n\n    /**\n     * Copies all bytes from a file to an output stream.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#copy(java.nio.file.Path, OutputStream)}.\n     *\n     * @param from the source file\n     * @param to the output stream\n     * @throws IOException if an I/O error occurs\n     */\n\n    /**\n     * Copies all the bytes from one file to another.\n     *\n     * <p>Copying is not an atomic operation - in the case of an I/O error, power loss, process\n     * termination, or other problems, {@code to} may not be a complete copy of {@code from}. If you\n     * need to guard against those conditions, you should employ other file-level synchronization.\n     *\n     * <p><b>Warning:</b> If {@code to} represents an existing file, that file will be overwritten\n     * with the contents of {@code from}. If {@code to} and {@code from} refer to the <i>same</i>\n     * file, the contents of that file will be deleted.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#copy(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...)}.\n     *\n     * @param from the source file\n     * @param to the destination file\n     * @throws IOException if an I/O error occurs\n     * @throws IllegalArgumentException if {@code from.equals(to)}\n     */\n    @Beta\n    public static void copy(File from, File to) throws IOException\n    {\n        checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n        asByteSource(from).copyTo(asByteSink(to));\n    }\n\n    /**\n     * Copies all characters from a file to an appendable object, using the given character set.\n     *\n     * @param from the source file\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @param to the appendable object\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(from, charset).copyTo(to)}. This method is scheduled to\n     *     be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static void copy(File from, Charset charset, Appendable to) throws IOException\n    {\n        asCharSource(from, charset).copyTo(to);\n    }\n\n    /**\n     * Appends a character sequence (such as a string) to a file using the given character set.\n     *\n     * @param from the character sequence to append\n     * @param to the destination file\n     * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSink(to, charset, FileWriteMode.APPEND).write(from)}. This\n     *     method is scheduled to be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static void append(CharSequence from, File to, Charset charset) throws IOException\n    {\n        asCharSink(to, charset, FileWriteMode.APPEND).write(from);\n    }\n\n    /**\n     * Returns true if the given files exist, are not directories, and contain the same bytes.\n     *\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static boolean equal(File file1, File file2) throws IOException\n    {\n        checkNotNull(file1);\n        checkNotNull(file2);\n        if (file1 == file2 || file1.equals(file2))\n        {\n            return true;\n        }\n\n        /*\n         * Some operating systems may return zero as the length for files denoting system-dependent\n         * entities such as devices or pipes, in which case we must fall back on comparing the bytes\n         * directly.\n         */\n        long len1 = file1.length();\n        long len2 = file2.length();\n        if (len1 != 0 && len2 != 0 && len1 != len2)\n        {\n            return false;\n        }\n        return asByteSource(file1).contentEquals(asByteSource(file2));\n    }\n\n    /**\n     * Atomically creates a new directory somewhere beneath the system's temporary directory (as\n     * defined by the {@code java.io.tmpdir} system property), and returns its name.\n     *\n     * <p>Use this method instead of {@link File#createTempFile(String, String)} when you wish to\n     * create a directory, not a regular file. A common pitfall is to call {@code createTempFile},\n     * delete the file and create a directory in its place, but this leads a race condition which can\n     * be exploited to create security vulnerabilities, especially when executable files are to be\n     * written into the directory.\n     *\n     * <p>This method assumes that the temporary volume is writable, has free inodes and free blocks,\n     * and that it will not be called thousands of times per second.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#createTempDirectory}.\n     *\n     * @return the newly-created directory\n     * @throws IllegalStateException if the directory could not be created\n     */\n    @Beta\n    public static File createTempDir()\n    {\n        File baseDir = new File(System.getProperty(\"java.io.tmpdir\"));\n        @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n        String baseName = System.currentTimeMillis() + \"-\";\n\n        for (int counter = 0; counter < TEMP_DIR_ATTEMPTS; counter++)\n        {\n            File tempDir = new File(baseDir, baseName + counter);\n            if (tempDir.mkdir())\n            {\n                return tempDir;\n            }\n        }\n        throw new IllegalStateException(\n            \"Failed to create directory within \"\n            + TEMP_DIR_ATTEMPTS\n            + \" attempts (tried \"\n            + baseName\n            + \"0 to \"\n            + baseName\n            + (TEMP_DIR_ATTEMPTS - 1)\n            + ')');\n    }\n\n    /**\n     * Creates an empty file or updates the last updated timestamp on the same as the unix command of\n     * the same name.\n     *\n     * @param file the file to create or update\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n    public static void touch(File file) throws IOException\n    {\n        checkNotNull(file);\n        if (!file.createNewFile() && !file.setLastModified(System.currentTimeMillis()))\n        {\n            throw new IOException(\"Unable to update modification time of \" + file);\n        }\n    }\n\n    /**\n     * Creates any necessary but nonexistent parent directories of the specified file. Note that if\n     * this operation fails it may have succeeded in creating some (but not all) of the necessary\n     * parent directories.\n     *\n     * @throws IOException if an I/O error occurs, or if any necessary but nonexistent parent\n     *     directories of the specified file could not be created.\n     * @since 4.0\n     */\n    @Beta\n    public static void createParentDirs(File file) throws IOException\n    {\n        checkNotNull(file);\n        File parent = file.getCanonicalFile().getParentFile();\n        if (parent == null)\n        {\n            /*\n             * The given directory is a filesystem root. All zero of its ancestors exist. This doesn't\n             * mean that the root itself exists -- consider x:\\ on a Windows machine without such a drive\n             * -- or even that the caller can create it, but this method makes no such guarantees even for\n             * non-root files.\n             */\n            return;\n        }\n        parent.mkdirs();\n        if (!parent.isDirectory())\n        {\n            throw new IOException(\"Unable to create parent directories of \" + file);\n        }\n    }\n\n    /**\n     * Moves a file from one path to another. This method can rename a file and/or move it to a\n     * different directory. In either case {@code to} must be the target path for the file itself; not\n     * just the new name for the file or the path to the new parent directory.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#move}.\n     *\n     * @param from the source file\n     * @param to the destination file\n     * @throws IOException if an I/O error occurs\n     * @throws IllegalArgumentException if {@code from.equals(to)}\n     */\n    @Beta\n    public static void move(File from, File to) throws IOException\n    {\n        checkNotNull(from);\n        checkNotNull(to);\n        checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n\n        if (!from.renameTo(to))\n        {\n            copy(from, to);\n            if (!from.delete())\n            {\n                if (!to.delete())\n                {\n                    throw new IOException(\"Unable to delete \" + to);\n                }\n                throw new IOException(\"Unable to delete \" + from);\n            }\n        }\n    }\n\n    /**\n     * Reads the first line from a file. The line does not include line-termination characters, but\n     * does include other leading and trailing whitespace.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return the first line, or null if the file is empty\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(file, charset).readFirstLine()}. This method is\n     *     scheduled to be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static String readFirstLine(File file, Charset charset) throws IOException\n    {\n        return asCharSource(file, charset).readFirstLine();\n    }\n\n    /**\n     * Reads all of the lines from a file. The lines do not include line-termination characters, but\n     * do include other leading and trailing whitespace.\n     *\n     * <p>This method returns a mutable {@code List}. For an {@code ImmutableList}, use {@code\n     * Files.asCharSource(file, charset).readLines()}.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#readAllLines(java.nio.file.Path, Charset)}.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return a mutable {@link List} containing all the lines\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static List<String> readLines(File file, Charset charset) throws IOException\n    {\n        // don't use asCharSource(file, charset).readLines() because that returns\n        // an immutable list, which would change the behavior of this method\n        return asCharSource(file, charset)\n               .readLines(\n                   new LineProcessor<List<String>>()\n        {\n            final List<String> result = Lists.newArrayList();\n\n            @Override\n            public boolean processLine(String line)\n            {\n                result.add(line);\n                return true;\n            }\n\n            @Override\n            public List<String> getResult()\n            {\n                return result;\n            }\n        });\n    }\n\n    /**\n     * Streams lines from a {@link File}, stopping when our callback returns false, or we have read\n     * all of the lines.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @param callback the {@link LineProcessor} to use to handle the lines\n     * @return the output of processing the lines\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(file, charset).readLines(callback)}. This method is\n     *     scheduled to be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    @CanIgnoreReturnValue // some processors won't return a useful result\n    public\n    static <T> T readLines(File file, Charset charset, LineProcessor<T> callback) throws IOException\n    {\n        return asCharSource(file, charset).readLines(callback);\n    }\n\n    /**\n     * Process the bytes of a file.\n     *\n     * <p>(If this seems too complicated, maybe you're looking for {@link #toByteArray}.)\n     *\n     * @param file the file to read\n     * @param processor the object to which the bytes of the file are passed.\n     * @return the result of the byte processor\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asByteSource(file).read(processor)}. This method is scheduled to be\n     *     removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    @CanIgnoreReturnValue // some processors won't return a useful result\n    public\n    static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException\n    {\n        return asByteSource(file).read(processor);\n    }\n\n    /**\n     * Computes the hash code of the {@code file} using {@code hashFunction}.\n     *\n     * @param file the file to read\n     * @param hashFunction the hash function to use to hash the data\n     * @return the {@link HashCode} of all of the bytes in the file\n     * @throws IOException if an I/O error occurs\n     * @since 12.0\n     * @deprecated Prefer {@code asByteSource(file).hash(hashFunction)}. This method is scheduled to\n     *     be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static HashCode hash(File file, HashFunction hashFunction) throws IOException\n    {\n        return asByteSource(file).hash(hashFunction);\n    }\n\n    /**\n     * Fully maps a file read-only in to memory as per {@link\n     * FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}.\n     *\n     * <p>Files are mapped from offset 0 to its length.\n     *\n     * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n     *\n     * @param file the file to map\n     * @return a read-only buffer reflecting {@code file}\n     * @throws FileNotFoundException if the {@code file} does not exist\n     * @throws IOException if an I/O error occurs\n     * @see FileChannel#map(MapMode, long, long)\n     * @since 2.0\n     */\n    @Beta\n    public static MappedByteBuffer map(File file) throws IOException\n    {\n        checkNotNull(file);\n        return map(file, MapMode.READ_ONLY);\n    }\n\n    /**\n     * Fully maps a file in to memory as per {@link\n     * FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)} using the requested {@link\n     * MapMode}.\n     *\n     * <p>Files are mapped from offset 0 to its length.\n     *\n     * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n     *\n     * @param file the file to map\n     * @param mode the mode to use when mapping {@code file}\n     * @return a buffer reflecting {@code file}\n     * @throws FileNotFoundException if the {@code file} does not exist\n     * @throws IOException if an I/O error occurs\n     * @see FileChannel#map(MapMode, long, long)\n     * @since 2.0\n     */\n    @Beta\n    public static MappedByteBuffer map(File file, MapMode mode) throws IOException\n    {\n        return mapInternal(file, mode, -1);\n    }\n\n    /**\n     * Maps a file in to memory as per {@link FileChannel#map(java.nio.channels.FileChannel.MapMode,\n     * long, long)} using the requested {@link MapMode}.\n     *\n     * <p>Files are mapped from offset 0 to {@code size}.\n     *\n     * <p>If the mode is {@link MapMode#READ_WRITE} and the file does not exist, it will be created\n     * with the requested {@code size}. Thus this method is useful for creating memory mapped files\n     * which do not yet exist.\n     *\n     * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n     *\n     * @param file the file to map\n     * @param mode the mode to use when mapping {@code file}\n     * @return a buffer reflecting {@code file}\n     * @throws IOException if an I/O error occurs\n     * @see FileChannel#map(MapMode, long, long)\n     * @since 2.0\n     */\n    @Beta\n    public static MappedByteBuffer map(File file, MapMode mode, long size) throws IOException\n    {\n        checkArgument(size >= 0, \"size (%s) may not be negative\", size);\n        return mapInternal(file, mode, size);\n    }\n\n    private static MappedByteBuffer mapInternal(File file, MapMode mode, long size)\n    throws IOException\n    {\n        checkNotNull(file);\n        checkNotNull(mode);\n\n        Closer closer = Closer.create();\n        try\n        {\n            RandomAccessFile raf =\n                closer.register(new RandomAccessFile(file, mode == MapMode.READ_ONLY ? \"r\" : \"rw\"));\n            FileChannel channel = closer.register(raf.getChannel());\n            return channel.map(mode, 0, size == -1 ? channel.size() : size);\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Returns the lexically cleaned form of the path name, <i>usually</i> (but not always) equivalent\n     * to the original. The following heuristics are used:\n     *\n     * <ul>\n     *   <li>empty string becomes .\n     *   <li>. stays as .\n     *   <li>fold out ./\n     *   <li>fold out ../ when possible\n     *   <li>collapse multiple slashes\n     *   <li>delete trailing slashes (unless the path is just \"/\")\n     * </ul>\n     *\n     * <p>These heuristics do not always match the behavior of the filesystem. In particular, consider\n     * the path {@code a/../b}, which {@code simplifyPath} will change to {@code b}. If {@code a} is a\n     * symlink to {@code x}, {@code a/../b} may refer to a sibling of {@code x}, rather than the\n     * sibling of {@code a} referred to by {@code b}.\n     *\n     * @since 11.0\n     */\n    @Beta\n    public static String simplifyPath(String pathname)\n    {\n        checkNotNull(pathname);\n        if (pathname.length() == 0)\n        {\n            return \".\";\n        }\n\n        // split the path apart\n        Iterable<String> components = Splitter.on('/').omitEmptyStrings().split(pathname);\n        List<String> path = new ArrayList<>();\n\n        // resolve ., .., and //\n        for (String component : components)\n        {\n            switch (component)\n            {\n            case \".\":\n                continue;\n            case \"..\":\n                if (path.size() > 0 && !path.get(path.size() - 1).equals(\"..\"))\n                {\n                    path.remove(path.size() - 1);\n                }\n                else\n                {\n                    path.add(\"..\");\n                }\n                break;\n            default:\n                path.add(component);\n                break;\n            }\n        }\n\n        // put it back together\n        String result = Joiner.on('/').join(path);\n        if (pathname.charAt(0) == '/')\n        {\n            result = \"/\" + result;\n        }\n\n        while (result.startsWith(\"/../\"))\n        {\n            result = result.substring(3);\n        }\n        if (result.equals(\"/..\"))\n        {\n            result = \"/\";\n        }\n        else if (\"\".equals(result))\n        {\n            result = \".\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the <a href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> for\n     * the given file name, or the empty string if the file has no extension. The result does not\n     * include the '{@code .}'.\n     *\n     * <p><b>Note:</b> This method simply returns everything after the last '{@code .}' in the file's\n     * name as determined by {@link File#getName}. It does not account for any filesystem-specific\n     * behavior that the {@link File} API does not already account for. For example, on NTFS it will\n     * report {@code \"txt\"} as the extension for the filename {@code \"foo.exe:.txt\"} even though NTFS\n     * will drop the {@code \":.txt\"} part of the name when the file is actually created on the\n     * filesystem due to NTFS's <a href=\"https://goo.gl/vTpJi4\">Alternate Data Streams</a>.\n     *\n     * @since 11.0\n     */\n    @Beta\n    public static String getFileExtension(String fullName)\n    {\n        checkNotNull(fullName);\n        String fileName = new File(fullName).getName();\n        int dotIndex = fileName.lastIndexOf('.');\n        return (dotIndex == -1) ? \"\" : fileName.substring(dotIndex + 1);\n    }\n\n    /**\n     * Returns the file name without its <a\n     * href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> or path. This is\n     * similar to the {@code basename} unix command. The result does not include the '{@code .}'.\n     *\n     * @param file The name of the file to trim the extension from. This can be either a fully\n     *     qualified file name (including a path) or just a file name.\n     * @return The file name without its path or extension.\n     * @since 14.0\n     */\n    @Beta\n    public static String getNameWithoutExtension(String file)\n    {\n        checkNotNull(file);\n        String fileName = new File(file).getName();\n        int dotIndex = fileName.lastIndexOf('.');\n        return (dotIndex == -1) ? fileName : fileName.substring(0, dotIndex);\n    }\n\n    /**\n     * Returns a {@link TreeTraverser} instance for {@link File} trees.\n     *\n     * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no\n     * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n     * this case, iterables created by this traverser could contain files that are outside of the\n     * given directory or even be infinite if there is a symbolic link loop.\n     *\n     * @since 15.0\n     * @deprecated The returned {@link TreeTraverser} type is deprecated. Use the replacement method\n     *     {@link #fileTraverser()} instead with the same semantics as this method.\n     */\n    @Deprecated\n    static TreeTraverser<File> fileTreeTraverser()\n    {\n        return FILE_TREE_TRAVERSER;\n    }\n\n    private static final TreeTraverser<File> FILE_TREE_TRAVERSER =\n        new TreeTraverser<File>()\n    {\n        @Override\n        public Iterable<File> children(File file)\n        {\n            return fileTreeChildren(file);\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"Files.fileTreeTraverser()\";\n        }\n    };\n\n    /**\n     * Returns a {@link Traverser} instance for the file and directory tree. The returned traverser\n     * starts from a {@link File} and will return all files and directories it encounters.\n     *\n     * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no\n     * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n     * this case, iterables created by this traverser could contain files that are outside of the\n     * given directory or even be infinite if there is a symbolic link loop.\n     *\n     * <p>If available, consider using {@link MoreFiles#fileTraverser()} instead. It behaves the same\n     * except that it doesn't follow symbolic links and returns {@code Path} instances.\n     *\n     * <p>If the {@link File} passed to one of the {@link Traverser} methods does not exist or is not\n     * a directory, no exception will be thrown and the returned {@link Iterable} will contain a\n     * single element: that file.\n     *\n     * <p>Example: {@code Files.fileTraverser().depthFirstPreOrder(new File(\"/\"))} may return files\n     * with the following paths: {@code [\"/\", \"/etc\", \"/etc/config.txt\", \"/etc/fonts\", \"/home\",\n     * \"/home/alice\", ...]}\n     *\n     * @since 23.5\n     */\n    @Beta\n    public static Traverser<File> fileTraverser()\n    {\n        return Traverser.forTree(FILE_TREE);\n    }\n\n    private static final SuccessorsFunction<File> FILE_TREE =\n        new SuccessorsFunction<File>()\n    {\n        @Override\n        public Iterable<File> successors(File file)\n        {\n            return fileTreeChildren(file);\n        }\n    };\n\n    private static Iterable<File> fileTreeChildren(File file)\n    {\n        // check isDirectory() just because it may be faster than listFiles() on a non-directory\n        if (file.isDirectory())\n        {\n            File[] files = file.listFiles();\n            if (files != null)\n            {\n                return Collections.unmodifiableList(Arrays.asList(files));\n            }\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * Returns a predicate that returns the result of {@link File#isDirectory} on input files.\n     *\n     * @since 15.0\n     */\n    @Beta\n    public static Predicate<File> isDirectory()\n    {\n        return FilePredicate.IS_DIRECTORY;\n    }\n\n    /**\n     * Returns a predicate that returns the result of {@link File#isFile} on input files.\n     *\n     * @since 15.0\n     */\n    @Beta\n    public static Predicate<File> isFile()\n    {\n        return FilePredicate.IS_FILE;\n    }\n\n    private enum FilePredicate implements Predicate<File>\n    {\n        IS_DIRECTORY {\n            @Override\n            public boolean apply(File file)\n            {\n                return file.isDirectory();\n            }\n\n            @Override\n            public String toString()\n            {\n                return \"Files.isDirectory()\";\n            }\n        },\n\n        IS_FILE {\n            @Override\n            public boolean apply(File file)\n            {\n                return file.isFile();\n            }\n\n            @Override\n            public String toString()\n            {\n                return \"Files.isFile()\";\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/io/Files.java", "func_name": "Files.copy", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Copies all the bytes from one file to another.\n\n<p>Copying is not an atomic operation - in the case of an I/O error, power loss, process\ntermination, or other problems, {@code to} may not be a complete copy of {@code from}. If you\nneed to guard against those conditions, you should employ other file-level synchronization.\n\n<p><b>Warning:</b> If {@code to} represents an existing file, that file will be overwritten\nwith the contents of {@code from}. If {@code to} and {@code from} refer to the <i>same</i>\nfile, the contents of that file will be deleted.\n\n<p><b>{@link java.nio.file.Path} equivalent:</b> {@link\njava.nio.file.Files#copy(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...)}.\n\n@param from the source file\n@param to the destination file\n@throws IOException if an I/O error occurs\n@throws IllegalArgumentException if {@code from.equals(to)}", "docstring_tokens": ["Copies", "all", "the", "bytes", "from", "one", "file", "to", "another", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/io/Files.java#L323-L327", "partition": "valid", "up_fun_num": 12, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.io.FileWriteMode.APPEND;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.Joiner;", "import com.google.common.base.Optional;", "import com.google.common.base.Predicate;", "import com.google.common.base.Splitter;", "import com.google.common.collect.ImmutableSet;", "import com.google.common.collect.Lists;", "import com.google.common.collect.TreeTraverser;", "import com.google.common.graph.SuccessorsFunction;", "import com.google.common.graph.Traverser;", "import com.google.common.hash.HashCode;", "import com.google.common.hash.HashFunction;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.io.BufferedReader;", "import java.io.BufferedWriter;", "import java.io.File;", "import java.io.FileInputStream;", "import java.io.FileNotFoundException;", "import java.io.FileOutputStream;", "import java.io.IOException;", "import java.io.InputStreamReader;", "import java.io.OutputStream;", "import java.io.OutputStreamWriter;", "import java.io.RandomAccessFile;", "import java.nio.MappedByteBuffer;", "import java.nio.channels.FileChannel;", "import java.nio.channels.FileChannel.MapMode;", "import java.nio.charset.Charset;", "import java.nio.charset.StandardCharsets;", "import java.util.ArrayList;", "import java.util.Arrays;", "import java.util.Collections;", "import java.util.List;"], "function": ["public final class Files\n", "    public static BufferedReader newReader(File file, Charset charset) throws FileNotFoundException\n", "    public static BufferedWriter newWriter(File file, Charset charset) throws FileNotFoundException\n", "    public static ByteSource asByteSource(File file)\n", "    public static ByteSink asByteSink(File file, FileWriteMode... modes)\n", "    public static CharSource asCharSource(File file, Charset charset)\n", "    public static CharSink asCharSink(File file, Charset charset, FileWriteMode... modes)\n", "    public static byte[] toByteArray(File file) throws IOException\n", "    public static String toString(File file, Charset charset) throws IOException\n", "    public static void write(byte[] from, File to) throws IOException\n", "    public static void write(CharSequence from, File to, Charset charset) throws IOException\n", "    public static void copy(File from, OutputStream to) throws IOException\n", "    static void copy(File from, Charset charset, Appendable to) throws IOException\n", "    static void append(CharSequence from, File to, Charset charset) throws IOException\n", "    public static boolean equal(File file1, File file2) throws IOException\n", "    public static File createTempDir()\n", "    public static void touch(File file) throws IOException\n", "    public static void createParentDirs(File file) throws IOException\n", "    public static void move(File from, File to) throws IOException\n", "    static String readFirstLine(File file, Charset charset) throws IOException\n", "    public static List<String> readLines(File file, Charset charset) throws IOException\n", "    static <T> T readLines(File file, Charset charset, LineProcessor<T> callback) throws IOException\n", "    static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException\n", "    static HashCode hash(File file, HashFunction hashFunction) throws IOException\n", "    public static MappedByteBuffer map(File file) throws IOException\n", "    public static MappedByteBuffer map(File file, MapMode mode) throws IOException\n", "    public static MappedByteBuffer map(File file, MapMode mode, long size) throws IOException\n", "    private static MappedByteBuffer mapInternal(File file, MapMode mode, long size)\n", "    public static String simplifyPath(String pathname)\n", "    public static String getFileExtension(String fullName)\n", "    public static String getNameWithoutExtension(String file)\n", "    static TreeTraverser<File> fileTreeTraverser()\n", "    public static Traverser<File> fileTraverser()\n", "    private static Iterable<File> fileTreeChildren(File file)\n", "    public static Predicate<File> isDirectory()\n", "    public static Predicate<File> isFile()\n"], "context": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.io.FileWriteMode.APPEND;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.TreeTraverser;\nimport com.google.common.graph.SuccessorsFunction;\nimport com.google.common.graph.Traverser;\nimport com.google.common.hash.HashCode;\nimport com.google.common.hash.HashFunction;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Provides utility methods for working with {@linkplain File files}.\n *\n * <p>{@link java.nio.file.Path} users will find similar utilities in {@link MoreFiles} and the\n * JDK's {@link java.nio.file.Files} class.\n *\n * @author Chris Nokleberg\n * @author Colin Decker\n * @since 1.0\n */\n@GwtIncompatible\npublic final class Files\n{\n\n    /** Maximum loop count when creating temp directories. */\n    private static final int TEMP_DIR_ATTEMPTS = 10000;\n\n    private Files() {}\n\n    /**\n     * Returns a buffered reader that reads from a file using the given character set.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#newBufferedReader(java.nio.file.Path, Charset)}.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return the buffered reader\n     */\n    @Beta\n    public static BufferedReader newReader(File file, Charset charset) throws FileNotFoundException\n    {\n        checkNotNull(file);\n        checkNotNull(charset);\n        return new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));\n    }\n\n    /**\n     * Returns a buffered writer that writes to a file using the given character set.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#newBufferedWriter(java.nio.file.Path, Charset,\n     * java.nio.file.OpenOption...)}.\n     *\n     * @param file the file to write to\n     * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return the buffered writer\n     */\n    @Beta\n    public static BufferedWriter newWriter(File file, Charset charset) throws FileNotFoundException\n    {\n        checkNotNull(file);\n        checkNotNull(charset);\n        return new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset));\n    }\n\n    /**\n     * Returns a new {@link ByteSource} for reading bytes from the given file.\n     *\n     * @since 14.0\n     */\n    public static ByteSource asByteSource(File file)\n    {\n        return new FileByteSource(file);\n    }\n\n    private static final class FileByteSource extends ByteSource\n    {\n\n        private final File file;\n\n        private FileByteSource(File file)\n        {\n            this.file = checkNotNull(file);\n        }\n\n        @Override\n        public FileInputStream openStream() throws IOException\n        {\n            return new FileInputStream(file);\n        }\n\n        @Override\n        public Optional<Long> sizeIfKnown()\n        {\n            if (file.isFile())\n            {\n                return Optional.of(file.length());\n            }\n            else\n            {\n                return Optional.absent();\n            }\n        }\n\n        @Override\n        public long size() throws IOException\n        {\n            if (!file.isFile())\n            {\n                throw new FileNotFoundException(file.toString());\n            }\n            return file.length();\n        }\n\n        @Override\n        public byte[] read() throws IOException\n        {\n            Closer closer = Closer.create();\n            try\n            {\n                FileInputStream in = closer.register(openStream());\n                return ByteStreams.toByteArray(in, in.getChannel().size());\n            }\n            catch (Throwable e)\n            {\n                throw closer.rethrow(e);\n            }\n            finally\n            {\n                closer.close();\n            }\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"Files.asByteSource(\" + file + \")\";\n        }\n    }\n\n    /**\n     * Returns a new {@link ByteSink} for writing bytes to the given file. The given {@code modes}\n     * control how the file is opened for writing. When no mode is provided, the file will be\n     * truncated before writing. When the {@link FileWriteMode#APPEND APPEND} mode is provided, writes\n     * will append to the end of the file without truncating it.\n     *\n     * @since 14.0\n     */\n    public static ByteSink asByteSink(File file, FileWriteMode... modes)\n    {\n        return new FileByteSink(file, modes);\n    }\n\n    private static final class FileByteSink extends ByteSink\n    {\n\n        private final File file;\n        private final ImmutableSet<FileWriteMode> modes;\n\n        private FileByteSink(File file, FileWriteMode... modes)\n        {\n            this.file = checkNotNull(file);\n            this.modes = ImmutableSet.copyOf(modes);\n        }\n\n        @Override\n        public FileOutputStream openStream() throws IOException\n        {\n            return new FileOutputStream(file, modes.contains(APPEND));\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"Files.asByteSink(\" + file + \", \" + modes + \")\";\n        }\n    }\n\n    /**\n     * Returns a new {@link CharSource} for reading character data from the given file using the given\n     * character set.\n     *\n     * @since 14.0\n     */\n    public static CharSource asCharSource(File file, Charset charset)\n    {\n        return asByteSource(file).asCharSource(charset);\n    }\n\n    /**\n     * Returns a new {@link CharSink} for writing character data to the given file using the given\n     * character set. The given {@code modes} control how the file is opened for writing. When no mode\n     * is provided, the file will be truncated before writing. When the {@link FileWriteMode#APPEND\n     * APPEND} mode is provided, writes will append to the end of the file without truncating it.\n     *\n     * @since 14.0\n     */\n    public static CharSink asCharSink(File file, Charset charset, FileWriteMode... modes)\n    {\n        return asByteSink(file, modes).asCharSink(charset);\n    }\n\n    /**\n     * Reads all bytes from a file into a byte array.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#readAllBytes}.\n     *\n     * @param file the file to read from\n     * @return a byte array containing all the bytes from file\n     * @throws IllegalArgumentException if the file is bigger than the largest possible byte array\n     *     (2^31 - 1)\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static byte[] toByteArray(File file) throws IOException\n    {\n        return asByteSource(file).read();\n    }\n\n    /**\n     * Reads all characters from a file into a {@link String}, using the given character set.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return a string containing all the characters from the file\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(file, charset).read()}. This method is scheduled to be\n     *     removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public static String toString(File file, Charset charset) throws IOException\n    {\n        return asCharSource(file, charset).read();\n    }\n\n    /**\n     * Overwrites a file with the contents of a byte array.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#write(java.nio.file.Path, byte[], java.nio.file.OpenOption...)}.\n     *\n     * @param from the bytes to write\n     * @param to the destination file\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static void write(byte[] from, File to) throws IOException\n    {\n        asByteSink(to).write(from);\n    }\n\n    /**\n     * Writes a character sequence (such as a string) to a file using the given character set.\n     *\n     * @param from the character sequence to write\n     * @param to the destination file\n     * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSink(to, charset).write(from)}. This method is scheduled to be\n     *     removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public static void write(CharSequence from, File to, Charset charset) throws IOException\n    {\n        asCharSink(to, charset).write(from);\n    }\n\n    /**\n     * Copies all bytes from a file to an output stream.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#copy(java.nio.file.Path, OutputStream)}.\n     *\n     * @param from the source file\n     * @param to the output stream\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static void copy(File from, OutputStream to) throws IOException\n    {\n        asByteSource(from).copyTo(to);\n    }\n\n    /**\n     * Copies all the bytes from one file to another.\n     *\n     * <p>Copying is not an atomic operation - in the case of an I/O error, power loss, process\n     * termination, or other problems, {@code to} may not be a complete copy of {@code from}. If you\n     * need to guard against those conditions, you should employ other file-level synchronization.\n     *\n     * <p><b>Warning:</b> If {@code to} represents an existing file, that file will be overwritten\n     * with the contents of {@code from}. If {@code to} and {@code from} refer to the <i>same</i>\n     * file, the contents of that file will be deleted.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#copy(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...)}.\n     *\n     * @param from the source file\n     * @param to the destination file\n     * @throws IOException if an I/O error occurs\n     * @throws IllegalArgumentException if {@code from.equals(to)}\n     */\n\n    /**\n     * Copies all characters from a file to an appendable object, using the given character set.\n     *\n     * @param from the source file\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @param to the appendable object\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(from, charset).copyTo(to)}. This method is scheduled to\n     *     be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static void copy(File from, Charset charset, Appendable to) throws IOException\n    {\n        asCharSource(from, charset).copyTo(to);\n    }\n\n    /**\n     * Appends a character sequence (such as a string) to a file using the given character set.\n     *\n     * @param from the character sequence to append\n     * @param to the destination file\n     * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSink(to, charset, FileWriteMode.APPEND).write(from)}. This\n     *     method is scheduled to be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static void append(CharSequence from, File to, Charset charset) throws IOException\n    {\n        asCharSink(to, charset, FileWriteMode.APPEND).write(from);\n    }\n\n    /**\n     * Returns true if the given files exist, are not directories, and contain the same bytes.\n     *\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static boolean equal(File file1, File file2) throws IOException\n    {\n        checkNotNull(file1);\n        checkNotNull(file2);\n        if (file1 == file2 || file1.equals(file2))\n        {\n            return true;\n        }\n\n        /*\n         * Some operating systems may return zero as the length for files denoting system-dependent\n         * entities such as devices or pipes, in which case we must fall back on comparing the bytes\n         * directly.\n         */\n        long len1 = file1.length();\n        long len2 = file2.length();\n        if (len1 != 0 && len2 != 0 && len1 != len2)\n        {\n            return false;\n        }\n        return asByteSource(file1).contentEquals(asByteSource(file2));\n    }\n\n    /**\n     * Atomically creates a new directory somewhere beneath the system's temporary directory (as\n     * defined by the {@code java.io.tmpdir} system property), and returns its name.\n     *\n     * <p>Use this method instead of {@link File#createTempFile(String, String)} when you wish to\n     * create a directory, not a regular file. A common pitfall is to call {@code createTempFile},\n     * delete the file and create a directory in its place, but this leads a race condition which can\n     * be exploited to create security vulnerabilities, especially when executable files are to be\n     * written into the directory.\n     *\n     * <p>This method assumes that the temporary volume is writable, has free inodes and free blocks,\n     * and that it will not be called thousands of times per second.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#createTempDirectory}.\n     *\n     * @return the newly-created directory\n     * @throws IllegalStateException if the directory could not be created\n     */\n    @Beta\n    public static File createTempDir()\n    {\n        File baseDir = new File(System.getProperty(\"java.io.tmpdir\"));\n        @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n        String baseName = System.currentTimeMillis() + \"-\";\n\n        for (int counter = 0; counter < TEMP_DIR_ATTEMPTS; counter++)\n        {\n            File tempDir = new File(baseDir, baseName + counter);\n            if (tempDir.mkdir())\n            {\n                return tempDir;\n            }\n        }\n        throw new IllegalStateException(\n            \"Failed to create directory within \"\n            + TEMP_DIR_ATTEMPTS\n            + \" attempts (tried \"\n            + baseName\n            + \"0 to \"\n            + baseName\n            + (TEMP_DIR_ATTEMPTS - 1)\n            + ')');\n    }\n\n    /**\n     * Creates an empty file or updates the last updated timestamp on the same as the unix command of\n     * the same name.\n     *\n     * @param file the file to create or update\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n    public static void touch(File file) throws IOException\n    {\n        checkNotNull(file);\n        if (!file.createNewFile() && !file.setLastModified(System.currentTimeMillis()))\n        {\n            throw new IOException(\"Unable to update modification time of \" + file);\n        }\n    }\n\n    /**\n     * Creates any necessary but nonexistent parent directories of the specified file. Note that if\n     * this operation fails it may have succeeded in creating some (but not all) of the necessary\n     * parent directories.\n     *\n     * @throws IOException if an I/O error occurs, or if any necessary but nonexistent parent\n     *     directories of the specified file could not be created.\n     * @since 4.0\n     */\n    @Beta\n    public static void createParentDirs(File file) throws IOException\n    {\n        checkNotNull(file);\n        File parent = file.getCanonicalFile().getParentFile();\n        if (parent == null)\n        {\n            /*\n             * The given directory is a filesystem root. All zero of its ancestors exist. This doesn't\n             * mean that the root itself exists -- consider x:\\ on a Windows machine without such a drive\n             * -- or even that the caller can create it, but this method makes no such guarantees even for\n             * non-root files.\n             */\n            return;\n        }\n        parent.mkdirs();\n        if (!parent.isDirectory())\n        {\n            throw new IOException(\"Unable to create parent directories of \" + file);\n        }\n    }\n\n    /**\n     * Moves a file from one path to another. This method can rename a file and/or move it to a\n     * different directory. In either case {@code to} must be the target path for the file itself; not\n     * just the new name for the file or the path to the new parent directory.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#move}.\n     *\n     * @param from the source file\n     * @param to the destination file\n     * @throws IOException if an I/O error occurs\n     * @throws IllegalArgumentException if {@code from.equals(to)}\n     */\n    @Beta\n    public static void move(File from, File to) throws IOException\n    {\n        checkNotNull(from);\n        checkNotNull(to);\n        checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n\n        if (!from.renameTo(to))\n        {\n            copy(from, to);\n            if (!from.delete())\n            {\n                if (!to.delete())\n                {\n                    throw new IOException(\"Unable to delete \" + to);\n                }\n                throw new IOException(\"Unable to delete \" + from);\n            }\n        }\n    }\n\n    /**\n     * Reads the first line from a file. The line does not include line-termination characters, but\n     * does include other leading and trailing whitespace.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return the first line, or null if the file is empty\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(file, charset).readFirstLine()}. This method is\n     *     scheduled to be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static String readFirstLine(File file, Charset charset) throws IOException\n    {\n        return asCharSource(file, charset).readFirstLine();\n    }\n\n    /**\n     * Reads all of the lines from a file. The lines do not include line-termination characters, but\n     * do include other leading and trailing whitespace.\n     *\n     * <p>This method returns a mutable {@code List}. For an {@code ImmutableList}, use {@code\n     * Files.asCharSource(file, charset).readLines()}.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#readAllLines(java.nio.file.Path, Charset)}.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return a mutable {@link List} containing all the lines\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static List<String> readLines(File file, Charset charset) throws IOException\n    {\n        // don't use asCharSource(file, charset).readLines() because that returns\n        // an immutable list, which would change the behavior of this method\n        return asCharSource(file, charset)\n               .readLines(\n                   new LineProcessor<List<String>>()\n        {\n            final List<String> result = Lists.newArrayList();\n\n            @Override\n            public boolean processLine(String line)\n            {\n                result.add(line);\n                return true;\n            }\n\n            @Override\n            public List<String> getResult()\n            {\n                return result;\n            }\n        });\n    }\n\n    /**\n     * Streams lines from a {@link File}, stopping when our callback returns false, or we have read\n     * all of the lines.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @param callback the {@link LineProcessor} to use to handle the lines\n     * @return the output of processing the lines\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(file, charset).readLines(callback)}. This method is\n     *     scheduled to be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    @CanIgnoreReturnValue // some processors won't return a useful result\n    public\n    static <T> T readLines(File file, Charset charset, LineProcessor<T> callback) throws IOException\n    {\n        return asCharSource(file, charset).readLines(callback);\n    }\n\n    /**\n     * Process the bytes of a file.\n     *\n     * <p>(If this seems too complicated, maybe you're looking for {@link #toByteArray}.)\n     *\n     * @param file the file to read\n     * @param processor the object to which the bytes of the file are passed.\n     * @return the result of the byte processor\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asByteSource(file).read(processor)}. This method is scheduled to be\n     *     removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    @CanIgnoreReturnValue // some processors won't return a useful result\n    public\n    static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException\n    {\n        return asByteSource(file).read(processor);\n    }\n\n    /**\n     * Computes the hash code of the {@code file} using {@code hashFunction}.\n     *\n     * @param file the file to read\n     * @param hashFunction the hash function to use to hash the data\n     * @return the {@link HashCode} of all of the bytes in the file\n     * @throws IOException if an I/O error occurs\n     * @since 12.0\n     * @deprecated Prefer {@code asByteSource(file).hash(hashFunction)}. This method is scheduled to\n     *     be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static HashCode hash(File file, HashFunction hashFunction) throws IOException\n    {\n        return asByteSource(file).hash(hashFunction);\n    }\n\n    /**\n     * Fully maps a file read-only in to memory as per {@link\n     * FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}.\n     *\n     * <p>Files are mapped from offset 0 to its length.\n     *\n     * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n     *\n     * @param file the file to map\n     * @return a read-only buffer reflecting {@code file}\n     * @throws FileNotFoundException if the {@code file} does not exist\n     * @throws IOException if an I/O error occurs\n     * @see FileChannel#map(MapMode, long, long)\n     * @since 2.0\n     */\n    @Beta\n    public static MappedByteBuffer map(File file) throws IOException\n    {\n        checkNotNull(file);\n        return map(file, MapMode.READ_ONLY);\n    }\n\n    /**\n     * Fully maps a file in to memory as per {@link\n     * FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)} using the requested {@link\n     * MapMode}.\n     *\n     * <p>Files are mapped from offset 0 to its length.\n     *\n     * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n     *\n     * @param file the file to map\n     * @param mode the mode to use when mapping {@code file}\n     * @return a buffer reflecting {@code file}\n     * @throws FileNotFoundException if the {@code file} does not exist\n     * @throws IOException if an I/O error occurs\n     * @see FileChannel#map(MapMode, long, long)\n     * @since 2.0\n     */\n    @Beta\n    public static MappedByteBuffer map(File file, MapMode mode) throws IOException\n    {\n        return mapInternal(file, mode, -1);\n    }\n\n    /**\n     * Maps a file in to memory as per {@link FileChannel#map(java.nio.channels.FileChannel.MapMode,\n     * long, long)} using the requested {@link MapMode}.\n     *\n     * <p>Files are mapped from offset 0 to {@code size}.\n     *\n     * <p>If the mode is {@link MapMode#READ_WRITE} and the file does not exist, it will be created\n     * with the requested {@code size}. Thus this method is useful for creating memory mapped files\n     * which do not yet exist.\n     *\n     * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n     *\n     * @param file the file to map\n     * @param mode the mode to use when mapping {@code file}\n     * @return a buffer reflecting {@code file}\n     * @throws IOException if an I/O error occurs\n     * @see FileChannel#map(MapMode, long, long)\n     * @since 2.0\n     */\n    @Beta\n    public static MappedByteBuffer map(File file, MapMode mode, long size) throws IOException\n    {\n        checkArgument(size >= 0, \"size (%s) may not be negative\", size);\n        return mapInternal(file, mode, size);\n    }\n\n    private static MappedByteBuffer mapInternal(File file, MapMode mode, long size)\n    throws IOException\n    {\n        checkNotNull(file);\n        checkNotNull(mode);\n\n        Closer closer = Closer.create();\n        try\n        {\n            RandomAccessFile raf =\n                closer.register(new RandomAccessFile(file, mode == MapMode.READ_ONLY ? \"r\" : \"rw\"));\n            FileChannel channel = closer.register(raf.getChannel());\n            return channel.map(mode, 0, size == -1 ? channel.size() : size);\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Returns the lexically cleaned form of the path name, <i>usually</i> (but not always) equivalent\n     * to the original. The following heuristics are used:\n     *\n     * <ul>\n     *   <li>empty string becomes .\n     *   <li>. stays as .\n     *   <li>fold out ./\n     *   <li>fold out ../ when possible\n     *   <li>collapse multiple slashes\n     *   <li>delete trailing slashes (unless the path is just \"/\")\n     * </ul>\n     *\n     * <p>These heuristics do not always match the behavior of the filesystem. In particular, consider\n     * the path {@code a/../b}, which {@code simplifyPath} will change to {@code b}. If {@code a} is a\n     * symlink to {@code x}, {@code a/../b} may refer to a sibling of {@code x}, rather than the\n     * sibling of {@code a} referred to by {@code b}.\n     *\n     * @since 11.0\n     */\n    @Beta\n    public static String simplifyPath(String pathname)\n    {\n        checkNotNull(pathname);\n        if (pathname.length() == 0)\n        {\n            return \".\";\n        }\n\n        // split the path apart\n        Iterable<String> components = Splitter.on('/').omitEmptyStrings().split(pathname);\n        List<String> path = new ArrayList<>();\n\n        // resolve ., .., and //\n        for (String component : components)\n        {\n            switch (component)\n            {\n            case \".\":\n                continue;\n            case \"..\":\n                if (path.size() > 0 && !path.get(path.size() - 1).equals(\"..\"))\n                {\n                    path.remove(path.size() - 1);\n                }\n                else\n                {\n                    path.add(\"..\");\n                }\n                break;\n            default:\n                path.add(component);\n                break;\n            }\n        }\n\n        // put it back together\n        String result = Joiner.on('/').join(path);\n        if (pathname.charAt(0) == '/')\n        {\n            result = \"/\" + result;\n        }\n\n        while (result.startsWith(\"/../\"))\n        {\n            result = result.substring(3);\n        }\n        if (result.equals(\"/..\"))\n        {\n            result = \"/\";\n        }\n        else if (\"\".equals(result))\n        {\n            result = \".\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the <a href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> for\n     * the given file name, or the empty string if the file has no extension. The result does not\n     * include the '{@code .}'.\n     *\n     * <p><b>Note:</b> This method simply returns everything after the last '{@code .}' in the file's\n     * name as determined by {@link File#getName}. It does not account for any filesystem-specific\n     * behavior that the {@link File} API does not already account for. For example, on NTFS it will\n     * report {@code \"txt\"} as the extension for the filename {@code \"foo.exe:.txt\"} even though NTFS\n     * will drop the {@code \":.txt\"} part of the name when the file is actually created on the\n     * filesystem due to NTFS's <a href=\"https://goo.gl/vTpJi4\">Alternate Data Streams</a>.\n     *\n     * @since 11.0\n     */\n    @Beta\n    public static String getFileExtension(String fullName)\n    {\n        checkNotNull(fullName);\n        String fileName = new File(fullName).getName();\n        int dotIndex = fileName.lastIndexOf('.');\n        return (dotIndex == -1) ? \"\" : fileName.substring(dotIndex + 1);\n    }\n\n    /**\n     * Returns the file name without its <a\n     * href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> or path. This is\n     * similar to the {@code basename} unix command. The result does not include the '{@code .}'.\n     *\n     * @param file The name of the file to trim the extension from. This can be either a fully\n     *     qualified file name (including a path) or just a file name.\n     * @return The file name without its path or extension.\n     * @since 14.0\n     */\n    @Beta\n    public static String getNameWithoutExtension(String file)\n    {\n        checkNotNull(file);\n        String fileName = new File(file).getName();\n        int dotIndex = fileName.lastIndexOf('.');\n        return (dotIndex == -1) ? fileName : fileName.substring(0, dotIndex);\n    }\n\n    /**\n     * Returns a {@link TreeTraverser} instance for {@link File} trees.\n     *\n     * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no\n     * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n     * this case, iterables created by this traverser could contain files that are outside of the\n     * given directory or even be infinite if there is a symbolic link loop.\n     *\n     * @since 15.0\n     * @deprecated The returned {@link TreeTraverser} type is deprecated. Use the replacement method\n     *     {@link #fileTraverser()} instead with the same semantics as this method.\n     */\n    @Deprecated\n    static TreeTraverser<File> fileTreeTraverser()\n    {\n        return FILE_TREE_TRAVERSER;\n    }\n\n    private static final TreeTraverser<File> FILE_TREE_TRAVERSER =\n        new TreeTraverser<File>()\n    {\n        @Override\n        public Iterable<File> children(File file)\n        {\n            return fileTreeChildren(file);\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"Files.fileTreeTraverser()\";\n        }\n    };\n\n    /**\n     * Returns a {@link Traverser} instance for the file and directory tree. The returned traverser\n     * starts from a {@link File} and will return all files and directories it encounters.\n     *\n     * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no\n     * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n     * this case, iterables created by this traverser could contain files that are outside of the\n     * given directory or even be infinite if there is a symbolic link loop.\n     *\n     * <p>If available, consider using {@link MoreFiles#fileTraverser()} instead. It behaves the same\n     * except that it doesn't follow symbolic links and returns {@code Path} instances.\n     *\n     * <p>If the {@link File} passed to one of the {@link Traverser} methods does not exist or is not\n     * a directory, no exception will be thrown and the returned {@link Iterable} will contain a\n     * single element: that file.\n     *\n     * <p>Example: {@code Files.fileTraverser().depthFirstPreOrder(new File(\"/\"))} may return files\n     * with the following paths: {@code [\"/\", \"/etc\", \"/etc/config.txt\", \"/etc/fonts\", \"/home\",\n     * \"/home/alice\", ...]}\n     *\n     * @since 23.5\n     */\n    @Beta\n    public static Traverser<File> fileTraverser()\n    {\n        return Traverser.forTree(FILE_TREE);\n    }\n\n    private static final SuccessorsFunction<File> FILE_TREE =\n        new SuccessorsFunction<File>()\n    {\n        @Override\n        public Iterable<File> successors(File file)\n        {\n            return fileTreeChildren(file);\n        }\n    };\n\n    private static Iterable<File> fileTreeChildren(File file)\n    {\n        // check isDirectory() just because it may be faster than listFiles() on a non-directory\n        if (file.isDirectory())\n        {\n            File[] files = file.listFiles();\n            if (files != null)\n            {\n                return Collections.unmodifiableList(Arrays.asList(files));\n            }\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * Returns a predicate that returns the result of {@link File#isDirectory} on input files.\n     *\n     * @since 15.0\n     */\n    @Beta\n    public static Predicate<File> isDirectory()\n    {\n        return FilePredicate.IS_DIRECTORY;\n    }\n\n    /**\n     * Returns a predicate that returns the result of {@link File#isFile} on input files.\n     *\n     * @since 15.0\n     */\n    @Beta\n    public static Predicate<File> isFile()\n    {\n        return FilePredicate.IS_FILE;\n    }\n\n    private enum FilePredicate implements Predicate<File>\n    {\n        IS_DIRECTORY {\n            @Override\n            public boolean apply(File file)\n            {\n                return file.isDirectory();\n            }\n\n            @Override\n            public String toString()\n            {\n                return \"Files.isDirectory()\";\n            }\n        },\n\n        IS_FILE {\n            @Override\n            public boolean apply(File file)\n            {\n                return file.isFile();\n            }\n\n            @Override\n            public String toString()\n            {\n                return \"Files.isFile()\";\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/io/Files.java", "func_name": "Files.touch", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Creates an empty file or updates the last updated timestamp on the same as the unix command of\nthe same name.\n\n@param file the file to create or update\n@throws IOException if an I/O error occurs", "docstring_tokens": ["Creates", "an", "empty", "file", "or", "updates", "the", "last", "updated", "timestamp", "on", "the", "same", "as", "the", "unix", "command", "of", "the", "same", "name", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/io/Files.java#L440-L447", "partition": "valid", "up_fun_num": 17, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.io.FileWriteMode.APPEND;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.Joiner;", "import com.google.common.base.Optional;", "import com.google.common.base.Predicate;", "import com.google.common.base.Splitter;", "import com.google.common.collect.ImmutableSet;", "import com.google.common.collect.Lists;", "import com.google.common.collect.TreeTraverser;", "import com.google.common.graph.SuccessorsFunction;", "import com.google.common.graph.Traverser;", "import com.google.common.hash.HashCode;", "import com.google.common.hash.HashFunction;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.io.BufferedReader;", "import java.io.BufferedWriter;", "import java.io.File;", "import java.io.FileInputStream;", "import java.io.FileNotFoundException;", "import java.io.FileOutputStream;", "import java.io.IOException;", "import java.io.InputStreamReader;", "import java.io.OutputStream;", "import java.io.OutputStreamWriter;", "import java.io.RandomAccessFile;", "import java.nio.MappedByteBuffer;", "import java.nio.channels.FileChannel;", "import java.nio.channels.FileChannel.MapMode;", "import java.nio.charset.Charset;", "import java.nio.charset.StandardCharsets;", "import java.util.ArrayList;", "import java.util.Arrays;", "import java.util.Collections;", "import java.util.List;"], "function": ["public final class Files\n", "    public static BufferedReader newReader(File file, Charset charset) throws FileNotFoundException\n", "    public static BufferedWriter newWriter(File file, Charset charset) throws FileNotFoundException\n", "    public static ByteSource asByteSource(File file)\n", "    public static ByteSink asByteSink(File file, FileWriteMode... modes)\n", "    public static CharSource asCharSource(File file, Charset charset)\n", "    public static CharSink asCharSink(File file, Charset charset, FileWriteMode... modes)\n", "    public static byte[] toByteArray(File file) throws IOException\n", "    public static String toString(File file, Charset charset) throws IOException\n", "    public static void write(byte[] from, File to) throws IOException\n", "    public static void write(CharSequence from, File to, Charset charset) throws IOException\n", "    public static void copy(File from, OutputStream to) throws IOException\n", "    public static void copy(File from, File to) throws IOException\n", "    static void copy(File from, Charset charset, Appendable to) throws IOException\n", "    static void append(CharSequence from, File to, Charset charset) throws IOException\n", "    public static boolean equal(File file1, File file2) throws IOException\n", "    public static File createTempDir()\n", "    public static void createParentDirs(File file) throws IOException\n", "    public static void move(File from, File to) throws IOException\n", "    static String readFirstLine(File file, Charset charset) throws IOException\n", "    public static List<String> readLines(File file, Charset charset) throws IOException\n", "    static <T> T readLines(File file, Charset charset, LineProcessor<T> callback) throws IOException\n", "    static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException\n", "    static HashCode hash(File file, HashFunction hashFunction) throws IOException\n", "    public static MappedByteBuffer map(File file) throws IOException\n", "    public static MappedByteBuffer map(File file, MapMode mode) throws IOException\n", "    public static MappedByteBuffer map(File file, MapMode mode, long size) throws IOException\n", "    private static MappedByteBuffer mapInternal(File file, MapMode mode, long size)\n", "    public static String simplifyPath(String pathname)\n", "    public static String getFileExtension(String fullName)\n", "    public static String getNameWithoutExtension(String file)\n", "    static TreeTraverser<File> fileTreeTraverser()\n", "    public static Traverser<File> fileTraverser()\n", "    private static Iterable<File> fileTreeChildren(File file)\n", "    public static Predicate<File> isDirectory()\n", "    public static Predicate<File> isFile()\n"], "context": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.io.FileWriteMode.APPEND;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.TreeTraverser;\nimport com.google.common.graph.SuccessorsFunction;\nimport com.google.common.graph.Traverser;\nimport com.google.common.hash.HashCode;\nimport com.google.common.hash.HashFunction;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Provides utility methods for working with {@linkplain File files}.\n *\n * <p>{@link java.nio.file.Path} users will find similar utilities in {@link MoreFiles} and the\n * JDK's {@link java.nio.file.Files} class.\n *\n * @author Chris Nokleberg\n * @author Colin Decker\n * @since 1.0\n */\n@GwtIncompatible\npublic final class Files\n{\n\n    /** Maximum loop count when creating temp directories. */\n    private static final int TEMP_DIR_ATTEMPTS = 10000;\n\n    private Files() {}\n\n    /**\n     * Returns a buffered reader that reads from a file using the given character set.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#newBufferedReader(java.nio.file.Path, Charset)}.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return the buffered reader\n     */\n    @Beta\n    public static BufferedReader newReader(File file, Charset charset) throws FileNotFoundException\n    {\n        checkNotNull(file);\n        checkNotNull(charset);\n        return new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));\n    }\n\n    /**\n     * Returns a buffered writer that writes to a file using the given character set.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#newBufferedWriter(java.nio.file.Path, Charset,\n     * java.nio.file.OpenOption...)}.\n     *\n     * @param file the file to write to\n     * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return the buffered writer\n     */\n    @Beta\n    public static BufferedWriter newWriter(File file, Charset charset) throws FileNotFoundException\n    {\n        checkNotNull(file);\n        checkNotNull(charset);\n        return new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset));\n    }\n\n    /**\n     * Returns a new {@link ByteSource} for reading bytes from the given file.\n     *\n     * @since 14.0\n     */\n    public static ByteSource asByteSource(File file)\n    {\n        return new FileByteSource(file);\n    }\n\n    private static final class FileByteSource extends ByteSource\n    {\n\n        private final File file;\n\n        private FileByteSource(File file)\n        {\n            this.file = checkNotNull(file);\n        }\n\n        @Override\n        public FileInputStream openStream() throws IOException\n        {\n            return new FileInputStream(file);\n        }\n\n        @Override\n        public Optional<Long> sizeIfKnown()\n        {\n            if (file.isFile())\n            {\n                return Optional.of(file.length());\n            }\n            else\n            {\n                return Optional.absent();\n            }\n        }\n\n        @Override\n        public long size() throws IOException\n        {\n            if (!file.isFile())\n            {\n                throw new FileNotFoundException(file.toString());\n            }\n            return file.length();\n        }\n\n        @Override\n        public byte[] read() throws IOException\n        {\n            Closer closer = Closer.create();\n            try\n            {\n                FileInputStream in = closer.register(openStream());\n                return ByteStreams.toByteArray(in, in.getChannel().size());\n            }\n            catch (Throwable e)\n            {\n                throw closer.rethrow(e);\n            }\n            finally\n            {\n                closer.close();\n            }\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"Files.asByteSource(\" + file + \")\";\n        }\n    }\n\n    /**\n     * Returns a new {@link ByteSink} for writing bytes to the given file. The given {@code modes}\n     * control how the file is opened for writing. When no mode is provided, the file will be\n     * truncated before writing. When the {@link FileWriteMode#APPEND APPEND} mode is provided, writes\n     * will append to the end of the file without truncating it.\n     *\n     * @since 14.0\n     */\n    public static ByteSink asByteSink(File file, FileWriteMode... modes)\n    {\n        return new FileByteSink(file, modes);\n    }\n\n    private static final class FileByteSink extends ByteSink\n    {\n\n        private final File file;\n        private final ImmutableSet<FileWriteMode> modes;\n\n        private FileByteSink(File file, FileWriteMode... modes)\n        {\n            this.file = checkNotNull(file);\n            this.modes = ImmutableSet.copyOf(modes);\n        }\n\n        @Override\n        public FileOutputStream openStream() throws IOException\n        {\n            return new FileOutputStream(file, modes.contains(APPEND));\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"Files.asByteSink(\" + file + \", \" + modes + \")\";\n        }\n    }\n\n    /**\n     * Returns a new {@link CharSource} for reading character data from the given file using the given\n     * character set.\n     *\n     * @since 14.0\n     */\n    public static CharSource asCharSource(File file, Charset charset)\n    {\n        return asByteSource(file).asCharSource(charset);\n    }\n\n    /**\n     * Returns a new {@link CharSink} for writing character data to the given file using the given\n     * character set. The given {@code modes} control how the file is opened for writing. When no mode\n     * is provided, the file will be truncated before writing. When the {@link FileWriteMode#APPEND\n     * APPEND} mode is provided, writes will append to the end of the file without truncating it.\n     *\n     * @since 14.0\n     */\n    public static CharSink asCharSink(File file, Charset charset, FileWriteMode... modes)\n    {\n        return asByteSink(file, modes).asCharSink(charset);\n    }\n\n    /**\n     * Reads all bytes from a file into a byte array.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#readAllBytes}.\n     *\n     * @param file the file to read from\n     * @return a byte array containing all the bytes from file\n     * @throws IllegalArgumentException if the file is bigger than the largest possible byte array\n     *     (2^31 - 1)\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static byte[] toByteArray(File file) throws IOException\n    {\n        return asByteSource(file).read();\n    }\n\n    /**\n     * Reads all characters from a file into a {@link String}, using the given character set.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return a string containing all the characters from the file\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(file, charset).read()}. This method is scheduled to be\n     *     removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public static String toString(File file, Charset charset) throws IOException\n    {\n        return asCharSource(file, charset).read();\n    }\n\n    /**\n     * Overwrites a file with the contents of a byte array.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#write(java.nio.file.Path, byte[], java.nio.file.OpenOption...)}.\n     *\n     * @param from the bytes to write\n     * @param to the destination file\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static void write(byte[] from, File to) throws IOException\n    {\n        asByteSink(to).write(from);\n    }\n\n    /**\n     * Writes a character sequence (such as a string) to a file using the given character set.\n     *\n     * @param from the character sequence to write\n     * @param to the destination file\n     * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSink(to, charset).write(from)}. This method is scheduled to be\n     *     removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public static void write(CharSequence from, File to, Charset charset) throws IOException\n    {\n        asCharSink(to, charset).write(from);\n    }\n\n    /**\n     * Copies all bytes from a file to an output stream.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#copy(java.nio.file.Path, OutputStream)}.\n     *\n     * @param from the source file\n     * @param to the output stream\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static void copy(File from, OutputStream to) throws IOException\n    {\n        asByteSource(from).copyTo(to);\n    }\n\n    /**\n     * Copies all the bytes from one file to another.\n     *\n     * <p>Copying is not an atomic operation - in the case of an I/O error, power loss, process\n     * termination, or other problems, {@code to} may not be a complete copy of {@code from}. If you\n     * need to guard against those conditions, you should employ other file-level synchronization.\n     *\n     * <p><b>Warning:</b> If {@code to} represents an existing file, that file will be overwritten\n     * with the contents of {@code from}. If {@code to} and {@code from} refer to the <i>same</i>\n     * file, the contents of that file will be deleted.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#copy(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...)}.\n     *\n     * @param from the source file\n     * @param to the destination file\n     * @throws IOException if an I/O error occurs\n     * @throws IllegalArgumentException if {@code from.equals(to)}\n     */\n    @Beta\n    public static void copy(File from, File to) throws IOException\n    {\n        checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n        asByteSource(from).copyTo(asByteSink(to));\n    }\n\n    /**\n     * Copies all characters from a file to an appendable object, using the given character set.\n     *\n     * @param from the source file\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @param to the appendable object\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(from, charset).copyTo(to)}. This method is scheduled to\n     *     be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static void copy(File from, Charset charset, Appendable to) throws IOException\n    {\n        asCharSource(from, charset).copyTo(to);\n    }\n\n    /**\n     * Appends a character sequence (such as a string) to a file using the given character set.\n     *\n     * @param from the character sequence to append\n     * @param to the destination file\n     * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSink(to, charset, FileWriteMode.APPEND).write(from)}. This\n     *     method is scheduled to be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static void append(CharSequence from, File to, Charset charset) throws IOException\n    {\n        asCharSink(to, charset, FileWriteMode.APPEND).write(from);\n    }\n\n    /**\n     * Returns true if the given files exist, are not directories, and contain the same bytes.\n     *\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static boolean equal(File file1, File file2) throws IOException\n    {\n        checkNotNull(file1);\n        checkNotNull(file2);\n        if (file1 == file2 || file1.equals(file2))\n        {\n            return true;\n        }\n\n        /*\n         * Some operating systems may return zero as the length for files denoting system-dependent\n         * entities such as devices or pipes, in which case we must fall back on comparing the bytes\n         * directly.\n         */\n        long len1 = file1.length();\n        long len2 = file2.length();\n        if (len1 != 0 && len2 != 0 && len1 != len2)\n        {\n            return false;\n        }\n        return asByteSource(file1).contentEquals(asByteSource(file2));\n    }\n\n    /**\n     * Atomically creates a new directory somewhere beneath the system's temporary directory (as\n     * defined by the {@code java.io.tmpdir} system property), and returns its name.\n     *\n     * <p>Use this method instead of {@link File#createTempFile(String, String)} when you wish to\n     * create a directory, not a regular file. A common pitfall is to call {@code createTempFile},\n     * delete the file and create a directory in its place, but this leads a race condition which can\n     * be exploited to create security vulnerabilities, especially when executable files are to be\n     * written into the directory.\n     *\n     * <p>This method assumes that the temporary volume is writable, has free inodes and free blocks,\n     * and that it will not be called thousands of times per second.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#createTempDirectory}.\n     *\n     * @return the newly-created directory\n     * @throws IllegalStateException if the directory could not be created\n     */\n    @Beta\n    public static File createTempDir()\n    {\n        File baseDir = new File(System.getProperty(\"java.io.tmpdir\"));\n        @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n        String baseName = System.currentTimeMillis() + \"-\";\n\n        for (int counter = 0; counter < TEMP_DIR_ATTEMPTS; counter++)\n        {\n            File tempDir = new File(baseDir, baseName + counter);\n            if (tempDir.mkdir())\n            {\n                return tempDir;\n            }\n        }\n        throw new IllegalStateException(\n            \"Failed to create directory within \"\n            + TEMP_DIR_ATTEMPTS\n            + \" attempts (tried \"\n            + baseName\n            + \"0 to \"\n            + baseName\n            + (TEMP_DIR_ATTEMPTS - 1)\n            + ')');\n    }\n\n    /**\n     * Creates an empty file or updates the last updated timestamp on the same as the unix command of\n     * the same name.\n     *\n     * @param file the file to create or update\n     * @throws IOException if an I/O error occurs\n     */\n\n    /**\n     * Creates any necessary but nonexistent parent directories of the specified file. Note that if\n     * this operation fails it may have succeeded in creating some (but not all) of the necessary\n     * parent directories.\n     *\n     * @throws IOException if an I/O error occurs, or if any necessary but nonexistent parent\n     *     directories of the specified file could not be created.\n     * @since 4.0\n     */\n    @Beta\n    public static void createParentDirs(File file) throws IOException\n    {\n        checkNotNull(file);\n        File parent = file.getCanonicalFile().getParentFile();\n        if (parent == null)\n        {\n            /*\n             * The given directory is a filesystem root. All zero of its ancestors exist. This doesn't\n             * mean that the root itself exists -- consider x:\\ on a Windows machine without such a drive\n             * -- or even that the caller can create it, but this method makes no such guarantees even for\n             * non-root files.\n             */\n            return;\n        }\n        parent.mkdirs();\n        if (!parent.isDirectory())\n        {\n            throw new IOException(\"Unable to create parent directories of \" + file);\n        }\n    }\n\n    /**\n     * Moves a file from one path to another. This method can rename a file and/or move it to a\n     * different directory. In either case {@code to} must be the target path for the file itself; not\n     * just the new name for the file or the path to the new parent directory.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#move}.\n     *\n     * @param from the source file\n     * @param to the destination file\n     * @throws IOException if an I/O error occurs\n     * @throws IllegalArgumentException if {@code from.equals(to)}\n     */\n    @Beta\n    public static void move(File from, File to) throws IOException\n    {\n        checkNotNull(from);\n        checkNotNull(to);\n        checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n\n        if (!from.renameTo(to))\n        {\n            copy(from, to);\n            if (!from.delete())\n            {\n                if (!to.delete())\n                {\n                    throw new IOException(\"Unable to delete \" + to);\n                }\n                throw new IOException(\"Unable to delete \" + from);\n            }\n        }\n    }\n\n    /**\n     * Reads the first line from a file. The line does not include line-termination characters, but\n     * does include other leading and trailing whitespace.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return the first line, or null if the file is empty\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(file, charset).readFirstLine()}. This method is\n     *     scheduled to be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static String readFirstLine(File file, Charset charset) throws IOException\n    {\n        return asCharSource(file, charset).readFirstLine();\n    }\n\n    /**\n     * Reads all of the lines from a file. The lines do not include line-termination characters, but\n     * do include other leading and trailing whitespace.\n     *\n     * <p>This method returns a mutable {@code List}. For an {@code ImmutableList}, use {@code\n     * Files.asCharSource(file, charset).readLines()}.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#readAllLines(java.nio.file.Path, Charset)}.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return a mutable {@link List} containing all the lines\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static List<String> readLines(File file, Charset charset) throws IOException\n    {\n        // don't use asCharSource(file, charset).readLines() because that returns\n        // an immutable list, which would change the behavior of this method\n        return asCharSource(file, charset)\n               .readLines(\n                   new LineProcessor<List<String>>()\n        {\n            final List<String> result = Lists.newArrayList();\n\n            @Override\n            public boolean processLine(String line)\n            {\n                result.add(line);\n                return true;\n            }\n\n            @Override\n            public List<String> getResult()\n            {\n                return result;\n            }\n        });\n    }\n\n    /**\n     * Streams lines from a {@link File}, stopping when our callback returns false, or we have read\n     * all of the lines.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @param callback the {@link LineProcessor} to use to handle the lines\n     * @return the output of processing the lines\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(file, charset).readLines(callback)}. This method is\n     *     scheduled to be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    @CanIgnoreReturnValue // some processors won't return a useful result\n    public\n    static <T> T readLines(File file, Charset charset, LineProcessor<T> callback) throws IOException\n    {\n        return asCharSource(file, charset).readLines(callback);\n    }\n\n    /**\n     * Process the bytes of a file.\n     *\n     * <p>(If this seems too complicated, maybe you're looking for {@link #toByteArray}.)\n     *\n     * @param file the file to read\n     * @param processor the object to which the bytes of the file are passed.\n     * @return the result of the byte processor\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asByteSource(file).read(processor)}. This method is scheduled to be\n     *     removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    @CanIgnoreReturnValue // some processors won't return a useful result\n    public\n    static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException\n    {\n        return asByteSource(file).read(processor);\n    }\n\n    /**\n     * Computes the hash code of the {@code file} using {@code hashFunction}.\n     *\n     * @param file the file to read\n     * @param hashFunction the hash function to use to hash the data\n     * @return the {@link HashCode} of all of the bytes in the file\n     * @throws IOException if an I/O error occurs\n     * @since 12.0\n     * @deprecated Prefer {@code asByteSource(file).hash(hashFunction)}. This method is scheduled to\n     *     be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static HashCode hash(File file, HashFunction hashFunction) throws IOException\n    {\n        return asByteSource(file).hash(hashFunction);\n    }\n\n    /**\n     * Fully maps a file read-only in to memory as per {@link\n     * FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}.\n     *\n     * <p>Files are mapped from offset 0 to its length.\n     *\n     * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n     *\n     * @param file the file to map\n     * @return a read-only buffer reflecting {@code file}\n     * @throws FileNotFoundException if the {@code file} does not exist\n     * @throws IOException if an I/O error occurs\n     * @see FileChannel#map(MapMode, long, long)\n     * @since 2.0\n     */\n    @Beta\n    public static MappedByteBuffer map(File file) throws IOException\n    {\n        checkNotNull(file);\n        return map(file, MapMode.READ_ONLY);\n    }\n\n    /**\n     * Fully maps a file in to memory as per {@link\n     * FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)} using the requested {@link\n     * MapMode}.\n     *\n     * <p>Files are mapped from offset 0 to its length.\n     *\n     * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n     *\n     * @param file the file to map\n     * @param mode the mode to use when mapping {@code file}\n     * @return a buffer reflecting {@code file}\n     * @throws FileNotFoundException if the {@code file} does not exist\n     * @throws IOException if an I/O error occurs\n     * @see FileChannel#map(MapMode, long, long)\n     * @since 2.0\n     */\n    @Beta\n    public static MappedByteBuffer map(File file, MapMode mode) throws IOException\n    {\n        return mapInternal(file, mode, -1);\n    }\n\n    /**\n     * Maps a file in to memory as per {@link FileChannel#map(java.nio.channels.FileChannel.MapMode,\n     * long, long)} using the requested {@link MapMode}.\n     *\n     * <p>Files are mapped from offset 0 to {@code size}.\n     *\n     * <p>If the mode is {@link MapMode#READ_WRITE} and the file does not exist, it will be created\n     * with the requested {@code size}. Thus this method is useful for creating memory mapped files\n     * which do not yet exist.\n     *\n     * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n     *\n     * @param file the file to map\n     * @param mode the mode to use when mapping {@code file}\n     * @return a buffer reflecting {@code file}\n     * @throws IOException if an I/O error occurs\n     * @see FileChannel#map(MapMode, long, long)\n     * @since 2.0\n     */\n    @Beta\n    public static MappedByteBuffer map(File file, MapMode mode, long size) throws IOException\n    {\n        checkArgument(size >= 0, \"size (%s) may not be negative\", size);\n        return mapInternal(file, mode, size);\n    }\n\n    private static MappedByteBuffer mapInternal(File file, MapMode mode, long size)\n    throws IOException\n    {\n        checkNotNull(file);\n        checkNotNull(mode);\n\n        Closer closer = Closer.create();\n        try\n        {\n            RandomAccessFile raf =\n                closer.register(new RandomAccessFile(file, mode == MapMode.READ_ONLY ? \"r\" : \"rw\"));\n            FileChannel channel = closer.register(raf.getChannel());\n            return channel.map(mode, 0, size == -1 ? channel.size() : size);\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Returns the lexically cleaned form of the path name, <i>usually</i> (but not always) equivalent\n     * to the original. The following heuristics are used:\n     *\n     * <ul>\n     *   <li>empty string becomes .\n     *   <li>. stays as .\n     *   <li>fold out ./\n     *   <li>fold out ../ when possible\n     *   <li>collapse multiple slashes\n     *   <li>delete trailing slashes (unless the path is just \"/\")\n     * </ul>\n     *\n     * <p>These heuristics do not always match the behavior of the filesystem. In particular, consider\n     * the path {@code a/../b}, which {@code simplifyPath} will change to {@code b}. If {@code a} is a\n     * symlink to {@code x}, {@code a/../b} may refer to a sibling of {@code x}, rather than the\n     * sibling of {@code a} referred to by {@code b}.\n     *\n     * @since 11.0\n     */\n    @Beta\n    public static String simplifyPath(String pathname)\n    {\n        checkNotNull(pathname);\n        if (pathname.length() == 0)\n        {\n            return \".\";\n        }\n\n        // split the path apart\n        Iterable<String> components = Splitter.on('/').omitEmptyStrings().split(pathname);\n        List<String> path = new ArrayList<>();\n\n        // resolve ., .., and //\n        for (String component : components)\n        {\n            switch (component)\n            {\n            case \".\":\n                continue;\n            case \"..\":\n                if (path.size() > 0 && !path.get(path.size() - 1).equals(\"..\"))\n                {\n                    path.remove(path.size() - 1);\n                }\n                else\n                {\n                    path.add(\"..\");\n                }\n                break;\n            default:\n                path.add(component);\n                break;\n            }\n        }\n\n        // put it back together\n        String result = Joiner.on('/').join(path);\n        if (pathname.charAt(0) == '/')\n        {\n            result = \"/\" + result;\n        }\n\n        while (result.startsWith(\"/../\"))\n        {\n            result = result.substring(3);\n        }\n        if (result.equals(\"/..\"))\n        {\n            result = \"/\";\n        }\n        else if (\"\".equals(result))\n        {\n            result = \".\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the <a href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> for\n     * the given file name, or the empty string if the file has no extension. The result does not\n     * include the '{@code .}'.\n     *\n     * <p><b>Note:</b> This method simply returns everything after the last '{@code .}' in the file's\n     * name as determined by {@link File#getName}. It does not account for any filesystem-specific\n     * behavior that the {@link File} API does not already account for. For example, on NTFS it will\n     * report {@code \"txt\"} as the extension for the filename {@code \"foo.exe:.txt\"} even though NTFS\n     * will drop the {@code \":.txt\"} part of the name when the file is actually created on the\n     * filesystem due to NTFS's <a href=\"https://goo.gl/vTpJi4\">Alternate Data Streams</a>.\n     *\n     * @since 11.0\n     */\n    @Beta\n    public static String getFileExtension(String fullName)\n    {\n        checkNotNull(fullName);\n        String fileName = new File(fullName).getName();\n        int dotIndex = fileName.lastIndexOf('.');\n        return (dotIndex == -1) ? \"\" : fileName.substring(dotIndex + 1);\n    }\n\n    /**\n     * Returns the file name without its <a\n     * href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> or path. This is\n     * similar to the {@code basename} unix command. The result does not include the '{@code .}'.\n     *\n     * @param file The name of the file to trim the extension from. This can be either a fully\n     *     qualified file name (including a path) or just a file name.\n     * @return The file name without its path or extension.\n     * @since 14.0\n     */\n    @Beta\n    public static String getNameWithoutExtension(String file)\n    {\n        checkNotNull(file);\n        String fileName = new File(file).getName();\n        int dotIndex = fileName.lastIndexOf('.');\n        return (dotIndex == -1) ? fileName : fileName.substring(0, dotIndex);\n    }\n\n    /**\n     * Returns a {@link TreeTraverser} instance for {@link File} trees.\n     *\n     * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no\n     * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n     * this case, iterables created by this traverser could contain files that are outside of the\n     * given directory or even be infinite if there is a symbolic link loop.\n     *\n     * @since 15.0\n     * @deprecated The returned {@link TreeTraverser} type is deprecated. Use the replacement method\n     *     {@link #fileTraverser()} instead with the same semantics as this method.\n     */\n    @Deprecated\n    static TreeTraverser<File> fileTreeTraverser()\n    {\n        return FILE_TREE_TRAVERSER;\n    }\n\n    private static final TreeTraverser<File> FILE_TREE_TRAVERSER =\n        new TreeTraverser<File>()\n    {\n        @Override\n        public Iterable<File> children(File file)\n        {\n            return fileTreeChildren(file);\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"Files.fileTreeTraverser()\";\n        }\n    };\n\n    /**\n     * Returns a {@link Traverser} instance for the file and directory tree. The returned traverser\n     * starts from a {@link File} and will return all files and directories it encounters.\n     *\n     * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no\n     * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n     * this case, iterables created by this traverser could contain files that are outside of the\n     * given directory or even be infinite if there is a symbolic link loop.\n     *\n     * <p>If available, consider using {@link MoreFiles#fileTraverser()} instead. It behaves the same\n     * except that it doesn't follow symbolic links and returns {@code Path} instances.\n     *\n     * <p>If the {@link File} passed to one of the {@link Traverser} methods does not exist or is not\n     * a directory, no exception will be thrown and the returned {@link Iterable} will contain a\n     * single element: that file.\n     *\n     * <p>Example: {@code Files.fileTraverser().depthFirstPreOrder(new File(\"/\"))} may return files\n     * with the following paths: {@code [\"/\", \"/etc\", \"/etc/config.txt\", \"/etc/fonts\", \"/home\",\n     * \"/home/alice\", ...]}\n     *\n     * @since 23.5\n     */\n    @Beta\n    public static Traverser<File> fileTraverser()\n    {\n        return Traverser.forTree(FILE_TREE);\n    }\n\n    private static final SuccessorsFunction<File> FILE_TREE =\n        new SuccessorsFunction<File>()\n    {\n        @Override\n        public Iterable<File> successors(File file)\n        {\n            return fileTreeChildren(file);\n        }\n    };\n\n    private static Iterable<File> fileTreeChildren(File file)\n    {\n        // check isDirectory() just because it may be faster than listFiles() on a non-directory\n        if (file.isDirectory())\n        {\n            File[] files = file.listFiles();\n            if (files != null)\n            {\n                return Collections.unmodifiableList(Arrays.asList(files));\n            }\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * Returns a predicate that returns the result of {@link File#isDirectory} on input files.\n     *\n     * @since 15.0\n     */\n    @Beta\n    public static Predicate<File> isDirectory()\n    {\n        return FilePredicate.IS_DIRECTORY;\n    }\n\n    /**\n     * Returns a predicate that returns the result of {@link File#isFile} on input files.\n     *\n     * @since 15.0\n     */\n    @Beta\n    public static Predicate<File> isFile()\n    {\n        return FilePredicate.IS_FILE;\n    }\n\n    private enum FilePredicate implements Predicate<File>\n    {\n        IS_DIRECTORY {\n            @Override\n            public boolean apply(File file)\n            {\n                return file.isDirectory();\n            }\n\n            @Override\n            public String toString()\n            {\n                return \"Files.isDirectory()\";\n            }\n        },\n\n        IS_FILE {\n            @Override\n            public boolean apply(File file)\n            {\n                return file.isFile();\n            }\n\n            @Override\n            public String toString()\n            {\n                return \"Files.isFile()\";\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/io/Files.java", "func_name": "Files.readFirstLine", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Reads the first line from a file. The line does not include line-termination characters, but\ndoes include other leading and trailing whitespace.\n\n@param file the file to read from\n@param charset the charset used to decode the input stream; see {@link StandardCharsets} for\nhelpful predefined constants\n@return the first line, or null if the file is empty\n@throws IOException if an I/O error occurs\n@deprecated Prefer {@code asCharSource(file, charset).readFirstLine()}. This method is\nscheduled to be removed in January 2019.", "docstring_tokens": ["Reads", "the", "first", "line", "from", "a", "file", ".", "The", "line", "does", "not", "include", "line", "-", "termination", "characters", "but", "does", "include", "other", "leading", "and", "trailing", "whitespace", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/io/Files.java#L518-L523", "partition": "valid", "up_fun_num": 20, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.io.FileWriteMode.APPEND;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.Joiner;", "import com.google.common.base.Optional;", "import com.google.common.base.Predicate;", "import com.google.common.base.Splitter;", "import com.google.common.collect.ImmutableSet;", "import com.google.common.collect.Lists;", "import com.google.common.collect.TreeTraverser;", "import com.google.common.graph.SuccessorsFunction;", "import com.google.common.graph.Traverser;", "import com.google.common.hash.HashCode;", "import com.google.common.hash.HashFunction;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.io.BufferedReader;", "import java.io.BufferedWriter;", "import java.io.File;", "import java.io.FileInputStream;", "import java.io.FileNotFoundException;", "import java.io.FileOutputStream;", "import java.io.IOException;", "import java.io.InputStreamReader;", "import java.io.OutputStream;", "import java.io.OutputStreamWriter;", "import java.io.RandomAccessFile;", "import java.nio.MappedByteBuffer;", "import java.nio.channels.FileChannel;", "import java.nio.channels.FileChannel.MapMode;", "import java.nio.charset.Charset;", "import java.nio.charset.StandardCharsets;", "import java.util.ArrayList;", "import java.util.Arrays;", "import java.util.Collections;", "import java.util.List;"], "function": ["public final class Files\n", "    public static BufferedReader newReader(File file, Charset charset) throws FileNotFoundException\n", "    public static BufferedWriter newWriter(File file, Charset charset) throws FileNotFoundException\n", "    public static ByteSource asByteSource(File file)\n", "    public static ByteSink asByteSink(File file, FileWriteMode... modes)\n", "    public static CharSource asCharSource(File file, Charset charset)\n", "    public static CharSink asCharSink(File file, Charset charset, FileWriteMode... modes)\n", "    public static byte[] toByteArray(File file) throws IOException\n", "    public static String toString(File file, Charset charset) throws IOException\n", "    public static void write(byte[] from, File to) throws IOException\n", "    public static void write(CharSequence from, File to, Charset charset) throws IOException\n", "    public static void copy(File from, OutputStream to) throws IOException\n", "    public static void copy(File from, File to) throws IOException\n", "    static void copy(File from, Charset charset, Appendable to) throws IOException\n", "    static void append(CharSequence from, File to, Charset charset) throws IOException\n", "    public static boolean equal(File file1, File file2) throws IOException\n", "    public static File createTempDir()\n", "    public static void touch(File file) throws IOException\n", "    public static void createParentDirs(File file) throws IOException\n", "    public static void move(File from, File to) throws IOException\n", "    public static List<String> readLines(File file, Charset charset) throws IOException\n", "    static <T> T readLines(File file, Charset charset, LineProcessor<T> callback) throws IOException\n", "    static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException\n", "    static HashCode hash(File file, HashFunction hashFunction) throws IOException\n", "    public static MappedByteBuffer map(File file) throws IOException\n", "    public static MappedByteBuffer map(File file, MapMode mode) throws IOException\n", "    public static MappedByteBuffer map(File file, MapMode mode, long size) throws IOException\n", "    private static MappedByteBuffer mapInternal(File file, MapMode mode, long size)\n", "    public static String simplifyPath(String pathname)\n", "    public static String getFileExtension(String fullName)\n", "    public static String getNameWithoutExtension(String file)\n", "    static TreeTraverser<File> fileTreeTraverser()\n", "    public static Traverser<File> fileTraverser()\n", "    private static Iterable<File> fileTreeChildren(File file)\n", "    public static Predicate<File> isDirectory()\n", "    public static Predicate<File> isFile()\n"], "context": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.io.FileWriteMode.APPEND;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.TreeTraverser;\nimport com.google.common.graph.SuccessorsFunction;\nimport com.google.common.graph.Traverser;\nimport com.google.common.hash.HashCode;\nimport com.google.common.hash.HashFunction;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Provides utility methods for working with {@linkplain File files}.\n *\n * <p>{@link java.nio.file.Path} users will find similar utilities in {@link MoreFiles} and the\n * JDK's {@link java.nio.file.Files} class.\n *\n * @author Chris Nokleberg\n * @author Colin Decker\n * @since 1.0\n */\n@GwtIncompatible\npublic final class Files\n{\n\n    /** Maximum loop count when creating temp directories. */\n    private static final int TEMP_DIR_ATTEMPTS = 10000;\n\n    private Files() {}\n\n    /**\n     * Returns a buffered reader that reads from a file using the given character set.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#newBufferedReader(java.nio.file.Path, Charset)}.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return the buffered reader\n     */\n    @Beta\n    public static BufferedReader newReader(File file, Charset charset) throws FileNotFoundException\n    {\n        checkNotNull(file);\n        checkNotNull(charset);\n        return new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));\n    }\n\n    /**\n     * Returns a buffered writer that writes to a file using the given character set.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#newBufferedWriter(java.nio.file.Path, Charset,\n     * java.nio.file.OpenOption...)}.\n     *\n     * @param file the file to write to\n     * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return the buffered writer\n     */\n    @Beta\n    public static BufferedWriter newWriter(File file, Charset charset) throws FileNotFoundException\n    {\n        checkNotNull(file);\n        checkNotNull(charset);\n        return new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset));\n    }\n\n    /**\n     * Returns a new {@link ByteSource} for reading bytes from the given file.\n     *\n     * @since 14.0\n     */\n    public static ByteSource asByteSource(File file)\n    {\n        return new FileByteSource(file);\n    }\n\n    private static final class FileByteSource extends ByteSource\n    {\n\n        private final File file;\n\n        private FileByteSource(File file)\n        {\n            this.file = checkNotNull(file);\n        }\n\n        @Override\n        public FileInputStream openStream() throws IOException\n        {\n            return new FileInputStream(file);\n        }\n\n        @Override\n        public Optional<Long> sizeIfKnown()\n        {\n            if (file.isFile())\n            {\n                return Optional.of(file.length());\n            }\n            else\n            {\n                return Optional.absent();\n            }\n        }\n\n        @Override\n        public long size() throws IOException\n        {\n            if (!file.isFile())\n            {\n                throw new FileNotFoundException(file.toString());\n            }\n            return file.length();\n        }\n\n        @Override\n        public byte[] read() throws IOException\n        {\n            Closer closer = Closer.create();\n            try\n            {\n                FileInputStream in = closer.register(openStream());\n                return ByteStreams.toByteArray(in, in.getChannel().size());\n            }\n            catch (Throwable e)\n            {\n                throw closer.rethrow(e);\n            }\n            finally\n            {\n                closer.close();\n            }\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"Files.asByteSource(\" + file + \")\";\n        }\n    }\n\n    /**\n     * Returns a new {@link ByteSink} for writing bytes to the given file. The given {@code modes}\n     * control how the file is opened for writing. When no mode is provided, the file will be\n     * truncated before writing. When the {@link FileWriteMode#APPEND APPEND} mode is provided, writes\n     * will append to the end of the file without truncating it.\n     *\n     * @since 14.0\n     */\n    public static ByteSink asByteSink(File file, FileWriteMode... modes)\n    {\n        return new FileByteSink(file, modes);\n    }\n\n    private static final class FileByteSink extends ByteSink\n    {\n\n        private final File file;\n        private final ImmutableSet<FileWriteMode> modes;\n\n        private FileByteSink(File file, FileWriteMode... modes)\n        {\n            this.file = checkNotNull(file);\n            this.modes = ImmutableSet.copyOf(modes);\n        }\n\n        @Override\n        public FileOutputStream openStream() throws IOException\n        {\n            return new FileOutputStream(file, modes.contains(APPEND));\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"Files.asByteSink(\" + file + \", \" + modes + \")\";\n        }\n    }\n\n    /**\n     * Returns a new {@link CharSource} for reading character data from the given file using the given\n     * character set.\n     *\n     * @since 14.0\n     */\n    public static CharSource asCharSource(File file, Charset charset)\n    {\n        return asByteSource(file).asCharSource(charset);\n    }\n\n    /**\n     * Returns a new {@link CharSink} for writing character data to the given file using the given\n     * character set. The given {@code modes} control how the file is opened for writing. When no mode\n     * is provided, the file will be truncated before writing. When the {@link FileWriteMode#APPEND\n     * APPEND} mode is provided, writes will append to the end of the file without truncating it.\n     *\n     * @since 14.0\n     */\n    public static CharSink asCharSink(File file, Charset charset, FileWriteMode... modes)\n    {\n        return asByteSink(file, modes).asCharSink(charset);\n    }\n\n    /**\n     * Reads all bytes from a file into a byte array.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#readAllBytes}.\n     *\n     * @param file the file to read from\n     * @return a byte array containing all the bytes from file\n     * @throws IllegalArgumentException if the file is bigger than the largest possible byte array\n     *     (2^31 - 1)\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static byte[] toByteArray(File file) throws IOException\n    {\n        return asByteSource(file).read();\n    }\n\n    /**\n     * Reads all characters from a file into a {@link String}, using the given character set.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return a string containing all the characters from the file\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(file, charset).read()}. This method is scheduled to be\n     *     removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public static String toString(File file, Charset charset) throws IOException\n    {\n        return asCharSource(file, charset).read();\n    }\n\n    /**\n     * Overwrites a file with the contents of a byte array.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#write(java.nio.file.Path, byte[], java.nio.file.OpenOption...)}.\n     *\n     * @param from the bytes to write\n     * @param to the destination file\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static void write(byte[] from, File to) throws IOException\n    {\n        asByteSink(to).write(from);\n    }\n\n    /**\n     * Writes a character sequence (such as a string) to a file using the given character set.\n     *\n     * @param from the character sequence to write\n     * @param to the destination file\n     * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSink(to, charset).write(from)}. This method is scheduled to be\n     *     removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public static void write(CharSequence from, File to, Charset charset) throws IOException\n    {\n        asCharSink(to, charset).write(from);\n    }\n\n    /**\n     * Copies all bytes from a file to an output stream.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#copy(java.nio.file.Path, OutputStream)}.\n     *\n     * @param from the source file\n     * @param to the output stream\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static void copy(File from, OutputStream to) throws IOException\n    {\n        asByteSource(from).copyTo(to);\n    }\n\n    /**\n     * Copies all the bytes from one file to another.\n     *\n     * <p>Copying is not an atomic operation - in the case of an I/O error, power loss, process\n     * termination, or other problems, {@code to} may not be a complete copy of {@code from}. If you\n     * need to guard against those conditions, you should employ other file-level synchronization.\n     *\n     * <p><b>Warning:</b> If {@code to} represents an existing file, that file will be overwritten\n     * with the contents of {@code from}. If {@code to} and {@code from} refer to the <i>same</i>\n     * file, the contents of that file will be deleted.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#copy(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...)}.\n     *\n     * @param from the source file\n     * @param to the destination file\n     * @throws IOException if an I/O error occurs\n     * @throws IllegalArgumentException if {@code from.equals(to)}\n     */\n    @Beta\n    public static void copy(File from, File to) throws IOException\n    {\n        checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n        asByteSource(from).copyTo(asByteSink(to));\n    }\n\n    /**\n     * Copies all characters from a file to an appendable object, using the given character set.\n     *\n     * @param from the source file\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @param to the appendable object\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(from, charset).copyTo(to)}. This method is scheduled to\n     *     be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static void copy(File from, Charset charset, Appendable to) throws IOException\n    {\n        asCharSource(from, charset).copyTo(to);\n    }\n\n    /**\n     * Appends a character sequence (such as a string) to a file using the given character set.\n     *\n     * @param from the character sequence to append\n     * @param to the destination file\n     * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSink(to, charset, FileWriteMode.APPEND).write(from)}. This\n     *     method is scheduled to be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static void append(CharSequence from, File to, Charset charset) throws IOException\n    {\n        asCharSink(to, charset, FileWriteMode.APPEND).write(from);\n    }\n\n    /**\n     * Returns true if the given files exist, are not directories, and contain the same bytes.\n     *\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static boolean equal(File file1, File file2) throws IOException\n    {\n        checkNotNull(file1);\n        checkNotNull(file2);\n        if (file1 == file2 || file1.equals(file2))\n        {\n            return true;\n        }\n\n        /*\n         * Some operating systems may return zero as the length for files denoting system-dependent\n         * entities such as devices or pipes, in which case we must fall back on comparing the bytes\n         * directly.\n         */\n        long len1 = file1.length();\n        long len2 = file2.length();\n        if (len1 != 0 && len2 != 0 && len1 != len2)\n        {\n            return false;\n        }\n        return asByteSource(file1).contentEquals(asByteSource(file2));\n    }\n\n    /**\n     * Atomically creates a new directory somewhere beneath the system's temporary directory (as\n     * defined by the {@code java.io.tmpdir} system property), and returns its name.\n     *\n     * <p>Use this method instead of {@link File#createTempFile(String, String)} when you wish to\n     * create a directory, not a regular file. A common pitfall is to call {@code createTempFile},\n     * delete the file and create a directory in its place, but this leads a race condition which can\n     * be exploited to create security vulnerabilities, especially when executable files are to be\n     * written into the directory.\n     *\n     * <p>This method assumes that the temporary volume is writable, has free inodes and free blocks,\n     * and that it will not be called thousands of times per second.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#createTempDirectory}.\n     *\n     * @return the newly-created directory\n     * @throws IllegalStateException if the directory could not be created\n     */\n    @Beta\n    public static File createTempDir()\n    {\n        File baseDir = new File(System.getProperty(\"java.io.tmpdir\"));\n        @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n        String baseName = System.currentTimeMillis() + \"-\";\n\n        for (int counter = 0; counter < TEMP_DIR_ATTEMPTS; counter++)\n        {\n            File tempDir = new File(baseDir, baseName + counter);\n            if (tempDir.mkdir())\n            {\n                return tempDir;\n            }\n        }\n        throw new IllegalStateException(\n            \"Failed to create directory within \"\n            + TEMP_DIR_ATTEMPTS\n            + \" attempts (tried \"\n            + baseName\n            + \"0 to \"\n            + baseName\n            + (TEMP_DIR_ATTEMPTS - 1)\n            + ')');\n    }\n\n    /**\n     * Creates an empty file or updates the last updated timestamp on the same as the unix command of\n     * the same name.\n     *\n     * @param file the file to create or update\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n    public static void touch(File file) throws IOException\n    {\n        checkNotNull(file);\n        if (!file.createNewFile() && !file.setLastModified(System.currentTimeMillis()))\n        {\n            throw new IOException(\"Unable to update modification time of \" + file);\n        }\n    }\n\n    /**\n     * Creates any necessary but nonexistent parent directories of the specified file. Note that if\n     * this operation fails it may have succeeded in creating some (but not all) of the necessary\n     * parent directories.\n     *\n     * @throws IOException if an I/O error occurs, or if any necessary but nonexistent parent\n     *     directories of the specified file could not be created.\n     * @since 4.0\n     */\n    @Beta\n    public static void createParentDirs(File file) throws IOException\n    {\n        checkNotNull(file);\n        File parent = file.getCanonicalFile().getParentFile();\n        if (parent == null)\n        {\n            /*\n             * The given directory is a filesystem root. All zero of its ancestors exist. This doesn't\n             * mean that the root itself exists -- consider x:\\ on a Windows machine without such a drive\n             * -- or even that the caller can create it, but this method makes no such guarantees even for\n             * non-root files.\n             */\n            return;\n        }\n        parent.mkdirs();\n        if (!parent.isDirectory())\n        {\n            throw new IOException(\"Unable to create parent directories of \" + file);\n        }\n    }\n\n    /**\n     * Moves a file from one path to another. This method can rename a file and/or move it to a\n     * different directory. In either case {@code to} must be the target path for the file itself; not\n     * just the new name for the file or the path to the new parent directory.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#move}.\n     *\n     * @param from the source file\n     * @param to the destination file\n     * @throws IOException if an I/O error occurs\n     * @throws IllegalArgumentException if {@code from.equals(to)}\n     */\n    @Beta\n    public static void move(File from, File to) throws IOException\n    {\n        checkNotNull(from);\n        checkNotNull(to);\n        checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n\n        if (!from.renameTo(to))\n        {\n            copy(from, to);\n            if (!from.delete())\n            {\n                if (!to.delete())\n                {\n                    throw new IOException(\"Unable to delete \" + to);\n                }\n                throw new IOException(\"Unable to delete \" + from);\n            }\n        }\n    }\n\n    /**\n     * Reads the first line from a file. The line does not include line-termination characters, but\n     * does include other leading and trailing whitespace.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return the first line, or null if the file is empty\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(file, charset).readFirstLine()}. This method is\n     *     scheduled to be removed in January 2019.\n     */\n\n    /**\n     * Reads all of the lines from a file. The lines do not include line-termination characters, but\n     * do include other leading and trailing whitespace.\n     *\n     * <p>This method returns a mutable {@code List}. For an {@code ImmutableList}, use {@code\n     * Files.asCharSource(file, charset).readLines()}.\n     *\n     * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n     * java.nio.file.Files#readAllLines(java.nio.file.Path, Charset)}.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @return a mutable {@link List} containing all the lines\n     * @throws IOException if an I/O error occurs\n     */\n    @Beta\n    public static List<String> readLines(File file, Charset charset) throws IOException\n    {\n        // don't use asCharSource(file, charset).readLines() because that returns\n        // an immutable list, which would change the behavior of this method\n        return asCharSource(file, charset)\n               .readLines(\n                   new LineProcessor<List<String>>()\n        {\n            final List<String> result = Lists.newArrayList();\n\n            @Override\n            public boolean processLine(String line)\n            {\n                result.add(line);\n                return true;\n            }\n\n            @Override\n            public List<String> getResult()\n            {\n                return result;\n            }\n        });\n    }\n\n    /**\n     * Streams lines from a {@link File}, stopping when our callback returns false, or we have read\n     * all of the lines.\n     *\n     * @param file the file to read from\n     * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n     *     helpful predefined constants\n     * @param callback the {@link LineProcessor} to use to handle the lines\n     * @return the output of processing the lines\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asCharSource(file, charset).readLines(callback)}. This method is\n     *     scheduled to be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    @CanIgnoreReturnValue // some processors won't return a useful result\n    public\n    static <T> T readLines(File file, Charset charset, LineProcessor<T> callback) throws IOException\n    {\n        return asCharSource(file, charset).readLines(callback);\n    }\n\n    /**\n     * Process the bytes of a file.\n     *\n     * <p>(If this seems too complicated, maybe you're looking for {@link #toByteArray}.)\n     *\n     * @param file the file to read\n     * @param processor the object to which the bytes of the file are passed.\n     * @return the result of the byte processor\n     * @throws IOException if an I/O error occurs\n     * @deprecated Prefer {@code asByteSource(file).read(processor)}. This method is scheduled to be\n     *     removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    @CanIgnoreReturnValue // some processors won't return a useful result\n    public\n    static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException\n    {\n        return asByteSource(file).read(processor);\n    }\n\n    /**\n     * Computes the hash code of the {@code file} using {@code hashFunction}.\n     *\n     * @param file the file to read\n     * @param hashFunction the hash function to use to hash the data\n     * @return the {@link HashCode} of all of the bytes in the file\n     * @throws IOException if an I/O error occurs\n     * @since 12.0\n     * @deprecated Prefer {@code asByteSource(file).hash(hashFunction)}. This method is scheduled to\n     *     be removed in January 2019.\n     */\n    @Beta\n    @Deprecated\n    public\n    static HashCode hash(File file, HashFunction hashFunction) throws IOException\n    {\n        return asByteSource(file).hash(hashFunction);\n    }\n\n    /**\n     * Fully maps a file read-only in to memory as per {@link\n     * FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}.\n     *\n     * <p>Files are mapped from offset 0 to its length.\n     *\n     * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n     *\n     * @param file the file to map\n     * @return a read-only buffer reflecting {@code file}\n     * @throws FileNotFoundException if the {@code file} does not exist\n     * @throws IOException if an I/O error occurs\n     * @see FileChannel#map(MapMode, long, long)\n     * @since 2.0\n     */\n    @Beta\n    public static MappedByteBuffer map(File file) throws IOException\n    {\n        checkNotNull(file);\n        return map(file, MapMode.READ_ONLY);\n    }\n\n    /**\n     * Fully maps a file in to memory as per {@link\n     * FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)} using the requested {@link\n     * MapMode}.\n     *\n     * <p>Files are mapped from offset 0 to its length.\n     *\n     * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n     *\n     * @param file the file to map\n     * @param mode the mode to use when mapping {@code file}\n     * @return a buffer reflecting {@code file}\n     * @throws FileNotFoundException if the {@code file} does not exist\n     * @throws IOException if an I/O error occurs\n     * @see FileChannel#map(MapMode, long, long)\n     * @since 2.0\n     */\n    @Beta\n    public static MappedByteBuffer map(File file, MapMode mode) throws IOException\n    {\n        return mapInternal(file, mode, -1);\n    }\n\n    /**\n     * Maps a file in to memory as per {@link FileChannel#map(java.nio.channels.FileChannel.MapMode,\n     * long, long)} using the requested {@link MapMode}.\n     *\n     * <p>Files are mapped from offset 0 to {@code size}.\n     *\n     * <p>If the mode is {@link MapMode#READ_WRITE} and the file does not exist, it will be created\n     * with the requested {@code size}. Thus this method is useful for creating memory mapped files\n     * which do not yet exist.\n     *\n     * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n     *\n     * @param file the file to map\n     * @param mode the mode to use when mapping {@code file}\n     * @return a buffer reflecting {@code file}\n     * @throws IOException if an I/O error occurs\n     * @see FileChannel#map(MapMode, long, long)\n     * @since 2.0\n     */\n    @Beta\n    public static MappedByteBuffer map(File file, MapMode mode, long size) throws IOException\n    {\n        checkArgument(size >= 0, \"size (%s) may not be negative\", size);\n        return mapInternal(file, mode, size);\n    }\n\n    private static MappedByteBuffer mapInternal(File file, MapMode mode, long size)\n    throws IOException\n    {\n        checkNotNull(file);\n        checkNotNull(mode);\n\n        Closer closer = Closer.create();\n        try\n        {\n            RandomAccessFile raf =\n                closer.register(new RandomAccessFile(file, mode == MapMode.READ_ONLY ? \"r\" : \"rw\"));\n            FileChannel channel = closer.register(raf.getChannel());\n            return channel.map(mode, 0, size == -1 ? channel.size() : size);\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n\n    /**\n     * Returns the lexically cleaned form of the path name, <i>usually</i> (but not always) equivalent\n     * to the original. The following heuristics are used:\n     *\n     * <ul>\n     *   <li>empty string becomes .\n     *   <li>. stays as .\n     *   <li>fold out ./\n     *   <li>fold out ../ when possible\n     *   <li>collapse multiple slashes\n     *   <li>delete trailing slashes (unless the path is just \"/\")\n     * </ul>\n     *\n     * <p>These heuristics do not always match the behavior of the filesystem. In particular, consider\n     * the path {@code a/../b}, which {@code simplifyPath} will change to {@code b}. If {@code a} is a\n     * symlink to {@code x}, {@code a/../b} may refer to a sibling of {@code x}, rather than the\n     * sibling of {@code a} referred to by {@code b}.\n     *\n     * @since 11.0\n     */\n    @Beta\n    public static String simplifyPath(String pathname)\n    {\n        checkNotNull(pathname);\n        if (pathname.length() == 0)\n        {\n            return \".\";\n        }\n\n        // split the path apart\n        Iterable<String> components = Splitter.on('/').omitEmptyStrings().split(pathname);\n        List<String> path = new ArrayList<>();\n\n        // resolve ., .., and //\n        for (String component : components)\n        {\n            switch (component)\n            {\n            case \".\":\n                continue;\n            case \"..\":\n                if (path.size() > 0 && !path.get(path.size() - 1).equals(\"..\"))\n                {\n                    path.remove(path.size() - 1);\n                }\n                else\n                {\n                    path.add(\"..\");\n                }\n                break;\n            default:\n                path.add(component);\n                break;\n            }\n        }\n\n        // put it back together\n        String result = Joiner.on('/').join(path);\n        if (pathname.charAt(0) == '/')\n        {\n            result = \"/\" + result;\n        }\n\n        while (result.startsWith(\"/../\"))\n        {\n            result = result.substring(3);\n        }\n        if (result.equals(\"/..\"))\n        {\n            result = \"/\";\n        }\n        else if (\"\".equals(result))\n        {\n            result = \".\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the <a href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> for\n     * the given file name, or the empty string if the file has no extension. The result does not\n     * include the '{@code .}'.\n     *\n     * <p><b>Note:</b> This method simply returns everything after the last '{@code .}' in the file's\n     * name as determined by {@link File#getName}. It does not account for any filesystem-specific\n     * behavior that the {@link File} API does not already account for. For example, on NTFS it will\n     * report {@code \"txt\"} as the extension for the filename {@code \"foo.exe:.txt\"} even though NTFS\n     * will drop the {@code \":.txt\"} part of the name when the file is actually created on the\n     * filesystem due to NTFS's <a href=\"https://goo.gl/vTpJi4\">Alternate Data Streams</a>.\n     *\n     * @since 11.0\n     */\n    @Beta\n    public static String getFileExtension(String fullName)\n    {\n        checkNotNull(fullName);\n        String fileName = new File(fullName).getName();\n        int dotIndex = fileName.lastIndexOf('.');\n        return (dotIndex == -1) ? \"\" : fileName.substring(dotIndex + 1);\n    }\n\n    /**\n     * Returns the file name without its <a\n     * href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> or path. This is\n     * similar to the {@code basename} unix command. The result does not include the '{@code .}'.\n     *\n     * @param file The name of the file to trim the extension from. This can be either a fully\n     *     qualified file name (including a path) or just a file name.\n     * @return The file name without its path or extension.\n     * @since 14.0\n     */\n    @Beta\n    public static String getNameWithoutExtension(String file)\n    {\n        checkNotNull(file);\n        String fileName = new File(file).getName();\n        int dotIndex = fileName.lastIndexOf('.');\n        return (dotIndex == -1) ? fileName : fileName.substring(0, dotIndex);\n    }\n\n    /**\n     * Returns a {@link TreeTraverser} instance for {@link File} trees.\n     *\n     * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no\n     * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n     * this case, iterables created by this traverser could contain files that are outside of the\n     * given directory or even be infinite if there is a symbolic link loop.\n     *\n     * @since 15.0\n     * @deprecated The returned {@link TreeTraverser} type is deprecated. Use the replacement method\n     *     {@link #fileTraverser()} instead with the same semantics as this method.\n     */\n    @Deprecated\n    static TreeTraverser<File> fileTreeTraverser()\n    {\n        return FILE_TREE_TRAVERSER;\n    }\n\n    private static final TreeTraverser<File> FILE_TREE_TRAVERSER =\n        new TreeTraverser<File>()\n    {\n        @Override\n        public Iterable<File> children(File file)\n        {\n            return fileTreeChildren(file);\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"Files.fileTreeTraverser()\";\n        }\n    };\n\n    /**\n     * Returns a {@link Traverser} instance for the file and directory tree. The returned traverser\n     * starts from a {@link File} and will return all files and directories it encounters.\n     *\n     * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no\n     * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n     * this case, iterables created by this traverser could contain files that are outside of the\n     * given directory or even be infinite if there is a symbolic link loop.\n     *\n     * <p>If available, consider using {@link MoreFiles#fileTraverser()} instead. It behaves the same\n     * except that it doesn't follow symbolic links and returns {@code Path} instances.\n     *\n     * <p>If the {@link File} passed to one of the {@link Traverser} methods does not exist or is not\n     * a directory, no exception will be thrown and the returned {@link Iterable} will contain a\n     * single element: that file.\n     *\n     * <p>Example: {@code Files.fileTraverser().depthFirstPreOrder(new File(\"/\"))} may return files\n     * with the following paths: {@code [\"/\", \"/etc\", \"/etc/config.txt\", \"/etc/fonts\", \"/home\",\n     * \"/home/alice\", ...]}\n     *\n     * @since 23.5\n     */\n    @Beta\n    public static Traverser<File> fileTraverser()\n    {\n        return Traverser.forTree(FILE_TREE);\n    }\n\n    private static final SuccessorsFunction<File> FILE_TREE =\n        new SuccessorsFunction<File>()\n    {\n        @Override\n        public Iterable<File> successors(File file)\n        {\n            return fileTreeChildren(file);\n        }\n    };\n\n    private static Iterable<File> fileTreeChildren(File file)\n    {\n        // check isDirectory() just because it may be faster than listFiles() on a non-directory\n        if (file.isDirectory())\n        {\n            File[] files = file.listFiles();\n            if (files != null)\n            {\n                return Collections.unmodifiableList(Arrays.asList(files));\n            }\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * Returns a predicate that returns the result of {@link File#isDirectory} on input files.\n     *\n     * @since 15.0\n     */\n    @Beta\n    public static Predicate<File> isDirectory()\n    {\n        return FilePredicate.IS_DIRECTORY;\n    }\n\n    /**\n     * Returns a predicate that returns the result of {@link File#isFile} on input files.\n     *\n     * @since 15.0\n     */\n    @Beta\n    public static Predicate<File> isFile()\n    {\n        return FilePredicate.IS_FILE;\n    }\n\n    private enum FilePredicate implements Predicate<File>\n    {\n        IS_DIRECTORY {\n            @Override\n            public boolean apply(File file)\n            {\n                return file.isDirectory();\n            }\n\n            @Override\n            public String toString()\n            {\n                return \"Files.isDirectory()\";\n            }\n        },\n\n        IS_FILE {\n            @Override\n            public boolean apply(File file)\n            {\n                return file.isFile();\n            }\n\n            @Override\n            public String toString()\n            {\n                return \"Files.isFile()\";\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/collect/ImmutableBiMap.java", "func_name": "ImmutableBiMap.builderWithExpectedSize", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns a new builder, expecting the specified number of entries to be added.\n\n<p>If {@code expectedSize} is exactly the number of entries added to the builder before {@link\nBuilder#build} is called, the builder is likely to perform better than an unsized {@link\n#builder()} would have.\n\n<p>It is not specified if any performance benefits apply if {@code expectedSize} is close to,\nbut not exactly, the number of entries added to the builder.\n\n@since 23.1", "docstring_tokens": ["Returns", "a", "new", "builder", "expecting", "the", "specified", "number", "of", "entries", "to", "be", "added", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/collect/ImmutableBiMap.java#L135-L139", "partition": "valid", "up_fun_num": 9, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkState;", "import static com.google.common.collect.CollectPreconditions.checkNonnegative;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.annotations.VisibleForTesting;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.util.Arrays;", "import java.util.Comparator;", "import java.util.Map;", "import java.util.function.Function;", "import java.util.stream.Collector;", "import java.util.stream.Collectors;"], "function": ["public abstract class ImmutableBiMap<K, V> extends ImmutableBiMapFauxverideShim<K, V>\n", "    public static <T, K, V> Collector<T, ?, ImmutableBiMap<K, V>> toImmutableBiMap(\n", "    public static <K, V> ImmutableBiMap<K, V> of()\n", "    public static <K, V> ImmutableBiMap<K, V> of(K k1, V v1)\n", "    public static <K, V> ImmutableBiMap<K, V> of(K k1, V v1, K k2, V v2)\n", "    public static <K, V> ImmutableBiMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3)\n", "    public static <K, V> ImmutableBiMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4)\n", "    public static <K, V> ImmutableBiMap<K, V> of(\n", "    public static <K, V> Builder<K, V> builder()\n", "    public static <K, V> ImmutableBiMap<K, V> copyOf(Map<? extends K, ? extends V> map)\n", "    public static <K, V> ImmutableBiMap<K, V> copyOf(\n", "    public abstract ImmutableBiMap<V, K> inverse();\n", "    public ImmutableSet<V> values()\n", "    final ImmutableSet<V> createValues()\n", "    public V forcePut(K key, V value)\n", "    Object writeReplace()\n"], "context": "/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.collect.CollectPreconditions.checkNonnegative;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\n\n/**\n * A {@link BiMap} whose contents will never change, with many other important properties detailed\n * at {@link ImmutableCollection}.\n *\n * @author Jared Levy\n * @since 2.0\n */\n@GwtCompatible(serializable = true, emulated = true)\npublic abstract class ImmutableBiMap<K, V> extends ImmutableBiMapFauxverideShim<K, V>\n    implements BiMap<K, V>\n{\n\n    /**\n     * Returns a {@link Collector} that accumulates elements into an {@code ImmutableBiMap} whose keys\n     * and values are the result of applying the provided mapping functions to the input elements.\n     * Entries appear in the result {@code ImmutableBiMap} in encounter order.\n     *\n     * <p>If the mapped keys or values contain duplicates (according to {@link Object#equals(Object)},\n     * an {@code IllegalArgumentException} is thrown when the collection operation is performed. (This\n     * differs from the {@code Collector} returned by {@link Collectors#toMap(Function, Function)},\n     * which throws an {@code IllegalStateException}.)\n     *\n     * @since 21.0\n     */\n    public static <T, K, V> Collector<T, ?, ImmutableBiMap<K, V>> toImmutableBiMap(\n        Function<? super T, ? extends K> keyFunction,\n        Function<? super T, ? extends V> valueFunction)\n    {\n        return CollectCollectors.toImmutableBiMap(keyFunction, valueFunction);\n    }\n\n    /** Returns the empty bimap. */\n    // Casting to any type is safe because the set will never hold any elements.\n    @SuppressWarnings(\"unchecked\")\n    public static <K, V> ImmutableBiMap<K, V> of()\n    {\n        return (ImmutableBiMap<K, V>) RegularImmutableBiMap.EMPTY;\n    }\n\n    /** Returns an immutable bimap containing a single entry. */\n    public static <K, V> ImmutableBiMap<K, V> of(K k1, V v1)\n    {\n        return new SingletonImmutableBiMap<>(k1, v1);\n    }\n\n    /**\n     * Returns an immutable map containing the given entries, in order.\n     *\n     * @throws IllegalArgumentException if duplicate keys or values are added\n     */\n    public static <K, V> ImmutableBiMap<K, V> of(K k1, V v1, K k2, V v2)\n    {\n        return RegularImmutableBiMap.fromEntries(entryOf(k1, v1), entryOf(k2, v2));\n    }\n\n    /**\n     * Returns an immutable map containing the given entries, in order.\n     *\n     * @throws IllegalArgumentException if duplicate keys or values are added\n     */\n    public static <K, V> ImmutableBiMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3)\n    {\n        return RegularImmutableBiMap.fromEntries(entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3));\n    }\n\n    /**\n     * Returns an immutable map containing the given entries, in order.\n     *\n     * @throws IllegalArgumentException if duplicate keys or values are added\n     */\n    public static <K, V> ImmutableBiMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4)\n    {\n        return RegularImmutableBiMap.fromEntries(\n                   entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3), entryOf(k4, v4));\n    }\n\n    /**\n     * Returns an immutable map containing the given entries, in order.\n     *\n     * @throws IllegalArgumentException if duplicate keys or values are added\n     */\n    public static <K, V> ImmutableBiMap<K, V> of(\n        K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5)\n    {\n        return RegularImmutableBiMap.fromEntries(\n                   entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3), entryOf(k4, v4), entryOf(k5, v5));\n    }\n\n    // looking for of() with > 5 entries? Use the builder instead.\n\n    /**\n     * Returns a new builder. The generated builder is equivalent to the builder created by the {@link\n     * Builder} constructor.\n     */\n    public static <K, V> Builder<K, V> builder()\n    {\n        return new Builder<>();\n    }\n\n    /**\n     * Returns a new builder, expecting the specified number of entries to be added.\n     *\n     * <p>If {@code expectedSize} is exactly the number of entries added to the builder before {@link\n     * Builder#build} is called, the builder is likely to perform better than an unsized {@link\n     * #builder()} would have.\n     *\n     * <p>It is not specified if any performance benefits apply if {@code expectedSize} is close to,\n     * but not exactly, the number of entries added to the builder.\n     *\n     * @since 23.1\n     */\n\n    /**\n     * A builder for creating immutable bimap instances, especially {@code public static final} bimaps\n     * (\"constant bimaps\"). Example:\n     *\n     * <pre>{@code\n     * static final ImmutableBiMap<String, Integer> WORD_TO_INT =\n     *     new ImmutableBiMap.Builder<String, Integer>()\n     *         .put(\"one\", 1)\n     *         .put(\"two\", 2)\n     *         .put(\"three\", 3)\n     *         .build();\n     * }</pre>\n     *\n     * <p>For <i>small</i> immutable bimaps, the {@code ImmutableBiMap.of()} methods are even more\n     * convenient.\n     *\n     * <p>By default, a {@code Builder} will generate bimaps that iterate over entries in the order\n     * they were inserted into the builder. For example, in the above example, {@code\n     * WORD_TO_INT.entrySet()} is guaranteed to iterate over the entries in the order {@code \"one\"=1,\n     * \"two\"=2, \"three\"=3}, and {@code keySet()} and {@code values()} respect the same order. If you\n     * want a different order, consider using {@link #orderEntriesByValue(Comparator)}, which changes\n     * this builder to sort entries by value.\n     *\n     * <p>Builder instances can be reused - it is safe to call {@link #build} multiple times to build\n     * multiple bimaps in series. Each bimap is a superset of the bimaps created before it.\n     *\n     * @since 2.0\n     */\n    public static final class Builder<K, V> extends ImmutableMap.Builder<K, V>\n    {\n\n        /**\n         * Creates a new builder. The returned builder is equivalent to the builder generated by {@link\n         * ImmutableBiMap#builder}.\n         */\n        public Builder() {}\n\n        Builder(int size)\n        {\n            super(size);\n        }\n\n        /**\n         * Associates {@code key} with {@code value} in the built bimap. Duplicate keys or values are\n         * not allowed, and will cause {@link #build} to fail.\n         */\n        @CanIgnoreReturnValue\n        @Override\n        public Builder<K, V> put(K key, V value)\n        {\n            super.put(key, value);\n            return this;\n        }\n\n        /**\n         * Adds the given {@code entry} to the bimap. Duplicate keys or values are not allowed, and will\n         * cause {@link #build} to fail.\n         *\n         * @since 19.0\n         */\n        @CanIgnoreReturnValue\n        @Override\n        public Builder<K, V> put(Entry<? extends K, ? extends V> entry)\n        {\n            super.put(entry);\n            return this;\n        }\n\n        /**\n         * Associates all of the given map's keys and values in the built bimap. Duplicate keys or\n         * values are not allowed, and will cause {@link #build} to fail.\n         *\n         * @throws NullPointerException if any key or value in {@code map} is null\n         */\n        @CanIgnoreReturnValue\n        @Override\n        public Builder<K, V> putAll(Map<? extends K, ? extends V> map)\n        {\n            super.putAll(map);\n            return this;\n        }\n\n        /**\n         * Adds all of the given entries to the built bimap. Duplicate keys or values are not allowed,\n         * and will cause {@link #build} to fail.\n         *\n         * @throws NullPointerException if any key, value, or entry is null\n         * @since 19.0\n         */\n        @CanIgnoreReturnValue\n        @Beta\n        @Override\n        public Builder<K, V> putAll(Iterable<? extends Entry<? extends K, ? extends V>> entries)\n        {\n            super.putAll(entries);\n            return this;\n        }\n\n        /**\n         * Configures this {@code Builder} to order entries by value according to the specified\n         * comparator.\n         *\n         * <p>The sort order is stable, that is, if two entries have values that compare as equivalent,\n         * the entry that was inserted first will be first in the built map's iteration order.\n         *\n         * @throws IllegalStateException if this method was already called\n         * @since 19.0\n         */\n        @CanIgnoreReturnValue\n        @Beta\n        @Override\n        public Builder<K, V> orderEntriesByValue(Comparator<? super V> valueComparator)\n        {\n            super.orderEntriesByValue(valueComparator);\n            return this;\n        }\n\n        @Override\n        @CanIgnoreReturnValue\n        Builder<K, V> combine(ImmutableMap.Builder<K, V> builder)\n        {\n            super.combine(builder);\n            return this;\n        }\n\n        /**\n         * Returns a newly-created immutable bimap. The iteration order of the returned bimap is the\n         * order in which entries were inserted into the builder, unless {@link #orderEntriesByValue}\n         * was called, in which case entries are sorted by value.\n         *\n         * @throws IllegalArgumentException if duplicate keys or values were added\n         */\n        @Override\n        public ImmutableBiMap<K, V> build()\n        {\n            switch (size)\n            {\n            case 0:\n                return of();\n            case 1:\n                return of(entries[0].getKey(), entries[0].getValue());\n            default:\n                /*\n                 * If entries is full, or if hash flooding is detected, then this implementation may end\n                 * up using the entries array directly and writing over the entry objects with\n                 * non-terminal entries, but this is safe; if this Builder is used further, it will grow\n                 * the entries array (so it can't affect the original array), and future build() calls\n                 * will always copy any entry objects that cannot be safely reused.\n                 */\n                if (valueComparator != null)\n                {\n                    if (entriesUsed)\n                    {\n                        entries = Arrays.copyOf(entries, size);\n                    }\n                    Arrays.sort(\n                        entries,\n                        0,\n                        size,\n                        Ordering.from(valueComparator).onResultOf(Maps.<V>valueFunction()));\n                }\n                entriesUsed = true;\n                return RegularImmutableBiMap.fromEntryArray(size, entries);\n            }\n        }\n\n        @Override\n        @VisibleForTesting\n        ImmutableBiMap<K, V> buildJdkBacked()\n        {\n            checkState(\n                valueComparator == null,\n                \"buildJdkBacked is for tests only, doesn't support orderEntriesByValue\");\n            switch (size)\n            {\n            case 0:\n                return of();\n            case 1:\n                return of(entries[0].getKey(), entries[0].getValue());\n            default:\n                entriesUsed = true;\n                return RegularImmutableBiMap.fromEntryArray(size, entries);\n            }\n        }\n    }\n\n    /**\n     * Returns an immutable bimap containing the same entries as {@code map}. If {@code map} somehow\n     * contains entries with duplicate keys (for example, if it is a {@code SortedMap} whose\n     * comparator is not <i>consistent with equals</i>), the results of this method are undefined.\n     *\n     * <p>The returned {@code BiMap} iterates over entries in the same order as the {@code entrySet}\n     * of the original map.\n     *\n     * <p>Despite the method name, this method attempts to avoid actually copying the data when it is\n     * safe to do so. The exact circumstances under which a copy will or will not be performed are\n     * undocumented and subject to change.\n     *\n     * @throws IllegalArgumentException if two keys have the same value or two values have the same\n     *     key\n     * @throws NullPointerException if any key or value in {@code map} is null\n     */\n    public static <K, V> ImmutableBiMap<K, V> copyOf(Map<? extends K, ? extends V> map)\n    {\n        if (map instanceof ImmutableBiMap)\n        {\n            @SuppressWarnings(\"unchecked\") // safe since map is not writable\n            ImmutableBiMap<K, V> bimap = (ImmutableBiMap<K, V>) map;\n            // TODO(lowasser): if we need to make a copy of a BiMap because the\n            // forward map is a view, don't make a copy of the non-view delegate map\n            if (!bimap.isPartialView())\n            {\n                return bimap;\n            }\n        }\n        return copyOf(map.entrySet());\n    }\n\n    /**\n     * Returns an immutable bimap containing the given entries. The returned bimap iterates over\n     * entries in the same order as the original iterable.\n     *\n     * @throws IllegalArgumentException if two keys have the same value or two values have the same\n     *     key\n     * @throws NullPointerException if any key, value, or entry is null\n     * @since 19.0\n     */\n    @Beta\n    public static <K, V> ImmutableBiMap<K, V> copyOf(\n        Iterable<? extends Entry<? extends K, ? extends V>> entries)\n    {\n        @SuppressWarnings(\"unchecked\") // we'll only be using getKey and getValue, which are covariant\n        Entry<K, V>[] entryArray = (Entry<K, V>[]) Iterables.toArray(entries, EMPTY_ENTRY_ARRAY);\n        switch (entryArray.length)\n        {\n        case 0:\n            return of();\n        case 1:\n            Entry<K, V> entry = entryArray[0];\n            return of(entry.getKey(), entry.getValue());\n        default:\n            /*\n             * The current implementation will end up using entryArray directly, though it will write\n             * over the (arbitrary, potentially mutable) Entry objects actually stored in entryArray.\n             */\n            return RegularImmutableBiMap.fromEntries(entryArray);\n        }\n    }\n\n    ImmutableBiMap() {}\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>The inverse of an {@code ImmutableBiMap} is another {@code ImmutableBiMap}.\n     */\n    @Override\n    public abstract ImmutableBiMap<V, K> inverse();\n\n    /**\n     * Returns an immutable set of the values in this map, in the same order they appear in {@link\n     * #entrySet}.\n     */\n    @Override\n    public ImmutableSet<V> values()\n    {\n        return inverse().keySet();\n    }\n\n    @Override\n    final ImmutableSet<V> createValues()\n    {\n        throw new AssertionError(\"should never be called\");\n    }\n\n    /**\n     * Guaranteed to throw an exception and leave the bimap unmodified.\n     *\n     * @throws UnsupportedOperationException always\n     * @deprecated Unsupported operation.\n     */\n    @CanIgnoreReturnValue\n    @Deprecated\n    @Override\n    public V forcePut(K key, V value)\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Serialized type for all ImmutableBiMap instances. It captures the logical contents and they are\n     * reconstructed using public factory methods. This ensures that the implementation types remain\n     * as implementation details.\n     *\n     * <p>Since the bimap is immutable, ImmutableBiMap doesn't require special logic for keeping the\n     * bimap and its inverse in sync during serialization, the way AbstractBiMap does.\n     */\n    private static class SerializedForm extends ImmutableMap.SerializedForm\n    {\n        SerializedForm(ImmutableBiMap<?, ?> bimap)\n        {\n            super(bimap);\n        }\n\n        @Override\n        Object readResolve()\n        {\n            Builder<Object, Object> builder = new Builder<>();\n            return createMap(builder);\n        }\n\n        private static final long serialVersionUID = 0;\n    }\n\n    @Override\n    Object writeReplace()\n    {\n        return new SerializedForm(this);\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/collect/ImmutableBiMap.java", "func_name": "ImmutableBiMap.forcePut", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Guaranteed to throw an exception and leave the bimap unmodified.\n\n@throws UnsupportedOperationException always\n@deprecated Unsupported operation.", "docstring_tokens": ["Guaranteed", "to", "throw", "an", "exception", "and", "leave", "the", "bimap", "unmodified", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/collect/ImmutableBiMap.java#L401-L406", "partition": "valid", "up_fun_num": 15, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkState;", "import static com.google.common.collect.CollectPreconditions.checkNonnegative;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.annotations.VisibleForTesting;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.util.Arrays;", "import java.util.Comparator;", "import java.util.Map;", "import java.util.function.Function;", "import java.util.stream.Collector;", "import java.util.stream.Collectors;"], "function": ["public abstract class ImmutableBiMap<K, V> extends ImmutableBiMapFauxverideShim<K, V>\n", "    public static <T, K, V> Collector<T, ?, ImmutableBiMap<K, V>> toImmutableBiMap(\n", "    public static <K, V> ImmutableBiMap<K, V> of()\n", "    public static <K, V> ImmutableBiMap<K, V> of(K k1, V v1)\n", "    public static <K, V> ImmutableBiMap<K, V> of(K k1, V v1, K k2, V v2)\n", "    public static <K, V> ImmutableBiMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3)\n", "    public static <K, V> ImmutableBiMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4)\n", "    public static <K, V> ImmutableBiMap<K, V> of(\n", "    public static <K, V> Builder<K, V> builder()\n", "    public static <K, V> Builder<K, V> builderWithExpectedSize(int expectedSize)\n", "    public static <K, V> ImmutableBiMap<K, V> copyOf(Map<? extends K, ? extends V> map)\n", "    public static <K, V> ImmutableBiMap<K, V> copyOf(\n", "    public abstract ImmutableBiMap<V, K> inverse();\n", "    public ImmutableSet<V> values()\n", "    final ImmutableSet<V> createValues()\n", "    Object writeReplace()\n"], "context": "/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.collect.CollectPreconditions.checkNonnegative;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\n\n/**\n * A {@link BiMap} whose contents will never change, with many other important properties detailed\n * at {@link ImmutableCollection}.\n *\n * @author Jared Levy\n * @since 2.0\n */\n@GwtCompatible(serializable = true, emulated = true)\npublic abstract class ImmutableBiMap<K, V> extends ImmutableBiMapFauxverideShim<K, V>\n    implements BiMap<K, V>\n{\n\n    /**\n     * Returns a {@link Collector} that accumulates elements into an {@code ImmutableBiMap} whose keys\n     * and values are the result of applying the provided mapping functions to the input elements.\n     * Entries appear in the result {@code ImmutableBiMap} in encounter order.\n     *\n     * <p>If the mapped keys or values contain duplicates (according to {@link Object#equals(Object)},\n     * an {@code IllegalArgumentException} is thrown when the collection operation is performed. (This\n     * differs from the {@code Collector} returned by {@link Collectors#toMap(Function, Function)},\n     * which throws an {@code IllegalStateException}.)\n     *\n     * @since 21.0\n     */\n    public static <T, K, V> Collector<T, ?, ImmutableBiMap<K, V>> toImmutableBiMap(\n        Function<? super T, ? extends K> keyFunction,\n        Function<? super T, ? extends V> valueFunction)\n    {\n        return CollectCollectors.toImmutableBiMap(keyFunction, valueFunction);\n    }\n\n    /** Returns the empty bimap. */\n    // Casting to any type is safe because the set will never hold any elements.\n    @SuppressWarnings(\"unchecked\")\n    public static <K, V> ImmutableBiMap<K, V> of()\n    {\n        return (ImmutableBiMap<K, V>) RegularImmutableBiMap.EMPTY;\n    }\n\n    /** Returns an immutable bimap containing a single entry. */\n    public static <K, V> ImmutableBiMap<K, V> of(K k1, V v1)\n    {\n        return new SingletonImmutableBiMap<>(k1, v1);\n    }\n\n    /**\n     * Returns an immutable map containing the given entries, in order.\n     *\n     * @throws IllegalArgumentException if duplicate keys or values are added\n     */\n    public static <K, V> ImmutableBiMap<K, V> of(K k1, V v1, K k2, V v2)\n    {\n        return RegularImmutableBiMap.fromEntries(entryOf(k1, v1), entryOf(k2, v2));\n    }\n\n    /**\n     * Returns an immutable map containing the given entries, in order.\n     *\n     * @throws IllegalArgumentException if duplicate keys or values are added\n     */\n    public static <K, V> ImmutableBiMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3)\n    {\n        return RegularImmutableBiMap.fromEntries(entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3));\n    }\n\n    /**\n     * Returns an immutable map containing the given entries, in order.\n     *\n     * @throws IllegalArgumentException if duplicate keys or values are added\n     */\n    public static <K, V> ImmutableBiMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4)\n    {\n        return RegularImmutableBiMap.fromEntries(\n                   entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3), entryOf(k4, v4));\n    }\n\n    /**\n     * Returns an immutable map containing the given entries, in order.\n     *\n     * @throws IllegalArgumentException if duplicate keys or values are added\n     */\n    public static <K, V> ImmutableBiMap<K, V> of(\n        K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5)\n    {\n        return RegularImmutableBiMap.fromEntries(\n                   entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3), entryOf(k4, v4), entryOf(k5, v5));\n    }\n\n    // looking for of() with > 5 entries? Use the builder instead.\n\n    /**\n     * Returns a new builder. The generated builder is equivalent to the builder created by the {@link\n     * Builder} constructor.\n     */\n    public static <K, V> Builder<K, V> builder()\n    {\n        return new Builder<>();\n    }\n\n    /**\n     * Returns a new builder, expecting the specified number of entries to be added.\n     *\n     * <p>If {@code expectedSize} is exactly the number of entries added to the builder before {@link\n     * Builder#build} is called, the builder is likely to perform better than an unsized {@link\n     * #builder()} would have.\n     *\n     * <p>It is not specified if any performance benefits apply if {@code expectedSize} is close to,\n     * but not exactly, the number of entries added to the builder.\n     *\n     * @since 23.1\n     */\n    @Beta\n    public static <K, V> Builder<K, V> builderWithExpectedSize(int expectedSize)\n    {\n        checkNonnegative(expectedSize, \"expectedSize\");\n        return new Builder<>(expectedSize);\n    }\n\n    /**\n     * A builder for creating immutable bimap instances, especially {@code public static final} bimaps\n     * (\"constant bimaps\"). Example:\n     *\n     * <pre>{@code\n     * static final ImmutableBiMap<String, Integer> WORD_TO_INT =\n     *     new ImmutableBiMap.Builder<String, Integer>()\n     *         .put(\"one\", 1)\n     *         .put(\"two\", 2)\n     *         .put(\"three\", 3)\n     *         .build();\n     * }</pre>\n     *\n     * <p>For <i>small</i> immutable bimaps, the {@code ImmutableBiMap.of()} methods are even more\n     * convenient.\n     *\n     * <p>By default, a {@code Builder} will generate bimaps that iterate over entries in the order\n     * they were inserted into the builder. For example, in the above example, {@code\n     * WORD_TO_INT.entrySet()} is guaranteed to iterate over the entries in the order {@code \"one\"=1,\n     * \"two\"=2, \"three\"=3}, and {@code keySet()} and {@code values()} respect the same order. If you\n     * want a different order, consider using {@link #orderEntriesByValue(Comparator)}, which changes\n     * this builder to sort entries by value.\n     *\n     * <p>Builder instances can be reused - it is safe to call {@link #build} multiple times to build\n     * multiple bimaps in series. Each bimap is a superset of the bimaps created before it.\n     *\n     * @since 2.0\n     */\n    public static final class Builder<K, V> extends ImmutableMap.Builder<K, V>\n    {\n\n        /**\n         * Creates a new builder. The returned builder is equivalent to the builder generated by {@link\n         * ImmutableBiMap#builder}.\n         */\n        public Builder() {}\n\n        Builder(int size)\n        {\n            super(size);\n        }\n\n        /**\n         * Associates {@code key} with {@code value} in the built bimap. Duplicate keys or values are\n         * not allowed, and will cause {@link #build} to fail.\n         */\n        @CanIgnoreReturnValue\n        @Override\n        public Builder<K, V> put(K key, V value)\n        {\n            super.put(key, value);\n            return this;\n        }\n\n        /**\n         * Adds the given {@code entry} to the bimap. Duplicate keys or values are not allowed, and will\n         * cause {@link #build} to fail.\n         *\n         * @since 19.0\n         */\n        @CanIgnoreReturnValue\n        @Override\n        public Builder<K, V> put(Entry<? extends K, ? extends V> entry)\n        {\n            super.put(entry);\n            return this;\n        }\n\n        /**\n         * Associates all of the given map's keys and values in the built bimap. Duplicate keys or\n         * values are not allowed, and will cause {@link #build} to fail.\n         *\n         * @throws NullPointerException if any key or value in {@code map} is null\n         */\n        @CanIgnoreReturnValue\n        @Override\n        public Builder<K, V> putAll(Map<? extends K, ? extends V> map)\n        {\n            super.putAll(map);\n            return this;\n        }\n\n        /**\n         * Adds all of the given entries to the built bimap. Duplicate keys or values are not allowed,\n         * and will cause {@link #build} to fail.\n         *\n         * @throws NullPointerException if any key, value, or entry is null\n         * @since 19.0\n         */\n        @CanIgnoreReturnValue\n        @Beta\n        @Override\n        public Builder<K, V> putAll(Iterable<? extends Entry<? extends K, ? extends V>> entries)\n        {\n            super.putAll(entries);\n            return this;\n        }\n\n        /**\n         * Configures this {@code Builder} to order entries by value according to the specified\n         * comparator.\n         *\n         * <p>The sort order is stable, that is, if two entries have values that compare as equivalent,\n         * the entry that was inserted first will be first in the built map's iteration order.\n         *\n         * @throws IllegalStateException if this method was already called\n         * @since 19.0\n         */\n        @CanIgnoreReturnValue\n        @Beta\n        @Override\n        public Builder<K, V> orderEntriesByValue(Comparator<? super V> valueComparator)\n        {\n            super.orderEntriesByValue(valueComparator);\n            return this;\n        }\n\n        @Override\n        @CanIgnoreReturnValue\n        Builder<K, V> combine(ImmutableMap.Builder<K, V> builder)\n        {\n            super.combine(builder);\n            return this;\n        }\n\n        /**\n         * Returns a newly-created immutable bimap. The iteration order of the returned bimap is the\n         * order in which entries were inserted into the builder, unless {@link #orderEntriesByValue}\n         * was called, in which case entries are sorted by value.\n         *\n         * @throws IllegalArgumentException if duplicate keys or values were added\n         */\n        @Override\n        public ImmutableBiMap<K, V> build()\n        {\n            switch (size)\n            {\n            case 0:\n                return of();\n            case 1:\n                return of(entries[0].getKey(), entries[0].getValue());\n            default:\n                /*\n                 * If entries is full, or if hash flooding is detected, then this implementation may end\n                 * up using the entries array directly and writing over the entry objects with\n                 * non-terminal entries, but this is safe; if this Builder is used further, it will grow\n                 * the entries array (so it can't affect the original array), and future build() calls\n                 * will always copy any entry objects that cannot be safely reused.\n                 */\n                if (valueComparator != null)\n                {\n                    if (entriesUsed)\n                    {\n                        entries = Arrays.copyOf(entries, size);\n                    }\n                    Arrays.sort(\n                        entries,\n                        0,\n                        size,\n                        Ordering.from(valueComparator).onResultOf(Maps.<V>valueFunction()));\n                }\n                entriesUsed = true;\n                return RegularImmutableBiMap.fromEntryArray(size, entries);\n            }\n        }\n\n        @Override\n        @VisibleForTesting\n        ImmutableBiMap<K, V> buildJdkBacked()\n        {\n            checkState(\n                valueComparator == null,\n                \"buildJdkBacked is for tests only, doesn't support orderEntriesByValue\");\n            switch (size)\n            {\n            case 0:\n                return of();\n            case 1:\n                return of(entries[0].getKey(), entries[0].getValue());\n            default:\n                entriesUsed = true;\n                return RegularImmutableBiMap.fromEntryArray(size, entries);\n            }\n        }\n    }\n\n    /**\n     * Returns an immutable bimap containing the same entries as {@code map}. If {@code map} somehow\n     * contains entries with duplicate keys (for example, if it is a {@code SortedMap} whose\n     * comparator is not <i>consistent with equals</i>), the results of this method are undefined.\n     *\n     * <p>The returned {@code BiMap} iterates over entries in the same order as the {@code entrySet}\n     * of the original map.\n     *\n     * <p>Despite the method name, this method attempts to avoid actually copying the data when it is\n     * safe to do so. The exact circumstances under which a copy will or will not be performed are\n     * undocumented and subject to change.\n     *\n     * @throws IllegalArgumentException if two keys have the same value or two values have the same\n     *     key\n     * @throws NullPointerException if any key or value in {@code map} is null\n     */\n    public static <K, V> ImmutableBiMap<K, V> copyOf(Map<? extends K, ? extends V> map)\n    {\n        if (map instanceof ImmutableBiMap)\n        {\n            @SuppressWarnings(\"unchecked\") // safe since map is not writable\n            ImmutableBiMap<K, V> bimap = (ImmutableBiMap<K, V>) map;\n            // TODO(lowasser): if we need to make a copy of a BiMap because the\n            // forward map is a view, don't make a copy of the non-view delegate map\n            if (!bimap.isPartialView())\n            {\n                return bimap;\n            }\n        }\n        return copyOf(map.entrySet());\n    }\n\n    /**\n     * Returns an immutable bimap containing the given entries. The returned bimap iterates over\n     * entries in the same order as the original iterable.\n     *\n     * @throws IllegalArgumentException if two keys have the same value or two values have the same\n     *     key\n     * @throws NullPointerException if any key, value, or entry is null\n     * @since 19.0\n     */\n    @Beta\n    public static <K, V> ImmutableBiMap<K, V> copyOf(\n        Iterable<? extends Entry<? extends K, ? extends V>> entries)\n    {\n        @SuppressWarnings(\"unchecked\") // we'll only be using getKey and getValue, which are covariant\n        Entry<K, V>[] entryArray = (Entry<K, V>[]) Iterables.toArray(entries, EMPTY_ENTRY_ARRAY);\n        switch (entryArray.length)\n        {\n        case 0:\n            return of();\n        case 1:\n            Entry<K, V> entry = entryArray[0];\n            return of(entry.getKey(), entry.getValue());\n        default:\n            /*\n             * The current implementation will end up using entryArray directly, though it will write\n             * over the (arbitrary, potentially mutable) Entry objects actually stored in entryArray.\n             */\n            return RegularImmutableBiMap.fromEntries(entryArray);\n        }\n    }\n\n    ImmutableBiMap() {}\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>The inverse of an {@code ImmutableBiMap} is another {@code ImmutableBiMap}.\n     */\n    @Override\n    public abstract ImmutableBiMap<V, K> inverse();\n\n    /**\n     * Returns an immutable set of the values in this map, in the same order they appear in {@link\n     * #entrySet}.\n     */\n    @Override\n    public ImmutableSet<V> values()\n    {\n        return inverse().keySet();\n    }\n\n    @Override\n    final ImmutableSet<V> createValues()\n    {\n        throw new AssertionError(\"should never be called\");\n    }\n\n    /**\n     * Guaranteed to throw an exception and leave the bimap unmodified.\n     *\n     * @throws UnsupportedOperationException always\n     * @deprecated Unsupported operation.\n     */\n\n    /**\n     * Serialized type for all ImmutableBiMap instances. It captures the logical contents and they are\n     * reconstructed using public factory methods. This ensures that the implementation types remain\n     * as implementation details.\n     *\n     * <p>Since the bimap is immutable, ImmutableBiMap doesn't require special logic for keeping the\n     * bimap and its inverse in sync during serialization, the way AbstractBiMap does.\n     */\n    private static class SerializedForm extends ImmutableMap.SerializedForm\n    {\n        SerializedForm(ImmutableBiMap<?, ?> bimap)\n        {\n            super(bimap);\n        }\n\n        @Override\n        Object readResolve()\n        {\n            Builder<Object, Object> builder = new Builder<>();\n            return createMap(builder);\n        }\n\n        private static final long serialVersionUID = 0;\n    }\n\n    @Override\n    Object writeReplace()\n    {\n        return new SerializedForm(this);\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/collect/MinMaxPriorityQueue.java", "func_name": "MinMaxPriorityQueue.create", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Creates a new min-max priority queue using natural order, no maximum size, and initially\ncontaining the given elements.", "docstring_tokens": ["Creates", "a", "new", "min", "-", "max", "priority", "queue", "using", "natural", "order", "no", "maximum", "size", "and", "initially", "containing", "the", "given", "elements", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/collect/MinMaxPriorityQueue.java#L116-L119", "partition": "valid", "up_fun_num": 3, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.base.Preconditions.checkPositionIndex;", "import static com.google.common.base.Preconditions.checkState;", "import static com.google.common.collect.CollectPreconditions.checkRemove;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.annotations.VisibleForTesting;", "import com.google.common.math.IntMath;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import com.google.j2objc.annotations.Weak;", "import com.google.j2objc.annotations.WeakOuter;", "import java.util.AbstractQueue;", "import java.util.ArrayDeque;", "import java.util.ArrayList;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.Comparator;", "import java.util.ConcurrentModificationException;", "import java.util.Iterator;", "import java.util.List;", "import java.util.NoSuchElementException;", "import java.util.PriorityQueue;", "import java.util.Queue;", "import org.checkerframework.checker.nullness.qual.MonotonicNonNull;", "import org.checkerframework.checker.nullness.qual.Nullable;"], "function": ["public final class MinMaxPriorityQueue<E> extends AbstractQueue<E>\n", "    public static <E extends Comparable<E>> MinMaxPriorityQueue<E> create()\n", "    public static <B> Builder<B> orderedBy(Comparator<B> comparator)\n", "    public static Builder<Comparable> expectedSize(int expectedSize)\n", "    public static Builder<Comparable> maximumSize(int maximumSize)\n", "    public int size()\n", "    public boolean add(E element)\n", "    public boolean addAll(Collection<? extends E> newElements)\n", "    public boolean offer(E element)\n", "    public E poll()\n", "    E elementData(int index)\n", "    public E peek()\n", "    private int getMaxElementIndex()\n", "    public E pollFirst()\n", "    public E removeFirst()\n", "    public E peekFirst()\n", "    public E pollLast()\n", "    public E removeLast()\n", "    public E peekLast()\n", "    MoveDesc<E> removeAt(int index)\n", "    private MoveDesc<E> fillHole(int index, E toTrickle)\n", "    private E removeAndGet(int index)\n", "    private Heap heapForIndex(int i)\n", "    static boolean isEvenLevel(int index)\n", "    boolean isIntact()\n", "    public Iterator<E> iterator()\n", "    public void clear()\n", "    public Object[] toArray()\n", "    public Comparator<? super E> comparator()\n", "    int capacity()\n", "    static int initialQueueSize(\n", "    private void growIfNeeded()\n", "    private int calculateNewCapacity()\n", "    private static int capAtMaximumSize(int queueSize, int maximumSize)\n"], "context": "/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkPositionIndex;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.collect.CollectPreconditions.checkRemove;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.math.IntMath;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.google.j2objc.annotations.Weak;\nimport com.google.j2objc.annotations.WeakOuter;\nimport java.util.AbstractQueue;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.ConcurrentModificationException;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport org.checkerframework.checker.nullness.qual.MonotonicNonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\n/**\n * A double-ended priority queue, which provides constant-time access to both its least element and\n * its greatest element, as determined by the queue's specified comparator. If no comparator is\n * given at creation time, the natural order of elements is used. If no maximum size is given at\n * creation time, the queue is unbounded.\n *\n * <p>Usage example:\n *\n * <pre>{@code\n * MinMaxPriorityQueue<User> users = MinMaxPriorityQueue.orderedBy(userComparator)\n *     .maximumSize(1000)\n *     .create();\n * }</pre>\n *\n * <p>As a {@link Queue} it functions exactly as a {@link PriorityQueue}: its head element -- the\n * implicit target of the methods {@link #peek()}, {@link #poll()} and {@link #remove()} -- is\n * defined as the <i>least</i> element in the queue according to the queue's comparator. But unlike\n * a regular priority queue, the methods {@link #peekLast}, {@link #pollLast} and {@link\n * #removeLast} are also provided, to act on the <i>greatest</i> element in the queue instead.\n *\n * <p>A min-max priority queue can be configured with a maximum size. If so, each time the size of\n * the queue exceeds that value, the queue automatically removes its greatest element according to\n * its comparator (which might be the element that was just added). This is different from\n * conventional bounded queues, which either block or reject new elements when full.\n *\n * <p>This implementation is based on the <a\n * href=\"http://portal.acm.org/citation.cfm?id=6621\">min-max heap</a> developed by Atkinson, et al.\n * Unlike many other double-ended priority queues, it stores elements in a single array, as compact\n * as the traditional heap data structure used in {@link PriorityQueue}.\n *\n * <p>This class is not thread-safe, and does not accept null elements.\n *\n * <p><i>Performance notes:</i>\n *\n * <ul>\n *   <li>If you only access one end of the queue, and do use a maximum size, this class will perform\n *       significantly worse than a {@code PriorityQueue} with manual eviction above the maximum\n *       size. In many cases {@link Ordering#leastOf} may work for your use case with significantly\n *       improved (and asymptotically superior) performance.\n *   <li>The retrieval operations {@link #peek}, {@link #peekFirst}, {@link #peekLast}, {@link\n *       #element}, and {@link #size} are constant-time.\n *   <li>The enqueuing and dequeuing operations ({@link #offer}, {@link #add}, and all the forms of\n *       {@link #poll} and {@link #remove()}) run in {@code O(log n) time}.\n *   <li>The {@link #remove(Object)} and {@link #contains} operations require linear ({@code O(n)})\n *       time.\n *   <li>If you only access one end of the queue, and don't use a maximum size, this class is\n *       functionally equivalent to {@link PriorityQueue}, but significantly slower.\n * </ul>\n *\n * @author Sverre Sundsdal\n * @author Torbjorn Gannholm\n * @since 8.0\n */\n@Beta\n@GwtCompatible\npublic final class MinMaxPriorityQueue<E> extends AbstractQueue<E>\n{\n\n    /**\n     * Creates a new min-max priority queue with default settings: natural order, no maximum size, no\n     * initial contents, and an initial expected size of 11.\n     */\n    public static <E extends Comparable<E>> MinMaxPriorityQueue<E> create()\n    {\n        return new Builder<Comparable>(Ordering.natural()).create();\n    }\n\n    /**\n     * Creates a new min-max priority queue using natural order, no maximum size, and initially\n     * containing the given elements.\n     */\n\n    /**\n     * Creates and returns a new builder, configured to build {@code MinMaxPriorityQueue} instances\n     * that use {@code comparator} to determine the least and greatest elements.\n     */\n    public static <B> Builder<B> orderedBy(Comparator<B> comparator)\n    {\n        return new Builder<B>(comparator);\n    }\n\n    /**\n     * Creates and returns a new builder, configured to build {@code MinMaxPriorityQueue} instances\n     * sized appropriately to hold {@code expectedSize} elements.\n     */\n    public static Builder<Comparable> expectedSize(int expectedSize)\n    {\n        return new Builder<Comparable>(Ordering.natural()).expectedSize(expectedSize);\n    }\n\n    /**\n     * Creates and returns a new builder, configured to build {@code MinMaxPriorityQueue} instances\n     * that are limited to {@code maximumSize} elements. Each time a queue grows beyond this bound, it\n     * immediately removes its greatest element (according to its comparator), which might be the\n     * element that was just added.\n     */\n    public static Builder<Comparable> maximumSize(int maximumSize)\n    {\n        return new Builder<Comparable>(Ordering.natural()).maximumSize(maximumSize);\n    }\n\n    /**\n     * The builder class used in creation of min-max priority queues. Instead of constructing one\n     * directly, use {@link MinMaxPriorityQueue#orderedBy(Comparator)}, {@link\n     * MinMaxPriorityQueue#expectedSize(int)} or {@link MinMaxPriorityQueue#maximumSize(int)}.\n     *\n     * @param <B> the upper bound on the eventual type that can be produced by this builder (for\n     *     example, a {@code Builder<Number>} can produce a {@code Queue<Number>} or {@code\n     *     Queue<Integer>} but not a {@code Queue<Object>}).\n     * @since 8.0\n     */\n    @Beta\n    public static final class Builder<B>\n    {\n        /*\n         * TODO(kevinb): when the dust settles, see if we still need this or can\n         * just default to DEFAULT_CAPACITY.\n         */\n        private static final int UNSET_EXPECTED_SIZE = -1;\n\n        private final Comparator<B> comparator;\n        private int expectedSize = UNSET_EXPECTED_SIZE;\n        private int maximumSize = Integer.MAX_VALUE;\n\n        private Builder(Comparator<B> comparator)\n        {\n            this.comparator = checkNotNull(comparator);\n        }\n\n        /**\n         * Configures this builder to build min-max priority queues with an initial expected size of\n         * {@code expectedSize}.\n         */\n        @CanIgnoreReturnValue\n        public Builder<B> expectedSize(int expectedSize)\n        {\n            checkArgument(expectedSize >= 0);\n            this.expectedSize = expectedSize;\n            return this;\n        }\n\n        /**\n         * Configures this builder to build {@code MinMaxPriorityQueue} instances that are limited to\n         * {@code maximumSize} elements. Each time a queue grows beyond this bound, it immediately\n         * removes its greatest element (according to its comparator), which might be the element that\n         * was just added.\n         */\n        @CanIgnoreReturnValue\n        public Builder<B> maximumSize(int maximumSize)\n        {\n            checkArgument(maximumSize > 0);\n            this.maximumSize = maximumSize;\n            return this;\n        }\n\n        /**\n         * Builds a new min-max priority queue using the previously specified options, and having no\n         * initial contents.\n         */\n        public <T extends B> MinMaxPriorityQueue<T> create()\n        {\n            return create(Collections.<T>emptySet());\n        }\n\n        /**\n         * Builds a new min-max priority queue using the previously specified options, and having the\n         * given initial elements.\n         */\n        public <T extends B> MinMaxPriorityQueue<T> create(Iterable<? extends T> initialContents)\n        {\n            MinMaxPriorityQueue<T> queue =\n                new MinMaxPriorityQueue<T>(\n                this, initialQueueSize(expectedSize, maximumSize, initialContents));\n            for (T element : initialContents)\n            {\n                queue.offer(element);\n            }\n            return queue;\n        }\n\n        @SuppressWarnings(\"unchecked\") // safe \"contravariant cast\"\n        private <T extends B> Ordering<T> ordering()\n        {\n            return Ordering.from((Comparator<T>) comparator);\n        }\n    }\n\n    private final Heap minHeap;\n    private final Heap maxHeap;\n    @VisibleForTesting final int maximumSize;\n    private Object[] queue;\n    private int size;\n    private int modCount;\n\n    private MinMaxPriorityQueue(Builder<? super E> builder, int queueSize)\n    {\n        Ordering<E> ordering = builder.ordering();\n        this.minHeap = new Heap(ordering);\n        this.maxHeap = new Heap(ordering.reverse());\n        minHeap.otherHeap = maxHeap;\n        maxHeap.otherHeap = minHeap;\n\n        this.maximumSize = builder.maximumSize;\n        // TODO(kevinb): pad?\n        this.queue = new Object[queueSize];\n    }\n\n    @Override\n    public int size()\n    {\n        return size;\n    }\n\n    /**\n     * Adds the given element to this queue. If this queue has a maximum size, after adding {@code\n     * element} the queue will automatically evict its greatest element (according to its comparator),\n     * which may be {@code element} itself.\n     *\n     * @return {@code true} always\n     */\n    @CanIgnoreReturnValue\n    @Override\n    public boolean add(E element)\n    {\n        offer(element);\n        return true;\n    }\n\n    @CanIgnoreReturnValue\n    @Override\n    public boolean addAll(Collection<? extends E> newElements)\n    {\n        boolean modified = false;\n        for (E element : newElements)\n        {\n            offer(element);\n            modified = true;\n        }\n        return modified;\n    }\n\n    /**\n     * Adds the given element to this queue. If this queue has a maximum size, after adding {@code\n     * element} the queue will automatically evict its greatest element (according to its comparator),\n     * which may be {@code element} itself.\n     */\n    @CanIgnoreReturnValue\n    @Override\n    public boolean offer(E element)\n    {\n        checkNotNull(element);\n        modCount++;\n        int insertIndex = size++;\n\n        growIfNeeded();\n\n        // Adds the element to the end of the heap and bubbles it up to the correct\n        // position.\n        heapForIndex(insertIndex).bubbleUp(insertIndex, element);\n        return size <= maximumSize || pollLast() != element;\n    }\n\n    @CanIgnoreReturnValue\n    @Override\n    public E poll()\n    {\n        return isEmpty() ? null : removeAndGet(0);\n    }\n\n    @SuppressWarnings(\"unchecked\") // we must carefully only allow Es to get in\n    E elementData(int index)\n    {\n        return (E) queue[index];\n    }\n\n    @Override\n    public E peek()\n    {\n        return isEmpty() ? null : elementData(0);\n    }\n\n    /** Returns the index of the max element. */\n    private int getMaxElementIndex()\n    {\n        switch (size)\n        {\n        case 1:\n            return 0; // The lone element in the queue is the maximum.\n        case 2:\n            return 1; // The lone element in the maxHeap is the maximum.\n        default:\n            // The max element must sit on the first level of the maxHeap. It is\n            // actually the *lesser* of the two from the maxHeap's perspective.\n            return (maxHeap.compareElements(1, 2) <= 0) ? 1 : 2;\n        }\n    }\n\n    /**\n     * Removes and returns the least element of this queue, or returns {@code null} if the queue is\n     * empty.\n     */\n    @CanIgnoreReturnValue\n    public E pollFirst()\n    {\n        return poll();\n    }\n\n    /**\n     * Removes and returns the least element of this queue.\n     *\n     * @throws NoSuchElementException if the queue is empty\n     */\n    @CanIgnoreReturnValue\n    public E removeFirst()\n    {\n        return remove();\n    }\n\n    /**\n     * Retrieves, but does not remove, the least element of this queue, or returns {@code null} if the\n     * queue is empty.\n     */\n    public E peekFirst()\n    {\n        return peek();\n    }\n\n    /**\n     * Removes and returns the greatest element of this queue, or returns {@code null} if the queue is\n     * empty.\n     */\n    @CanIgnoreReturnValue\n    public E pollLast()\n    {\n        return isEmpty() ? null : removeAndGet(getMaxElementIndex());\n    }\n\n    /**\n     * Removes and returns the greatest element of this queue.\n     *\n     * @throws NoSuchElementException if the queue is empty\n     */\n    @CanIgnoreReturnValue\n    public E removeLast()\n    {\n        if (isEmpty())\n        {\n            throw new NoSuchElementException();\n        }\n        return removeAndGet(getMaxElementIndex());\n    }\n\n    /**\n     * Retrieves, but does not remove, the greatest element of this queue, or returns {@code null} if\n     * the queue is empty.\n     */\n    public E peekLast()\n    {\n        return isEmpty() ? null : elementData(getMaxElementIndex());\n    }\n\n    /**\n     * Removes the element at position {@code index}.\n     *\n     * <p>Normally this method leaves the elements at up to {@code index - 1}, inclusive, untouched.\n     * Under these circumstances, it returns {@code null}.\n     *\n     * <p>Occasionally, in order to maintain the heap invariant, it must swap a later element of the\n     * list with one before {@code index}. Under these circumstances it returns a pair of elements as\n     * a {@link MoveDesc}. The first one is the element that was previously at the end of the heap and\n     * is now at some position before {@code index}. The second element is the one that was swapped\n     * down to replace the element at {@code index}. This fact is used by iterator.remove so as to\n     * visit elements during a traversal once and only once.\n     */\n    @VisibleForTesting\n    @CanIgnoreReturnValue\n    MoveDesc<E> removeAt(int index)\n    {\n        checkPositionIndex(index, size);\n        modCount++;\n        size--;\n        if (size == index)\n        {\n            queue[size] = null;\n            return null;\n        }\n        E actualLastElement = elementData(size);\n        int lastElementAt = heapForIndex(size).swapWithConceptuallyLastElement(actualLastElement);\n        if (lastElementAt == index)\n        {\n            // 'actualLastElement' is now at 'lastElementAt', and the element that was at 'lastElementAt'\n            // is now at the end of queue. If that's the element we wanted to remove in the first place,\n            // don't try to (incorrectly) trickle it. Instead, just delete it and we're done.\n            queue[size] = null;\n            return null;\n        }\n        E toTrickle = elementData(size);\n        queue[size] = null;\n        MoveDesc<E> changes = fillHole(index, toTrickle);\n        if (lastElementAt < index)\n        {\n            // Last element is moved to before index, swapped with trickled element.\n            if (changes == null)\n            {\n                // The trickled element is still after index.\n                return new MoveDesc<E>(actualLastElement, toTrickle);\n            }\n            else\n            {\n                // The trickled element is back before index, but the replaced element\n                // has now been moved after index.\n                return new MoveDesc<E>(actualLastElement, changes.replaced);\n            }\n        }\n        // Trickled element was after index to begin with, no adjustment needed.\n        return changes;\n    }\n\n    private MoveDesc<E> fillHole(int index, E toTrickle)\n    {\n        Heap heap = heapForIndex(index);\n        // We consider elementData(index) a \"hole\", and we want to fill it\n        // with the last element of the heap, toTrickle.\n        // Since the last element of the heap is from the bottom level, we\n        // optimistically fill index position with elements from lower levels,\n        // moving the hole down. In most cases this reduces the number of\n        // comparisons with toTrickle, but in some cases we will need to bubble it\n        // all the way up again.\n        int vacated = heap.fillHoleAt(index);\n        // Try to see if toTrickle can be bubbled up min levels.\n        int bubbledTo = heap.bubbleUpAlternatingLevels(vacated, toTrickle);\n        if (bubbledTo == vacated)\n        {\n            // Could not bubble toTrickle up min levels, try moving\n            // it from min level to max level (or max to min level) and bubble up\n            // there.\n            return heap.tryCrossOverAndBubbleUp(index, vacated, toTrickle);\n        }\n        else\n        {\n            return (bubbledTo < index) ? new MoveDesc<E>(toTrickle, elementData(index)) : null;\n        }\n    }\n\n    // Returned from removeAt() to iterator.remove()\n    static class MoveDesc<E>\n    {\n        final E toTrickle;\n        final E replaced;\n\n        MoveDesc(E toTrickle, E replaced)\n        {\n            this.toTrickle = toTrickle;\n            this.replaced = replaced;\n        }\n    }\n\n    /** Removes and returns the value at {@code index}. */\n    private E removeAndGet(int index)\n    {\n        E value = elementData(index);\n        removeAt(index);\n        return value;\n    }\n\n    private Heap heapForIndex(int i)\n    {\n        return isEvenLevel(i) ? minHeap : maxHeap;\n    }\n\n    private static final int EVEN_POWERS_OF_TWO = 0x55555555;\n    private static final int ODD_POWERS_OF_TWO = 0xaaaaaaaa;\n\n    @VisibleForTesting\n    static boolean isEvenLevel(int index)\n    {\n        int oneBased = ~~(index + 1); // for GWT\n        checkState(oneBased > 0, \"negative index\");\n        return (oneBased & EVEN_POWERS_OF_TWO) > (oneBased & ODD_POWERS_OF_TWO);\n    }\n\n    /**\n     * Returns {@code true} if the MinMax heap structure holds. This is only used in testing.\n     *\n     * <p>TODO(kevinb): move to the test class?\n     */\n    @VisibleForTesting\n    boolean isIntact()\n    {\n        for (int i = 1; i < size; i++)\n        {\n            if (!heapForIndex(i).verifyIndex(i))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Each instance of MinMaxPriortyQueue encapsulates two instances of Heap: a min-heap and a\n     * max-heap. Conceptually, these might each have their own array for storage, but for efficiency's\n     * sake they are stored interleaved on alternate heap levels in the same array (MMPQ.queue).\n     */\n    @WeakOuter\n    private class Heap\n    {\n        final Ordering<E> ordering;\n        @MonotonicNonNull @Weak Heap otherHeap;\n\n        Heap(Ordering<E> ordering)\n        {\n            this.ordering = ordering;\n        }\n\n        int compareElements(int a, int b)\n        {\n            return ordering.compare(elementData(a), elementData(b));\n        }\n\n        /**\n         * Tries to move {@code toTrickle} from a min to a max level and bubble up there. If it moved\n         * before {@code removeIndex} this method returns a pair as described in {@link #removeAt}.\n         */\n        MoveDesc<E> tryCrossOverAndBubbleUp(int removeIndex, int vacated, E toTrickle)\n        {\n            int crossOver = crossOver(vacated, toTrickle);\n            if (crossOver == vacated)\n            {\n                return null;\n            }\n            // Successfully crossed over from min to max.\n            // Bubble up max levels.\n            E parent;\n            // If toTrickle is moved up to a parent of removeIndex, the parent is\n            // placed in removeIndex position. We must return that to the iterator so\n            // that it knows to skip it.\n            if (crossOver < removeIndex)\n            {\n                // We crossed over to the parent level in crossOver, so the parent\n                // has already been moved.\n                parent = elementData(removeIndex);\n            }\n            else\n            {\n                parent = elementData(getParentIndex(removeIndex));\n            }\n            // bubble it up the opposite heap\n            if (otherHeap.bubbleUpAlternatingLevels(crossOver, toTrickle) < removeIndex)\n            {\n                return new MoveDesc<E>(toTrickle, parent);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /** Bubbles a value from {@code index} up the appropriate heap if required. */\n        void bubbleUp(int index, E x)\n        {\n            int crossOver = crossOverUp(index, x);\n\n            Heap heap;\n            if (crossOver == index)\n            {\n                heap = this;\n            }\n            else\n            {\n                index = crossOver;\n                heap = otherHeap;\n            }\n            heap.bubbleUpAlternatingLevels(index, x);\n        }\n\n        /**\n         * Bubbles a value from {@code index} up the levels of this heap, and returns the index the\n         * element ended up at.\n         */\n        @CanIgnoreReturnValue\n        int bubbleUpAlternatingLevels(int index, E x)\n        {\n            while (index > 2)\n            {\n                int grandParentIndex = getGrandparentIndex(index);\n                E e = elementData(grandParentIndex);\n                if (ordering.compare(e, x) <= 0)\n                {\n                    break;\n                }\n                queue[index] = e;\n                index = grandParentIndex;\n            }\n            queue[index] = x;\n            return index;\n        }\n\n        /**\n         * Returns the index of minimum value between {@code index} and {@code index + len}, or {@code\n         * -1} if {@code index} is greater than {@code size}.\n         */\n        int findMin(int index, int len)\n        {\n            if (index >= size)\n            {\n                return -1;\n            }\n            checkState(index > 0);\n            int limit = Math.min(index, size - len) + len;\n            int minIndex = index;\n            for (int i = index + 1; i < limit; i++)\n            {\n                if (compareElements(i, minIndex) < 0)\n                {\n                    minIndex = i;\n                }\n            }\n            return minIndex;\n        }\n\n        /** Returns the minimum child or {@code -1} if no child exists. */\n        int findMinChild(int index)\n        {\n            return findMin(getLeftChildIndex(index), 2);\n        }\n\n        /** Returns the minimum grand child or -1 if no grand child exists. */\n        int findMinGrandChild(int index)\n        {\n            int leftChildIndex = getLeftChildIndex(index);\n            if (leftChildIndex < 0)\n            {\n                return -1;\n            }\n            return findMin(getLeftChildIndex(leftChildIndex), 4);\n        }\n\n        /**\n         * Moves an element one level up from a min level to a max level (or vice versa). Returns the\n         * new position of the element.\n         */\n        int crossOverUp(int index, E x)\n        {\n            if (index == 0)\n            {\n                queue[0] = x;\n                return 0;\n            }\n            int parentIndex = getParentIndex(index);\n            E parentElement = elementData(parentIndex);\n            if (parentIndex != 0)\n            {\n                // This is a guard for the case of the childless uncle.\n                // Since the end of the array is actually the middle of the heap,\n                // a smaller childless uncle can become a child of x when we\n                // bubble up alternate levels, violating the invariant.\n                int grandparentIndex = getParentIndex(parentIndex);\n                int uncleIndex = getRightChildIndex(grandparentIndex);\n                if (uncleIndex != parentIndex && getLeftChildIndex(uncleIndex) >= size)\n                {\n                    E uncleElement = elementData(uncleIndex);\n                    if (ordering.compare(uncleElement, parentElement) < 0)\n                    {\n                        parentIndex = uncleIndex;\n                        parentElement = uncleElement;\n                    }\n                }\n            }\n            if (ordering.compare(parentElement, x) < 0)\n            {\n                queue[index] = parentElement;\n                queue[parentIndex] = x;\n                return parentIndex;\n            }\n            queue[index] = x;\n            return index;\n        }\n\n        /**\n         * Swap {@code actualLastElement} with the conceptually correct last element of the heap.\n         * Returns the index that {@code actualLastElement} now resides in.\n         *\n         * <p>Since the last element of the array is actually in the middle of the sorted structure, a\n         * childless uncle node could be smaller, which would corrupt the invariant if this element\n         * becomes the new parent of the uncle. In that case, we first switch the last element with its\n         * uncle, before returning.\n         */\n        int swapWithConceptuallyLastElement(E actualLastElement)\n        {\n            int parentIndex = getParentIndex(size);\n            if (parentIndex != 0)\n            {\n                int grandparentIndex = getParentIndex(parentIndex);\n                int uncleIndex = getRightChildIndex(grandparentIndex);\n                if (uncleIndex != parentIndex && getLeftChildIndex(uncleIndex) >= size)\n                {\n                    E uncleElement = elementData(uncleIndex);\n                    if (ordering.compare(uncleElement, actualLastElement) < 0)\n                    {\n                        queue[uncleIndex] = actualLastElement;\n                        queue[size] = uncleElement;\n                        return uncleIndex;\n                    }\n                }\n            }\n            return size;\n        }\n\n        /**\n         * Crosses an element over to the opposite heap by moving it one level down (or up if there are\n         * no elements below it).\n         *\n         * <p>Returns the new position of the element.\n         */\n        int crossOver(int index, E x)\n        {\n            int minChildIndex = findMinChild(index);\n            // TODO(kevinb): split the && into two if's and move crossOverUp so it's\n            // only called when there's no child.\n            if ((minChildIndex > 0) && (ordering.compare(elementData(minChildIndex), x) < 0))\n            {\n                queue[index] = elementData(minChildIndex);\n                queue[minChildIndex] = x;\n                return minChildIndex;\n            }\n            return crossOverUp(index, x);\n        }\n\n        /**\n         * Fills the hole at {@code index} by moving in the least of its grandchildren to this position,\n         * then recursively filling the new hole created.\n         *\n         * @return the position of the new hole (where the lowest grandchild moved from, that had no\n         *     grandchild to replace it)\n         */\n        int fillHoleAt(int index)\n        {\n            int minGrandchildIndex;\n            while ((minGrandchildIndex = findMinGrandChild(index)) > 0)\n            {\n                queue[index] = elementData(minGrandchildIndex);\n                index = minGrandchildIndex;\n            }\n            return index;\n        }\n\n        private boolean verifyIndex(int i)\n        {\n            if ((getLeftChildIndex(i) < size) && (compareElements(i, getLeftChildIndex(i)) > 0))\n            {\n                return false;\n            }\n            if ((getRightChildIndex(i) < size) && (compareElements(i, getRightChildIndex(i)) > 0))\n            {\n                return false;\n            }\n            if ((i > 0) && (compareElements(i, getParentIndex(i)) > 0))\n            {\n                return false;\n            }\n            if ((i > 2) && (compareElements(getGrandparentIndex(i), i) > 0))\n            {\n                return false;\n            }\n            return true;\n        }\n\n        // These would be static if inner classes could have static members.\n\n        private int getLeftChildIndex(int i)\n        {\n            return i * 2 + 1;\n        }\n\n        private int getRightChildIndex(int i)\n        {\n            return i * 2 + 2;\n        }\n\n        private int getParentIndex(int i)\n        {\n            return (i - 1) / 2;\n        }\n\n        private int getGrandparentIndex(int i)\n        {\n            return getParentIndex(getParentIndex(i)); // (i - 3) / 4\n        }\n    }\n\n    /**\n     * Iterates the elements of the queue in no particular order.\n     *\n     * <p>If the underlying queue is modified during iteration an exception will be thrown.\n     */\n    private class QueueIterator implements Iterator<E>\n    {\n        private int cursor = -1;\n        private int nextCursor = -1;\n        private int expectedModCount = modCount;\n        // The same element is not allowed in both forgetMeNot and skipMe, but duplicates are allowed in\n        // either of them, up to the same multiplicity as the queue.\n        @MonotonicNonNull private Queue<E> forgetMeNot;\n        @MonotonicNonNull private List<E> skipMe;\n        private @Nullable E lastFromForgetMeNot;\n        private boolean canRemove;\n\n        @Override\n        public boolean hasNext()\n        {\n            checkModCount();\n            nextNotInSkipMe(cursor + 1);\n            return (nextCursor < size()) || ((forgetMeNot != null) && !forgetMeNot.isEmpty());\n        }\n\n        @Override\n        public E next()\n        {\n            checkModCount();\n            nextNotInSkipMe(cursor + 1);\n            if (nextCursor < size())\n            {\n                cursor = nextCursor;\n                canRemove = true;\n                return elementData(cursor);\n            }\n            else if (forgetMeNot != null)\n            {\n                cursor = size();\n                lastFromForgetMeNot = forgetMeNot.poll();\n                if (lastFromForgetMeNot != null)\n                {\n                    canRemove = true;\n                    return lastFromForgetMeNot;\n                }\n            }\n            throw new NoSuchElementException(\"iterator moved past last element in queue.\");\n        }\n\n        @Override\n        public void remove()\n        {\n            checkRemove(canRemove);\n            checkModCount();\n            canRemove = false;\n            expectedModCount++;\n            if (cursor < size())\n            {\n                MoveDesc<E> moved = removeAt(cursor);\n                if (moved != null)\n                {\n                    if (forgetMeNot == null)\n                    {\n                        forgetMeNot = new ArrayDeque<E>();\n                        skipMe = new ArrayList<E>(3);\n                    }\n                    if (!foundAndRemovedExactReference(skipMe, moved.toTrickle))\n                    {\n                        forgetMeNot.add(moved.toTrickle);\n                    }\n                    if (!foundAndRemovedExactReference(forgetMeNot, moved.replaced))\n                    {\n                        skipMe.add(moved.replaced);\n                    }\n                }\n                cursor--;\n                nextCursor--;\n            }\n            else     // we must have set lastFromForgetMeNot in next()\n            {\n                checkState(removeExact(lastFromForgetMeNot));\n                lastFromForgetMeNot = null;\n            }\n        }\n\n        /** Returns true if an exact reference (==) was found and removed from the supplied iterable. */\n        private boolean foundAndRemovedExactReference(Iterable<E> elements, E target)\n        {\n            for (Iterator<E> it = elements.iterator(); it.hasNext(); )\n            {\n                E element = it.next();\n                if (element == target)\n                {\n                    it.remove();\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /** Removes only this exact instance, not others that are equals() */\n        private boolean removeExact(Object target)\n        {\n            for (int i = 0; i < size; i++)\n            {\n                if (queue[i] == target)\n                {\n                    removeAt(i);\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private void checkModCount()\n        {\n            if (modCount != expectedModCount)\n            {\n                throw new ConcurrentModificationException();\n            }\n        }\n\n        /**\n         * Advances nextCursor to the index of the first element after {@code c} that is not in {@code\n         * skipMe} and returns {@code size()} if there is no such element.\n         */\n        private void nextNotInSkipMe(int c)\n        {\n            if (nextCursor < c)\n            {\n                if (skipMe != null)\n                {\n                    while (c < size() && foundAndRemovedExactReference(skipMe, elementData(c)))\n                    {\n                        c++;\n                    }\n                }\n                nextCursor = c;\n            }\n        }\n    }\n\n    /**\n     * Returns an iterator over the elements contained in this collection, <i>in no particular\n     * order</i>.\n     *\n     * <p>The iterator is <i>fail-fast</i>: If the MinMaxPriorityQueue is modified at any time after\n     * the iterator is created, in any way except through the iterator's own remove method, the\n     * iterator will generally throw a {@link ConcurrentModificationException}. Thus, in the face of\n     * concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary,\n     * non-deterministic behavior at an undetermined time in the future.\n     *\n     * <p>Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally\n     * speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent\n     * modification. Fail-fast iterators throw {@code ConcurrentModificationException} on a\n     * best-effort basis. Therefore, it would be wrong to write a program that depended on this\n     * exception for its correctness: <i>the fail-fast behavior of iterators should be used only to\n     * detect bugs.</i>\n     *\n     * @return an iterator over the elements contained in this collection\n     */\n    @Override\n    public Iterator<E> iterator()\n    {\n        return new QueueIterator();\n    }\n\n    @Override\n    public void clear()\n    {\n        for (int i = 0; i < size; i++)\n        {\n            queue[i] = null;\n        }\n        size = 0;\n    }\n\n    @Override\n    public Object[] toArray()\n    {\n        Object[] copyTo = new Object[size];\n        System.arraycopy(queue, 0, copyTo, 0, size);\n        return copyTo;\n    }\n\n    /**\n     * Returns the comparator used to order the elements in this queue. Obeys the general contract of\n     * {@link PriorityQueue#comparator}, but returns {@link Ordering#natural} instead of {@code null}\n     * to indicate natural ordering.\n     */\n    public Comparator<? super E> comparator()\n    {\n        return minHeap.ordering;\n    }\n\n    @VisibleForTesting\n    int capacity()\n    {\n        return queue.length;\n    }\n\n    // Size/capacity-related methods\n\n    private static final int DEFAULT_CAPACITY = 11;\n\n    @VisibleForTesting\n    static int initialQueueSize(\n        int configuredExpectedSize, int maximumSize, Iterable<?> initialContents)\n    {\n        // Start with what they said, if they said it, otherwise DEFAULT_CAPACITY\n        int result =\n            (configuredExpectedSize == Builder.UNSET_EXPECTED_SIZE)\n            ? DEFAULT_CAPACITY\n            : configuredExpectedSize;\n\n        // Enlarge to contain initial contents\n        if (initialContents instanceof Collection)\n        {\n            int initialSize = ((Collection<?>) initialContents).size();\n            result = Math.max(result, initialSize);\n        }\n\n        // Now cap it at maxSize + 1\n        return capAtMaximumSize(result, maximumSize);\n    }\n\n    private void growIfNeeded()\n    {\n        if (size > queue.length)\n        {\n            int newCapacity = calculateNewCapacity();\n            Object[] newQueue = new Object[newCapacity];\n            System.arraycopy(queue, 0, newQueue, 0, queue.length);\n            queue = newQueue;\n        }\n    }\n\n    /** Returns ~2x the old capacity if small; ~1.5x otherwise. */\n    private int calculateNewCapacity()\n    {\n        int oldCapacity = queue.length;\n        int newCapacity =\n            (oldCapacity < 64) ? (oldCapacity + 1) * 2 : IntMath.checkedMultiply(oldCapacity / 2, 3);\n        return capAtMaximumSize(newCapacity, maximumSize);\n    }\n\n    /** There's no reason for the queueSize to ever be more than maxSize + 1 */\n    private static int capAtMaximumSize(int queueSize, int maximumSize)\n    {\n        return Math.min(queueSize - 1, maximumSize) + 1; // don't overflow\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/collect/MinMaxPriorityQueue.java", "func_name": "MinMaxPriorityQueue.calculateNewCapacity", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns ~2x the old capacity if small; ~1.5x otherwise.", "docstring_tokens": ["Returns", "~2x", "the", "old", "capacity", "if", "small", ";", "~1", ".", "5x", "otherwise", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/collect/MinMaxPriorityQueue.java#L945-L950", "partition": "valid", "up_fun_num": 34, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.base.Preconditions.checkPositionIndex;", "import static com.google.common.base.Preconditions.checkState;", "import static com.google.common.collect.CollectPreconditions.checkRemove;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.annotations.VisibleForTesting;", "import com.google.common.math.IntMath;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import com.google.j2objc.annotations.Weak;", "import com.google.j2objc.annotations.WeakOuter;", "import java.util.AbstractQueue;", "import java.util.ArrayDeque;", "import java.util.ArrayList;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.Comparator;", "import java.util.ConcurrentModificationException;", "import java.util.Iterator;", "import java.util.List;", "import java.util.NoSuchElementException;", "import java.util.PriorityQueue;", "import java.util.Queue;", "import org.checkerframework.checker.nullness.qual.MonotonicNonNull;", "import org.checkerframework.checker.nullness.qual.Nullable;"], "function": ["public final class MinMaxPriorityQueue<E> extends AbstractQueue<E>\n", "    public static <E extends Comparable<E>> MinMaxPriorityQueue<E> create()\n", "    public static <E extends Comparable<E>> MinMaxPriorityQueue<E> create(\n", "    public static <B> Builder<B> orderedBy(Comparator<B> comparator)\n", "    public static Builder<Comparable> expectedSize(int expectedSize)\n", "    public static Builder<Comparable> maximumSize(int maximumSize)\n", "    public int size()\n", "    public boolean add(E element)\n", "    public boolean addAll(Collection<? extends E> newElements)\n", "    public boolean offer(E element)\n", "    public E poll()\n", "    E elementData(int index)\n", "    public E peek()\n", "    private int getMaxElementIndex()\n", "    public E pollFirst()\n", "    public E removeFirst()\n", "    public E peekFirst()\n", "    public E pollLast()\n", "    public E removeLast()\n", "    public E peekLast()\n", "    MoveDesc<E> removeAt(int index)\n", "    private MoveDesc<E> fillHole(int index, E toTrickle)\n", "    private E removeAndGet(int index)\n", "    private Heap heapForIndex(int i)\n", "    static boolean isEvenLevel(int index)\n", "    boolean isIntact()\n", "    public Iterator<E> iterator()\n", "    public void clear()\n", "    public Object[] toArray()\n", "    public Comparator<? super E> comparator()\n", "    int capacity()\n", "    static int initialQueueSize(\n", "    private void growIfNeeded()\n", "    private static int capAtMaximumSize(int queueSize, int maximumSize)\n"], "context": "/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkPositionIndex;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.collect.CollectPreconditions.checkRemove;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.math.IntMath;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.google.j2objc.annotations.Weak;\nimport com.google.j2objc.annotations.WeakOuter;\nimport java.util.AbstractQueue;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.ConcurrentModificationException;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport org.checkerframework.checker.nullness.qual.MonotonicNonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\n/**\n * A double-ended priority queue, which provides constant-time access to both its least element and\n * its greatest element, as determined by the queue's specified comparator. If no comparator is\n * given at creation time, the natural order of elements is used. If no maximum size is given at\n * creation time, the queue is unbounded.\n *\n * <p>Usage example:\n *\n * <pre>{@code\n * MinMaxPriorityQueue<User> users = MinMaxPriorityQueue.orderedBy(userComparator)\n *     .maximumSize(1000)\n *     .create();\n * }</pre>\n *\n * <p>As a {@link Queue} it functions exactly as a {@link PriorityQueue}: its head element -- the\n * implicit target of the methods {@link #peek()}, {@link #poll()} and {@link #remove()} -- is\n * defined as the <i>least</i> element in the queue according to the queue's comparator. But unlike\n * a regular priority queue, the methods {@link #peekLast}, {@link #pollLast} and {@link\n * #removeLast} are also provided, to act on the <i>greatest</i> element in the queue instead.\n *\n * <p>A min-max priority queue can be configured with a maximum size. If so, each time the size of\n * the queue exceeds that value, the queue automatically removes its greatest element according to\n * its comparator (which might be the element that was just added). This is different from\n * conventional bounded queues, which either block or reject new elements when full.\n *\n * <p>This implementation is based on the <a\n * href=\"http://portal.acm.org/citation.cfm?id=6621\">min-max heap</a> developed by Atkinson, et al.\n * Unlike many other double-ended priority queues, it stores elements in a single array, as compact\n * as the traditional heap data structure used in {@link PriorityQueue}.\n *\n * <p>This class is not thread-safe, and does not accept null elements.\n *\n * <p><i>Performance notes:</i>\n *\n * <ul>\n *   <li>If you only access one end of the queue, and do use a maximum size, this class will perform\n *       significantly worse than a {@code PriorityQueue} with manual eviction above the maximum\n *       size. In many cases {@link Ordering#leastOf} may work for your use case with significantly\n *       improved (and asymptotically superior) performance.\n *   <li>The retrieval operations {@link #peek}, {@link #peekFirst}, {@link #peekLast}, {@link\n *       #element}, and {@link #size} are constant-time.\n *   <li>The enqueuing and dequeuing operations ({@link #offer}, {@link #add}, and all the forms of\n *       {@link #poll} and {@link #remove()}) run in {@code O(log n) time}.\n *   <li>The {@link #remove(Object)} and {@link #contains} operations require linear ({@code O(n)})\n *       time.\n *   <li>If you only access one end of the queue, and don't use a maximum size, this class is\n *       functionally equivalent to {@link PriorityQueue}, but significantly slower.\n * </ul>\n *\n * @author Sverre Sundsdal\n * @author Torbjorn Gannholm\n * @since 8.0\n */\n@Beta\n@GwtCompatible\npublic final class MinMaxPriorityQueue<E> extends AbstractQueue<E>\n{\n\n    /**\n     * Creates a new min-max priority queue with default settings: natural order, no maximum size, no\n     * initial contents, and an initial expected size of 11.\n     */\n    public static <E extends Comparable<E>> MinMaxPriorityQueue<E> create()\n    {\n        return new Builder<Comparable>(Ordering.natural()).create();\n    }\n\n    /**\n     * Creates a new min-max priority queue using natural order, no maximum size, and initially\n     * containing the given elements.\n     */\n    public static <E extends Comparable<E>> MinMaxPriorityQueue<E> create(\n        Iterable<? extends E> initialContents)\n    {\n        return new Builder<E>(Ordering.<E>natural()).create(initialContents);\n    }\n\n    /**\n     * Creates and returns a new builder, configured to build {@code MinMaxPriorityQueue} instances\n     * that use {@code comparator} to determine the least and greatest elements.\n     */\n    public static <B> Builder<B> orderedBy(Comparator<B> comparator)\n    {\n        return new Builder<B>(comparator);\n    }\n\n    /**\n     * Creates and returns a new builder, configured to build {@code MinMaxPriorityQueue} instances\n     * sized appropriately to hold {@code expectedSize} elements.\n     */\n    public static Builder<Comparable> expectedSize(int expectedSize)\n    {\n        return new Builder<Comparable>(Ordering.natural()).expectedSize(expectedSize);\n    }\n\n    /**\n     * Creates and returns a new builder, configured to build {@code MinMaxPriorityQueue} instances\n     * that are limited to {@code maximumSize} elements. Each time a queue grows beyond this bound, it\n     * immediately removes its greatest element (according to its comparator), which might be the\n     * element that was just added.\n     */\n    public static Builder<Comparable> maximumSize(int maximumSize)\n    {\n        return new Builder<Comparable>(Ordering.natural()).maximumSize(maximumSize);\n    }\n\n    /**\n     * The builder class used in creation of min-max priority queues. Instead of constructing one\n     * directly, use {@link MinMaxPriorityQueue#orderedBy(Comparator)}, {@link\n     * MinMaxPriorityQueue#expectedSize(int)} or {@link MinMaxPriorityQueue#maximumSize(int)}.\n     *\n     * @param <B> the upper bound on the eventual type that can be produced by this builder (for\n     *     example, a {@code Builder<Number>} can produce a {@code Queue<Number>} or {@code\n     *     Queue<Integer>} but not a {@code Queue<Object>}).\n     * @since 8.0\n     */\n    @Beta\n    public static final class Builder<B>\n    {\n        /*\n         * TODO(kevinb): when the dust settles, see if we still need this or can\n         * just default to DEFAULT_CAPACITY.\n         */\n        private static final int UNSET_EXPECTED_SIZE = -1;\n\n        private final Comparator<B> comparator;\n        private int expectedSize = UNSET_EXPECTED_SIZE;\n        private int maximumSize = Integer.MAX_VALUE;\n\n        private Builder(Comparator<B> comparator)\n        {\n            this.comparator = checkNotNull(comparator);\n        }\n\n        /**\n         * Configures this builder to build min-max priority queues with an initial expected size of\n         * {@code expectedSize}.\n         */\n        @CanIgnoreReturnValue\n        public Builder<B> expectedSize(int expectedSize)\n        {\n            checkArgument(expectedSize >= 0);\n            this.expectedSize = expectedSize;\n            return this;\n        }\n\n        /**\n         * Configures this builder to build {@code MinMaxPriorityQueue} instances that are limited to\n         * {@code maximumSize} elements. Each time a queue grows beyond this bound, it immediately\n         * removes its greatest element (according to its comparator), which might be the element that\n         * was just added.\n         */\n        @CanIgnoreReturnValue\n        public Builder<B> maximumSize(int maximumSize)\n        {\n            checkArgument(maximumSize > 0);\n            this.maximumSize = maximumSize;\n            return this;\n        }\n\n        /**\n         * Builds a new min-max priority queue using the previously specified options, and having no\n         * initial contents.\n         */\n        public <T extends B> MinMaxPriorityQueue<T> create()\n        {\n            return create(Collections.<T>emptySet());\n        }\n\n        /**\n         * Builds a new min-max priority queue using the previously specified options, and having the\n         * given initial elements.\n         */\n        public <T extends B> MinMaxPriorityQueue<T> create(Iterable<? extends T> initialContents)\n        {\n            MinMaxPriorityQueue<T> queue =\n                new MinMaxPriorityQueue<T>(\n                this, initialQueueSize(expectedSize, maximumSize, initialContents));\n            for (T element : initialContents)\n            {\n                queue.offer(element);\n            }\n            return queue;\n        }\n\n        @SuppressWarnings(\"unchecked\") // safe \"contravariant cast\"\n        private <T extends B> Ordering<T> ordering()\n        {\n            return Ordering.from((Comparator<T>) comparator);\n        }\n    }\n\n    private final Heap minHeap;\n    private final Heap maxHeap;\n    @VisibleForTesting final int maximumSize;\n    private Object[] queue;\n    private int size;\n    private int modCount;\n\n    private MinMaxPriorityQueue(Builder<? super E> builder, int queueSize)\n    {\n        Ordering<E> ordering = builder.ordering();\n        this.minHeap = new Heap(ordering);\n        this.maxHeap = new Heap(ordering.reverse());\n        minHeap.otherHeap = maxHeap;\n        maxHeap.otherHeap = minHeap;\n\n        this.maximumSize = builder.maximumSize;\n        // TODO(kevinb): pad?\n        this.queue = new Object[queueSize];\n    }\n\n    @Override\n    public int size()\n    {\n        return size;\n    }\n\n    /**\n     * Adds the given element to this queue. If this queue has a maximum size, after adding {@code\n     * element} the queue will automatically evict its greatest element (according to its comparator),\n     * which may be {@code element} itself.\n     *\n     * @return {@code true} always\n     */\n    @CanIgnoreReturnValue\n    @Override\n    public boolean add(E element)\n    {\n        offer(element);\n        return true;\n    }\n\n    @CanIgnoreReturnValue\n    @Override\n    public boolean addAll(Collection<? extends E> newElements)\n    {\n        boolean modified = false;\n        for (E element : newElements)\n        {\n            offer(element);\n            modified = true;\n        }\n        return modified;\n    }\n\n    /**\n     * Adds the given element to this queue. If this queue has a maximum size, after adding {@code\n     * element} the queue will automatically evict its greatest element (according to its comparator),\n     * which may be {@code element} itself.\n     */\n    @CanIgnoreReturnValue\n    @Override\n    public boolean offer(E element)\n    {\n        checkNotNull(element);\n        modCount++;\n        int insertIndex = size++;\n\n        growIfNeeded();\n\n        // Adds the element to the end of the heap and bubbles it up to the correct\n        // position.\n        heapForIndex(insertIndex).bubbleUp(insertIndex, element);\n        return size <= maximumSize || pollLast() != element;\n    }\n\n    @CanIgnoreReturnValue\n    @Override\n    public E poll()\n    {\n        return isEmpty() ? null : removeAndGet(0);\n    }\n\n    @SuppressWarnings(\"unchecked\") // we must carefully only allow Es to get in\n    E elementData(int index)\n    {\n        return (E) queue[index];\n    }\n\n    @Override\n    public E peek()\n    {\n        return isEmpty() ? null : elementData(0);\n    }\n\n    /** Returns the index of the max element. */\n    private int getMaxElementIndex()\n    {\n        switch (size)\n        {\n        case 1:\n            return 0; // The lone element in the queue is the maximum.\n        case 2:\n            return 1; // The lone element in the maxHeap is the maximum.\n        default:\n            // The max element must sit on the first level of the maxHeap. It is\n            // actually the *lesser* of the two from the maxHeap's perspective.\n            return (maxHeap.compareElements(1, 2) <= 0) ? 1 : 2;\n        }\n    }\n\n    /**\n     * Removes and returns the least element of this queue, or returns {@code null} if the queue is\n     * empty.\n     */\n    @CanIgnoreReturnValue\n    public E pollFirst()\n    {\n        return poll();\n    }\n\n    /**\n     * Removes and returns the least element of this queue.\n     *\n     * @throws NoSuchElementException if the queue is empty\n     */\n    @CanIgnoreReturnValue\n    public E removeFirst()\n    {\n        return remove();\n    }\n\n    /**\n     * Retrieves, but does not remove, the least element of this queue, or returns {@code null} if the\n     * queue is empty.\n     */\n    public E peekFirst()\n    {\n        return peek();\n    }\n\n    /**\n     * Removes and returns the greatest element of this queue, or returns {@code null} if the queue is\n     * empty.\n     */\n    @CanIgnoreReturnValue\n    public E pollLast()\n    {\n        return isEmpty() ? null : removeAndGet(getMaxElementIndex());\n    }\n\n    /**\n     * Removes and returns the greatest element of this queue.\n     *\n     * @throws NoSuchElementException if the queue is empty\n     */\n    @CanIgnoreReturnValue\n    public E removeLast()\n    {\n        if (isEmpty())\n        {\n            throw new NoSuchElementException();\n        }\n        return removeAndGet(getMaxElementIndex());\n    }\n\n    /**\n     * Retrieves, but does not remove, the greatest element of this queue, or returns {@code null} if\n     * the queue is empty.\n     */\n    public E peekLast()\n    {\n        return isEmpty() ? null : elementData(getMaxElementIndex());\n    }\n\n    /**\n     * Removes the element at position {@code index}.\n     *\n     * <p>Normally this method leaves the elements at up to {@code index - 1}, inclusive, untouched.\n     * Under these circumstances, it returns {@code null}.\n     *\n     * <p>Occasionally, in order to maintain the heap invariant, it must swap a later element of the\n     * list with one before {@code index}. Under these circumstances it returns a pair of elements as\n     * a {@link MoveDesc}. The first one is the element that was previously at the end of the heap and\n     * is now at some position before {@code index}. The second element is the one that was swapped\n     * down to replace the element at {@code index}. This fact is used by iterator.remove so as to\n     * visit elements during a traversal once and only once.\n     */\n    @VisibleForTesting\n    @CanIgnoreReturnValue\n    MoveDesc<E> removeAt(int index)\n    {\n        checkPositionIndex(index, size);\n        modCount++;\n        size--;\n        if (size == index)\n        {\n            queue[size] = null;\n            return null;\n        }\n        E actualLastElement = elementData(size);\n        int lastElementAt = heapForIndex(size).swapWithConceptuallyLastElement(actualLastElement);\n        if (lastElementAt == index)\n        {\n            // 'actualLastElement' is now at 'lastElementAt', and the element that was at 'lastElementAt'\n            // is now at the end of queue. If that's the element we wanted to remove in the first place,\n            // don't try to (incorrectly) trickle it. Instead, just delete it and we're done.\n            queue[size] = null;\n            return null;\n        }\n        E toTrickle = elementData(size);\n        queue[size] = null;\n        MoveDesc<E> changes = fillHole(index, toTrickle);\n        if (lastElementAt < index)\n        {\n            // Last element is moved to before index, swapped with trickled element.\n            if (changes == null)\n            {\n                // The trickled element is still after index.\n                return new MoveDesc<E>(actualLastElement, toTrickle);\n            }\n            else\n            {\n                // The trickled element is back before index, but the replaced element\n                // has now been moved after index.\n                return new MoveDesc<E>(actualLastElement, changes.replaced);\n            }\n        }\n        // Trickled element was after index to begin with, no adjustment needed.\n        return changes;\n    }\n\n    private MoveDesc<E> fillHole(int index, E toTrickle)\n    {\n        Heap heap = heapForIndex(index);\n        // We consider elementData(index) a \"hole\", and we want to fill it\n        // with the last element of the heap, toTrickle.\n        // Since the last element of the heap is from the bottom level, we\n        // optimistically fill index position with elements from lower levels,\n        // moving the hole down. In most cases this reduces the number of\n        // comparisons with toTrickle, but in some cases we will need to bubble it\n        // all the way up again.\n        int vacated = heap.fillHoleAt(index);\n        // Try to see if toTrickle can be bubbled up min levels.\n        int bubbledTo = heap.bubbleUpAlternatingLevels(vacated, toTrickle);\n        if (bubbledTo == vacated)\n        {\n            // Could not bubble toTrickle up min levels, try moving\n            // it from min level to max level (or max to min level) and bubble up\n            // there.\n            return heap.tryCrossOverAndBubbleUp(index, vacated, toTrickle);\n        }\n        else\n        {\n            return (bubbledTo < index) ? new MoveDesc<E>(toTrickle, elementData(index)) : null;\n        }\n    }\n\n    // Returned from removeAt() to iterator.remove()\n    static class MoveDesc<E>\n    {\n        final E toTrickle;\n        final E replaced;\n\n        MoveDesc(E toTrickle, E replaced)\n        {\n            this.toTrickle = toTrickle;\n            this.replaced = replaced;\n        }\n    }\n\n    /** Removes and returns the value at {@code index}. */\n    private E removeAndGet(int index)\n    {\n        E value = elementData(index);\n        removeAt(index);\n        return value;\n    }\n\n    private Heap heapForIndex(int i)\n    {\n        return isEvenLevel(i) ? minHeap : maxHeap;\n    }\n\n    private static final int EVEN_POWERS_OF_TWO = 0x55555555;\n    private static final int ODD_POWERS_OF_TWO = 0xaaaaaaaa;\n\n    @VisibleForTesting\n    static boolean isEvenLevel(int index)\n    {\n        int oneBased = ~~(index + 1); // for GWT\n        checkState(oneBased > 0, \"negative index\");\n        return (oneBased & EVEN_POWERS_OF_TWO) > (oneBased & ODD_POWERS_OF_TWO);\n    }\n\n    /**\n     * Returns {@code true} if the MinMax heap structure holds. This is only used in testing.\n     *\n     * <p>TODO(kevinb): move to the test class?\n     */\n    @VisibleForTesting\n    boolean isIntact()\n    {\n        for (int i = 1; i < size; i++)\n        {\n            if (!heapForIndex(i).verifyIndex(i))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Each instance of MinMaxPriortyQueue encapsulates two instances of Heap: a min-heap and a\n     * max-heap. Conceptually, these might each have their own array for storage, but for efficiency's\n     * sake they are stored interleaved on alternate heap levels in the same array (MMPQ.queue).\n     */\n    @WeakOuter\n    private class Heap\n    {\n        final Ordering<E> ordering;\n        @MonotonicNonNull @Weak Heap otherHeap;\n\n        Heap(Ordering<E> ordering)\n        {\n            this.ordering = ordering;\n        }\n\n        int compareElements(int a, int b)\n        {\n            return ordering.compare(elementData(a), elementData(b));\n        }\n\n        /**\n         * Tries to move {@code toTrickle} from a min to a max level and bubble up there. If it moved\n         * before {@code removeIndex} this method returns a pair as described in {@link #removeAt}.\n         */\n        MoveDesc<E> tryCrossOverAndBubbleUp(int removeIndex, int vacated, E toTrickle)\n        {\n            int crossOver = crossOver(vacated, toTrickle);\n            if (crossOver == vacated)\n            {\n                return null;\n            }\n            // Successfully crossed over from min to max.\n            // Bubble up max levels.\n            E parent;\n            // If toTrickle is moved up to a parent of removeIndex, the parent is\n            // placed in removeIndex position. We must return that to the iterator so\n            // that it knows to skip it.\n            if (crossOver < removeIndex)\n            {\n                // We crossed over to the parent level in crossOver, so the parent\n                // has already been moved.\n                parent = elementData(removeIndex);\n            }\n            else\n            {\n                parent = elementData(getParentIndex(removeIndex));\n            }\n            // bubble it up the opposite heap\n            if (otherHeap.bubbleUpAlternatingLevels(crossOver, toTrickle) < removeIndex)\n            {\n                return new MoveDesc<E>(toTrickle, parent);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /** Bubbles a value from {@code index} up the appropriate heap if required. */\n        void bubbleUp(int index, E x)\n        {\n            int crossOver = crossOverUp(index, x);\n\n            Heap heap;\n            if (crossOver == index)\n            {\n                heap = this;\n            }\n            else\n            {\n                index = crossOver;\n                heap = otherHeap;\n            }\n            heap.bubbleUpAlternatingLevels(index, x);\n        }\n\n        /**\n         * Bubbles a value from {@code index} up the levels of this heap, and returns the index the\n         * element ended up at.\n         */\n        @CanIgnoreReturnValue\n        int bubbleUpAlternatingLevels(int index, E x)\n        {\n            while (index > 2)\n            {\n                int grandParentIndex = getGrandparentIndex(index);\n                E e = elementData(grandParentIndex);\n                if (ordering.compare(e, x) <= 0)\n                {\n                    break;\n                }\n                queue[index] = e;\n                index = grandParentIndex;\n            }\n            queue[index] = x;\n            return index;\n        }\n\n        /**\n         * Returns the index of minimum value between {@code index} and {@code index + len}, or {@code\n         * -1} if {@code index} is greater than {@code size}.\n         */\n        int findMin(int index, int len)\n        {\n            if (index >= size)\n            {\n                return -1;\n            }\n            checkState(index > 0);\n            int limit = Math.min(index, size - len) + len;\n            int minIndex = index;\n            for (int i = index + 1; i < limit; i++)\n            {\n                if (compareElements(i, minIndex) < 0)\n                {\n                    minIndex = i;\n                }\n            }\n            return minIndex;\n        }\n\n        /** Returns the minimum child or {@code -1} if no child exists. */\n        int findMinChild(int index)\n        {\n            return findMin(getLeftChildIndex(index), 2);\n        }\n\n        /** Returns the minimum grand child or -1 if no grand child exists. */\n        int findMinGrandChild(int index)\n        {\n            int leftChildIndex = getLeftChildIndex(index);\n            if (leftChildIndex < 0)\n            {\n                return -1;\n            }\n            return findMin(getLeftChildIndex(leftChildIndex), 4);\n        }\n\n        /**\n         * Moves an element one level up from a min level to a max level (or vice versa). Returns the\n         * new position of the element.\n         */\n        int crossOverUp(int index, E x)\n        {\n            if (index == 0)\n            {\n                queue[0] = x;\n                return 0;\n            }\n            int parentIndex = getParentIndex(index);\n            E parentElement = elementData(parentIndex);\n            if (parentIndex != 0)\n            {\n                // This is a guard for the case of the childless uncle.\n                // Since the end of the array is actually the middle of the heap,\n                // a smaller childless uncle can become a child of x when we\n                // bubble up alternate levels, violating the invariant.\n                int grandparentIndex = getParentIndex(parentIndex);\n                int uncleIndex = getRightChildIndex(grandparentIndex);\n                if (uncleIndex != parentIndex && getLeftChildIndex(uncleIndex) >= size)\n                {\n                    E uncleElement = elementData(uncleIndex);\n                    if (ordering.compare(uncleElement, parentElement) < 0)\n                    {\n                        parentIndex = uncleIndex;\n                        parentElement = uncleElement;\n                    }\n                }\n            }\n            if (ordering.compare(parentElement, x) < 0)\n            {\n                queue[index] = parentElement;\n                queue[parentIndex] = x;\n                return parentIndex;\n            }\n            queue[index] = x;\n            return index;\n        }\n\n        /**\n         * Swap {@code actualLastElement} with the conceptually correct last element of the heap.\n         * Returns the index that {@code actualLastElement} now resides in.\n         *\n         * <p>Since the last element of the array is actually in the middle of the sorted structure, a\n         * childless uncle node could be smaller, which would corrupt the invariant if this element\n         * becomes the new parent of the uncle. In that case, we first switch the last element with its\n         * uncle, before returning.\n         */\n        int swapWithConceptuallyLastElement(E actualLastElement)\n        {\n            int parentIndex = getParentIndex(size);\n            if (parentIndex != 0)\n            {\n                int grandparentIndex = getParentIndex(parentIndex);\n                int uncleIndex = getRightChildIndex(grandparentIndex);\n                if (uncleIndex != parentIndex && getLeftChildIndex(uncleIndex) >= size)\n                {\n                    E uncleElement = elementData(uncleIndex);\n                    if (ordering.compare(uncleElement, actualLastElement) < 0)\n                    {\n                        queue[uncleIndex] = actualLastElement;\n                        queue[size] = uncleElement;\n                        return uncleIndex;\n                    }\n                }\n            }\n            return size;\n        }\n\n        /**\n         * Crosses an element over to the opposite heap by moving it one level down (or up if there are\n         * no elements below it).\n         *\n         * <p>Returns the new position of the element.\n         */\n        int crossOver(int index, E x)\n        {\n            int minChildIndex = findMinChild(index);\n            // TODO(kevinb): split the && into two if's and move crossOverUp so it's\n            // only called when there's no child.\n            if ((minChildIndex > 0) && (ordering.compare(elementData(minChildIndex), x) < 0))\n            {\n                queue[index] = elementData(minChildIndex);\n                queue[minChildIndex] = x;\n                return minChildIndex;\n            }\n            return crossOverUp(index, x);\n        }\n\n        /**\n         * Fills the hole at {@code index} by moving in the least of its grandchildren to this position,\n         * then recursively filling the new hole created.\n         *\n         * @return the position of the new hole (where the lowest grandchild moved from, that had no\n         *     grandchild to replace it)\n         */\n        int fillHoleAt(int index)\n        {\n            int minGrandchildIndex;\n            while ((minGrandchildIndex = findMinGrandChild(index)) > 0)\n            {\n                queue[index] = elementData(minGrandchildIndex);\n                index = minGrandchildIndex;\n            }\n            return index;\n        }\n\n        private boolean verifyIndex(int i)\n        {\n            if ((getLeftChildIndex(i) < size) && (compareElements(i, getLeftChildIndex(i)) > 0))\n            {\n                return false;\n            }\n            if ((getRightChildIndex(i) < size) && (compareElements(i, getRightChildIndex(i)) > 0))\n            {\n                return false;\n            }\n            if ((i > 0) && (compareElements(i, getParentIndex(i)) > 0))\n            {\n                return false;\n            }\n            if ((i > 2) && (compareElements(getGrandparentIndex(i), i) > 0))\n            {\n                return false;\n            }\n            return true;\n        }\n\n        // These would be static if inner classes could have static members.\n\n        private int getLeftChildIndex(int i)\n        {\n            return i * 2 + 1;\n        }\n\n        private int getRightChildIndex(int i)\n        {\n            return i * 2 + 2;\n        }\n\n        private int getParentIndex(int i)\n        {\n            return (i - 1) / 2;\n        }\n\n        private int getGrandparentIndex(int i)\n        {\n            return getParentIndex(getParentIndex(i)); // (i - 3) / 4\n        }\n    }\n\n    /**\n     * Iterates the elements of the queue in no particular order.\n     *\n     * <p>If the underlying queue is modified during iteration an exception will be thrown.\n     */\n    private class QueueIterator implements Iterator<E>\n    {\n        private int cursor = -1;\n        private int nextCursor = -1;\n        private int expectedModCount = modCount;\n        // The same element is not allowed in both forgetMeNot and skipMe, but duplicates are allowed in\n        // either of them, up to the same multiplicity as the queue.\n        @MonotonicNonNull private Queue<E> forgetMeNot;\n        @MonotonicNonNull private List<E> skipMe;\n        private @Nullable E lastFromForgetMeNot;\n        private boolean canRemove;\n\n        @Override\n        public boolean hasNext()\n        {\n            checkModCount();\n            nextNotInSkipMe(cursor + 1);\n            return (nextCursor < size()) || ((forgetMeNot != null) && !forgetMeNot.isEmpty());\n        }\n\n        @Override\n        public E next()\n        {\n            checkModCount();\n            nextNotInSkipMe(cursor + 1);\n            if (nextCursor < size())\n            {\n                cursor = nextCursor;\n                canRemove = true;\n                return elementData(cursor);\n            }\n            else if (forgetMeNot != null)\n            {\n                cursor = size();\n                lastFromForgetMeNot = forgetMeNot.poll();\n                if (lastFromForgetMeNot != null)\n                {\n                    canRemove = true;\n                    return lastFromForgetMeNot;\n                }\n            }\n            throw new NoSuchElementException(\"iterator moved past last element in queue.\");\n        }\n\n        @Override\n        public void remove()\n        {\n            checkRemove(canRemove);\n            checkModCount();\n            canRemove = false;\n            expectedModCount++;\n            if (cursor < size())\n            {\n                MoveDesc<E> moved = removeAt(cursor);\n                if (moved != null)\n                {\n                    if (forgetMeNot == null)\n                    {\n                        forgetMeNot = new ArrayDeque<E>();\n                        skipMe = new ArrayList<E>(3);\n                    }\n                    if (!foundAndRemovedExactReference(skipMe, moved.toTrickle))\n                    {\n                        forgetMeNot.add(moved.toTrickle);\n                    }\n                    if (!foundAndRemovedExactReference(forgetMeNot, moved.replaced))\n                    {\n                        skipMe.add(moved.replaced);\n                    }\n                }\n                cursor--;\n                nextCursor--;\n            }\n            else     // we must have set lastFromForgetMeNot in next()\n            {\n                checkState(removeExact(lastFromForgetMeNot));\n                lastFromForgetMeNot = null;\n            }\n        }\n\n        /** Returns true if an exact reference (==) was found and removed from the supplied iterable. */\n        private boolean foundAndRemovedExactReference(Iterable<E> elements, E target)\n        {\n            for (Iterator<E> it = elements.iterator(); it.hasNext(); )\n            {\n                E element = it.next();\n                if (element == target)\n                {\n                    it.remove();\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /** Removes only this exact instance, not others that are equals() */\n        private boolean removeExact(Object target)\n        {\n            for (int i = 0; i < size; i++)\n            {\n                if (queue[i] == target)\n                {\n                    removeAt(i);\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private void checkModCount()\n        {\n            if (modCount != expectedModCount)\n            {\n                throw new ConcurrentModificationException();\n            }\n        }\n\n        /**\n         * Advances nextCursor to the index of the first element after {@code c} that is not in {@code\n         * skipMe} and returns {@code size()} if there is no such element.\n         */\n        private void nextNotInSkipMe(int c)\n        {\n            if (nextCursor < c)\n            {\n                if (skipMe != null)\n                {\n                    while (c < size() && foundAndRemovedExactReference(skipMe, elementData(c)))\n                    {\n                        c++;\n                    }\n                }\n                nextCursor = c;\n            }\n        }\n    }\n\n    /**\n     * Returns an iterator over the elements contained in this collection, <i>in no particular\n     * order</i>.\n     *\n     * <p>The iterator is <i>fail-fast</i>: If the MinMaxPriorityQueue is modified at any time after\n     * the iterator is created, in any way except through the iterator's own remove method, the\n     * iterator will generally throw a {@link ConcurrentModificationException}. Thus, in the face of\n     * concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary,\n     * non-deterministic behavior at an undetermined time in the future.\n     *\n     * <p>Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally\n     * speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent\n     * modification. Fail-fast iterators throw {@code ConcurrentModificationException} on a\n     * best-effort basis. Therefore, it would be wrong to write a program that depended on this\n     * exception for its correctness: <i>the fail-fast behavior of iterators should be used only to\n     * detect bugs.</i>\n     *\n     * @return an iterator over the elements contained in this collection\n     */\n    @Override\n    public Iterator<E> iterator()\n    {\n        return new QueueIterator();\n    }\n\n    @Override\n    public void clear()\n    {\n        for (int i = 0; i < size; i++)\n        {\n            queue[i] = null;\n        }\n        size = 0;\n    }\n\n    @Override\n    public Object[] toArray()\n    {\n        Object[] copyTo = new Object[size];\n        System.arraycopy(queue, 0, copyTo, 0, size);\n        return copyTo;\n    }\n\n    /**\n     * Returns the comparator used to order the elements in this queue. Obeys the general contract of\n     * {@link PriorityQueue#comparator}, but returns {@link Ordering#natural} instead of {@code null}\n     * to indicate natural ordering.\n     */\n    public Comparator<? super E> comparator()\n    {\n        return minHeap.ordering;\n    }\n\n    @VisibleForTesting\n    int capacity()\n    {\n        return queue.length;\n    }\n\n    // Size/capacity-related methods\n\n    private static final int DEFAULT_CAPACITY = 11;\n\n    @VisibleForTesting\n    static int initialQueueSize(\n        int configuredExpectedSize, int maximumSize, Iterable<?> initialContents)\n    {\n        // Start with what they said, if they said it, otherwise DEFAULT_CAPACITY\n        int result =\n            (configuredExpectedSize == Builder.UNSET_EXPECTED_SIZE)\n            ? DEFAULT_CAPACITY\n            : configuredExpectedSize;\n\n        // Enlarge to contain initial contents\n        if (initialContents instanceof Collection)\n        {\n            int initialSize = ((Collection<?>) initialContents).size();\n            result = Math.max(result, initialSize);\n        }\n\n        // Now cap it at maxSize + 1\n        return capAtMaximumSize(result, maximumSize);\n    }\n\n    private void growIfNeeded()\n    {\n        if (size > queue.length)\n        {\n            int newCapacity = calculateNewCapacity();\n            Object[] newQueue = new Object[newCapacity];\n            System.arraycopy(queue, 0, newQueue, 0, queue.length);\n            queue = newQueue;\n        }\n    }\n\n    /** Returns ~2x the old capacity if small; ~1.5x otherwise. */\n\n    /** There's no reason for the queueSize to ever be more than maxSize + 1 */\n    private static int capAtMaximumSize(int queueSize, int maximumSize)\n    {\n        return Math.min(queueSize - 1, maximumSize) + 1; // don't overflow\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/hash/Murmur3_32HashFunction.java", "func_name": "Murmur3_32HashFunction.fmix", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Finalization mix - force all bits of a hash block to avalanche", "docstring_tokens": ["Finalization", "mix", "-", "force", "all", "bits", "of", "a", "hash", "block", "to", "avalanche"], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/hash/Murmur3_32HashFunction.java#L249-L257", "partition": "valid", "up_fun_num": 15, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkPositionIndexes;", "import static com.google.common.base.Preconditions.checkState;", "import static com.google.common.primitives.UnsignedBytes.toInt;", "import com.google.common.base.Charsets;", "import com.google.common.primitives.Chars;", "import com.google.common.primitives.Ints;", "import com.google.common.primitives.Longs;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import com.google.errorprone.annotations.Immutable;", "import java.io.Serializable;", "import java.nio.ByteBuffer;", "import java.nio.ByteOrder;", "import java.nio.charset.Charset;", "import org.checkerframework.checker.nullness.qual.Nullable;"], "function": ["final class Murmur3_32HashFunction extends AbstractHashFunction implements Serializable\n", "    public int bits()\n", "    public Hasher newHasher()\n", "    public String toString()\n", "    public boolean equals(@Nullable Object object)\n", "    public int hashCode()\n", "    public HashCode hashInt(int input)\n", "    public HashCode hashLong(long input)\n", "    public HashCode hashUnencodedChars(CharSequence input)\n", "    public HashCode hashString(CharSequence input, Charset charset)\n", "    public HashCode hashBytes(byte[] input, int off, int len)\n", "    private static int getIntLittleEndian(byte[] input, int offset)\n", "    private static int mixK1(int k1)\n", "    private static int mixH1(int h1, int k1)\n", "    private static long codePointToFourUtf8Bytes(int codePoint)\n", "    private static long charToThreeUtf8Bytes(char c)\n", "    private static long charToTwoUtf8Bytes(char c)\n"], "context": "/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\n/*\n * MurmurHash3 was written by Austin Appleby, and is placed in the public\n * domain. The author hereby disclaims copyright to this source code.\n */\n\n/*\n * Source:\n * http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp\n * (Modified to adapt to Guava coding conventions and to use the HashFunction interface)\n */\n\npackage com.google.common.hash;\n\nimport static com.google.common.base.Preconditions.checkPositionIndexes;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.primitives.UnsignedBytes.toInt;\n\nimport com.google.common.base.Charsets;\nimport com.google.common.primitives.Chars;\nimport com.google.common.primitives.Ints;\nimport com.google.common.primitives.Longs;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.google.errorprone.annotations.Immutable;\nimport java.io.Serializable;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.charset.Charset;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\n/**\n * See MurmurHash3_x86_32 in <a\n * href=\"https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp\">the C++\n * implementation</a>.\n *\n * @author Austin Appleby\n * @author Dimitris Andreou\n * @author Kurt Alfred Kluever\n */\n@Immutable\nfinal class Murmur3_32HashFunction extends AbstractHashFunction implements Serializable\n{\n    static final HashFunction MURMUR3_32 = new Murmur3_32HashFunction(0);\n\n    static final HashFunction GOOD_FAST_HASH_32 =\n        new Murmur3_32HashFunction(Hashing.GOOD_FAST_HASH_SEED);\n\n    private static final int CHUNK_SIZE = 4;\n\n    private static final int C1 = 0xcc9e2d51;\n    private static final int C2 = 0x1b873593;\n\n    private final int seed;\n\n    Murmur3_32HashFunction(int seed)\n    {\n        this.seed = seed;\n    }\n\n    @Override\n    public int bits()\n    {\n        return 32;\n    }\n\n    @Override\n    public Hasher newHasher()\n    {\n        return new Murmur3_32Hasher(seed);\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"Hashing.murmur3_32(\" + seed + \")\";\n    }\n\n    @Override\n    public boolean equals(@Nullable Object object)\n    {\n        if (object instanceof Murmur3_32HashFunction)\n        {\n            Murmur3_32HashFunction other = (Murmur3_32HashFunction) object;\n            return seed == other.seed;\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return getClass().hashCode() ^ seed;\n    }\n\n    @Override\n    public HashCode hashInt(int input)\n    {\n        int k1 = mixK1(input);\n        int h1 = mixH1(seed, k1);\n\n        return fmix(h1, Ints.BYTES);\n    }\n\n    @Override\n    public HashCode hashLong(long input)\n    {\n        int low = (int) input;\n        int high = (int) (input >>> 32);\n\n        int k1 = mixK1(low);\n        int h1 = mixH1(seed, k1);\n\n        k1 = mixK1(high);\n        h1 = mixH1(h1, k1);\n\n        return fmix(h1, Longs.BYTES);\n    }\n\n    @Override\n    public HashCode hashUnencodedChars(CharSequence input)\n    {\n        int h1 = seed;\n\n        // step through the CharSequence 2 chars at a time\n        for (int i = 1; i < input.length(); i += 2)\n        {\n            int k1 = input.charAt(i - 1) | (input.charAt(i) << 16);\n            k1 = mixK1(k1);\n            h1 = mixH1(h1, k1);\n        }\n\n        // deal with any remaining characters\n        if ((input.length() & 1) == 1)\n        {\n            int k1 = input.charAt(input.length() - 1);\n            k1 = mixK1(k1);\n            h1 ^= k1;\n        }\n\n        return fmix(h1, Chars.BYTES * input.length());\n    }\n\n    @SuppressWarnings(\"deprecation\") // need to use Charsets for Android tests to pass\n    @Override\n    public HashCode hashString(CharSequence input, Charset charset)\n    {\n        if (Charsets.UTF_8.equals(charset))\n        {\n            int utf16Length = input.length();\n            int h1 = seed;\n            int i = 0;\n            int len = 0;\n\n            // This loop optimizes for pure ASCII.\n            while (i + 4 <= utf16Length)\n            {\n                char c0 = input.charAt(i);\n                char c1 = input.charAt(i + 1);\n                char c2 = input.charAt(i + 2);\n                char c3 = input.charAt(i + 3);\n                if (c0 < 0x80 && c1 < 0x80 && c2 < 0x80 && c3 < 0x80)\n                {\n                    int k1 = c0 | (c1 << 8) | (c2 << 16) | (c3 << 24);\n                    k1 = mixK1(k1);\n                    h1 = mixH1(h1, k1);\n                    i += 4;\n                    len += 4;\n                }\n                else\n                {\n                    break;\n                }\n            }\n\n            long buffer = 0;\n            int shift = 0;\n            for (; i < utf16Length; i++)\n            {\n                char c = input.charAt(i);\n                if (c < 0x80)\n                {\n                    buffer |= (long) c << shift;\n                    shift += 8;\n                    len++;\n                }\n                else if (c < 0x800)\n                {\n                    buffer |= charToTwoUtf8Bytes(c) << shift;\n                    shift += 16;\n                    len += 2;\n                }\n                else if (c < Character.MIN_SURROGATE || c > Character.MAX_SURROGATE)\n                {\n                    buffer |= charToThreeUtf8Bytes(c) << shift;\n                    shift += 24;\n                    len += 3;\n                }\n                else\n                {\n                    int codePoint = Character.codePointAt(input, i);\n                    if (codePoint == c)\n                    {\n                        // not a valid code point; let the JDK handle invalid Unicode\n                        return hashBytes(input.toString().getBytes(charset));\n                    }\n                    i++;\n                    buffer |= codePointToFourUtf8Bytes(codePoint) << shift;\n                    len += 4;\n                }\n\n                if (shift >= 32)\n                {\n                    int k1 = mixK1((int) buffer);\n                    h1 = mixH1(h1, k1);\n                    buffer = buffer >>> 32;\n                    shift -= 32;\n                }\n            }\n\n            int k1 = mixK1((int) buffer);\n            h1 ^= k1;\n            return fmix(h1, len);\n        }\n        else\n        {\n            return hashBytes(input.toString().getBytes(charset));\n        }\n    }\n\n    @Override\n    public HashCode hashBytes(byte[] input, int off, int len)\n    {\n        checkPositionIndexes(off, off + len, input.length);\n        int h1 = seed;\n        int i;\n        for (i = 0; i + CHUNK_SIZE <= len; i += CHUNK_SIZE)\n        {\n            int k1 = mixK1(getIntLittleEndian(input, off + i));\n            h1 = mixH1(h1, k1);\n        }\n\n        int k1 = 0;\n        for (int shift = 0; i < len; i++, shift += 8)\n        {\n            k1 ^= toInt(input[off + i]) << shift;\n        }\n        h1 ^= mixK1(k1);\n        return fmix(h1, len);\n    }\n\n    private static int getIntLittleEndian(byte[] input, int offset)\n    {\n        return Ints.fromBytes(input[offset + 3], input[offset + 2], input[offset + 1], input[offset]);\n    }\n\n    private static int mixK1(int k1)\n    {\n        k1 *= C1;\n        k1 = Integer.rotateLeft(k1, 15);\n        k1 *= C2;\n        return k1;\n    }\n\n    private static int mixH1(int h1, int k1)\n    {\n        h1 ^= k1;\n        h1 = Integer.rotateLeft(h1, 13);\n        h1 = h1 * 5 + 0xe6546b64;\n        return h1;\n    }\n\n    // Finalization mix - force all bits of a hash block to avalanche\n\n    @CanIgnoreReturnValue\n    private static final class Murmur3_32Hasher extends AbstractHasher\n    {\n        private int h1;\n        private long buffer;\n        private int shift;\n        private int length;\n        private boolean isDone;\n\n        Murmur3_32Hasher(int seed)\n        {\n            this.h1 = seed;\n            this.length = 0;\n            isDone = false;\n        }\n\n        private void update(int nBytes, long update)\n        {\n            // 1 <= nBytes <= 4\n            buffer |= (update & 0xFFFFFFFFL) << shift;\n            shift += nBytes * 8;\n            length += nBytes;\n\n            if (shift >= 32)\n            {\n                h1 = mixH1(h1, mixK1((int) buffer));\n                buffer >>>= 32;\n                shift -= 32;\n            }\n        }\n\n        @Override\n        public Hasher putByte(byte b)\n        {\n            update(1, b & 0xFF);\n            return this;\n        }\n\n        @Override\n        public Hasher putBytes(byte[] bytes, int off, int len)\n        {\n            checkPositionIndexes(off, off + len, bytes.length);\n            int i;\n            for (i = 0; i + 4 <= len; i += 4)\n            {\n                update(4, getIntLittleEndian(bytes, off + i));\n            }\n            for (; i < len; i++)\n            {\n                putByte(bytes[off + i]);\n            }\n            return this;\n        }\n\n        @Override\n        public Hasher putBytes(ByteBuffer buffer)\n        {\n            ByteOrder bo = buffer.order();\n            buffer.order(ByteOrder.LITTLE_ENDIAN);\n            while (buffer.remaining() >= 4)\n            {\n                putInt(buffer.getInt());\n            }\n            while (buffer.hasRemaining())\n            {\n                putByte(buffer.get());\n            }\n            buffer.order(bo);\n            return this;\n        }\n\n        @Override\n        public Hasher putInt(int i)\n        {\n            update(4, i);\n            return this;\n        }\n\n        @Override\n        public Hasher putLong(long l)\n        {\n            update(4, (int) l);\n            update(4, l >>> 32);\n            return this;\n        }\n\n        @Override\n        public Hasher putChar(char c)\n        {\n            update(2, c);\n            return this;\n        }\n\n        @SuppressWarnings(\"deprecation\") // need to use Charsets for Android tests to pass\n        @Override\n        public Hasher putString(CharSequence input, Charset charset)\n        {\n            if (Charsets.UTF_8.equals(charset))\n            {\n                int utf16Length = input.length();\n                int i = 0;\n\n                // This loop optimizes for pure ASCII.\n                while (i + 4 <= utf16Length)\n                {\n                    char c0 = input.charAt(i);\n                    char c1 = input.charAt(i + 1);\n                    char c2 = input.charAt(i + 2);\n                    char c3 = input.charAt(i + 3);\n                    if (c0 < 0x80 && c1 < 0x80 && c2 < 0x80 && c3 < 0x80)\n                    {\n                        update(4, c0 | (c1 << 8) | (c2 << 16) | (c3 << 24));\n                        i += 4;\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n\n                for (; i < utf16Length; i++)\n                {\n                    char c = input.charAt(i);\n                    if (c < 0x80)\n                    {\n                        update(1, c);\n                    }\n                    else if (c < 0x800)\n                    {\n                        update(2, charToTwoUtf8Bytes(c));\n                    }\n                    else if (c < Character.MIN_SURROGATE || c > Character.MAX_SURROGATE)\n                    {\n                        update(3, charToThreeUtf8Bytes(c));\n                    }\n                    else\n                    {\n                        int codePoint = Character.codePointAt(input, i);\n                        if (codePoint == c)\n                        {\n                            // fall back to JDK getBytes instead of trying to handle invalid surrogates ourselves\n                            putBytes(input.subSequence(i, utf16Length).toString().getBytes(charset));\n                            return this;\n                        }\n                        i++;\n                        update(4, codePointToFourUtf8Bytes(codePoint));\n                    }\n                }\n                return this;\n            }\n            else\n            {\n                return super.putString(input, charset);\n            }\n        }\n\n        @Override\n        public HashCode hash()\n        {\n            checkState(!isDone);\n            isDone = true;\n            h1 ^= mixK1((int) buffer);\n            return fmix(h1, length);\n        }\n    }\n\n    private static long codePointToFourUtf8Bytes(int codePoint)\n    {\n        return (((0xFL << 4) | (codePoint >>> 18)) & 0xFF)\n               | ((0x80L | (0x3F & (codePoint >>> 12))) << 8)\n               | ((0x80L | (0x3F & (codePoint >>> 6))) << 16)\n               | ((0x80L | (0x3F & codePoint)) << 24);\n    }\n\n    private static long charToThreeUtf8Bytes(char c)\n    {\n        return (((0xF << 5) | (c >>> 12)) & 0xFF)\n               | ((0x80 | (0x3F & (c >>> 6))) << 8)\n               | ((0x80 | (0x3F & c)) << 16);\n    }\n\n    private static long charToTwoUtf8Bytes(char c)\n    {\n        return (((0xF << 6) | (c >>> 6)) & 0xFF) | ((0x80 | (0x3F & c)) << 8);\n    }\n\n    private static final long serialVersionUID = 0L;\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/graph/ElementOrder.java", "func_name": "ElementOrder.natural", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns an instance which specifies that the natural ordering of the elements is guaranteed.", "docstring_tokens": ["Returns", "an", "instance", "which", "specifies", "that", "the", "natural", "ordering", "of", "the", "elements", "is", "guaranteed", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/graph/ElementOrder.java#L89-L91", "partition": "valid", "up_fun_num": 4, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.base.Preconditions.checkState;", "import com.google.common.annotations.Beta;", "import com.google.common.base.MoreObjects;", "import com.google.common.base.MoreObjects.ToStringHelper;", "import com.google.common.base.Objects;", "import com.google.common.collect.Maps;", "import com.google.common.collect.Ordering;", "import com.google.errorprone.annotations.Immutable;", "import java.util.Comparator;", "import java.util.Map;", "import org.checkerframework.checker.nullness.qual.Nullable;"], "function": ["public final class ElementOrder<T>\n", "    public static <S> ElementOrder<S> unordered()\n", "    public static <S> ElementOrder<S> insertion()\n", "    public static <S> ElementOrder<S> sorted(Comparator<S> comparator)\n", "    public Type type()\n", "    public Comparator<T> comparator()\n", "    public boolean equals(@Nullable Object obj)\n", "    public int hashCode()\n", "    public String toString()\n", "    <K extends T, V> Map<K, V> createMap(int expectedSize)\n", "    <T1 extends T> ElementOrder<T1> cast()\n"], "context": "/*\n * Copyright (C) 2016 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.graph;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.MoreObjects.ToStringHelper;\nimport com.google.common.base.Objects;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Ordering;\nimport com.google.errorprone.annotations.Immutable;\nimport java.util.Comparator;\nimport java.util.Map;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\n/**\n * Used to represent the order of elements in a data structure that supports different options for\n * iteration order guarantees.\n *\n * <p>Example usage:\n *\n * <pre>{@code\n * MutableGraph<Integer> graph =\n *     GraphBuilder.directed().nodeOrder(ElementOrder.<Integer>natural()).build();\n * }</pre>\n *\n * @author Joshua O'Madadhain\n * @since 20.0\n */\n@Beta\n@Immutable\npublic final class ElementOrder<T>\n{\n    private final Type type;\n\n    @SuppressWarnings(\"Immutable\") // Hopefully the comparator provided is immutable!\n    private final @Nullable Comparator<T> comparator;\n\n    /**\n     * The type of ordering that this object specifies.\n     *\n     * <ul>\n     *   <li>UNORDERED: no order is guaranteed.\n     *   <li>INSERTION: insertion ordering is guaranteed.\n     *   <li>SORTED: ordering according to a supplied comparator is guaranteed.\n     * </ul>\n     */\n    public enum Type\n    {\n        UNORDERED,\n        INSERTION,\n        SORTED\n    }\n\n    private ElementOrder(Type type, @Nullable Comparator<T> comparator)\n    {\n        this.type = checkNotNull(type);\n        this.comparator = comparator;\n        checkState((type == Type.SORTED) == (comparator != null));\n    }\n\n    /** Returns an instance which specifies that no ordering is guaranteed. */\n    public static <S> ElementOrder<S> unordered()\n    {\n        return new ElementOrder<S>(Type.UNORDERED, null);\n    }\n\n    /** Returns an instance which specifies that insertion ordering is guaranteed. */\n    public static <S> ElementOrder<S> insertion()\n    {\n        return new ElementOrder<S>(Type.INSERTION, null);\n    }\n\n    /**\n     * Returns an instance which specifies that the natural ordering of the elements is guaranteed.\n     */\n\n    /**\n     * Returns an instance which specifies that the ordering of the elements is guaranteed to be\n     * determined by {@code comparator}.\n     */\n    public static <S> ElementOrder<S> sorted(Comparator<S> comparator)\n    {\n        return new ElementOrder<S>(Type.SORTED, comparator);\n    }\n\n    /** Returns the type of ordering used. */\n    public Type type()\n    {\n        return type;\n    }\n\n    /**\n     * Returns the {@link Comparator} used.\n     *\n     * @throws UnsupportedOperationException if comparator is not defined\n     */\n    public Comparator<T> comparator()\n    {\n        if (comparator != null)\n        {\n            return comparator;\n        }\n        throw new UnsupportedOperationException(\"This ordering does not define a comparator.\");\n    }\n\n    @Override\n    public boolean equals(@Nullable Object obj)\n    {\n        if (obj == this)\n        {\n            return true;\n        }\n        if (!(obj instanceof ElementOrder))\n        {\n            return false;\n        }\n\n        ElementOrder<?> other = (ElementOrder<?>) obj;\n        return (type == other.type) && Objects.equal(comparator, other.comparator);\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return Objects.hashCode(type, comparator);\n    }\n\n    @Override\n    public String toString()\n    {\n        ToStringHelper helper = MoreObjects.toStringHelper(this).add(\"type\", type);\n        if (comparator != null)\n        {\n            helper.add(\"comparator\", comparator);\n        }\n        return helper.toString();\n    }\n\n    /** Returns an empty mutable map whose keys will respect this {@link ElementOrder}. */\n    <K extends T, V> Map<K, V> createMap(int expectedSize)\n    {\n        switch (type)\n        {\n        case UNORDERED:\n            return Maps.newHashMapWithExpectedSize(expectedSize);\n        case INSERTION:\n            return Maps.newLinkedHashMapWithExpectedSize(expectedSize);\n        case SORTED:\n            return Maps.newTreeMap(comparator());\n        default:\n            throw new AssertionError();\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T1 extends T> ElementOrder<T1> cast()\n    {\n        return (ElementOrder<T1>) this;\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.enter", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Enters this monitor. Blocks at most the given time.\n\n@return whether the monitor was entered", "docstring_tokens": ["Enters", "this", "monitor", ".", "Blocks", "at", "most", "the", "given", "time", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L371-L394", "partition": "valid", "up_fun_num": 2, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.errorprone.annotations.concurrent.GuardedBy;", "import com.google.j2objc.annotations.Weak;", "import java.util.concurrent.TimeUnit;", "import java.util.concurrent.locks.Condition;", "import java.util.concurrent.locks.ReentrantLock;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Monitor\n", "    public void enter()\n", "    public void enterInterruptibly() throws InterruptedException\n", "    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n", "    public boolean tryEnter()\n", "    public void enterWhen(Guard guard) throws InterruptedException\n", "    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void enterWhenUninterruptibly(Guard guard)\n", "    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIf(Guard guard)\n", "    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n", "    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean tryEnterIf(Guard guard)\n", "    public void waitFor(Guard guard) throws InterruptedException\n", "    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void waitForUninterruptibly(Guard guard)\n", "    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public void leave()\n", "    public boolean isFair()\n", "    public boolean isOccupied()\n", "    public boolean isOccupiedByCurrentThread()\n", "    public int getOccupiedDepth()\n", "    public int getQueueLength()\n", "    public boolean hasQueuedThreads()\n", "    public boolean hasQueuedThread(Thread thread)\n", "    public boolean hasWaiters(Guard guard)\n", "    public int getWaitQueueLength(Guard guard)\n", "    private static long toSafeNanos(long time, TimeUnit unit)\n", "    private static long initNanoTime(long timeoutNanos)\n", "    private static long remainingNanos(long startTime, long timeoutNanos)\n", "    private void signalNextWaiter()\n", "    private boolean isSatisfied(Guard guard)\n", "    private void signalAllWaiters()\n", "    private void beginWaitingFor(Guard guard)\n", "    private void endWaitingFor(Guard guard)\n", "    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n", "    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n", "    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n"], "context": "/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.concurrent.GuardedBy;\nimport com.google.j2objc.annotations.Weak;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A synchronization abstraction supporting waiting on arbitrary boolean conditions.\n *\n * <p>This class is intended as a replacement for {@link ReentrantLock}. Code using {@code Monitor}\n * is less error-prone and more readable than code using {@code ReentrantLock}, without significant\n * performance loss. {@code Monitor} even has the potential for performance gain by optimizing the\n * evaluation and signaling of conditions. Signaling is entirely <a\n * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>. By\n * eliminating explicit signaling, this class can guarantee that only one thread is awakened when a\n * condition becomes true (no \"signaling storms\" due to use of {@link\n * java.util.concurrent.locks.Condition#signalAll Condition.signalAll}) and that no signals are lost\n * (no \"hangs\" due to incorrect use of {@link java.util.concurrent.locks.Condition#signal\n * Condition.signal}).\n *\n * <p>A thread is said to <i>occupy</i> a monitor if it has <i>entered</i> the monitor but not yet\n * <i>left</i>. Only one thread may occupy a given monitor at any moment. A monitor is also\n * reentrant, so a thread may enter a monitor any number of times, and then must leave the same\n * number of times. The <i>enter</i> and <i>leave</i> operations have the same synchronization\n * semantics as the built-in Java language synchronization primitives.\n *\n * <p>A call to any of the <i>enter</i> methods with <b>void</b> return type should always be\n * followed immediately by a <i>try/finally</i> block to ensure that the current thread leaves the\n * monitor cleanly:\n *\n * <pre>{@code\n * monitor.enter();\n * try {\n *   // do things while occupying the monitor\n * } finally {\n *   monitor.leave();\n * }\n * }</pre>\n *\n * <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear\n * as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that\n * the current thread leaves the monitor cleanly:\n *\n * <pre>{@code\n * if (monitor.tryEnter()) {\n *   try {\n *     // do things while occupying the monitor\n *   } finally {\n *     monitor.leave();\n *   }\n * } else {\n *   // do other things since the monitor was not available\n * }\n * }</pre>\n *\n * <h2>Comparison with {@code synchronized} and {@code ReentrantLock}</h2>\n *\n * <p>The following examples show a simple threadsafe holder expressed using {@code synchronized},\n * {@link ReentrantLock}, and {@code Monitor}.\n *\n * <h3>{@code synchronized}</h3>\n *\n * <p>This version is the fewest lines of code, largely because the synchronization mechanism used\n * is built into the language and runtime. But the programmer has to remember to avoid a couple of\n * common bugs: The {@code wait()} must be inside a {@code while} instead of an {@code if}, and\n * {@code notifyAll()} must be used instead of {@code notify()} because there are two different\n * logical conditions being awaited.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *\n *   public synchronized V get() throws InterruptedException {\n *     while (value == null) {\n *       wait();\n *     }\n *     V result = value;\n *     value = null;\n *     notifyAll();\n *     return result;\n *   }\n *\n *   public synchronized void set(V newValue) throws InterruptedException {\n *     while (value != null) {\n *       wait();\n *     }\n *     value = newValue;\n *     notifyAll();\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code ReentrantLock}</h3>\n *\n * <p>This version is much more verbose than the {@code synchronized} version, and still suffers\n * from the need for the programmer to remember to use {@code while} instead of {@code if}. However,\n * one advantage is that we can introduce two separate {@code Condition} objects, which allows us to\n * use {@code signal()} instead of {@code signalAll()}, which may be a performance benefit.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final ReentrantLock lock = new ReentrantLock();\n *   private final Condition valuePresent = lock.newCondition();\n *   private final Condition valueAbsent = lock.newCondition();\n *\n *   public V get() throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value == null) {\n *         valuePresent.await();\n *       }\n *       V result = value;\n *       value = null;\n *       valueAbsent.signal();\n *       return result;\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value != null) {\n *         valueAbsent.await();\n *       }\n *       value = newValue;\n *       valuePresent.signal();\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code Monitor}</h3>\n *\n * <p>This version adds some verbosity around the {@code Guard} objects, but removes that same\n * verbosity, and more, from the {@code get} and {@code set} methods. {@code Monitor} implements the\n * same efficient signaling as we had to hand-code in the {@code ReentrantLock} version above.\n * Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to\n * remember to use {@code while} instead of {@code if}.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final Monitor monitor = new Monitor();\n *   private final Monitor.Guard valuePresent = monitor.newGuard(() -> value != null);\n *   private final Monitor.Guard valueAbsent = monitor.newGuard(() -> value == null);\n *\n *   public V get() throws InterruptedException {\n *     monitor.enterWhen(valuePresent);\n *     try {\n *       V result = value;\n *       value = null;\n *       return result;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     monitor.enterWhen(valueAbsent);\n *     try {\n *       value = newValue;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n * }\n * }</pre>\n *\n * @author Justin T. Sampson\n * @author Martin Buchholz\n * @since 10.0\n */\n@Beta\n@GwtIncompatible\n@SuppressWarnings(\"GuardedBy\") // TODO(b/35466881): Fix or suppress.\npublic final class Monitor\n{\n    // TODO(user): Use raw LockSupport or AbstractQueuedSynchronizer instead of ReentrantLock.\n    // TODO(user): \"Port\" jsr166 tests for ReentrantLock.\n    //\n    // TODO(user): Change API to make it impossible to use a Guard with the \"wrong\" monitor,\n    //    by making the monitor implicit, and to eliminate other sources of IMSE.\n    //    Imagine:\n    //    guard.lock();\n    //    try { /* monitor locked and guard satisfied here */ }\n    //    finally { guard.unlock(); }\n    // Here are Justin's design notes about this:\n    //\n    // This idea has come up from time to time, and I think one of my\n    // earlier versions of Monitor even did something like this. I ended\n    // up strongly favoring the current interface.\n    //\n    // I probably can't remember all the reasons (it's possible you\n    // could find them in the code review archives), but here are a few:\n    //\n    // 1. What about leaving/unlocking? Are you going to do\n    //    guard.enter() paired with monitor.leave()? That might get\n    //    confusing. It's nice for the finally block to look as close as\n    //    possible to the thing right before the try. You could have\n    //    guard.leave(), but that's a little odd as well because the\n    //    guard doesn't have anything to do with leaving. You can't\n    //    really enforce that the guard you're leaving is the same one\n    //    you entered with, and it doesn't actually matter.\n    //\n    // 2. Since you can enter the monitor without a guard at all, some\n    //    places you'll have monitor.enter()/monitor.leave() and other\n    //    places you'll have guard.enter()/guard.leave() even though\n    //    it's the same lock being acquired underneath. Always using\n    //    monitor.enterXXX()/monitor.leave() will make it really clear\n    //    which lock is held at any point in the code.\n    //\n    // 3. I think \"enterWhen(notEmpty)\" reads better than \"notEmpty.enter()\".\n    //\n    // TODO(user): Implement ReentrantLock features:\n    //    - toString() method\n    //    - getOwner() method\n    //    - getQueuedThreads() method\n    //    - getWaitingThreads(Guard) method\n    //    - implement Serializable\n    //    - redo the API to be as close to identical to ReentrantLock as possible,\n    //      since, after all, this class is also a reentrant mutual exclusion lock!?\n\n    /*\n     * One of the key challenges of this class is to prevent lost signals, while trying hard to\n     * minimize unnecessary signals. One simple and correct algorithm is to signal some other waiter\n     * with a satisfied guard (if one exists) whenever any thread occupying the monitor exits the\n     * monitor, either by unlocking all of its held locks, or by starting to wait for a guard. This\n     * includes exceptional exits, so all control paths involving signalling must be protected by a\n     * finally block.\n     *\n     * Further optimizations of this algorithm become increasingly subtle. A wait that terminates\n     * without the guard being satisfied (due to timeout, but not interrupt) can then immediately exit\n     * the monitor without signalling. If it timed out without being signalled, it does not need to\n     * \"pass on\" the signal to another thread. If it *was* signalled, then its guard must have been\n     * satisfied at the time of signal, and has since been modified by some other thread to be\n     * non-satisfied before reacquiring the lock, and that other thread takes over the responsibility\n     * of signaling the next waiter.\n     *\n     * Unlike the underlying Condition, if we are not careful, an interrupt *can* cause a signal to be\n     * lost, because the signal may be sent to a condition whose sole waiter has just been\n     * interrupted.\n     *\n     * Imagine a monitor with multiple guards. A thread enters the monitor, satisfies all the guards,\n     * and leaves, calling signalNextWaiter. With traditional locks and conditions, all the conditions\n     * need to be signalled because it is not known which if any of them have waiters (and hasWaiters\n     * can't be used reliably because of a check-then-act race). With our Monitor guards, we only\n     * signal the first active guard that is satisfied. But the corresponding thread may have already\n     * been interrupted and is waiting to reacquire the lock while still registered in activeGuards,\n     * in which case the signal is a no-op, and the bigger-picture signal is lost unless interrupted\n     * threads take special action by participating in the signal-passing game.\n     */\n\n    /*\n     * Timeout handling is intricate, especially given our ambitious goals:\n     * - Avoid underflow and overflow of timeout values when specified timeouts are close to\n     *   Long.MIN_VALUE or Long.MAX_VALUE.\n     * - Favor responding to interrupts over timeouts.\n     * - System.nanoTime() is expensive enough that we want to call it the minimum required number of\n     *   times, typically once before invoking a blocking method. This often requires keeping track of\n     *   the first time in a method that nanoTime() has been invoked, for which the special value 0L\n     *   is reserved to mean \"uninitialized\". If timeout is non-positive, then nanoTime need never be\n     *   called.\n     * - Keep behavior of fair and non-fair instances consistent.\n     */\n\n    /**\n     * A boolean condition for which a thread may wait. A {@code Guard} is associated with a single\n     * {@code Monitor}. The monitor may check the guard at arbitrary times from any thread occupying\n     * the monitor, so code should not be written to rely on how often a guard might or might not be\n     * checked.\n     *\n     * <p>If a {@code Guard} is passed into any method of a {@code Monitor} other than the one it is\n     * associated with, an {@link IllegalMonitorStateException} is thrown.\n     *\n     * @since 10.0\n     */\n    @Beta\n    public abstract static class Guard\n    {\n\n        @Weak final Monitor monitor;\n        final Condition condition;\n\n        @GuardedBy(\"monitor.lock\")\n        int waiterCount = 0;\n\n        /** The next active guard */\n        @GuardedBy(\"monitor.lock\")\n        @NullableDecl\n        Guard next;\n\n        protected Guard(Monitor monitor)\n        {\n            this.monitor = checkNotNull(monitor, \"monitor\");\n            this.condition = monitor.lock.newCondition();\n        }\n\n        /**\n         * Evaluates this guard's boolean condition. This method is always called with the associated\n         * monitor already occupied. Implementations of this method must depend only on state protected\n         * by the associated monitor, and must not modify that state.\n         */\n        public abstract boolean isSatisfied();\n    }\n\n    /** Whether this monitor is fair. */\n    private final boolean fair;\n\n    /** The lock underlying this monitor. */\n    private final ReentrantLock lock;\n\n    /**\n     * The guards associated with this monitor that currently have waiters ({@code waiterCount > 0}).\n     * A linked list threaded through the Guard.next field.\n     */\n    @GuardedBy(\"lock\")\n    private Guard activeGuards = null;\n\n    /**\n     * Creates a monitor with a non-fair (but fast) ordering policy. Equivalent to {@code\n     * Monitor(false)}.\n     */\n    public Monitor()\n    {\n        this(false);\n    }\n\n    /**\n     * Creates a monitor with the given ordering policy.\n     *\n     * @param fair whether this monitor should use a fair ordering policy rather than a non-fair (but\n     *     fast) one\n     */\n    public Monitor(boolean fair)\n    {\n        this.fair = fair;\n        this.lock = new ReentrantLock(fair);\n    }\n\n    /** Enters this monitor. Blocks indefinitely. */\n    public void enter()\n    {\n        lock.lock();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time.\n     *\n     * @return whether the monitor was entered\n     */\n\n    /**\n     * Enters this monitor. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterInterruptibly() throws InterruptedException\n    {\n        lock.lockInterruptibly();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time, and may be interrupted.\n     *\n     * @return whether the monitor was entered\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n    {\n        return lock.tryLock(time, unit);\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately. Does not block.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered\n     */\n    public boolean tryEnter()\n    {\n        return lock.tryLock();\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterWhen(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                await(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied, and may be\n     * interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean reentrant = lock.isHeldByCurrentThread();\n        long startTime = 0L;\n\n        locked:\n        {\n            if (!fair)\n            {\n                // Check interrupt status to get behavior consistent with fair case.\n                if (Thread.interrupted())\n                {\n                    throw new InterruptedException();\n                }\n                if (lock.tryLock())\n                {\n                    break locked;\n                }\n            }\n            startTime = initNanoTime(timeoutNanos);\n            if (!lock.tryLock(time, unit))\n            {\n                return false;\n            }\n        }\n\n        boolean satisfied = false;\n        boolean threw = true;\n        try\n        {\n            satisfied =\n                guard.isSatisfied()\n                || awaitNanos(\n                    guard,\n                    (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),\n                    reentrant);\n            threw = false;\n            return satisfied;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                try\n                {\n                    // Don't need to signal if timed out, but do if interrupted\n                    if (threw && !reentrant)\n                    {\n                        signalNextWaiter();\n                    }\n                }\n                finally\n                {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n\n    /** Enters this monitor when the guard is satisfied. Blocks indefinitely. */\n    public void enterWhenUninterruptibly(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                awaitUninterruptibly(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        long startTime = 0L;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            if (fair || !lock.tryLock())\n            {\n                startTime = initNanoTime(timeoutNanos);\n                for (long remainingNanos = timeoutNanos; ; )\n                {\n                    try\n                    {\n                        if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS))\n                        {\n                            break;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        remainingNanos = remainingNanos(startTime, timeoutNanos);\n                    }\n                }\n            }\n\n            boolean satisfied = false;\n            try\n            {\n                while (true)\n                {\n                    try\n                    {\n                        if (guard.isSatisfied())\n                        {\n                            satisfied = true;\n                        }\n                        else\n                        {\n                            final long remainingNanos;\n                            if (startTime == 0L)\n                            {\n                                startTime = initNanoTime(timeoutNanos);\n                                remainingNanos = timeoutNanos;\n                            }\n                            else\n                            {\n                                remainingNanos = remainingNanos(startTime, timeoutNanos);\n                            }\n                            satisfied = awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                        }\n                        return satisfied;\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        signalBeforeWaiting = false;\n                    }\n                }\n            }\n            finally\n            {\n                if (!satisfied)\n                {\n                    lock.unlock(); // No need to signal if timed out\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean enterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!enter(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n    throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not\n     * block acquiring the lock and does not wait for the guard to be satisfied.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean tryEnterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock())\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be called\n     * only by a thread currently occupying this monitor.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void waitFor(Guard guard) throws InterruptedException\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            await(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted. May\n     * be called only by a thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        if (Thread.interrupted())\n        {\n            throw new InterruptedException();\n        }\n        return awaitNanos(guard, timeoutNanos, true);\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread\n     * currently occupying this monitor.\n     */\n    public void waitForUninterruptibly(Guard guard)\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            awaitUninterruptibly(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time. May be called only by a\n     * thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        boolean signalBeforeWaiting = true;\n        final long startTime = initNanoTime(timeoutNanos);\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    if (guard.isSatisfied())\n                    {\n                        return true;\n                    }\n                    signalBeforeWaiting = false;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /** Leaves this monitor. May be called only by a thread currently occupying this monitor. */\n    public void leave()\n    {\n        final ReentrantLock lock = this.lock;\n        try\n        {\n            // No need to signal if we will still be holding the lock when we return\n            if (lock.getHoldCount() == 1)\n            {\n                signalNextWaiter();\n            }\n        }\n        finally\n        {\n            lock.unlock(); // Will throw IllegalMonitorStateException if not held\n        }\n    }\n\n    /** Returns whether this monitor is using a fair ordering policy. */\n    public boolean isFair()\n    {\n        return fair;\n    }\n\n    /**\n     * Returns whether this monitor is occupied by any thread. This method is designed for use in\n     * monitoring of the system state, not for synchronization control.\n     */\n    public boolean isOccupied()\n    {\n        return lock.isLocked();\n    }\n\n    /**\n     * Returns whether the current thread is occupying this monitor (has entered more times than it\n     * has left).\n     */\n    public boolean isOccupiedByCurrentThread()\n    {\n        return lock.isHeldByCurrentThread();\n    }\n\n    /**\n     * Returns the number of times the current thread has entered this monitor in excess of the number\n     * of times it has left. Returns 0 if the current thread is not occupying this monitor.\n     */\n    public int getOccupiedDepth()\n    {\n        return lock.getHoldCount();\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting to enter this monitor. The value is only\n     * an estimate because the number of threads may change dynamically while this method traverses\n     * internal data structures. This method is designed for use in monitoring of the system state,\n     * not for synchronization control.\n     */\n    public int getQueueLength()\n    {\n        return lock.getQueueLength();\n    }\n\n    /**\n     * Returns whether any threads are waiting to enter this monitor. Note that because cancellations\n     * may occur at any time, a {@code true} return does not guarantee that any other thread will ever\n     * enter this monitor. This method is designed primarily for use in monitoring of the system\n     * state.\n     */\n    public boolean hasQueuedThreads()\n    {\n        return lock.hasQueuedThreads();\n    }\n\n    /**\n     * Queries whether the given thread is waiting to enter this monitor. Note that because\n     * cancellations may occur at any time, a {@code true} return does not guarantee that this thread\n     * will ever enter this monitor. This method is designed primarily for use in monitoring of the\n     * system state.\n     */\n    public boolean hasQueuedThread(Thread thread)\n    {\n        return lock.hasQueuedThread(thread);\n    }\n\n    /**\n     * Queries whether any threads are waiting for the given guard to become satisfied. Note that\n     * because timeouts and interrupts may occur at any time, a {@code true} return does not guarantee\n     * that the guard becoming satisfied in the future will awaken any threads. This method is\n     * designed primarily for use in monitoring of the system state.\n     */\n    public boolean hasWaiters(Guard guard)\n    {\n        return getWaitQueueLength(guard) > 0;\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting for the given guard to become satisfied.\n     * Note that because timeouts and interrupts may occur at any time, the estimate serves only as an\n     * upper bound on the actual number of waiters. This method is designed for use in monitoring of\n     * the system state, not for synchronization control.\n     */\n    public int getWaitQueueLength(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        lock.lock();\n        try\n        {\n            return guard.waiterCount;\n        }\n        finally\n        {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Returns unit.toNanos(time), additionally ensuring the returned value is not at risk of\n     * overflowing or underflowing, by bounding the value between 0 and (Long.MAX_VALUE / 4) * 3.\n     * Actually waiting for more than 219 years is not supported!\n     */\n    private static long toSafeNanos(long time, TimeUnit unit)\n    {\n        long timeoutNanos = unit.toNanos(time);\n        return (timeoutNanos <= 0L)\n               ? 0L\n               : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3 : timeoutNanos;\n    }\n\n    /**\n     * Returns System.nanoTime() unless the timeout has already elapsed. Returns 0L if and only if the\n     * timeout has already elapsed.\n     */\n    private static long initNanoTime(long timeoutNanos)\n    {\n        if (timeoutNanos <= 0L)\n        {\n            return 0L;\n        }\n        else\n        {\n            long startTime = System.nanoTime();\n            return (startTime == 0L) ? 1L : startTime;\n        }\n    }\n\n    /**\n     * Returns the remaining nanos until the given timeout, or 0L if the timeout has already elapsed.\n     * Caller must have previously sanitized timeoutNanos using toSafeNanos.\n     */\n    private static long remainingNanos(long startTime, long timeoutNanos)\n    {\n        // assert timeoutNanos == 0L || startTime != 0L;\n\n        // TODO : NOT CORRECT, BUT TESTS PASS ANYWAYS!\n        // if (true) return timeoutNanos;\n        // ONLY 2 TESTS FAIL IF WE DO:\n        // if (true) return 0;\n\n        return (timeoutNanos <= 0L) ? 0L : timeoutNanos - (System.nanoTime() - startTime);\n    }\n\n    /**\n     * Signals some other thread waiting on a satisfied guard, if one exists.\n     *\n     * <p>We manage calls to this method carefully, to signal only when necessary, but never losing a\n     * signal, which is the classic problem of this kind of concurrency construct. We must signal if\n     * the current thread is about to relinquish the lock and may have changed the state protected by\n     * the monitor, thereby causing some guard to be satisfied.\n     *\n     * <p>In addition, any thread that has been signalled when its guard was satisfied acquires the\n     * responsibility of signalling the next thread when it again relinquishes the lock. Unlike a\n     * normal Condition, there is no guarantee that an interrupted thread has not been signalled,\n     * since the concurrency control must manage multiple Conditions. So this method must generally be\n     * called when waits are interrupted.\n     *\n     * <p>On the other hand, if a signalled thread wakes up to discover that its guard is still not\n     * satisfied, it does *not* need to call this method before returning to wait. This can only\n     * happen due to spurious wakeup (ignorable) or another thread acquiring the lock before the\n     * current thread can and returning the guard to the unsatisfied state. In the latter case the\n     * other thread (last thread modifying the state protected by the monitor) takes over the\n     * responsibility of signalling the next waiter.\n     *\n     * <p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else\n     * the current thread's guard might be mistakenly signalled, leading to a lost signal.\n     */\n    @GuardedBy(\"lock\")\n    private void signalNextWaiter()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            if (isSatisfied(guard))\n            {\n                guard.condition.signal();\n                break;\n            }\n        }\n    }\n\n    /**\n     * Exactly like signalNextWaiter, but caller guarantees that guardToSkip need not be considered,\n     * because caller has previously checked that guardToSkip.isSatisfied() returned false. An\n     * optimization for the case that guardToSkip.isSatisfied() may be expensive.\n     *\n     * <p>We decided against using this method, since in practice, isSatisfied() is likely to be very\n     * cheap (typically one field read). Resurrect this method if you find that not to be true.\n     */\n    //   @GuardedBy(\"lock\")\n    //   private void signalNextWaiterSkipping(Guard guardToSkip) {\n    //     for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n    //       if (guard != guardToSkip && isSatisfied(guard)) {\n    //         guard.condition.signal();\n    //         break;\n    //       }\n    //     }\n    //   }\n\n    /**\n     * Exactly like guard.isSatisfied(), but in addition signals all waiting threads in the (hopefully\n     * unlikely) event that isSatisfied() throws.\n     */\n    @GuardedBy(\"lock\")\n    private boolean isSatisfied(Guard guard)\n    {\n        try\n        {\n            return guard.isSatisfied();\n        }\n        catch (Throwable throwable)\n        {\n            signalAllWaiters();\n            throw throwable;\n        }\n    }\n\n    /** Signals all threads waiting on guards. */\n    @GuardedBy(\"lock\")\n    private void signalAllWaiters()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            guard.condition.signalAll();\n        }\n    }\n\n    /** Records that the current thread is about to wait on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void beginWaitingFor(Guard guard)\n    {\n        int waiters = guard.waiterCount++;\n        if (waiters == 0)\n        {\n            // push guard onto activeGuards\n            guard.next = activeGuards;\n            activeGuards = guard;\n        }\n    }\n\n    /** Records that the current thread is no longer waiting on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void endWaitingFor(Guard guard)\n    {\n        int waiters = --guard.waiterCount;\n        if (waiters == 0)\n        {\n            // unlink guard from activeGuards\n            for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next)\n            {\n                if (p == guard)\n                {\n                    if (pred == null)\n                    {\n                        activeGuards = p.next;\n                    }\n                    else\n                    {\n                        pred.next = p.next;\n                    }\n                    p.next = null; // help GC\n                    break;\n                }\n            }\n        }\n    }\n\n    /*\n     * Methods that loop waiting on a guard's condition until the guard is satisfied, while recording\n     * this fact so that other threads know to check our guard and signal us. It's caller's\n     * responsibility to ensure that the guard is *not* currently satisfied.\n     */\n\n    @GuardedBy(\"lock\")\n    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.await();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    @GuardedBy(\"lock\")\n    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.awaitUninterruptibly();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    /** Caller should check before calling that guard is not satisfied. */\n    @GuardedBy(\"lock\")\n    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n    throws InterruptedException\n    {\n        boolean firstTime = true;\n        try\n        {\n            do\n            {\n                if (nanos <= 0L)\n                {\n                    return false;\n                }\n                if (firstTime)\n                {\n                    if (signalBeforeWaiting)\n                    {\n                        signalNextWaiter();\n                    }\n                    beginWaitingFor(guard);\n                    firstTime = false;\n                }\n                nanos = guard.condition.awaitNanos(nanos);\n            }\n            while (!guard.isSatisfied());\n            return true;\n        }\n        finally\n        {\n            if (!firstTime)\n            {\n                endWaitingFor(guard);\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.enterInterruptibly", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Enters this monitor. Blocks at most the given time, and may be interrupted.\n\n@return whether the monitor was entered\n@throws InterruptedException if interrupted while waiting", "docstring_tokens": ["Enters", "this", "monitor", ".", "Blocks", "at", "most", "the", "given", "time", "and", "may", "be", "interrupted", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L411-L414", "partition": "valid", "up_fun_num": 4, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.errorprone.annotations.concurrent.GuardedBy;", "import com.google.j2objc.annotations.Weak;", "import java.util.concurrent.TimeUnit;", "import java.util.concurrent.locks.Condition;", "import java.util.concurrent.locks.ReentrantLock;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Monitor\n", "    public void enter()\n", "    public boolean enter(long time, TimeUnit unit)\n", "    public void enterInterruptibly() throws InterruptedException\n", "    public boolean tryEnter()\n", "    public void enterWhen(Guard guard) throws InterruptedException\n", "    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void enterWhenUninterruptibly(Guard guard)\n", "    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIf(Guard guard)\n", "    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n", "    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean tryEnterIf(Guard guard)\n", "    public void waitFor(Guard guard) throws InterruptedException\n", "    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void waitForUninterruptibly(Guard guard)\n", "    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public void leave()\n", "    public boolean isFair()\n", "    public boolean isOccupied()\n", "    public boolean isOccupiedByCurrentThread()\n", "    public int getOccupiedDepth()\n", "    public int getQueueLength()\n", "    public boolean hasQueuedThreads()\n", "    public boolean hasQueuedThread(Thread thread)\n", "    public boolean hasWaiters(Guard guard)\n", "    public int getWaitQueueLength(Guard guard)\n", "    private static long toSafeNanos(long time, TimeUnit unit)\n", "    private static long initNanoTime(long timeoutNanos)\n", "    private static long remainingNanos(long startTime, long timeoutNanos)\n", "    private void signalNextWaiter()\n", "    private boolean isSatisfied(Guard guard)\n", "    private void signalAllWaiters()\n", "    private void beginWaitingFor(Guard guard)\n", "    private void endWaitingFor(Guard guard)\n", "    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n", "    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n", "    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n"], "context": "/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.concurrent.GuardedBy;\nimport com.google.j2objc.annotations.Weak;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A synchronization abstraction supporting waiting on arbitrary boolean conditions.\n *\n * <p>This class is intended as a replacement for {@link ReentrantLock}. Code using {@code Monitor}\n * is less error-prone and more readable than code using {@code ReentrantLock}, without significant\n * performance loss. {@code Monitor} even has the potential for performance gain by optimizing the\n * evaluation and signaling of conditions. Signaling is entirely <a\n * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>. By\n * eliminating explicit signaling, this class can guarantee that only one thread is awakened when a\n * condition becomes true (no \"signaling storms\" due to use of {@link\n * java.util.concurrent.locks.Condition#signalAll Condition.signalAll}) and that no signals are lost\n * (no \"hangs\" due to incorrect use of {@link java.util.concurrent.locks.Condition#signal\n * Condition.signal}).\n *\n * <p>A thread is said to <i>occupy</i> a monitor if it has <i>entered</i> the monitor but not yet\n * <i>left</i>. Only one thread may occupy a given monitor at any moment. A monitor is also\n * reentrant, so a thread may enter a monitor any number of times, and then must leave the same\n * number of times. The <i>enter</i> and <i>leave</i> operations have the same synchronization\n * semantics as the built-in Java language synchronization primitives.\n *\n * <p>A call to any of the <i>enter</i> methods with <b>void</b> return type should always be\n * followed immediately by a <i>try/finally</i> block to ensure that the current thread leaves the\n * monitor cleanly:\n *\n * <pre>{@code\n * monitor.enter();\n * try {\n *   // do things while occupying the monitor\n * } finally {\n *   monitor.leave();\n * }\n * }</pre>\n *\n * <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear\n * as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that\n * the current thread leaves the monitor cleanly:\n *\n * <pre>{@code\n * if (monitor.tryEnter()) {\n *   try {\n *     // do things while occupying the monitor\n *   } finally {\n *     monitor.leave();\n *   }\n * } else {\n *   // do other things since the monitor was not available\n * }\n * }</pre>\n *\n * <h2>Comparison with {@code synchronized} and {@code ReentrantLock}</h2>\n *\n * <p>The following examples show a simple threadsafe holder expressed using {@code synchronized},\n * {@link ReentrantLock}, and {@code Monitor}.\n *\n * <h3>{@code synchronized}</h3>\n *\n * <p>This version is the fewest lines of code, largely because the synchronization mechanism used\n * is built into the language and runtime. But the programmer has to remember to avoid a couple of\n * common bugs: The {@code wait()} must be inside a {@code while} instead of an {@code if}, and\n * {@code notifyAll()} must be used instead of {@code notify()} because there are two different\n * logical conditions being awaited.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *\n *   public synchronized V get() throws InterruptedException {\n *     while (value == null) {\n *       wait();\n *     }\n *     V result = value;\n *     value = null;\n *     notifyAll();\n *     return result;\n *   }\n *\n *   public synchronized void set(V newValue) throws InterruptedException {\n *     while (value != null) {\n *       wait();\n *     }\n *     value = newValue;\n *     notifyAll();\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code ReentrantLock}</h3>\n *\n * <p>This version is much more verbose than the {@code synchronized} version, and still suffers\n * from the need for the programmer to remember to use {@code while} instead of {@code if}. However,\n * one advantage is that we can introduce two separate {@code Condition} objects, which allows us to\n * use {@code signal()} instead of {@code signalAll()}, which may be a performance benefit.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final ReentrantLock lock = new ReentrantLock();\n *   private final Condition valuePresent = lock.newCondition();\n *   private final Condition valueAbsent = lock.newCondition();\n *\n *   public V get() throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value == null) {\n *         valuePresent.await();\n *       }\n *       V result = value;\n *       value = null;\n *       valueAbsent.signal();\n *       return result;\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value != null) {\n *         valueAbsent.await();\n *       }\n *       value = newValue;\n *       valuePresent.signal();\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code Monitor}</h3>\n *\n * <p>This version adds some verbosity around the {@code Guard} objects, but removes that same\n * verbosity, and more, from the {@code get} and {@code set} methods. {@code Monitor} implements the\n * same efficient signaling as we had to hand-code in the {@code ReentrantLock} version above.\n * Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to\n * remember to use {@code while} instead of {@code if}.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final Monitor monitor = new Monitor();\n *   private final Monitor.Guard valuePresent = monitor.newGuard(() -> value != null);\n *   private final Monitor.Guard valueAbsent = monitor.newGuard(() -> value == null);\n *\n *   public V get() throws InterruptedException {\n *     monitor.enterWhen(valuePresent);\n *     try {\n *       V result = value;\n *       value = null;\n *       return result;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     monitor.enterWhen(valueAbsent);\n *     try {\n *       value = newValue;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n * }\n * }</pre>\n *\n * @author Justin T. Sampson\n * @author Martin Buchholz\n * @since 10.0\n */\n@Beta\n@GwtIncompatible\n@SuppressWarnings(\"GuardedBy\") // TODO(b/35466881): Fix or suppress.\npublic final class Monitor\n{\n    // TODO(user): Use raw LockSupport or AbstractQueuedSynchronizer instead of ReentrantLock.\n    // TODO(user): \"Port\" jsr166 tests for ReentrantLock.\n    //\n    // TODO(user): Change API to make it impossible to use a Guard with the \"wrong\" monitor,\n    //    by making the monitor implicit, and to eliminate other sources of IMSE.\n    //    Imagine:\n    //    guard.lock();\n    //    try { /* monitor locked and guard satisfied here */ }\n    //    finally { guard.unlock(); }\n    // Here are Justin's design notes about this:\n    //\n    // This idea has come up from time to time, and I think one of my\n    // earlier versions of Monitor even did something like this. I ended\n    // up strongly favoring the current interface.\n    //\n    // I probably can't remember all the reasons (it's possible you\n    // could find them in the code review archives), but here are a few:\n    //\n    // 1. What about leaving/unlocking? Are you going to do\n    //    guard.enter() paired with monitor.leave()? That might get\n    //    confusing. It's nice for the finally block to look as close as\n    //    possible to the thing right before the try. You could have\n    //    guard.leave(), but that's a little odd as well because the\n    //    guard doesn't have anything to do with leaving. You can't\n    //    really enforce that the guard you're leaving is the same one\n    //    you entered with, and it doesn't actually matter.\n    //\n    // 2. Since you can enter the monitor without a guard at all, some\n    //    places you'll have monitor.enter()/monitor.leave() and other\n    //    places you'll have guard.enter()/guard.leave() even though\n    //    it's the same lock being acquired underneath. Always using\n    //    monitor.enterXXX()/monitor.leave() will make it really clear\n    //    which lock is held at any point in the code.\n    //\n    // 3. I think \"enterWhen(notEmpty)\" reads better than \"notEmpty.enter()\".\n    //\n    // TODO(user): Implement ReentrantLock features:\n    //    - toString() method\n    //    - getOwner() method\n    //    - getQueuedThreads() method\n    //    - getWaitingThreads(Guard) method\n    //    - implement Serializable\n    //    - redo the API to be as close to identical to ReentrantLock as possible,\n    //      since, after all, this class is also a reentrant mutual exclusion lock!?\n\n    /*\n     * One of the key challenges of this class is to prevent lost signals, while trying hard to\n     * minimize unnecessary signals. One simple and correct algorithm is to signal some other waiter\n     * with a satisfied guard (if one exists) whenever any thread occupying the monitor exits the\n     * monitor, either by unlocking all of its held locks, or by starting to wait for a guard. This\n     * includes exceptional exits, so all control paths involving signalling must be protected by a\n     * finally block.\n     *\n     * Further optimizations of this algorithm become increasingly subtle. A wait that terminates\n     * without the guard being satisfied (due to timeout, but not interrupt) can then immediately exit\n     * the monitor without signalling. If it timed out without being signalled, it does not need to\n     * \"pass on\" the signal to another thread. If it *was* signalled, then its guard must have been\n     * satisfied at the time of signal, and has since been modified by some other thread to be\n     * non-satisfied before reacquiring the lock, and that other thread takes over the responsibility\n     * of signaling the next waiter.\n     *\n     * Unlike the underlying Condition, if we are not careful, an interrupt *can* cause a signal to be\n     * lost, because the signal may be sent to a condition whose sole waiter has just been\n     * interrupted.\n     *\n     * Imagine a monitor with multiple guards. A thread enters the monitor, satisfies all the guards,\n     * and leaves, calling signalNextWaiter. With traditional locks and conditions, all the conditions\n     * need to be signalled because it is not known which if any of them have waiters (and hasWaiters\n     * can't be used reliably because of a check-then-act race). With our Monitor guards, we only\n     * signal the first active guard that is satisfied. But the corresponding thread may have already\n     * been interrupted and is waiting to reacquire the lock while still registered in activeGuards,\n     * in which case the signal is a no-op, and the bigger-picture signal is lost unless interrupted\n     * threads take special action by participating in the signal-passing game.\n     */\n\n    /*\n     * Timeout handling is intricate, especially given our ambitious goals:\n     * - Avoid underflow and overflow of timeout values when specified timeouts are close to\n     *   Long.MIN_VALUE or Long.MAX_VALUE.\n     * - Favor responding to interrupts over timeouts.\n     * - System.nanoTime() is expensive enough that we want to call it the minimum required number of\n     *   times, typically once before invoking a blocking method. This often requires keeping track of\n     *   the first time in a method that nanoTime() has been invoked, for which the special value 0L\n     *   is reserved to mean \"uninitialized\". If timeout is non-positive, then nanoTime need never be\n     *   called.\n     * - Keep behavior of fair and non-fair instances consistent.\n     */\n\n    /**\n     * A boolean condition for which a thread may wait. A {@code Guard} is associated with a single\n     * {@code Monitor}. The monitor may check the guard at arbitrary times from any thread occupying\n     * the monitor, so code should not be written to rely on how often a guard might or might not be\n     * checked.\n     *\n     * <p>If a {@code Guard} is passed into any method of a {@code Monitor} other than the one it is\n     * associated with, an {@link IllegalMonitorStateException} is thrown.\n     *\n     * @since 10.0\n     */\n    @Beta\n    public abstract static class Guard\n    {\n\n        @Weak final Monitor monitor;\n        final Condition condition;\n\n        @GuardedBy(\"monitor.lock\")\n        int waiterCount = 0;\n\n        /** The next active guard */\n        @GuardedBy(\"monitor.lock\")\n        @NullableDecl\n        Guard next;\n\n        protected Guard(Monitor monitor)\n        {\n            this.monitor = checkNotNull(monitor, \"monitor\");\n            this.condition = monitor.lock.newCondition();\n        }\n\n        /**\n         * Evaluates this guard's boolean condition. This method is always called with the associated\n         * monitor already occupied. Implementations of this method must depend only on state protected\n         * by the associated monitor, and must not modify that state.\n         */\n        public abstract boolean isSatisfied();\n    }\n\n    /** Whether this monitor is fair. */\n    private final boolean fair;\n\n    /** The lock underlying this monitor. */\n    private final ReentrantLock lock;\n\n    /**\n     * The guards associated with this monitor that currently have waiters ({@code waiterCount > 0}).\n     * A linked list threaded through the Guard.next field.\n     */\n    @GuardedBy(\"lock\")\n    private Guard activeGuards = null;\n\n    /**\n     * Creates a monitor with a non-fair (but fast) ordering policy. Equivalent to {@code\n     * Monitor(false)}.\n     */\n    public Monitor()\n    {\n        this(false);\n    }\n\n    /**\n     * Creates a monitor with the given ordering policy.\n     *\n     * @param fair whether this monitor should use a fair ordering policy rather than a non-fair (but\n     *     fast) one\n     */\n    public Monitor(boolean fair)\n    {\n        this.fair = fair;\n        this.lock = new ReentrantLock(fair);\n    }\n\n    /** Enters this monitor. Blocks indefinitely. */\n    public void enter()\n    {\n        lock.lock();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time.\n     *\n     * @return whether the monitor was entered\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enter(long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        final ReentrantLock lock = this.lock;\n        if (!fair && lock.tryLock())\n        {\n            return true;\n        }\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            final long startTime = System.nanoTime();\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterInterruptibly() throws InterruptedException\n    {\n        lock.lockInterruptibly();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time, and may be interrupted.\n     *\n     * @return whether the monitor was entered\n     * @throws InterruptedException if interrupted while waiting\n     */\n\n    /**\n     * Enters this monitor if it is possible to do so immediately. Does not block.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered\n     */\n    public boolean tryEnter()\n    {\n        return lock.tryLock();\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterWhen(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                await(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied, and may be\n     * interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean reentrant = lock.isHeldByCurrentThread();\n        long startTime = 0L;\n\n        locked:\n        {\n            if (!fair)\n            {\n                // Check interrupt status to get behavior consistent with fair case.\n                if (Thread.interrupted())\n                {\n                    throw new InterruptedException();\n                }\n                if (lock.tryLock())\n                {\n                    break locked;\n                }\n            }\n            startTime = initNanoTime(timeoutNanos);\n            if (!lock.tryLock(time, unit))\n            {\n                return false;\n            }\n        }\n\n        boolean satisfied = false;\n        boolean threw = true;\n        try\n        {\n            satisfied =\n                guard.isSatisfied()\n                || awaitNanos(\n                    guard,\n                    (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),\n                    reentrant);\n            threw = false;\n            return satisfied;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                try\n                {\n                    // Don't need to signal if timed out, but do if interrupted\n                    if (threw && !reentrant)\n                    {\n                        signalNextWaiter();\n                    }\n                }\n                finally\n                {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n\n    /** Enters this monitor when the guard is satisfied. Blocks indefinitely. */\n    public void enterWhenUninterruptibly(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                awaitUninterruptibly(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        long startTime = 0L;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            if (fair || !lock.tryLock())\n            {\n                startTime = initNanoTime(timeoutNanos);\n                for (long remainingNanos = timeoutNanos; ; )\n                {\n                    try\n                    {\n                        if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS))\n                        {\n                            break;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        remainingNanos = remainingNanos(startTime, timeoutNanos);\n                    }\n                }\n            }\n\n            boolean satisfied = false;\n            try\n            {\n                while (true)\n                {\n                    try\n                    {\n                        if (guard.isSatisfied())\n                        {\n                            satisfied = true;\n                        }\n                        else\n                        {\n                            final long remainingNanos;\n                            if (startTime == 0L)\n                            {\n                                startTime = initNanoTime(timeoutNanos);\n                                remainingNanos = timeoutNanos;\n                            }\n                            else\n                            {\n                                remainingNanos = remainingNanos(startTime, timeoutNanos);\n                            }\n                            satisfied = awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                        }\n                        return satisfied;\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        signalBeforeWaiting = false;\n                    }\n                }\n            }\n            finally\n            {\n                if (!satisfied)\n                {\n                    lock.unlock(); // No need to signal if timed out\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean enterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!enter(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n    throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not\n     * block acquiring the lock and does not wait for the guard to be satisfied.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean tryEnterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock())\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be called\n     * only by a thread currently occupying this monitor.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void waitFor(Guard guard) throws InterruptedException\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            await(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted. May\n     * be called only by a thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        if (Thread.interrupted())\n        {\n            throw new InterruptedException();\n        }\n        return awaitNanos(guard, timeoutNanos, true);\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread\n     * currently occupying this monitor.\n     */\n    public void waitForUninterruptibly(Guard guard)\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            awaitUninterruptibly(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time. May be called only by a\n     * thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        boolean signalBeforeWaiting = true;\n        final long startTime = initNanoTime(timeoutNanos);\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    if (guard.isSatisfied())\n                    {\n                        return true;\n                    }\n                    signalBeforeWaiting = false;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /** Leaves this monitor. May be called only by a thread currently occupying this monitor. */\n    public void leave()\n    {\n        final ReentrantLock lock = this.lock;\n        try\n        {\n            // No need to signal if we will still be holding the lock when we return\n            if (lock.getHoldCount() == 1)\n            {\n                signalNextWaiter();\n            }\n        }\n        finally\n        {\n            lock.unlock(); // Will throw IllegalMonitorStateException if not held\n        }\n    }\n\n    /** Returns whether this monitor is using a fair ordering policy. */\n    public boolean isFair()\n    {\n        return fair;\n    }\n\n    /**\n     * Returns whether this monitor is occupied by any thread. This method is designed for use in\n     * monitoring of the system state, not for synchronization control.\n     */\n    public boolean isOccupied()\n    {\n        return lock.isLocked();\n    }\n\n    /**\n     * Returns whether the current thread is occupying this monitor (has entered more times than it\n     * has left).\n     */\n    public boolean isOccupiedByCurrentThread()\n    {\n        return lock.isHeldByCurrentThread();\n    }\n\n    /**\n     * Returns the number of times the current thread has entered this monitor in excess of the number\n     * of times it has left. Returns 0 if the current thread is not occupying this monitor.\n     */\n    public int getOccupiedDepth()\n    {\n        return lock.getHoldCount();\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting to enter this monitor. The value is only\n     * an estimate because the number of threads may change dynamically while this method traverses\n     * internal data structures. This method is designed for use in monitoring of the system state,\n     * not for synchronization control.\n     */\n    public int getQueueLength()\n    {\n        return lock.getQueueLength();\n    }\n\n    /**\n     * Returns whether any threads are waiting to enter this monitor. Note that because cancellations\n     * may occur at any time, a {@code true} return does not guarantee that any other thread will ever\n     * enter this monitor. This method is designed primarily for use in monitoring of the system\n     * state.\n     */\n    public boolean hasQueuedThreads()\n    {\n        return lock.hasQueuedThreads();\n    }\n\n    /**\n     * Queries whether the given thread is waiting to enter this monitor. Note that because\n     * cancellations may occur at any time, a {@code true} return does not guarantee that this thread\n     * will ever enter this monitor. This method is designed primarily for use in monitoring of the\n     * system state.\n     */\n    public boolean hasQueuedThread(Thread thread)\n    {\n        return lock.hasQueuedThread(thread);\n    }\n\n    /**\n     * Queries whether any threads are waiting for the given guard to become satisfied. Note that\n     * because timeouts and interrupts may occur at any time, a {@code true} return does not guarantee\n     * that the guard becoming satisfied in the future will awaken any threads. This method is\n     * designed primarily for use in monitoring of the system state.\n     */\n    public boolean hasWaiters(Guard guard)\n    {\n        return getWaitQueueLength(guard) > 0;\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting for the given guard to become satisfied.\n     * Note that because timeouts and interrupts may occur at any time, the estimate serves only as an\n     * upper bound on the actual number of waiters. This method is designed for use in monitoring of\n     * the system state, not for synchronization control.\n     */\n    public int getWaitQueueLength(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        lock.lock();\n        try\n        {\n            return guard.waiterCount;\n        }\n        finally\n        {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Returns unit.toNanos(time), additionally ensuring the returned value is not at risk of\n     * overflowing or underflowing, by bounding the value between 0 and (Long.MAX_VALUE / 4) * 3.\n     * Actually waiting for more than 219 years is not supported!\n     */\n    private static long toSafeNanos(long time, TimeUnit unit)\n    {\n        long timeoutNanos = unit.toNanos(time);\n        return (timeoutNanos <= 0L)\n               ? 0L\n               : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3 : timeoutNanos;\n    }\n\n    /**\n     * Returns System.nanoTime() unless the timeout has already elapsed. Returns 0L if and only if the\n     * timeout has already elapsed.\n     */\n    private static long initNanoTime(long timeoutNanos)\n    {\n        if (timeoutNanos <= 0L)\n        {\n            return 0L;\n        }\n        else\n        {\n            long startTime = System.nanoTime();\n            return (startTime == 0L) ? 1L : startTime;\n        }\n    }\n\n    /**\n     * Returns the remaining nanos until the given timeout, or 0L if the timeout has already elapsed.\n     * Caller must have previously sanitized timeoutNanos using toSafeNanos.\n     */\n    private static long remainingNanos(long startTime, long timeoutNanos)\n    {\n        // assert timeoutNanos == 0L || startTime != 0L;\n\n        // TODO : NOT CORRECT, BUT TESTS PASS ANYWAYS!\n        // if (true) return timeoutNanos;\n        // ONLY 2 TESTS FAIL IF WE DO:\n        // if (true) return 0;\n\n        return (timeoutNanos <= 0L) ? 0L : timeoutNanos - (System.nanoTime() - startTime);\n    }\n\n    /**\n     * Signals some other thread waiting on a satisfied guard, if one exists.\n     *\n     * <p>We manage calls to this method carefully, to signal only when necessary, but never losing a\n     * signal, which is the classic problem of this kind of concurrency construct. We must signal if\n     * the current thread is about to relinquish the lock and may have changed the state protected by\n     * the monitor, thereby causing some guard to be satisfied.\n     *\n     * <p>In addition, any thread that has been signalled when its guard was satisfied acquires the\n     * responsibility of signalling the next thread when it again relinquishes the lock. Unlike a\n     * normal Condition, there is no guarantee that an interrupted thread has not been signalled,\n     * since the concurrency control must manage multiple Conditions. So this method must generally be\n     * called when waits are interrupted.\n     *\n     * <p>On the other hand, if a signalled thread wakes up to discover that its guard is still not\n     * satisfied, it does *not* need to call this method before returning to wait. This can only\n     * happen due to spurious wakeup (ignorable) or another thread acquiring the lock before the\n     * current thread can and returning the guard to the unsatisfied state. In the latter case the\n     * other thread (last thread modifying the state protected by the monitor) takes over the\n     * responsibility of signalling the next waiter.\n     *\n     * <p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else\n     * the current thread's guard might be mistakenly signalled, leading to a lost signal.\n     */\n    @GuardedBy(\"lock\")\n    private void signalNextWaiter()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            if (isSatisfied(guard))\n            {\n                guard.condition.signal();\n                break;\n            }\n        }\n    }\n\n    /**\n     * Exactly like signalNextWaiter, but caller guarantees that guardToSkip need not be considered,\n     * because caller has previously checked that guardToSkip.isSatisfied() returned false. An\n     * optimization for the case that guardToSkip.isSatisfied() may be expensive.\n     *\n     * <p>We decided against using this method, since in practice, isSatisfied() is likely to be very\n     * cheap (typically one field read). Resurrect this method if you find that not to be true.\n     */\n    //   @GuardedBy(\"lock\")\n    //   private void signalNextWaiterSkipping(Guard guardToSkip) {\n    //     for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n    //       if (guard != guardToSkip && isSatisfied(guard)) {\n    //         guard.condition.signal();\n    //         break;\n    //       }\n    //     }\n    //   }\n\n    /**\n     * Exactly like guard.isSatisfied(), but in addition signals all waiting threads in the (hopefully\n     * unlikely) event that isSatisfied() throws.\n     */\n    @GuardedBy(\"lock\")\n    private boolean isSatisfied(Guard guard)\n    {\n        try\n        {\n            return guard.isSatisfied();\n        }\n        catch (Throwable throwable)\n        {\n            signalAllWaiters();\n            throw throwable;\n        }\n    }\n\n    /** Signals all threads waiting on guards. */\n    @GuardedBy(\"lock\")\n    private void signalAllWaiters()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            guard.condition.signalAll();\n        }\n    }\n\n    /** Records that the current thread is about to wait on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void beginWaitingFor(Guard guard)\n    {\n        int waiters = guard.waiterCount++;\n        if (waiters == 0)\n        {\n            // push guard onto activeGuards\n            guard.next = activeGuards;\n            activeGuards = guard;\n        }\n    }\n\n    /** Records that the current thread is no longer waiting on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void endWaitingFor(Guard guard)\n    {\n        int waiters = --guard.waiterCount;\n        if (waiters == 0)\n        {\n            // unlink guard from activeGuards\n            for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next)\n            {\n                if (p == guard)\n                {\n                    if (pred == null)\n                    {\n                        activeGuards = p.next;\n                    }\n                    else\n                    {\n                        pred.next = p.next;\n                    }\n                    p.next = null; // help GC\n                    break;\n                }\n            }\n        }\n    }\n\n    /*\n     * Methods that loop waiting on a guard's condition until the guard is satisfied, while recording\n     * this fact so that other threads know to check our guard and signal us. It's caller's\n     * responsibility to ensure that the guard is *not* currently satisfied.\n     */\n\n    @GuardedBy(\"lock\")\n    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.await();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    @GuardedBy(\"lock\")\n    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.awaitUninterruptibly();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    /** Caller should check before calling that guard is not satisfied. */\n    @GuardedBy(\"lock\")\n    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n    throws InterruptedException\n    {\n        boolean firstTime = true;\n        try\n        {\n            do\n            {\n                if (nanos <= 0L)\n                {\n                    return false;\n                }\n                if (firstTime)\n                {\n                    if (signalBeforeWaiting)\n                    {\n                        signalNextWaiter();\n                    }\n                    beginWaitingFor(guard);\n                    firstTime = false;\n                }\n                nanos = guard.condition.awaitNanos(nanos);\n            }\n            while (!guard.isSatisfied());\n            return true;\n        }\n        finally\n        {\n            if (!firstTime)\n            {\n                endWaitingFor(guard);\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.enterWhen", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.\n\n@throws InterruptedException if interrupted while waiting", "docstring_tokens": ["Enters", "this", "monitor", "when", "the", "guard", "is", "satisfied", ".", "Blocks", "indefinitely", "but", "may", "be", "interrupted", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L432-L451", "partition": "valid", "up_fun_num": 7, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.errorprone.annotations.concurrent.GuardedBy;", "import com.google.j2objc.annotations.Weak;", "import java.util.concurrent.TimeUnit;", "import java.util.concurrent.locks.Condition;", "import java.util.concurrent.locks.ReentrantLock;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Monitor\n", "    public void enter()\n", "    public boolean enter(long time, TimeUnit unit)\n", "    public void enterInterruptibly() throws InterruptedException\n", "    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n", "    public boolean tryEnter()\n", "    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void enterWhenUninterruptibly(Guard guard)\n", "    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIf(Guard guard)\n", "    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n", "    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean tryEnterIf(Guard guard)\n", "    public void waitFor(Guard guard) throws InterruptedException\n", "    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void waitForUninterruptibly(Guard guard)\n", "    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public void leave()\n", "    public boolean isFair()\n", "    public boolean isOccupied()\n", "    public boolean isOccupiedByCurrentThread()\n", "    public int getOccupiedDepth()\n", "    public int getQueueLength()\n", "    public boolean hasQueuedThreads()\n", "    public boolean hasQueuedThread(Thread thread)\n", "    public boolean hasWaiters(Guard guard)\n", "    public int getWaitQueueLength(Guard guard)\n", "    private static long toSafeNanos(long time, TimeUnit unit)\n", "    private static long initNanoTime(long timeoutNanos)\n", "    private static long remainingNanos(long startTime, long timeoutNanos)\n", "    private void signalNextWaiter()\n", "    private boolean isSatisfied(Guard guard)\n", "    private void signalAllWaiters()\n", "    private void beginWaitingFor(Guard guard)\n", "    private void endWaitingFor(Guard guard)\n", "    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n", "    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n", "    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n"], "context": "/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.concurrent.GuardedBy;\nimport com.google.j2objc.annotations.Weak;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A synchronization abstraction supporting waiting on arbitrary boolean conditions.\n *\n * <p>This class is intended as a replacement for {@link ReentrantLock}. Code using {@code Monitor}\n * is less error-prone and more readable than code using {@code ReentrantLock}, without significant\n * performance loss. {@code Monitor} even has the potential for performance gain by optimizing the\n * evaluation and signaling of conditions. Signaling is entirely <a\n * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>. By\n * eliminating explicit signaling, this class can guarantee that only one thread is awakened when a\n * condition becomes true (no \"signaling storms\" due to use of {@link\n * java.util.concurrent.locks.Condition#signalAll Condition.signalAll}) and that no signals are lost\n * (no \"hangs\" due to incorrect use of {@link java.util.concurrent.locks.Condition#signal\n * Condition.signal}).\n *\n * <p>A thread is said to <i>occupy</i> a monitor if it has <i>entered</i> the monitor but not yet\n * <i>left</i>. Only one thread may occupy a given monitor at any moment. A monitor is also\n * reentrant, so a thread may enter a monitor any number of times, and then must leave the same\n * number of times. The <i>enter</i> and <i>leave</i> operations have the same synchronization\n * semantics as the built-in Java language synchronization primitives.\n *\n * <p>A call to any of the <i>enter</i> methods with <b>void</b> return type should always be\n * followed immediately by a <i>try/finally</i> block to ensure that the current thread leaves the\n * monitor cleanly:\n *\n * <pre>{@code\n * monitor.enter();\n * try {\n *   // do things while occupying the monitor\n * } finally {\n *   monitor.leave();\n * }\n * }</pre>\n *\n * <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear\n * as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that\n * the current thread leaves the monitor cleanly:\n *\n * <pre>{@code\n * if (monitor.tryEnter()) {\n *   try {\n *     // do things while occupying the monitor\n *   } finally {\n *     monitor.leave();\n *   }\n * } else {\n *   // do other things since the monitor was not available\n * }\n * }</pre>\n *\n * <h2>Comparison with {@code synchronized} and {@code ReentrantLock}</h2>\n *\n * <p>The following examples show a simple threadsafe holder expressed using {@code synchronized},\n * {@link ReentrantLock}, and {@code Monitor}.\n *\n * <h3>{@code synchronized}</h3>\n *\n * <p>This version is the fewest lines of code, largely because the synchronization mechanism used\n * is built into the language and runtime. But the programmer has to remember to avoid a couple of\n * common bugs: The {@code wait()} must be inside a {@code while} instead of an {@code if}, and\n * {@code notifyAll()} must be used instead of {@code notify()} because there are two different\n * logical conditions being awaited.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *\n *   public synchronized V get() throws InterruptedException {\n *     while (value == null) {\n *       wait();\n *     }\n *     V result = value;\n *     value = null;\n *     notifyAll();\n *     return result;\n *   }\n *\n *   public synchronized void set(V newValue) throws InterruptedException {\n *     while (value != null) {\n *       wait();\n *     }\n *     value = newValue;\n *     notifyAll();\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code ReentrantLock}</h3>\n *\n * <p>This version is much more verbose than the {@code synchronized} version, and still suffers\n * from the need for the programmer to remember to use {@code while} instead of {@code if}. However,\n * one advantage is that we can introduce two separate {@code Condition} objects, which allows us to\n * use {@code signal()} instead of {@code signalAll()}, which may be a performance benefit.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final ReentrantLock lock = new ReentrantLock();\n *   private final Condition valuePresent = lock.newCondition();\n *   private final Condition valueAbsent = lock.newCondition();\n *\n *   public V get() throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value == null) {\n *         valuePresent.await();\n *       }\n *       V result = value;\n *       value = null;\n *       valueAbsent.signal();\n *       return result;\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value != null) {\n *         valueAbsent.await();\n *       }\n *       value = newValue;\n *       valuePresent.signal();\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code Monitor}</h3>\n *\n * <p>This version adds some verbosity around the {@code Guard} objects, but removes that same\n * verbosity, and more, from the {@code get} and {@code set} methods. {@code Monitor} implements the\n * same efficient signaling as we had to hand-code in the {@code ReentrantLock} version above.\n * Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to\n * remember to use {@code while} instead of {@code if}.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final Monitor monitor = new Monitor();\n *   private final Monitor.Guard valuePresent = monitor.newGuard(() -> value != null);\n *   private final Monitor.Guard valueAbsent = monitor.newGuard(() -> value == null);\n *\n *   public V get() throws InterruptedException {\n *     monitor.enterWhen(valuePresent);\n *     try {\n *       V result = value;\n *       value = null;\n *       return result;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     monitor.enterWhen(valueAbsent);\n *     try {\n *       value = newValue;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n * }\n * }</pre>\n *\n * @author Justin T. Sampson\n * @author Martin Buchholz\n * @since 10.0\n */\n@Beta\n@GwtIncompatible\n@SuppressWarnings(\"GuardedBy\") // TODO(b/35466881): Fix or suppress.\npublic final class Monitor\n{\n    // TODO(user): Use raw LockSupport or AbstractQueuedSynchronizer instead of ReentrantLock.\n    // TODO(user): \"Port\" jsr166 tests for ReentrantLock.\n    //\n    // TODO(user): Change API to make it impossible to use a Guard with the \"wrong\" monitor,\n    //    by making the monitor implicit, and to eliminate other sources of IMSE.\n    //    Imagine:\n    //    guard.lock();\n    //    try { /* monitor locked and guard satisfied here */ }\n    //    finally { guard.unlock(); }\n    // Here are Justin's design notes about this:\n    //\n    // This idea has come up from time to time, and I think one of my\n    // earlier versions of Monitor even did something like this. I ended\n    // up strongly favoring the current interface.\n    //\n    // I probably can't remember all the reasons (it's possible you\n    // could find them in the code review archives), but here are a few:\n    //\n    // 1. What about leaving/unlocking? Are you going to do\n    //    guard.enter() paired with monitor.leave()? That might get\n    //    confusing. It's nice for the finally block to look as close as\n    //    possible to the thing right before the try. You could have\n    //    guard.leave(), but that's a little odd as well because the\n    //    guard doesn't have anything to do with leaving. You can't\n    //    really enforce that the guard you're leaving is the same one\n    //    you entered with, and it doesn't actually matter.\n    //\n    // 2. Since you can enter the monitor without a guard at all, some\n    //    places you'll have monitor.enter()/monitor.leave() and other\n    //    places you'll have guard.enter()/guard.leave() even though\n    //    it's the same lock being acquired underneath. Always using\n    //    monitor.enterXXX()/monitor.leave() will make it really clear\n    //    which lock is held at any point in the code.\n    //\n    // 3. I think \"enterWhen(notEmpty)\" reads better than \"notEmpty.enter()\".\n    //\n    // TODO(user): Implement ReentrantLock features:\n    //    - toString() method\n    //    - getOwner() method\n    //    - getQueuedThreads() method\n    //    - getWaitingThreads(Guard) method\n    //    - implement Serializable\n    //    - redo the API to be as close to identical to ReentrantLock as possible,\n    //      since, after all, this class is also a reentrant mutual exclusion lock!?\n\n    /*\n     * One of the key challenges of this class is to prevent lost signals, while trying hard to\n     * minimize unnecessary signals. One simple and correct algorithm is to signal some other waiter\n     * with a satisfied guard (if one exists) whenever any thread occupying the monitor exits the\n     * monitor, either by unlocking all of its held locks, or by starting to wait for a guard. This\n     * includes exceptional exits, so all control paths involving signalling must be protected by a\n     * finally block.\n     *\n     * Further optimizations of this algorithm become increasingly subtle. A wait that terminates\n     * without the guard being satisfied (due to timeout, but not interrupt) can then immediately exit\n     * the monitor without signalling. If it timed out without being signalled, it does not need to\n     * \"pass on\" the signal to another thread. If it *was* signalled, then its guard must have been\n     * satisfied at the time of signal, and has since been modified by some other thread to be\n     * non-satisfied before reacquiring the lock, and that other thread takes over the responsibility\n     * of signaling the next waiter.\n     *\n     * Unlike the underlying Condition, if we are not careful, an interrupt *can* cause a signal to be\n     * lost, because the signal may be sent to a condition whose sole waiter has just been\n     * interrupted.\n     *\n     * Imagine a monitor with multiple guards. A thread enters the monitor, satisfies all the guards,\n     * and leaves, calling signalNextWaiter. With traditional locks and conditions, all the conditions\n     * need to be signalled because it is not known which if any of them have waiters (and hasWaiters\n     * can't be used reliably because of a check-then-act race). With our Monitor guards, we only\n     * signal the first active guard that is satisfied. But the corresponding thread may have already\n     * been interrupted and is waiting to reacquire the lock while still registered in activeGuards,\n     * in which case the signal is a no-op, and the bigger-picture signal is lost unless interrupted\n     * threads take special action by participating in the signal-passing game.\n     */\n\n    /*\n     * Timeout handling is intricate, especially given our ambitious goals:\n     * - Avoid underflow and overflow of timeout values when specified timeouts are close to\n     *   Long.MIN_VALUE or Long.MAX_VALUE.\n     * - Favor responding to interrupts over timeouts.\n     * - System.nanoTime() is expensive enough that we want to call it the minimum required number of\n     *   times, typically once before invoking a blocking method. This often requires keeping track of\n     *   the first time in a method that nanoTime() has been invoked, for which the special value 0L\n     *   is reserved to mean \"uninitialized\". If timeout is non-positive, then nanoTime need never be\n     *   called.\n     * - Keep behavior of fair and non-fair instances consistent.\n     */\n\n    /**\n     * A boolean condition for which a thread may wait. A {@code Guard} is associated with a single\n     * {@code Monitor}. The monitor may check the guard at arbitrary times from any thread occupying\n     * the monitor, so code should not be written to rely on how often a guard might or might not be\n     * checked.\n     *\n     * <p>If a {@code Guard} is passed into any method of a {@code Monitor} other than the one it is\n     * associated with, an {@link IllegalMonitorStateException} is thrown.\n     *\n     * @since 10.0\n     */\n    @Beta\n    public abstract static class Guard\n    {\n\n        @Weak final Monitor monitor;\n        final Condition condition;\n\n        @GuardedBy(\"monitor.lock\")\n        int waiterCount = 0;\n\n        /** The next active guard */\n        @GuardedBy(\"monitor.lock\")\n        @NullableDecl\n        Guard next;\n\n        protected Guard(Monitor monitor)\n        {\n            this.monitor = checkNotNull(monitor, \"monitor\");\n            this.condition = monitor.lock.newCondition();\n        }\n\n        /**\n         * Evaluates this guard's boolean condition. This method is always called with the associated\n         * monitor already occupied. Implementations of this method must depend only on state protected\n         * by the associated monitor, and must not modify that state.\n         */\n        public abstract boolean isSatisfied();\n    }\n\n    /** Whether this monitor is fair. */\n    private final boolean fair;\n\n    /** The lock underlying this monitor. */\n    private final ReentrantLock lock;\n\n    /**\n     * The guards associated with this monitor that currently have waiters ({@code waiterCount > 0}).\n     * A linked list threaded through the Guard.next field.\n     */\n    @GuardedBy(\"lock\")\n    private Guard activeGuards = null;\n\n    /**\n     * Creates a monitor with a non-fair (but fast) ordering policy. Equivalent to {@code\n     * Monitor(false)}.\n     */\n    public Monitor()\n    {\n        this(false);\n    }\n\n    /**\n     * Creates a monitor with the given ordering policy.\n     *\n     * @param fair whether this monitor should use a fair ordering policy rather than a non-fair (but\n     *     fast) one\n     */\n    public Monitor(boolean fair)\n    {\n        this.fair = fair;\n        this.lock = new ReentrantLock(fair);\n    }\n\n    /** Enters this monitor. Blocks indefinitely. */\n    public void enter()\n    {\n        lock.lock();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time.\n     *\n     * @return whether the monitor was entered\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enter(long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        final ReentrantLock lock = this.lock;\n        if (!fair && lock.tryLock())\n        {\n            return true;\n        }\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            final long startTime = System.nanoTime();\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterInterruptibly() throws InterruptedException\n    {\n        lock.lockInterruptibly();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time, and may be interrupted.\n     *\n     * @return whether the monitor was entered\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n    {\n        return lock.tryLock(time, unit);\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately. Does not block.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered\n     */\n    public boolean tryEnter()\n    {\n        return lock.tryLock();\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied, and may be\n     * interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean reentrant = lock.isHeldByCurrentThread();\n        long startTime = 0L;\n\n        locked:\n        {\n            if (!fair)\n            {\n                // Check interrupt status to get behavior consistent with fair case.\n                if (Thread.interrupted())\n                {\n                    throw new InterruptedException();\n                }\n                if (lock.tryLock())\n                {\n                    break locked;\n                }\n            }\n            startTime = initNanoTime(timeoutNanos);\n            if (!lock.tryLock(time, unit))\n            {\n                return false;\n            }\n        }\n\n        boolean satisfied = false;\n        boolean threw = true;\n        try\n        {\n            satisfied =\n                guard.isSatisfied()\n                || awaitNanos(\n                    guard,\n                    (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),\n                    reentrant);\n            threw = false;\n            return satisfied;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                try\n                {\n                    // Don't need to signal if timed out, but do if interrupted\n                    if (threw && !reentrant)\n                    {\n                        signalNextWaiter();\n                    }\n                }\n                finally\n                {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n\n    /** Enters this monitor when the guard is satisfied. Blocks indefinitely. */\n    public void enterWhenUninterruptibly(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                awaitUninterruptibly(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        long startTime = 0L;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            if (fair || !lock.tryLock())\n            {\n                startTime = initNanoTime(timeoutNanos);\n                for (long remainingNanos = timeoutNanos; ; )\n                {\n                    try\n                    {\n                        if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS))\n                        {\n                            break;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        remainingNanos = remainingNanos(startTime, timeoutNanos);\n                    }\n                }\n            }\n\n            boolean satisfied = false;\n            try\n            {\n                while (true)\n                {\n                    try\n                    {\n                        if (guard.isSatisfied())\n                        {\n                            satisfied = true;\n                        }\n                        else\n                        {\n                            final long remainingNanos;\n                            if (startTime == 0L)\n                            {\n                                startTime = initNanoTime(timeoutNanos);\n                                remainingNanos = timeoutNanos;\n                            }\n                            else\n                            {\n                                remainingNanos = remainingNanos(startTime, timeoutNanos);\n                            }\n                            satisfied = awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                        }\n                        return satisfied;\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        signalBeforeWaiting = false;\n                    }\n                }\n            }\n            finally\n            {\n                if (!satisfied)\n                {\n                    lock.unlock(); // No need to signal if timed out\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean enterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!enter(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n    throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not\n     * block acquiring the lock and does not wait for the guard to be satisfied.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean tryEnterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock())\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be called\n     * only by a thread currently occupying this monitor.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void waitFor(Guard guard) throws InterruptedException\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            await(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted. May\n     * be called only by a thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        if (Thread.interrupted())\n        {\n            throw new InterruptedException();\n        }\n        return awaitNanos(guard, timeoutNanos, true);\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread\n     * currently occupying this monitor.\n     */\n    public void waitForUninterruptibly(Guard guard)\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            awaitUninterruptibly(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time. May be called only by a\n     * thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        boolean signalBeforeWaiting = true;\n        final long startTime = initNanoTime(timeoutNanos);\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    if (guard.isSatisfied())\n                    {\n                        return true;\n                    }\n                    signalBeforeWaiting = false;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /** Leaves this monitor. May be called only by a thread currently occupying this monitor. */\n    public void leave()\n    {\n        final ReentrantLock lock = this.lock;\n        try\n        {\n            // No need to signal if we will still be holding the lock when we return\n            if (lock.getHoldCount() == 1)\n            {\n                signalNextWaiter();\n            }\n        }\n        finally\n        {\n            lock.unlock(); // Will throw IllegalMonitorStateException if not held\n        }\n    }\n\n    /** Returns whether this monitor is using a fair ordering policy. */\n    public boolean isFair()\n    {\n        return fair;\n    }\n\n    /**\n     * Returns whether this monitor is occupied by any thread. This method is designed for use in\n     * monitoring of the system state, not for synchronization control.\n     */\n    public boolean isOccupied()\n    {\n        return lock.isLocked();\n    }\n\n    /**\n     * Returns whether the current thread is occupying this monitor (has entered more times than it\n     * has left).\n     */\n    public boolean isOccupiedByCurrentThread()\n    {\n        return lock.isHeldByCurrentThread();\n    }\n\n    /**\n     * Returns the number of times the current thread has entered this monitor in excess of the number\n     * of times it has left. Returns 0 if the current thread is not occupying this monitor.\n     */\n    public int getOccupiedDepth()\n    {\n        return lock.getHoldCount();\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting to enter this monitor. The value is only\n     * an estimate because the number of threads may change dynamically while this method traverses\n     * internal data structures. This method is designed for use in monitoring of the system state,\n     * not for synchronization control.\n     */\n    public int getQueueLength()\n    {\n        return lock.getQueueLength();\n    }\n\n    /**\n     * Returns whether any threads are waiting to enter this monitor. Note that because cancellations\n     * may occur at any time, a {@code true} return does not guarantee that any other thread will ever\n     * enter this monitor. This method is designed primarily for use in monitoring of the system\n     * state.\n     */\n    public boolean hasQueuedThreads()\n    {\n        return lock.hasQueuedThreads();\n    }\n\n    /**\n     * Queries whether the given thread is waiting to enter this monitor. Note that because\n     * cancellations may occur at any time, a {@code true} return does not guarantee that this thread\n     * will ever enter this monitor. This method is designed primarily for use in monitoring of the\n     * system state.\n     */\n    public boolean hasQueuedThread(Thread thread)\n    {\n        return lock.hasQueuedThread(thread);\n    }\n\n    /**\n     * Queries whether any threads are waiting for the given guard to become satisfied. Note that\n     * because timeouts and interrupts may occur at any time, a {@code true} return does not guarantee\n     * that the guard becoming satisfied in the future will awaken any threads. This method is\n     * designed primarily for use in monitoring of the system state.\n     */\n    public boolean hasWaiters(Guard guard)\n    {\n        return getWaitQueueLength(guard) > 0;\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting for the given guard to become satisfied.\n     * Note that because timeouts and interrupts may occur at any time, the estimate serves only as an\n     * upper bound on the actual number of waiters. This method is designed for use in monitoring of\n     * the system state, not for synchronization control.\n     */\n    public int getWaitQueueLength(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        lock.lock();\n        try\n        {\n            return guard.waiterCount;\n        }\n        finally\n        {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Returns unit.toNanos(time), additionally ensuring the returned value is not at risk of\n     * overflowing or underflowing, by bounding the value between 0 and (Long.MAX_VALUE / 4) * 3.\n     * Actually waiting for more than 219 years is not supported!\n     */\n    private static long toSafeNanos(long time, TimeUnit unit)\n    {\n        long timeoutNanos = unit.toNanos(time);\n        return (timeoutNanos <= 0L)\n               ? 0L\n               : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3 : timeoutNanos;\n    }\n\n    /**\n     * Returns System.nanoTime() unless the timeout has already elapsed. Returns 0L if and only if the\n     * timeout has already elapsed.\n     */\n    private static long initNanoTime(long timeoutNanos)\n    {\n        if (timeoutNanos <= 0L)\n        {\n            return 0L;\n        }\n        else\n        {\n            long startTime = System.nanoTime();\n            return (startTime == 0L) ? 1L : startTime;\n        }\n    }\n\n    /**\n     * Returns the remaining nanos until the given timeout, or 0L if the timeout has already elapsed.\n     * Caller must have previously sanitized timeoutNanos using toSafeNanos.\n     */\n    private static long remainingNanos(long startTime, long timeoutNanos)\n    {\n        // assert timeoutNanos == 0L || startTime != 0L;\n\n        // TODO : NOT CORRECT, BUT TESTS PASS ANYWAYS!\n        // if (true) return timeoutNanos;\n        // ONLY 2 TESTS FAIL IF WE DO:\n        // if (true) return 0;\n\n        return (timeoutNanos <= 0L) ? 0L : timeoutNanos - (System.nanoTime() - startTime);\n    }\n\n    /**\n     * Signals some other thread waiting on a satisfied guard, if one exists.\n     *\n     * <p>We manage calls to this method carefully, to signal only when necessary, but never losing a\n     * signal, which is the classic problem of this kind of concurrency construct. We must signal if\n     * the current thread is about to relinquish the lock and may have changed the state protected by\n     * the monitor, thereby causing some guard to be satisfied.\n     *\n     * <p>In addition, any thread that has been signalled when its guard was satisfied acquires the\n     * responsibility of signalling the next thread when it again relinquishes the lock. Unlike a\n     * normal Condition, there is no guarantee that an interrupted thread has not been signalled,\n     * since the concurrency control must manage multiple Conditions. So this method must generally be\n     * called when waits are interrupted.\n     *\n     * <p>On the other hand, if a signalled thread wakes up to discover that its guard is still not\n     * satisfied, it does *not* need to call this method before returning to wait. This can only\n     * happen due to spurious wakeup (ignorable) or another thread acquiring the lock before the\n     * current thread can and returning the guard to the unsatisfied state. In the latter case the\n     * other thread (last thread modifying the state protected by the monitor) takes over the\n     * responsibility of signalling the next waiter.\n     *\n     * <p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else\n     * the current thread's guard might be mistakenly signalled, leading to a lost signal.\n     */\n    @GuardedBy(\"lock\")\n    private void signalNextWaiter()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            if (isSatisfied(guard))\n            {\n                guard.condition.signal();\n                break;\n            }\n        }\n    }\n\n    /**\n     * Exactly like signalNextWaiter, but caller guarantees that guardToSkip need not be considered,\n     * because caller has previously checked that guardToSkip.isSatisfied() returned false. An\n     * optimization for the case that guardToSkip.isSatisfied() may be expensive.\n     *\n     * <p>We decided against using this method, since in practice, isSatisfied() is likely to be very\n     * cheap (typically one field read). Resurrect this method if you find that not to be true.\n     */\n    //   @GuardedBy(\"lock\")\n    //   private void signalNextWaiterSkipping(Guard guardToSkip) {\n    //     for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n    //       if (guard != guardToSkip && isSatisfied(guard)) {\n    //         guard.condition.signal();\n    //         break;\n    //       }\n    //     }\n    //   }\n\n    /**\n     * Exactly like guard.isSatisfied(), but in addition signals all waiting threads in the (hopefully\n     * unlikely) event that isSatisfied() throws.\n     */\n    @GuardedBy(\"lock\")\n    private boolean isSatisfied(Guard guard)\n    {\n        try\n        {\n            return guard.isSatisfied();\n        }\n        catch (Throwable throwable)\n        {\n            signalAllWaiters();\n            throw throwable;\n        }\n    }\n\n    /** Signals all threads waiting on guards. */\n    @GuardedBy(\"lock\")\n    private void signalAllWaiters()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            guard.condition.signalAll();\n        }\n    }\n\n    /** Records that the current thread is about to wait on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void beginWaitingFor(Guard guard)\n    {\n        int waiters = guard.waiterCount++;\n        if (waiters == 0)\n        {\n            // push guard onto activeGuards\n            guard.next = activeGuards;\n            activeGuards = guard;\n        }\n    }\n\n    /** Records that the current thread is no longer waiting on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void endWaitingFor(Guard guard)\n    {\n        int waiters = --guard.waiterCount;\n        if (waiters == 0)\n        {\n            // unlink guard from activeGuards\n            for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next)\n            {\n                if (p == guard)\n                {\n                    if (pred == null)\n                    {\n                        activeGuards = p.next;\n                    }\n                    else\n                    {\n                        pred.next = p.next;\n                    }\n                    p.next = null; // help GC\n                    break;\n                }\n            }\n        }\n    }\n\n    /*\n     * Methods that loop waiting on a guard's condition until the guard is satisfied, while recording\n     * this fact so that other threads know to check our guard and signal us. It's caller's\n     * responsibility to ensure that the guard is *not* currently satisfied.\n     */\n\n    @GuardedBy(\"lock\")\n    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.await();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    @GuardedBy(\"lock\")\n    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.awaitUninterruptibly();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    /** Caller should check before calling that guard is not satisfied. */\n    @GuardedBy(\"lock\")\n    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n    throws InterruptedException\n    {\n        boolean firstTime = true;\n        try\n        {\n            do\n            {\n                if (nanos <= 0L)\n                {\n                    return false;\n                }\n                if (firstTime)\n                {\n                    if (signalBeforeWaiting)\n                    {\n                        signalNextWaiter();\n                    }\n                    beginWaitingFor(guard);\n                    firstTime = false;\n                }\n                nanos = guard.condition.awaitNanos(nanos);\n            }\n            while (!guard.isSatisfied());\n            return true;\n        }\n        finally\n        {\n            if (!firstTime)\n            {\n                endWaitingFor(guard);\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.enterWhen", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\nthe time to acquire the lock and the time to wait for the guard to be satisfied, and may be\ninterrupted.\n\n@return whether the monitor was entered, which guarantees that the guard is now satisfied\n@throws InterruptedException if interrupted while waiting", "docstring_tokens": ["Enters", "this", "monitor", "when", "the", "guard", "is", "satisfied", ".", "Blocks", "at", "most", "the", "given", "time", "including", "both", "the", "time", "to", "acquire", "the", "lock", "and", "the", "time", "to", "wait", "for", "the", "guard", "to", "be", "satisfied", "and", "may", "be", "interrupted", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L461-L511", "partition": "valid", "up_fun_num": 7, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.errorprone.annotations.concurrent.GuardedBy;", "import com.google.j2objc.annotations.Weak;", "import java.util.concurrent.TimeUnit;", "import java.util.concurrent.locks.Condition;", "import java.util.concurrent.locks.ReentrantLock;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Monitor\n", "    public void enter()\n", "    public boolean enter(long time, TimeUnit unit)\n", "    public void enterInterruptibly() throws InterruptedException\n", "    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n", "    public boolean tryEnter()\n", "    public void enterWhen(Guard guard) throws InterruptedException\n", "    public void enterWhenUninterruptibly(Guard guard)\n", "    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIf(Guard guard)\n", "    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n", "    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean tryEnterIf(Guard guard)\n", "    public void waitFor(Guard guard) throws InterruptedException\n", "    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void waitForUninterruptibly(Guard guard)\n", "    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public void leave()\n", "    public boolean isFair()\n", "    public boolean isOccupied()\n", "    public boolean isOccupiedByCurrentThread()\n", "    public int getOccupiedDepth()\n", "    public int getQueueLength()\n", "    public boolean hasQueuedThreads()\n", "    public boolean hasQueuedThread(Thread thread)\n", "    public boolean hasWaiters(Guard guard)\n", "    public int getWaitQueueLength(Guard guard)\n", "    private static long toSafeNanos(long time, TimeUnit unit)\n", "    private static long initNanoTime(long timeoutNanos)\n", "    private static long remainingNanos(long startTime, long timeoutNanos)\n", "    private void signalNextWaiter()\n", "    private boolean isSatisfied(Guard guard)\n", "    private void signalAllWaiters()\n", "    private void beginWaitingFor(Guard guard)\n", "    private void endWaitingFor(Guard guard)\n", "    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n", "    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n", "    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n"], "context": "/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.concurrent.GuardedBy;\nimport com.google.j2objc.annotations.Weak;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A synchronization abstraction supporting waiting on arbitrary boolean conditions.\n *\n * <p>This class is intended as a replacement for {@link ReentrantLock}. Code using {@code Monitor}\n * is less error-prone and more readable than code using {@code ReentrantLock}, without significant\n * performance loss. {@code Monitor} even has the potential for performance gain by optimizing the\n * evaluation and signaling of conditions. Signaling is entirely <a\n * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>. By\n * eliminating explicit signaling, this class can guarantee that only one thread is awakened when a\n * condition becomes true (no \"signaling storms\" due to use of {@link\n * java.util.concurrent.locks.Condition#signalAll Condition.signalAll}) and that no signals are lost\n * (no \"hangs\" due to incorrect use of {@link java.util.concurrent.locks.Condition#signal\n * Condition.signal}).\n *\n * <p>A thread is said to <i>occupy</i> a monitor if it has <i>entered</i> the monitor but not yet\n * <i>left</i>. Only one thread may occupy a given monitor at any moment. A monitor is also\n * reentrant, so a thread may enter a monitor any number of times, and then must leave the same\n * number of times. The <i>enter</i> and <i>leave</i> operations have the same synchronization\n * semantics as the built-in Java language synchronization primitives.\n *\n * <p>A call to any of the <i>enter</i> methods with <b>void</b> return type should always be\n * followed immediately by a <i>try/finally</i> block to ensure that the current thread leaves the\n * monitor cleanly:\n *\n * <pre>{@code\n * monitor.enter();\n * try {\n *   // do things while occupying the monitor\n * } finally {\n *   monitor.leave();\n * }\n * }</pre>\n *\n * <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear\n * as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that\n * the current thread leaves the monitor cleanly:\n *\n * <pre>{@code\n * if (monitor.tryEnter()) {\n *   try {\n *     // do things while occupying the monitor\n *   } finally {\n *     monitor.leave();\n *   }\n * } else {\n *   // do other things since the monitor was not available\n * }\n * }</pre>\n *\n * <h2>Comparison with {@code synchronized} and {@code ReentrantLock}</h2>\n *\n * <p>The following examples show a simple threadsafe holder expressed using {@code synchronized},\n * {@link ReentrantLock}, and {@code Monitor}.\n *\n * <h3>{@code synchronized}</h3>\n *\n * <p>This version is the fewest lines of code, largely because the synchronization mechanism used\n * is built into the language and runtime. But the programmer has to remember to avoid a couple of\n * common bugs: The {@code wait()} must be inside a {@code while} instead of an {@code if}, and\n * {@code notifyAll()} must be used instead of {@code notify()} because there are two different\n * logical conditions being awaited.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *\n *   public synchronized V get() throws InterruptedException {\n *     while (value == null) {\n *       wait();\n *     }\n *     V result = value;\n *     value = null;\n *     notifyAll();\n *     return result;\n *   }\n *\n *   public synchronized void set(V newValue) throws InterruptedException {\n *     while (value != null) {\n *       wait();\n *     }\n *     value = newValue;\n *     notifyAll();\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code ReentrantLock}</h3>\n *\n * <p>This version is much more verbose than the {@code synchronized} version, and still suffers\n * from the need for the programmer to remember to use {@code while} instead of {@code if}. However,\n * one advantage is that we can introduce two separate {@code Condition} objects, which allows us to\n * use {@code signal()} instead of {@code signalAll()}, which may be a performance benefit.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final ReentrantLock lock = new ReentrantLock();\n *   private final Condition valuePresent = lock.newCondition();\n *   private final Condition valueAbsent = lock.newCondition();\n *\n *   public V get() throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value == null) {\n *         valuePresent.await();\n *       }\n *       V result = value;\n *       value = null;\n *       valueAbsent.signal();\n *       return result;\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value != null) {\n *         valueAbsent.await();\n *       }\n *       value = newValue;\n *       valuePresent.signal();\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code Monitor}</h3>\n *\n * <p>This version adds some verbosity around the {@code Guard} objects, but removes that same\n * verbosity, and more, from the {@code get} and {@code set} methods. {@code Monitor} implements the\n * same efficient signaling as we had to hand-code in the {@code ReentrantLock} version above.\n * Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to\n * remember to use {@code while} instead of {@code if}.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final Monitor monitor = new Monitor();\n *   private final Monitor.Guard valuePresent = monitor.newGuard(() -> value != null);\n *   private final Monitor.Guard valueAbsent = monitor.newGuard(() -> value == null);\n *\n *   public V get() throws InterruptedException {\n *     monitor.enterWhen(valuePresent);\n *     try {\n *       V result = value;\n *       value = null;\n *       return result;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     monitor.enterWhen(valueAbsent);\n *     try {\n *       value = newValue;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n * }\n * }</pre>\n *\n * @author Justin T. Sampson\n * @author Martin Buchholz\n * @since 10.0\n */\n@Beta\n@GwtIncompatible\n@SuppressWarnings(\"GuardedBy\") // TODO(b/35466881): Fix or suppress.\npublic final class Monitor\n{\n    // TODO(user): Use raw LockSupport or AbstractQueuedSynchronizer instead of ReentrantLock.\n    // TODO(user): \"Port\" jsr166 tests for ReentrantLock.\n    //\n    // TODO(user): Change API to make it impossible to use a Guard with the \"wrong\" monitor,\n    //    by making the monitor implicit, and to eliminate other sources of IMSE.\n    //    Imagine:\n    //    guard.lock();\n    //    try { /* monitor locked and guard satisfied here */ }\n    //    finally { guard.unlock(); }\n    // Here are Justin's design notes about this:\n    //\n    // This idea has come up from time to time, and I think one of my\n    // earlier versions of Monitor even did something like this. I ended\n    // up strongly favoring the current interface.\n    //\n    // I probably can't remember all the reasons (it's possible you\n    // could find them in the code review archives), but here are a few:\n    //\n    // 1. What about leaving/unlocking? Are you going to do\n    //    guard.enter() paired with monitor.leave()? That might get\n    //    confusing. It's nice for the finally block to look as close as\n    //    possible to the thing right before the try. You could have\n    //    guard.leave(), but that's a little odd as well because the\n    //    guard doesn't have anything to do with leaving. You can't\n    //    really enforce that the guard you're leaving is the same one\n    //    you entered with, and it doesn't actually matter.\n    //\n    // 2. Since you can enter the monitor without a guard at all, some\n    //    places you'll have monitor.enter()/monitor.leave() and other\n    //    places you'll have guard.enter()/guard.leave() even though\n    //    it's the same lock being acquired underneath. Always using\n    //    monitor.enterXXX()/monitor.leave() will make it really clear\n    //    which lock is held at any point in the code.\n    //\n    // 3. I think \"enterWhen(notEmpty)\" reads better than \"notEmpty.enter()\".\n    //\n    // TODO(user): Implement ReentrantLock features:\n    //    - toString() method\n    //    - getOwner() method\n    //    - getQueuedThreads() method\n    //    - getWaitingThreads(Guard) method\n    //    - implement Serializable\n    //    - redo the API to be as close to identical to ReentrantLock as possible,\n    //      since, after all, this class is also a reentrant mutual exclusion lock!?\n\n    /*\n     * One of the key challenges of this class is to prevent lost signals, while trying hard to\n     * minimize unnecessary signals. One simple and correct algorithm is to signal some other waiter\n     * with a satisfied guard (if one exists) whenever any thread occupying the monitor exits the\n     * monitor, either by unlocking all of its held locks, or by starting to wait for a guard. This\n     * includes exceptional exits, so all control paths involving signalling must be protected by a\n     * finally block.\n     *\n     * Further optimizations of this algorithm become increasingly subtle. A wait that terminates\n     * without the guard being satisfied (due to timeout, but not interrupt) can then immediately exit\n     * the monitor without signalling. If it timed out without being signalled, it does not need to\n     * \"pass on\" the signal to another thread. If it *was* signalled, then its guard must have been\n     * satisfied at the time of signal, and has since been modified by some other thread to be\n     * non-satisfied before reacquiring the lock, and that other thread takes over the responsibility\n     * of signaling the next waiter.\n     *\n     * Unlike the underlying Condition, if we are not careful, an interrupt *can* cause a signal to be\n     * lost, because the signal may be sent to a condition whose sole waiter has just been\n     * interrupted.\n     *\n     * Imagine a monitor with multiple guards. A thread enters the monitor, satisfies all the guards,\n     * and leaves, calling signalNextWaiter. With traditional locks and conditions, all the conditions\n     * need to be signalled because it is not known which if any of them have waiters (and hasWaiters\n     * can't be used reliably because of a check-then-act race). With our Monitor guards, we only\n     * signal the first active guard that is satisfied. But the corresponding thread may have already\n     * been interrupted and is waiting to reacquire the lock while still registered in activeGuards,\n     * in which case the signal is a no-op, and the bigger-picture signal is lost unless interrupted\n     * threads take special action by participating in the signal-passing game.\n     */\n\n    /*\n     * Timeout handling is intricate, especially given our ambitious goals:\n     * - Avoid underflow and overflow of timeout values when specified timeouts are close to\n     *   Long.MIN_VALUE or Long.MAX_VALUE.\n     * - Favor responding to interrupts over timeouts.\n     * - System.nanoTime() is expensive enough that we want to call it the minimum required number of\n     *   times, typically once before invoking a blocking method. This often requires keeping track of\n     *   the first time in a method that nanoTime() has been invoked, for which the special value 0L\n     *   is reserved to mean \"uninitialized\". If timeout is non-positive, then nanoTime need never be\n     *   called.\n     * - Keep behavior of fair and non-fair instances consistent.\n     */\n\n    /**\n     * A boolean condition for which a thread may wait. A {@code Guard} is associated with a single\n     * {@code Monitor}. The monitor may check the guard at arbitrary times from any thread occupying\n     * the monitor, so code should not be written to rely on how often a guard might or might not be\n     * checked.\n     *\n     * <p>If a {@code Guard} is passed into any method of a {@code Monitor} other than the one it is\n     * associated with, an {@link IllegalMonitorStateException} is thrown.\n     *\n     * @since 10.0\n     */\n    @Beta\n    public abstract static class Guard\n    {\n\n        @Weak final Monitor monitor;\n        final Condition condition;\n\n        @GuardedBy(\"monitor.lock\")\n        int waiterCount = 0;\n\n        /** The next active guard */\n        @GuardedBy(\"monitor.lock\")\n        @NullableDecl\n        Guard next;\n\n        protected Guard(Monitor monitor)\n        {\n            this.monitor = checkNotNull(monitor, \"monitor\");\n            this.condition = monitor.lock.newCondition();\n        }\n\n        /**\n         * Evaluates this guard's boolean condition. This method is always called with the associated\n         * monitor already occupied. Implementations of this method must depend only on state protected\n         * by the associated monitor, and must not modify that state.\n         */\n        public abstract boolean isSatisfied();\n    }\n\n    /** Whether this monitor is fair. */\n    private final boolean fair;\n\n    /** The lock underlying this monitor. */\n    private final ReentrantLock lock;\n\n    /**\n     * The guards associated with this monitor that currently have waiters ({@code waiterCount > 0}).\n     * A linked list threaded through the Guard.next field.\n     */\n    @GuardedBy(\"lock\")\n    private Guard activeGuards = null;\n\n    /**\n     * Creates a monitor with a non-fair (but fast) ordering policy. Equivalent to {@code\n     * Monitor(false)}.\n     */\n    public Monitor()\n    {\n        this(false);\n    }\n\n    /**\n     * Creates a monitor with the given ordering policy.\n     *\n     * @param fair whether this monitor should use a fair ordering policy rather than a non-fair (but\n     *     fast) one\n     */\n    public Monitor(boolean fair)\n    {\n        this.fair = fair;\n        this.lock = new ReentrantLock(fair);\n    }\n\n    /** Enters this monitor. Blocks indefinitely. */\n    public void enter()\n    {\n        lock.lock();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time.\n     *\n     * @return whether the monitor was entered\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enter(long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        final ReentrantLock lock = this.lock;\n        if (!fair && lock.tryLock())\n        {\n            return true;\n        }\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            final long startTime = System.nanoTime();\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterInterruptibly() throws InterruptedException\n    {\n        lock.lockInterruptibly();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time, and may be interrupted.\n     *\n     * @return whether the monitor was entered\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n    {\n        return lock.tryLock(time, unit);\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately. Does not block.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered\n     */\n    public boolean tryEnter()\n    {\n        return lock.tryLock();\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterWhen(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                await(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied, and may be\n     * interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n\n    /** Enters this monitor when the guard is satisfied. Blocks indefinitely. */\n    public void enterWhenUninterruptibly(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                awaitUninterruptibly(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        long startTime = 0L;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            if (fair || !lock.tryLock())\n            {\n                startTime = initNanoTime(timeoutNanos);\n                for (long remainingNanos = timeoutNanos; ; )\n                {\n                    try\n                    {\n                        if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS))\n                        {\n                            break;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        remainingNanos = remainingNanos(startTime, timeoutNanos);\n                    }\n                }\n            }\n\n            boolean satisfied = false;\n            try\n            {\n                while (true)\n                {\n                    try\n                    {\n                        if (guard.isSatisfied())\n                        {\n                            satisfied = true;\n                        }\n                        else\n                        {\n                            final long remainingNanos;\n                            if (startTime == 0L)\n                            {\n                                startTime = initNanoTime(timeoutNanos);\n                                remainingNanos = timeoutNanos;\n                            }\n                            else\n                            {\n                                remainingNanos = remainingNanos(startTime, timeoutNanos);\n                            }\n                            satisfied = awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                        }\n                        return satisfied;\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        signalBeforeWaiting = false;\n                    }\n                }\n            }\n            finally\n            {\n                if (!satisfied)\n                {\n                    lock.unlock(); // No need to signal if timed out\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean enterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!enter(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n    throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not\n     * block acquiring the lock and does not wait for the guard to be satisfied.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean tryEnterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock())\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be called\n     * only by a thread currently occupying this monitor.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void waitFor(Guard guard) throws InterruptedException\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            await(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted. May\n     * be called only by a thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        if (Thread.interrupted())\n        {\n            throw new InterruptedException();\n        }\n        return awaitNanos(guard, timeoutNanos, true);\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread\n     * currently occupying this monitor.\n     */\n    public void waitForUninterruptibly(Guard guard)\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            awaitUninterruptibly(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time. May be called only by a\n     * thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        boolean signalBeforeWaiting = true;\n        final long startTime = initNanoTime(timeoutNanos);\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    if (guard.isSatisfied())\n                    {\n                        return true;\n                    }\n                    signalBeforeWaiting = false;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /** Leaves this monitor. May be called only by a thread currently occupying this monitor. */\n    public void leave()\n    {\n        final ReentrantLock lock = this.lock;\n        try\n        {\n            // No need to signal if we will still be holding the lock when we return\n            if (lock.getHoldCount() == 1)\n            {\n                signalNextWaiter();\n            }\n        }\n        finally\n        {\n            lock.unlock(); // Will throw IllegalMonitorStateException if not held\n        }\n    }\n\n    /** Returns whether this monitor is using a fair ordering policy. */\n    public boolean isFair()\n    {\n        return fair;\n    }\n\n    /**\n     * Returns whether this monitor is occupied by any thread. This method is designed for use in\n     * monitoring of the system state, not for synchronization control.\n     */\n    public boolean isOccupied()\n    {\n        return lock.isLocked();\n    }\n\n    /**\n     * Returns whether the current thread is occupying this monitor (has entered more times than it\n     * has left).\n     */\n    public boolean isOccupiedByCurrentThread()\n    {\n        return lock.isHeldByCurrentThread();\n    }\n\n    /**\n     * Returns the number of times the current thread has entered this monitor in excess of the number\n     * of times it has left. Returns 0 if the current thread is not occupying this monitor.\n     */\n    public int getOccupiedDepth()\n    {\n        return lock.getHoldCount();\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting to enter this monitor. The value is only\n     * an estimate because the number of threads may change dynamically while this method traverses\n     * internal data structures. This method is designed for use in monitoring of the system state,\n     * not for synchronization control.\n     */\n    public int getQueueLength()\n    {\n        return lock.getQueueLength();\n    }\n\n    /**\n     * Returns whether any threads are waiting to enter this monitor. Note that because cancellations\n     * may occur at any time, a {@code true} return does not guarantee that any other thread will ever\n     * enter this monitor. This method is designed primarily for use in monitoring of the system\n     * state.\n     */\n    public boolean hasQueuedThreads()\n    {\n        return lock.hasQueuedThreads();\n    }\n\n    /**\n     * Queries whether the given thread is waiting to enter this monitor. Note that because\n     * cancellations may occur at any time, a {@code true} return does not guarantee that this thread\n     * will ever enter this monitor. This method is designed primarily for use in monitoring of the\n     * system state.\n     */\n    public boolean hasQueuedThread(Thread thread)\n    {\n        return lock.hasQueuedThread(thread);\n    }\n\n    /**\n     * Queries whether any threads are waiting for the given guard to become satisfied. Note that\n     * because timeouts and interrupts may occur at any time, a {@code true} return does not guarantee\n     * that the guard becoming satisfied in the future will awaken any threads. This method is\n     * designed primarily for use in monitoring of the system state.\n     */\n    public boolean hasWaiters(Guard guard)\n    {\n        return getWaitQueueLength(guard) > 0;\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting for the given guard to become satisfied.\n     * Note that because timeouts and interrupts may occur at any time, the estimate serves only as an\n     * upper bound on the actual number of waiters. This method is designed for use in monitoring of\n     * the system state, not for synchronization control.\n     */\n    public int getWaitQueueLength(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        lock.lock();\n        try\n        {\n            return guard.waiterCount;\n        }\n        finally\n        {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Returns unit.toNanos(time), additionally ensuring the returned value is not at risk of\n     * overflowing or underflowing, by bounding the value between 0 and (Long.MAX_VALUE / 4) * 3.\n     * Actually waiting for more than 219 years is not supported!\n     */\n    private static long toSafeNanos(long time, TimeUnit unit)\n    {\n        long timeoutNanos = unit.toNanos(time);\n        return (timeoutNanos <= 0L)\n               ? 0L\n               : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3 : timeoutNanos;\n    }\n\n    /**\n     * Returns System.nanoTime() unless the timeout has already elapsed. Returns 0L if and only if the\n     * timeout has already elapsed.\n     */\n    private static long initNanoTime(long timeoutNanos)\n    {\n        if (timeoutNanos <= 0L)\n        {\n            return 0L;\n        }\n        else\n        {\n            long startTime = System.nanoTime();\n            return (startTime == 0L) ? 1L : startTime;\n        }\n    }\n\n    /**\n     * Returns the remaining nanos until the given timeout, or 0L if the timeout has already elapsed.\n     * Caller must have previously sanitized timeoutNanos using toSafeNanos.\n     */\n    private static long remainingNanos(long startTime, long timeoutNanos)\n    {\n        // assert timeoutNanos == 0L || startTime != 0L;\n\n        // TODO : NOT CORRECT, BUT TESTS PASS ANYWAYS!\n        // if (true) return timeoutNanos;\n        // ONLY 2 TESTS FAIL IF WE DO:\n        // if (true) return 0;\n\n        return (timeoutNanos <= 0L) ? 0L : timeoutNanos - (System.nanoTime() - startTime);\n    }\n\n    /**\n     * Signals some other thread waiting on a satisfied guard, if one exists.\n     *\n     * <p>We manage calls to this method carefully, to signal only when necessary, but never losing a\n     * signal, which is the classic problem of this kind of concurrency construct. We must signal if\n     * the current thread is about to relinquish the lock and may have changed the state protected by\n     * the monitor, thereby causing some guard to be satisfied.\n     *\n     * <p>In addition, any thread that has been signalled when its guard was satisfied acquires the\n     * responsibility of signalling the next thread when it again relinquishes the lock. Unlike a\n     * normal Condition, there is no guarantee that an interrupted thread has not been signalled,\n     * since the concurrency control must manage multiple Conditions. So this method must generally be\n     * called when waits are interrupted.\n     *\n     * <p>On the other hand, if a signalled thread wakes up to discover that its guard is still not\n     * satisfied, it does *not* need to call this method before returning to wait. This can only\n     * happen due to spurious wakeup (ignorable) or another thread acquiring the lock before the\n     * current thread can and returning the guard to the unsatisfied state. In the latter case the\n     * other thread (last thread modifying the state protected by the monitor) takes over the\n     * responsibility of signalling the next waiter.\n     *\n     * <p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else\n     * the current thread's guard might be mistakenly signalled, leading to a lost signal.\n     */\n    @GuardedBy(\"lock\")\n    private void signalNextWaiter()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            if (isSatisfied(guard))\n            {\n                guard.condition.signal();\n                break;\n            }\n        }\n    }\n\n    /**\n     * Exactly like signalNextWaiter, but caller guarantees that guardToSkip need not be considered,\n     * because caller has previously checked that guardToSkip.isSatisfied() returned false. An\n     * optimization for the case that guardToSkip.isSatisfied() may be expensive.\n     *\n     * <p>We decided against using this method, since in practice, isSatisfied() is likely to be very\n     * cheap (typically one field read). Resurrect this method if you find that not to be true.\n     */\n    //   @GuardedBy(\"lock\")\n    //   private void signalNextWaiterSkipping(Guard guardToSkip) {\n    //     for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n    //       if (guard != guardToSkip && isSatisfied(guard)) {\n    //         guard.condition.signal();\n    //         break;\n    //       }\n    //     }\n    //   }\n\n    /**\n     * Exactly like guard.isSatisfied(), but in addition signals all waiting threads in the (hopefully\n     * unlikely) event that isSatisfied() throws.\n     */\n    @GuardedBy(\"lock\")\n    private boolean isSatisfied(Guard guard)\n    {\n        try\n        {\n            return guard.isSatisfied();\n        }\n        catch (Throwable throwable)\n        {\n            signalAllWaiters();\n            throw throwable;\n        }\n    }\n\n    /** Signals all threads waiting on guards. */\n    @GuardedBy(\"lock\")\n    private void signalAllWaiters()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            guard.condition.signalAll();\n        }\n    }\n\n    /** Records that the current thread is about to wait on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void beginWaitingFor(Guard guard)\n    {\n        int waiters = guard.waiterCount++;\n        if (waiters == 0)\n        {\n            // push guard onto activeGuards\n            guard.next = activeGuards;\n            activeGuards = guard;\n        }\n    }\n\n    /** Records that the current thread is no longer waiting on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void endWaitingFor(Guard guard)\n    {\n        int waiters = --guard.waiterCount;\n        if (waiters == 0)\n        {\n            // unlink guard from activeGuards\n            for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next)\n            {\n                if (p == guard)\n                {\n                    if (pred == null)\n                    {\n                        activeGuards = p.next;\n                    }\n                    else\n                    {\n                        pred.next = p.next;\n                    }\n                    p.next = null; // help GC\n                    break;\n                }\n            }\n        }\n    }\n\n    /*\n     * Methods that loop waiting on a guard's condition until the guard is satisfied, while recording\n     * this fact so that other threads know to check our guard and signal us. It's caller's\n     * responsibility to ensure that the guard is *not* currently satisfied.\n     */\n\n    @GuardedBy(\"lock\")\n    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.await();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    @GuardedBy(\"lock\")\n    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.awaitUninterruptibly();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    /** Caller should check before calling that guard is not satisfied. */\n    @GuardedBy(\"lock\")\n    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n    throws InterruptedException\n    {\n        boolean firstTime = true;\n        try\n        {\n            do\n            {\n                if (nanos <= 0L)\n                {\n                    return false;\n                }\n                if (firstTime)\n                {\n                    if (signalBeforeWaiting)\n                    {\n                        signalNextWaiter();\n                    }\n                    beginWaitingFor(guard);\n                    firstTime = false;\n                }\n                nanos = guard.condition.awaitNanos(nanos);\n            }\n            while (!guard.isSatisfied());\n            return true;\n        }\n        finally\n        {\n            if (!firstTime)\n            {\n                endWaitingFor(guard);\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.enterWhenUninterruptibly", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Enters this monitor when the guard is satisfied. Blocks indefinitely.", "docstring_tokens": ["Enters", "this", "monitor", "when", "the", "guard", "is", "satisfied", ".", "Blocks", "indefinitely", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L514-L533", "partition": "valid", "up_fun_num": 9, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.errorprone.annotations.concurrent.GuardedBy;", "import com.google.j2objc.annotations.Weak;", "import java.util.concurrent.TimeUnit;", "import java.util.concurrent.locks.Condition;", "import java.util.concurrent.locks.ReentrantLock;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Monitor\n", "    public void enter()\n", "    public boolean enter(long time, TimeUnit unit)\n", "    public void enterInterruptibly() throws InterruptedException\n", "    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n", "    public boolean tryEnter()\n", "    public void enterWhen(Guard guard) throws InterruptedException\n", "    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIf(Guard guard)\n", "    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n", "    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean tryEnterIf(Guard guard)\n", "    public void waitFor(Guard guard) throws InterruptedException\n", "    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void waitForUninterruptibly(Guard guard)\n", "    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public void leave()\n", "    public boolean isFair()\n", "    public boolean isOccupied()\n", "    public boolean isOccupiedByCurrentThread()\n", "    public int getOccupiedDepth()\n", "    public int getQueueLength()\n", "    public boolean hasQueuedThreads()\n", "    public boolean hasQueuedThread(Thread thread)\n", "    public boolean hasWaiters(Guard guard)\n", "    public int getWaitQueueLength(Guard guard)\n", "    private static long toSafeNanos(long time, TimeUnit unit)\n", "    private static long initNanoTime(long timeoutNanos)\n", "    private static long remainingNanos(long startTime, long timeoutNanos)\n", "    private void signalNextWaiter()\n", "    private boolean isSatisfied(Guard guard)\n", "    private void signalAllWaiters()\n", "    private void beginWaitingFor(Guard guard)\n", "    private void endWaitingFor(Guard guard)\n", "    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n", "    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n", "    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n"], "context": "/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.concurrent.GuardedBy;\nimport com.google.j2objc.annotations.Weak;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A synchronization abstraction supporting waiting on arbitrary boolean conditions.\n *\n * <p>This class is intended as a replacement for {@link ReentrantLock}. Code using {@code Monitor}\n * is less error-prone and more readable than code using {@code ReentrantLock}, without significant\n * performance loss. {@code Monitor} even has the potential for performance gain by optimizing the\n * evaluation and signaling of conditions. Signaling is entirely <a\n * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>. By\n * eliminating explicit signaling, this class can guarantee that only one thread is awakened when a\n * condition becomes true (no \"signaling storms\" due to use of {@link\n * java.util.concurrent.locks.Condition#signalAll Condition.signalAll}) and that no signals are lost\n * (no \"hangs\" due to incorrect use of {@link java.util.concurrent.locks.Condition#signal\n * Condition.signal}).\n *\n * <p>A thread is said to <i>occupy</i> a monitor if it has <i>entered</i> the monitor but not yet\n * <i>left</i>. Only one thread may occupy a given monitor at any moment. A monitor is also\n * reentrant, so a thread may enter a monitor any number of times, and then must leave the same\n * number of times. The <i>enter</i> and <i>leave</i> operations have the same synchronization\n * semantics as the built-in Java language synchronization primitives.\n *\n * <p>A call to any of the <i>enter</i> methods with <b>void</b> return type should always be\n * followed immediately by a <i>try/finally</i> block to ensure that the current thread leaves the\n * monitor cleanly:\n *\n * <pre>{@code\n * monitor.enter();\n * try {\n *   // do things while occupying the monitor\n * } finally {\n *   monitor.leave();\n * }\n * }</pre>\n *\n * <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear\n * as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that\n * the current thread leaves the monitor cleanly:\n *\n * <pre>{@code\n * if (monitor.tryEnter()) {\n *   try {\n *     // do things while occupying the monitor\n *   } finally {\n *     monitor.leave();\n *   }\n * } else {\n *   // do other things since the monitor was not available\n * }\n * }</pre>\n *\n * <h2>Comparison with {@code synchronized} and {@code ReentrantLock}</h2>\n *\n * <p>The following examples show a simple threadsafe holder expressed using {@code synchronized},\n * {@link ReentrantLock}, and {@code Monitor}.\n *\n * <h3>{@code synchronized}</h3>\n *\n * <p>This version is the fewest lines of code, largely because the synchronization mechanism used\n * is built into the language and runtime. But the programmer has to remember to avoid a couple of\n * common bugs: The {@code wait()} must be inside a {@code while} instead of an {@code if}, and\n * {@code notifyAll()} must be used instead of {@code notify()} because there are two different\n * logical conditions being awaited.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *\n *   public synchronized V get() throws InterruptedException {\n *     while (value == null) {\n *       wait();\n *     }\n *     V result = value;\n *     value = null;\n *     notifyAll();\n *     return result;\n *   }\n *\n *   public synchronized void set(V newValue) throws InterruptedException {\n *     while (value != null) {\n *       wait();\n *     }\n *     value = newValue;\n *     notifyAll();\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code ReentrantLock}</h3>\n *\n * <p>This version is much more verbose than the {@code synchronized} version, and still suffers\n * from the need for the programmer to remember to use {@code while} instead of {@code if}. However,\n * one advantage is that we can introduce two separate {@code Condition} objects, which allows us to\n * use {@code signal()} instead of {@code signalAll()}, which may be a performance benefit.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final ReentrantLock lock = new ReentrantLock();\n *   private final Condition valuePresent = lock.newCondition();\n *   private final Condition valueAbsent = lock.newCondition();\n *\n *   public V get() throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value == null) {\n *         valuePresent.await();\n *       }\n *       V result = value;\n *       value = null;\n *       valueAbsent.signal();\n *       return result;\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value != null) {\n *         valueAbsent.await();\n *       }\n *       value = newValue;\n *       valuePresent.signal();\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code Monitor}</h3>\n *\n * <p>This version adds some verbosity around the {@code Guard} objects, but removes that same\n * verbosity, and more, from the {@code get} and {@code set} methods. {@code Monitor} implements the\n * same efficient signaling as we had to hand-code in the {@code ReentrantLock} version above.\n * Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to\n * remember to use {@code while} instead of {@code if}.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final Monitor monitor = new Monitor();\n *   private final Monitor.Guard valuePresent = monitor.newGuard(() -> value != null);\n *   private final Monitor.Guard valueAbsent = monitor.newGuard(() -> value == null);\n *\n *   public V get() throws InterruptedException {\n *     monitor.enterWhen(valuePresent);\n *     try {\n *       V result = value;\n *       value = null;\n *       return result;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     monitor.enterWhen(valueAbsent);\n *     try {\n *       value = newValue;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n * }\n * }</pre>\n *\n * @author Justin T. Sampson\n * @author Martin Buchholz\n * @since 10.0\n */\n@Beta\n@GwtIncompatible\n@SuppressWarnings(\"GuardedBy\") // TODO(b/35466881): Fix or suppress.\npublic final class Monitor\n{\n    // TODO(user): Use raw LockSupport or AbstractQueuedSynchronizer instead of ReentrantLock.\n    // TODO(user): \"Port\" jsr166 tests for ReentrantLock.\n    //\n    // TODO(user): Change API to make it impossible to use a Guard with the \"wrong\" monitor,\n    //    by making the monitor implicit, and to eliminate other sources of IMSE.\n    //    Imagine:\n    //    guard.lock();\n    //    try { /* monitor locked and guard satisfied here */ }\n    //    finally { guard.unlock(); }\n    // Here are Justin's design notes about this:\n    //\n    // This idea has come up from time to time, and I think one of my\n    // earlier versions of Monitor even did something like this. I ended\n    // up strongly favoring the current interface.\n    //\n    // I probably can't remember all the reasons (it's possible you\n    // could find them in the code review archives), but here are a few:\n    //\n    // 1. What about leaving/unlocking? Are you going to do\n    //    guard.enter() paired with monitor.leave()? That might get\n    //    confusing. It's nice for the finally block to look as close as\n    //    possible to the thing right before the try. You could have\n    //    guard.leave(), but that's a little odd as well because the\n    //    guard doesn't have anything to do with leaving. You can't\n    //    really enforce that the guard you're leaving is the same one\n    //    you entered with, and it doesn't actually matter.\n    //\n    // 2. Since you can enter the monitor without a guard at all, some\n    //    places you'll have monitor.enter()/monitor.leave() and other\n    //    places you'll have guard.enter()/guard.leave() even though\n    //    it's the same lock being acquired underneath. Always using\n    //    monitor.enterXXX()/monitor.leave() will make it really clear\n    //    which lock is held at any point in the code.\n    //\n    // 3. I think \"enterWhen(notEmpty)\" reads better than \"notEmpty.enter()\".\n    //\n    // TODO(user): Implement ReentrantLock features:\n    //    - toString() method\n    //    - getOwner() method\n    //    - getQueuedThreads() method\n    //    - getWaitingThreads(Guard) method\n    //    - implement Serializable\n    //    - redo the API to be as close to identical to ReentrantLock as possible,\n    //      since, after all, this class is also a reentrant mutual exclusion lock!?\n\n    /*\n     * One of the key challenges of this class is to prevent lost signals, while trying hard to\n     * minimize unnecessary signals. One simple and correct algorithm is to signal some other waiter\n     * with a satisfied guard (if one exists) whenever any thread occupying the monitor exits the\n     * monitor, either by unlocking all of its held locks, or by starting to wait for a guard. This\n     * includes exceptional exits, so all control paths involving signalling must be protected by a\n     * finally block.\n     *\n     * Further optimizations of this algorithm become increasingly subtle. A wait that terminates\n     * without the guard being satisfied (due to timeout, but not interrupt) can then immediately exit\n     * the monitor without signalling. If it timed out without being signalled, it does not need to\n     * \"pass on\" the signal to another thread. If it *was* signalled, then its guard must have been\n     * satisfied at the time of signal, and has since been modified by some other thread to be\n     * non-satisfied before reacquiring the lock, and that other thread takes over the responsibility\n     * of signaling the next waiter.\n     *\n     * Unlike the underlying Condition, if we are not careful, an interrupt *can* cause a signal to be\n     * lost, because the signal may be sent to a condition whose sole waiter has just been\n     * interrupted.\n     *\n     * Imagine a monitor with multiple guards. A thread enters the monitor, satisfies all the guards,\n     * and leaves, calling signalNextWaiter. With traditional locks and conditions, all the conditions\n     * need to be signalled because it is not known which if any of them have waiters (and hasWaiters\n     * can't be used reliably because of a check-then-act race). With our Monitor guards, we only\n     * signal the first active guard that is satisfied. But the corresponding thread may have already\n     * been interrupted and is waiting to reacquire the lock while still registered in activeGuards,\n     * in which case the signal is a no-op, and the bigger-picture signal is lost unless interrupted\n     * threads take special action by participating in the signal-passing game.\n     */\n\n    /*\n     * Timeout handling is intricate, especially given our ambitious goals:\n     * - Avoid underflow and overflow of timeout values when specified timeouts are close to\n     *   Long.MIN_VALUE or Long.MAX_VALUE.\n     * - Favor responding to interrupts over timeouts.\n     * - System.nanoTime() is expensive enough that we want to call it the minimum required number of\n     *   times, typically once before invoking a blocking method. This often requires keeping track of\n     *   the first time in a method that nanoTime() has been invoked, for which the special value 0L\n     *   is reserved to mean \"uninitialized\". If timeout is non-positive, then nanoTime need never be\n     *   called.\n     * - Keep behavior of fair and non-fair instances consistent.\n     */\n\n    /**\n     * A boolean condition for which a thread may wait. A {@code Guard} is associated with a single\n     * {@code Monitor}. The monitor may check the guard at arbitrary times from any thread occupying\n     * the monitor, so code should not be written to rely on how often a guard might or might not be\n     * checked.\n     *\n     * <p>If a {@code Guard} is passed into any method of a {@code Monitor} other than the one it is\n     * associated with, an {@link IllegalMonitorStateException} is thrown.\n     *\n     * @since 10.0\n     */\n    @Beta\n    public abstract static class Guard\n    {\n\n        @Weak final Monitor monitor;\n        final Condition condition;\n\n        @GuardedBy(\"monitor.lock\")\n        int waiterCount = 0;\n\n        /** The next active guard */\n        @GuardedBy(\"monitor.lock\")\n        @NullableDecl\n        Guard next;\n\n        protected Guard(Monitor monitor)\n        {\n            this.monitor = checkNotNull(monitor, \"monitor\");\n            this.condition = monitor.lock.newCondition();\n        }\n\n        /**\n         * Evaluates this guard's boolean condition. This method is always called with the associated\n         * monitor already occupied. Implementations of this method must depend only on state protected\n         * by the associated monitor, and must not modify that state.\n         */\n        public abstract boolean isSatisfied();\n    }\n\n    /** Whether this monitor is fair. */\n    private final boolean fair;\n\n    /** The lock underlying this monitor. */\n    private final ReentrantLock lock;\n\n    /**\n     * The guards associated with this monitor that currently have waiters ({@code waiterCount > 0}).\n     * A linked list threaded through the Guard.next field.\n     */\n    @GuardedBy(\"lock\")\n    private Guard activeGuards = null;\n\n    /**\n     * Creates a monitor with a non-fair (but fast) ordering policy. Equivalent to {@code\n     * Monitor(false)}.\n     */\n    public Monitor()\n    {\n        this(false);\n    }\n\n    /**\n     * Creates a monitor with the given ordering policy.\n     *\n     * @param fair whether this monitor should use a fair ordering policy rather than a non-fair (but\n     *     fast) one\n     */\n    public Monitor(boolean fair)\n    {\n        this.fair = fair;\n        this.lock = new ReentrantLock(fair);\n    }\n\n    /** Enters this monitor. Blocks indefinitely. */\n    public void enter()\n    {\n        lock.lock();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time.\n     *\n     * @return whether the monitor was entered\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enter(long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        final ReentrantLock lock = this.lock;\n        if (!fair && lock.tryLock())\n        {\n            return true;\n        }\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            final long startTime = System.nanoTime();\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterInterruptibly() throws InterruptedException\n    {\n        lock.lockInterruptibly();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time, and may be interrupted.\n     *\n     * @return whether the monitor was entered\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n    {\n        return lock.tryLock(time, unit);\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately. Does not block.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered\n     */\n    public boolean tryEnter()\n    {\n        return lock.tryLock();\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterWhen(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                await(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied, and may be\n     * interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean reentrant = lock.isHeldByCurrentThread();\n        long startTime = 0L;\n\n        locked:\n        {\n            if (!fair)\n            {\n                // Check interrupt status to get behavior consistent with fair case.\n                if (Thread.interrupted())\n                {\n                    throw new InterruptedException();\n                }\n                if (lock.tryLock())\n                {\n                    break locked;\n                }\n            }\n            startTime = initNanoTime(timeoutNanos);\n            if (!lock.tryLock(time, unit))\n            {\n                return false;\n            }\n        }\n\n        boolean satisfied = false;\n        boolean threw = true;\n        try\n        {\n            satisfied =\n                guard.isSatisfied()\n                || awaitNanos(\n                    guard,\n                    (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),\n                    reentrant);\n            threw = false;\n            return satisfied;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                try\n                {\n                    // Don't need to signal if timed out, but do if interrupted\n                    if (threw && !reentrant)\n                    {\n                        signalNextWaiter();\n                    }\n                }\n                finally\n                {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n\n    /** Enters this monitor when the guard is satisfied. Blocks indefinitely. */\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        long startTime = 0L;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            if (fair || !lock.tryLock())\n            {\n                startTime = initNanoTime(timeoutNanos);\n                for (long remainingNanos = timeoutNanos; ; )\n                {\n                    try\n                    {\n                        if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS))\n                        {\n                            break;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        remainingNanos = remainingNanos(startTime, timeoutNanos);\n                    }\n                }\n            }\n\n            boolean satisfied = false;\n            try\n            {\n                while (true)\n                {\n                    try\n                    {\n                        if (guard.isSatisfied())\n                        {\n                            satisfied = true;\n                        }\n                        else\n                        {\n                            final long remainingNanos;\n                            if (startTime == 0L)\n                            {\n                                startTime = initNanoTime(timeoutNanos);\n                                remainingNanos = timeoutNanos;\n                            }\n                            else\n                            {\n                                remainingNanos = remainingNanos(startTime, timeoutNanos);\n                            }\n                            satisfied = awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                        }\n                        return satisfied;\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        signalBeforeWaiting = false;\n                    }\n                }\n            }\n            finally\n            {\n                if (!satisfied)\n                {\n                    lock.unlock(); // No need to signal if timed out\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean enterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!enter(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n    throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not\n     * block acquiring the lock and does not wait for the guard to be satisfied.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean tryEnterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock())\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be called\n     * only by a thread currently occupying this monitor.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void waitFor(Guard guard) throws InterruptedException\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            await(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted. May\n     * be called only by a thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        if (Thread.interrupted())\n        {\n            throw new InterruptedException();\n        }\n        return awaitNanos(guard, timeoutNanos, true);\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread\n     * currently occupying this monitor.\n     */\n    public void waitForUninterruptibly(Guard guard)\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            awaitUninterruptibly(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time. May be called only by a\n     * thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        boolean signalBeforeWaiting = true;\n        final long startTime = initNanoTime(timeoutNanos);\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    if (guard.isSatisfied())\n                    {\n                        return true;\n                    }\n                    signalBeforeWaiting = false;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /** Leaves this monitor. May be called only by a thread currently occupying this monitor. */\n    public void leave()\n    {\n        final ReentrantLock lock = this.lock;\n        try\n        {\n            // No need to signal if we will still be holding the lock when we return\n            if (lock.getHoldCount() == 1)\n            {\n                signalNextWaiter();\n            }\n        }\n        finally\n        {\n            lock.unlock(); // Will throw IllegalMonitorStateException if not held\n        }\n    }\n\n    /** Returns whether this monitor is using a fair ordering policy. */\n    public boolean isFair()\n    {\n        return fair;\n    }\n\n    /**\n     * Returns whether this monitor is occupied by any thread. This method is designed for use in\n     * monitoring of the system state, not for synchronization control.\n     */\n    public boolean isOccupied()\n    {\n        return lock.isLocked();\n    }\n\n    /**\n     * Returns whether the current thread is occupying this monitor (has entered more times than it\n     * has left).\n     */\n    public boolean isOccupiedByCurrentThread()\n    {\n        return lock.isHeldByCurrentThread();\n    }\n\n    /**\n     * Returns the number of times the current thread has entered this monitor in excess of the number\n     * of times it has left. Returns 0 if the current thread is not occupying this monitor.\n     */\n    public int getOccupiedDepth()\n    {\n        return lock.getHoldCount();\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting to enter this monitor. The value is only\n     * an estimate because the number of threads may change dynamically while this method traverses\n     * internal data structures. This method is designed for use in monitoring of the system state,\n     * not for synchronization control.\n     */\n    public int getQueueLength()\n    {\n        return lock.getQueueLength();\n    }\n\n    /**\n     * Returns whether any threads are waiting to enter this monitor. Note that because cancellations\n     * may occur at any time, a {@code true} return does not guarantee that any other thread will ever\n     * enter this monitor. This method is designed primarily for use in monitoring of the system\n     * state.\n     */\n    public boolean hasQueuedThreads()\n    {\n        return lock.hasQueuedThreads();\n    }\n\n    /**\n     * Queries whether the given thread is waiting to enter this monitor. Note that because\n     * cancellations may occur at any time, a {@code true} return does not guarantee that this thread\n     * will ever enter this monitor. This method is designed primarily for use in monitoring of the\n     * system state.\n     */\n    public boolean hasQueuedThread(Thread thread)\n    {\n        return lock.hasQueuedThread(thread);\n    }\n\n    /**\n     * Queries whether any threads are waiting for the given guard to become satisfied. Note that\n     * because timeouts and interrupts may occur at any time, a {@code true} return does not guarantee\n     * that the guard becoming satisfied in the future will awaken any threads. This method is\n     * designed primarily for use in monitoring of the system state.\n     */\n    public boolean hasWaiters(Guard guard)\n    {\n        return getWaitQueueLength(guard) > 0;\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting for the given guard to become satisfied.\n     * Note that because timeouts and interrupts may occur at any time, the estimate serves only as an\n     * upper bound on the actual number of waiters. This method is designed for use in monitoring of\n     * the system state, not for synchronization control.\n     */\n    public int getWaitQueueLength(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        lock.lock();\n        try\n        {\n            return guard.waiterCount;\n        }\n        finally\n        {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Returns unit.toNanos(time), additionally ensuring the returned value is not at risk of\n     * overflowing or underflowing, by bounding the value between 0 and (Long.MAX_VALUE / 4) * 3.\n     * Actually waiting for more than 219 years is not supported!\n     */\n    private static long toSafeNanos(long time, TimeUnit unit)\n    {\n        long timeoutNanos = unit.toNanos(time);\n        return (timeoutNanos <= 0L)\n               ? 0L\n               : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3 : timeoutNanos;\n    }\n\n    /**\n     * Returns System.nanoTime() unless the timeout has already elapsed. Returns 0L if and only if the\n     * timeout has already elapsed.\n     */\n    private static long initNanoTime(long timeoutNanos)\n    {\n        if (timeoutNanos <= 0L)\n        {\n            return 0L;\n        }\n        else\n        {\n            long startTime = System.nanoTime();\n            return (startTime == 0L) ? 1L : startTime;\n        }\n    }\n\n    /**\n     * Returns the remaining nanos until the given timeout, or 0L if the timeout has already elapsed.\n     * Caller must have previously sanitized timeoutNanos using toSafeNanos.\n     */\n    private static long remainingNanos(long startTime, long timeoutNanos)\n    {\n        // assert timeoutNanos == 0L || startTime != 0L;\n\n        // TODO : NOT CORRECT, BUT TESTS PASS ANYWAYS!\n        // if (true) return timeoutNanos;\n        // ONLY 2 TESTS FAIL IF WE DO:\n        // if (true) return 0;\n\n        return (timeoutNanos <= 0L) ? 0L : timeoutNanos - (System.nanoTime() - startTime);\n    }\n\n    /**\n     * Signals some other thread waiting on a satisfied guard, if one exists.\n     *\n     * <p>We manage calls to this method carefully, to signal only when necessary, but never losing a\n     * signal, which is the classic problem of this kind of concurrency construct. We must signal if\n     * the current thread is about to relinquish the lock and may have changed the state protected by\n     * the monitor, thereby causing some guard to be satisfied.\n     *\n     * <p>In addition, any thread that has been signalled when its guard was satisfied acquires the\n     * responsibility of signalling the next thread when it again relinquishes the lock. Unlike a\n     * normal Condition, there is no guarantee that an interrupted thread has not been signalled,\n     * since the concurrency control must manage multiple Conditions. So this method must generally be\n     * called when waits are interrupted.\n     *\n     * <p>On the other hand, if a signalled thread wakes up to discover that its guard is still not\n     * satisfied, it does *not* need to call this method before returning to wait. This can only\n     * happen due to spurious wakeup (ignorable) or another thread acquiring the lock before the\n     * current thread can and returning the guard to the unsatisfied state. In the latter case the\n     * other thread (last thread modifying the state protected by the monitor) takes over the\n     * responsibility of signalling the next waiter.\n     *\n     * <p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else\n     * the current thread's guard might be mistakenly signalled, leading to a lost signal.\n     */\n    @GuardedBy(\"lock\")\n    private void signalNextWaiter()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            if (isSatisfied(guard))\n            {\n                guard.condition.signal();\n                break;\n            }\n        }\n    }\n\n    /**\n     * Exactly like signalNextWaiter, but caller guarantees that guardToSkip need not be considered,\n     * because caller has previously checked that guardToSkip.isSatisfied() returned false. An\n     * optimization for the case that guardToSkip.isSatisfied() may be expensive.\n     *\n     * <p>We decided against using this method, since in practice, isSatisfied() is likely to be very\n     * cheap (typically one field read). Resurrect this method if you find that not to be true.\n     */\n    //   @GuardedBy(\"lock\")\n    //   private void signalNextWaiterSkipping(Guard guardToSkip) {\n    //     for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n    //       if (guard != guardToSkip && isSatisfied(guard)) {\n    //         guard.condition.signal();\n    //         break;\n    //       }\n    //     }\n    //   }\n\n    /**\n     * Exactly like guard.isSatisfied(), but in addition signals all waiting threads in the (hopefully\n     * unlikely) event that isSatisfied() throws.\n     */\n    @GuardedBy(\"lock\")\n    private boolean isSatisfied(Guard guard)\n    {\n        try\n        {\n            return guard.isSatisfied();\n        }\n        catch (Throwable throwable)\n        {\n            signalAllWaiters();\n            throw throwable;\n        }\n    }\n\n    /** Signals all threads waiting on guards. */\n    @GuardedBy(\"lock\")\n    private void signalAllWaiters()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            guard.condition.signalAll();\n        }\n    }\n\n    /** Records that the current thread is about to wait on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void beginWaitingFor(Guard guard)\n    {\n        int waiters = guard.waiterCount++;\n        if (waiters == 0)\n        {\n            // push guard onto activeGuards\n            guard.next = activeGuards;\n            activeGuards = guard;\n        }\n    }\n\n    /** Records that the current thread is no longer waiting on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void endWaitingFor(Guard guard)\n    {\n        int waiters = --guard.waiterCount;\n        if (waiters == 0)\n        {\n            // unlink guard from activeGuards\n            for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next)\n            {\n                if (p == guard)\n                {\n                    if (pred == null)\n                    {\n                        activeGuards = p.next;\n                    }\n                    else\n                    {\n                        pred.next = p.next;\n                    }\n                    p.next = null; // help GC\n                    break;\n                }\n            }\n        }\n    }\n\n    /*\n     * Methods that loop waiting on a guard's condition until the guard is satisfied, while recording\n     * this fact so that other threads know to check our guard and signal us. It's caller's\n     * responsibility to ensure that the guard is *not* currently satisfied.\n     */\n\n    @GuardedBy(\"lock\")\n    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.await();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    @GuardedBy(\"lock\")\n    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.awaitUninterruptibly();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    /** Caller should check before calling that guard is not satisfied. */\n    @GuardedBy(\"lock\")\n    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n    throws InterruptedException\n    {\n        boolean firstTime = true;\n        try\n        {\n            do\n            {\n                if (nanos <= 0L)\n                {\n                    return false;\n                }\n                if (firstTime)\n                {\n                    if (signalBeforeWaiting)\n                    {\n                        signalNextWaiter();\n                    }\n                    beginWaitingFor(guard);\n                    firstTime = false;\n                }\n                nanos = guard.condition.awaitNanos(nanos);\n            }\n            while (!guard.isSatisfied());\n            return true;\n        }\n        finally\n        {\n            if (!firstTime)\n            {\n                endWaitingFor(guard);\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.enterIf", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\nnot wait for the guard to be satisfied.\n\n@return whether the monitor was entered, which guarantees that the guard is now satisfied", "docstring_tokens": ["Enters", "this", "monitor", "if", "the", "guard", "is", "satisfied", ".", "Blocks", "indefinitely", "acquiring", "the", "lock", "but", "does", "not", "wait", "for", "the", "guard", "to", "be", "satisfied", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L608-L623", "partition": "valid", "up_fun_num": 11, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.errorprone.annotations.concurrent.GuardedBy;", "import com.google.j2objc.annotations.Weak;", "import java.util.concurrent.TimeUnit;", "import java.util.concurrent.locks.Condition;", "import java.util.concurrent.locks.ReentrantLock;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Monitor\n", "    public void enter()\n", "    public boolean enter(long time, TimeUnit unit)\n", "    public void enterInterruptibly() throws InterruptedException\n", "    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n", "    public boolean tryEnter()\n", "    public void enterWhen(Guard guard) throws InterruptedException\n", "    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void enterWhenUninterruptibly(Guard guard)\n", "    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n", "    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean tryEnterIf(Guard guard)\n", "    public void waitFor(Guard guard) throws InterruptedException\n", "    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void waitForUninterruptibly(Guard guard)\n", "    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public void leave()\n", "    public boolean isFair()\n", "    public boolean isOccupied()\n", "    public boolean isOccupiedByCurrentThread()\n", "    public int getOccupiedDepth()\n", "    public int getQueueLength()\n", "    public boolean hasQueuedThreads()\n", "    public boolean hasQueuedThread(Thread thread)\n", "    public boolean hasWaiters(Guard guard)\n", "    public int getWaitQueueLength(Guard guard)\n", "    private static long toSafeNanos(long time, TimeUnit unit)\n", "    private static long initNanoTime(long timeoutNanos)\n", "    private static long remainingNanos(long startTime, long timeoutNanos)\n", "    private void signalNextWaiter()\n", "    private boolean isSatisfied(Guard guard)\n", "    private void signalAllWaiters()\n", "    private void beginWaitingFor(Guard guard)\n", "    private void endWaitingFor(Guard guard)\n", "    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n", "    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n", "    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n"], "context": "/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.concurrent.GuardedBy;\nimport com.google.j2objc.annotations.Weak;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A synchronization abstraction supporting waiting on arbitrary boolean conditions.\n *\n * <p>This class is intended as a replacement for {@link ReentrantLock}. Code using {@code Monitor}\n * is less error-prone and more readable than code using {@code ReentrantLock}, without significant\n * performance loss. {@code Monitor} even has the potential for performance gain by optimizing the\n * evaluation and signaling of conditions. Signaling is entirely <a\n * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>. By\n * eliminating explicit signaling, this class can guarantee that only one thread is awakened when a\n * condition becomes true (no \"signaling storms\" due to use of {@link\n * java.util.concurrent.locks.Condition#signalAll Condition.signalAll}) and that no signals are lost\n * (no \"hangs\" due to incorrect use of {@link java.util.concurrent.locks.Condition#signal\n * Condition.signal}).\n *\n * <p>A thread is said to <i>occupy</i> a monitor if it has <i>entered</i> the monitor but not yet\n * <i>left</i>. Only one thread may occupy a given monitor at any moment. A monitor is also\n * reentrant, so a thread may enter a monitor any number of times, and then must leave the same\n * number of times. The <i>enter</i> and <i>leave</i> operations have the same synchronization\n * semantics as the built-in Java language synchronization primitives.\n *\n * <p>A call to any of the <i>enter</i> methods with <b>void</b> return type should always be\n * followed immediately by a <i>try/finally</i> block to ensure that the current thread leaves the\n * monitor cleanly:\n *\n * <pre>{@code\n * monitor.enter();\n * try {\n *   // do things while occupying the monitor\n * } finally {\n *   monitor.leave();\n * }\n * }</pre>\n *\n * <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear\n * as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that\n * the current thread leaves the monitor cleanly:\n *\n * <pre>{@code\n * if (monitor.tryEnter()) {\n *   try {\n *     // do things while occupying the monitor\n *   } finally {\n *     monitor.leave();\n *   }\n * } else {\n *   // do other things since the monitor was not available\n * }\n * }</pre>\n *\n * <h2>Comparison with {@code synchronized} and {@code ReentrantLock}</h2>\n *\n * <p>The following examples show a simple threadsafe holder expressed using {@code synchronized},\n * {@link ReentrantLock}, and {@code Monitor}.\n *\n * <h3>{@code synchronized}</h3>\n *\n * <p>This version is the fewest lines of code, largely because the synchronization mechanism used\n * is built into the language and runtime. But the programmer has to remember to avoid a couple of\n * common bugs: The {@code wait()} must be inside a {@code while} instead of an {@code if}, and\n * {@code notifyAll()} must be used instead of {@code notify()} because there are two different\n * logical conditions being awaited.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *\n *   public synchronized V get() throws InterruptedException {\n *     while (value == null) {\n *       wait();\n *     }\n *     V result = value;\n *     value = null;\n *     notifyAll();\n *     return result;\n *   }\n *\n *   public synchronized void set(V newValue) throws InterruptedException {\n *     while (value != null) {\n *       wait();\n *     }\n *     value = newValue;\n *     notifyAll();\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code ReentrantLock}</h3>\n *\n * <p>This version is much more verbose than the {@code synchronized} version, and still suffers\n * from the need for the programmer to remember to use {@code while} instead of {@code if}. However,\n * one advantage is that we can introduce two separate {@code Condition} objects, which allows us to\n * use {@code signal()} instead of {@code signalAll()}, which may be a performance benefit.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final ReentrantLock lock = new ReentrantLock();\n *   private final Condition valuePresent = lock.newCondition();\n *   private final Condition valueAbsent = lock.newCondition();\n *\n *   public V get() throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value == null) {\n *         valuePresent.await();\n *       }\n *       V result = value;\n *       value = null;\n *       valueAbsent.signal();\n *       return result;\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value != null) {\n *         valueAbsent.await();\n *       }\n *       value = newValue;\n *       valuePresent.signal();\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code Monitor}</h3>\n *\n * <p>This version adds some verbosity around the {@code Guard} objects, but removes that same\n * verbosity, and more, from the {@code get} and {@code set} methods. {@code Monitor} implements the\n * same efficient signaling as we had to hand-code in the {@code ReentrantLock} version above.\n * Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to\n * remember to use {@code while} instead of {@code if}.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final Monitor monitor = new Monitor();\n *   private final Monitor.Guard valuePresent = monitor.newGuard(() -> value != null);\n *   private final Monitor.Guard valueAbsent = monitor.newGuard(() -> value == null);\n *\n *   public V get() throws InterruptedException {\n *     monitor.enterWhen(valuePresent);\n *     try {\n *       V result = value;\n *       value = null;\n *       return result;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     monitor.enterWhen(valueAbsent);\n *     try {\n *       value = newValue;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n * }\n * }</pre>\n *\n * @author Justin T. Sampson\n * @author Martin Buchholz\n * @since 10.0\n */\n@Beta\n@GwtIncompatible\n@SuppressWarnings(\"GuardedBy\") // TODO(b/35466881): Fix or suppress.\npublic final class Monitor\n{\n    // TODO(user): Use raw LockSupport or AbstractQueuedSynchronizer instead of ReentrantLock.\n    // TODO(user): \"Port\" jsr166 tests for ReentrantLock.\n    //\n    // TODO(user): Change API to make it impossible to use a Guard with the \"wrong\" monitor,\n    //    by making the monitor implicit, and to eliminate other sources of IMSE.\n    //    Imagine:\n    //    guard.lock();\n    //    try { /* monitor locked and guard satisfied here */ }\n    //    finally { guard.unlock(); }\n    // Here are Justin's design notes about this:\n    //\n    // This idea has come up from time to time, and I think one of my\n    // earlier versions of Monitor even did something like this. I ended\n    // up strongly favoring the current interface.\n    //\n    // I probably can't remember all the reasons (it's possible you\n    // could find them in the code review archives), but here are a few:\n    //\n    // 1. What about leaving/unlocking? Are you going to do\n    //    guard.enter() paired with monitor.leave()? That might get\n    //    confusing. It's nice for the finally block to look as close as\n    //    possible to the thing right before the try. You could have\n    //    guard.leave(), but that's a little odd as well because the\n    //    guard doesn't have anything to do with leaving. You can't\n    //    really enforce that the guard you're leaving is the same one\n    //    you entered with, and it doesn't actually matter.\n    //\n    // 2. Since you can enter the monitor without a guard at all, some\n    //    places you'll have monitor.enter()/monitor.leave() and other\n    //    places you'll have guard.enter()/guard.leave() even though\n    //    it's the same lock being acquired underneath. Always using\n    //    monitor.enterXXX()/monitor.leave() will make it really clear\n    //    which lock is held at any point in the code.\n    //\n    // 3. I think \"enterWhen(notEmpty)\" reads better than \"notEmpty.enter()\".\n    //\n    // TODO(user): Implement ReentrantLock features:\n    //    - toString() method\n    //    - getOwner() method\n    //    - getQueuedThreads() method\n    //    - getWaitingThreads(Guard) method\n    //    - implement Serializable\n    //    - redo the API to be as close to identical to ReentrantLock as possible,\n    //      since, after all, this class is also a reentrant mutual exclusion lock!?\n\n    /*\n     * One of the key challenges of this class is to prevent lost signals, while trying hard to\n     * minimize unnecessary signals. One simple and correct algorithm is to signal some other waiter\n     * with a satisfied guard (if one exists) whenever any thread occupying the monitor exits the\n     * monitor, either by unlocking all of its held locks, or by starting to wait for a guard. This\n     * includes exceptional exits, so all control paths involving signalling must be protected by a\n     * finally block.\n     *\n     * Further optimizations of this algorithm become increasingly subtle. A wait that terminates\n     * without the guard being satisfied (due to timeout, but not interrupt) can then immediately exit\n     * the monitor without signalling. If it timed out without being signalled, it does not need to\n     * \"pass on\" the signal to another thread. If it *was* signalled, then its guard must have been\n     * satisfied at the time of signal, and has since been modified by some other thread to be\n     * non-satisfied before reacquiring the lock, and that other thread takes over the responsibility\n     * of signaling the next waiter.\n     *\n     * Unlike the underlying Condition, if we are not careful, an interrupt *can* cause a signal to be\n     * lost, because the signal may be sent to a condition whose sole waiter has just been\n     * interrupted.\n     *\n     * Imagine a monitor with multiple guards. A thread enters the monitor, satisfies all the guards,\n     * and leaves, calling signalNextWaiter. With traditional locks and conditions, all the conditions\n     * need to be signalled because it is not known which if any of them have waiters (and hasWaiters\n     * can't be used reliably because of a check-then-act race). With our Monitor guards, we only\n     * signal the first active guard that is satisfied. But the corresponding thread may have already\n     * been interrupted and is waiting to reacquire the lock while still registered in activeGuards,\n     * in which case the signal is a no-op, and the bigger-picture signal is lost unless interrupted\n     * threads take special action by participating in the signal-passing game.\n     */\n\n    /*\n     * Timeout handling is intricate, especially given our ambitious goals:\n     * - Avoid underflow and overflow of timeout values when specified timeouts are close to\n     *   Long.MIN_VALUE or Long.MAX_VALUE.\n     * - Favor responding to interrupts over timeouts.\n     * - System.nanoTime() is expensive enough that we want to call it the minimum required number of\n     *   times, typically once before invoking a blocking method. This often requires keeping track of\n     *   the first time in a method that nanoTime() has been invoked, for which the special value 0L\n     *   is reserved to mean \"uninitialized\". If timeout is non-positive, then nanoTime need never be\n     *   called.\n     * - Keep behavior of fair and non-fair instances consistent.\n     */\n\n    /**\n     * A boolean condition for which a thread may wait. A {@code Guard} is associated with a single\n     * {@code Monitor}. The monitor may check the guard at arbitrary times from any thread occupying\n     * the monitor, so code should not be written to rely on how often a guard might or might not be\n     * checked.\n     *\n     * <p>If a {@code Guard} is passed into any method of a {@code Monitor} other than the one it is\n     * associated with, an {@link IllegalMonitorStateException} is thrown.\n     *\n     * @since 10.0\n     */\n    @Beta\n    public abstract static class Guard\n    {\n\n        @Weak final Monitor monitor;\n        final Condition condition;\n\n        @GuardedBy(\"monitor.lock\")\n        int waiterCount = 0;\n\n        /** The next active guard */\n        @GuardedBy(\"monitor.lock\")\n        @NullableDecl\n        Guard next;\n\n        protected Guard(Monitor monitor)\n        {\n            this.monitor = checkNotNull(monitor, \"monitor\");\n            this.condition = monitor.lock.newCondition();\n        }\n\n        /**\n         * Evaluates this guard's boolean condition. This method is always called with the associated\n         * monitor already occupied. Implementations of this method must depend only on state protected\n         * by the associated monitor, and must not modify that state.\n         */\n        public abstract boolean isSatisfied();\n    }\n\n    /** Whether this monitor is fair. */\n    private final boolean fair;\n\n    /** The lock underlying this monitor. */\n    private final ReentrantLock lock;\n\n    /**\n     * The guards associated with this monitor that currently have waiters ({@code waiterCount > 0}).\n     * A linked list threaded through the Guard.next field.\n     */\n    @GuardedBy(\"lock\")\n    private Guard activeGuards = null;\n\n    /**\n     * Creates a monitor with a non-fair (but fast) ordering policy. Equivalent to {@code\n     * Monitor(false)}.\n     */\n    public Monitor()\n    {\n        this(false);\n    }\n\n    /**\n     * Creates a monitor with the given ordering policy.\n     *\n     * @param fair whether this monitor should use a fair ordering policy rather than a non-fair (but\n     *     fast) one\n     */\n    public Monitor(boolean fair)\n    {\n        this.fair = fair;\n        this.lock = new ReentrantLock(fair);\n    }\n\n    /** Enters this monitor. Blocks indefinitely. */\n    public void enter()\n    {\n        lock.lock();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time.\n     *\n     * @return whether the monitor was entered\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enter(long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        final ReentrantLock lock = this.lock;\n        if (!fair && lock.tryLock())\n        {\n            return true;\n        }\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            final long startTime = System.nanoTime();\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterInterruptibly() throws InterruptedException\n    {\n        lock.lockInterruptibly();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time, and may be interrupted.\n     *\n     * @return whether the monitor was entered\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n    {\n        return lock.tryLock(time, unit);\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately. Does not block.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered\n     */\n    public boolean tryEnter()\n    {\n        return lock.tryLock();\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterWhen(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                await(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied, and may be\n     * interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean reentrant = lock.isHeldByCurrentThread();\n        long startTime = 0L;\n\n        locked:\n        {\n            if (!fair)\n            {\n                // Check interrupt status to get behavior consistent with fair case.\n                if (Thread.interrupted())\n                {\n                    throw new InterruptedException();\n                }\n                if (lock.tryLock())\n                {\n                    break locked;\n                }\n            }\n            startTime = initNanoTime(timeoutNanos);\n            if (!lock.tryLock(time, unit))\n            {\n                return false;\n            }\n        }\n\n        boolean satisfied = false;\n        boolean threw = true;\n        try\n        {\n            satisfied =\n                guard.isSatisfied()\n                || awaitNanos(\n                    guard,\n                    (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),\n                    reentrant);\n            threw = false;\n            return satisfied;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                try\n                {\n                    // Don't need to signal if timed out, but do if interrupted\n                    if (threw && !reentrant)\n                    {\n                        signalNextWaiter();\n                    }\n                }\n                finally\n                {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n\n    /** Enters this monitor when the guard is satisfied. Blocks indefinitely. */\n    public void enterWhenUninterruptibly(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                awaitUninterruptibly(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        long startTime = 0L;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            if (fair || !lock.tryLock())\n            {\n                startTime = initNanoTime(timeoutNanos);\n                for (long remainingNanos = timeoutNanos; ; )\n                {\n                    try\n                    {\n                        if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS))\n                        {\n                            break;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        remainingNanos = remainingNanos(startTime, timeoutNanos);\n                    }\n                }\n            }\n\n            boolean satisfied = false;\n            try\n            {\n                while (true)\n                {\n                    try\n                    {\n                        if (guard.isSatisfied())\n                        {\n                            satisfied = true;\n                        }\n                        else\n                        {\n                            final long remainingNanos;\n                            if (startTime == 0L)\n                            {\n                                startTime = initNanoTime(timeoutNanos);\n                                remainingNanos = timeoutNanos;\n                            }\n                            else\n                            {\n                                remainingNanos = remainingNanos(startTime, timeoutNanos);\n                            }\n                            satisfied = awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                        }\n                        return satisfied;\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        signalBeforeWaiting = false;\n                    }\n                }\n            }\n            finally\n            {\n                if (!satisfied)\n                {\n                    lock.unlock(); // No need to signal if timed out\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!enter(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n    throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not\n     * block acquiring the lock and does not wait for the guard to be satisfied.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean tryEnterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock())\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be called\n     * only by a thread currently occupying this monitor.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void waitFor(Guard guard) throws InterruptedException\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            await(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted. May\n     * be called only by a thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        if (Thread.interrupted())\n        {\n            throw new InterruptedException();\n        }\n        return awaitNanos(guard, timeoutNanos, true);\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread\n     * currently occupying this monitor.\n     */\n    public void waitForUninterruptibly(Guard guard)\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            awaitUninterruptibly(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time. May be called only by a\n     * thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        boolean signalBeforeWaiting = true;\n        final long startTime = initNanoTime(timeoutNanos);\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    if (guard.isSatisfied())\n                    {\n                        return true;\n                    }\n                    signalBeforeWaiting = false;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /** Leaves this monitor. May be called only by a thread currently occupying this monitor. */\n    public void leave()\n    {\n        final ReentrantLock lock = this.lock;\n        try\n        {\n            // No need to signal if we will still be holding the lock when we return\n            if (lock.getHoldCount() == 1)\n            {\n                signalNextWaiter();\n            }\n        }\n        finally\n        {\n            lock.unlock(); // Will throw IllegalMonitorStateException if not held\n        }\n    }\n\n    /** Returns whether this monitor is using a fair ordering policy. */\n    public boolean isFair()\n    {\n        return fair;\n    }\n\n    /**\n     * Returns whether this monitor is occupied by any thread. This method is designed for use in\n     * monitoring of the system state, not for synchronization control.\n     */\n    public boolean isOccupied()\n    {\n        return lock.isLocked();\n    }\n\n    /**\n     * Returns whether the current thread is occupying this monitor (has entered more times than it\n     * has left).\n     */\n    public boolean isOccupiedByCurrentThread()\n    {\n        return lock.isHeldByCurrentThread();\n    }\n\n    /**\n     * Returns the number of times the current thread has entered this monitor in excess of the number\n     * of times it has left. Returns 0 if the current thread is not occupying this monitor.\n     */\n    public int getOccupiedDepth()\n    {\n        return lock.getHoldCount();\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting to enter this monitor. The value is only\n     * an estimate because the number of threads may change dynamically while this method traverses\n     * internal data structures. This method is designed for use in monitoring of the system state,\n     * not for synchronization control.\n     */\n    public int getQueueLength()\n    {\n        return lock.getQueueLength();\n    }\n\n    /**\n     * Returns whether any threads are waiting to enter this monitor. Note that because cancellations\n     * may occur at any time, a {@code true} return does not guarantee that any other thread will ever\n     * enter this monitor. This method is designed primarily for use in monitoring of the system\n     * state.\n     */\n    public boolean hasQueuedThreads()\n    {\n        return lock.hasQueuedThreads();\n    }\n\n    /**\n     * Queries whether the given thread is waiting to enter this monitor. Note that because\n     * cancellations may occur at any time, a {@code true} return does not guarantee that this thread\n     * will ever enter this monitor. This method is designed primarily for use in monitoring of the\n     * system state.\n     */\n    public boolean hasQueuedThread(Thread thread)\n    {\n        return lock.hasQueuedThread(thread);\n    }\n\n    /**\n     * Queries whether any threads are waiting for the given guard to become satisfied. Note that\n     * because timeouts and interrupts may occur at any time, a {@code true} return does not guarantee\n     * that the guard becoming satisfied in the future will awaken any threads. This method is\n     * designed primarily for use in monitoring of the system state.\n     */\n    public boolean hasWaiters(Guard guard)\n    {\n        return getWaitQueueLength(guard) > 0;\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting for the given guard to become satisfied.\n     * Note that because timeouts and interrupts may occur at any time, the estimate serves only as an\n     * upper bound on the actual number of waiters. This method is designed for use in monitoring of\n     * the system state, not for synchronization control.\n     */\n    public int getWaitQueueLength(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        lock.lock();\n        try\n        {\n            return guard.waiterCount;\n        }\n        finally\n        {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Returns unit.toNanos(time), additionally ensuring the returned value is not at risk of\n     * overflowing or underflowing, by bounding the value between 0 and (Long.MAX_VALUE / 4) * 3.\n     * Actually waiting for more than 219 years is not supported!\n     */\n    private static long toSafeNanos(long time, TimeUnit unit)\n    {\n        long timeoutNanos = unit.toNanos(time);\n        return (timeoutNanos <= 0L)\n               ? 0L\n               : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3 : timeoutNanos;\n    }\n\n    /**\n     * Returns System.nanoTime() unless the timeout has already elapsed. Returns 0L if and only if the\n     * timeout has already elapsed.\n     */\n    private static long initNanoTime(long timeoutNanos)\n    {\n        if (timeoutNanos <= 0L)\n        {\n            return 0L;\n        }\n        else\n        {\n            long startTime = System.nanoTime();\n            return (startTime == 0L) ? 1L : startTime;\n        }\n    }\n\n    /**\n     * Returns the remaining nanos until the given timeout, or 0L if the timeout has already elapsed.\n     * Caller must have previously sanitized timeoutNanos using toSafeNanos.\n     */\n    private static long remainingNanos(long startTime, long timeoutNanos)\n    {\n        // assert timeoutNanos == 0L || startTime != 0L;\n\n        // TODO : NOT CORRECT, BUT TESTS PASS ANYWAYS!\n        // if (true) return timeoutNanos;\n        // ONLY 2 TESTS FAIL IF WE DO:\n        // if (true) return 0;\n\n        return (timeoutNanos <= 0L) ? 0L : timeoutNanos - (System.nanoTime() - startTime);\n    }\n\n    /**\n     * Signals some other thread waiting on a satisfied guard, if one exists.\n     *\n     * <p>We manage calls to this method carefully, to signal only when necessary, but never losing a\n     * signal, which is the classic problem of this kind of concurrency construct. We must signal if\n     * the current thread is about to relinquish the lock and may have changed the state protected by\n     * the monitor, thereby causing some guard to be satisfied.\n     *\n     * <p>In addition, any thread that has been signalled when its guard was satisfied acquires the\n     * responsibility of signalling the next thread when it again relinquishes the lock. Unlike a\n     * normal Condition, there is no guarantee that an interrupted thread has not been signalled,\n     * since the concurrency control must manage multiple Conditions. So this method must generally be\n     * called when waits are interrupted.\n     *\n     * <p>On the other hand, if a signalled thread wakes up to discover that its guard is still not\n     * satisfied, it does *not* need to call this method before returning to wait. This can only\n     * happen due to spurious wakeup (ignorable) or another thread acquiring the lock before the\n     * current thread can and returning the guard to the unsatisfied state. In the latter case the\n     * other thread (last thread modifying the state protected by the monitor) takes over the\n     * responsibility of signalling the next waiter.\n     *\n     * <p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else\n     * the current thread's guard might be mistakenly signalled, leading to a lost signal.\n     */\n    @GuardedBy(\"lock\")\n    private void signalNextWaiter()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            if (isSatisfied(guard))\n            {\n                guard.condition.signal();\n                break;\n            }\n        }\n    }\n\n    /**\n     * Exactly like signalNextWaiter, but caller guarantees that guardToSkip need not be considered,\n     * because caller has previously checked that guardToSkip.isSatisfied() returned false. An\n     * optimization for the case that guardToSkip.isSatisfied() may be expensive.\n     *\n     * <p>We decided against using this method, since in practice, isSatisfied() is likely to be very\n     * cheap (typically one field read). Resurrect this method if you find that not to be true.\n     */\n    //   @GuardedBy(\"lock\")\n    //   private void signalNextWaiterSkipping(Guard guardToSkip) {\n    //     for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n    //       if (guard != guardToSkip && isSatisfied(guard)) {\n    //         guard.condition.signal();\n    //         break;\n    //       }\n    //     }\n    //   }\n\n    /**\n     * Exactly like guard.isSatisfied(), but in addition signals all waiting threads in the (hopefully\n     * unlikely) event that isSatisfied() throws.\n     */\n    @GuardedBy(\"lock\")\n    private boolean isSatisfied(Guard guard)\n    {\n        try\n        {\n            return guard.isSatisfied();\n        }\n        catch (Throwable throwable)\n        {\n            signalAllWaiters();\n            throw throwable;\n        }\n    }\n\n    /** Signals all threads waiting on guards. */\n    @GuardedBy(\"lock\")\n    private void signalAllWaiters()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            guard.condition.signalAll();\n        }\n    }\n\n    /** Records that the current thread is about to wait on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void beginWaitingFor(Guard guard)\n    {\n        int waiters = guard.waiterCount++;\n        if (waiters == 0)\n        {\n            // push guard onto activeGuards\n            guard.next = activeGuards;\n            activeGuards = guard;\n        }\n    }\n\n    /** Records that the current thread is no longer waiting on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void endWaitingFor(Guard guard)\n    {\n        int waiters = --guard.waiterCount;\n        if (waiters == 0)\n        {\n            // unlink guard from activeGuards\n            for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next)\n            {\n                if (p == guard)\n                {\n                    if (pred == null)\n                    {\n                        activeGuards = p.next;\n                    }\n                    else\n                    {\n                        pred.next = p.next;\n                    }\n                    p.next = null; // help GC\n                    break;\n                }\n            }\n        }\n    }\n\n    /*\n     * Methods that loop waiting on a guard's condition until the guard is satisfied, while recording\n     * this fact so that other threads know to check our guard and signal us. It's caller's\n     * responsibility to ensure that the guard is *not* currently satisfied.\n     */\n\n    @GuardedBy(\"lock\")\n    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.await();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    @GuardedBy(\"lock\")\n    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.awaitUninterruptibly();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    /** Caller should check before calling that guard is not satisfied. */\n    @GuardedBy(\"lock\")\n    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n    throws InterruptedException\n    {\n        boolean firstTime = true;\n        try\n        {\n            do\n            {\n                if (nanos <= 0L)\n                {\n                    return false;\n                }\n                if (firstTime)\n                {\n                    if (signalBeforeWaiting)\n                    {\n                        signalNextWaiter();\n                    }\n                    beginWaitingFor(guard);\n                    firstTime = false;\n                }\n                nanos = guard.condition.awaitNanos(nanos);\n            }\n            while (!guard.isSatisfied());\n            return true;\n        }\n        finally\n        {\n            if (!firstTime)\n            {\n                endWaitingFor(guard);\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.enterIf", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\nlock, but does not wait for the guard to be satisfied.\n\n@return whether the monitor was entered, which guarantees that the guard is now satisfied", "docstring_tokens": ["Enters", "this", "monitor", "if", "the", "guard", "is", "satisfied", ".", "Blocks", "at", "most", "the", "given", "time", "acquiring", "the", "lock", "but", "does", "not", "wait", "for", "the", "guard", "to", "be", "satisfied", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L631-L648", "partition": "valid", "up_fun_num": 11, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.errorprone.annotations.concurrent.GuardedBy;", "import com.google.j2objc.annotations.Weak;", "import java.util.concurrent.TimeUnit;", "import java.util.concurrent.locks.Condition;", "import java.util.concurrent.locks.ReentrantLock;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Monitor\n", "    public void enter()\n", "    public boolean enter(long time, TimeUnit unit)\n", "    public void enterInterruptibly() throws InterruptedException\n", "    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n", "    public boolean tryEnter()\n", "    public void enterWhen(Guard guard) throws InterruptedException\n", "    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void enterWhenUninterruptibly(Guard guard)\n", "    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIf(Guard guard)\n", "    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n", "    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean tryEnterIf(Guard guard)\n", "    public void waitFor(Guard guard) throws InterruptedException\n", "    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void waitForUninterruptibly(Guard guard)\n", "    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public void leave()\n", "    public boolean isFair()\n", "    public boolean isOccupied()\n", "    public boolean isOccupiedByCurrentThread()\n", "    public int getOccupiedDepth()\n", "    public int getQueueLength()\n", "    public boolean hasQueuedThreads()\n", "    public boolean hasQueuedThread(Thread thread)\n", "    public boolean hasWaiters(Guard guard)\n", "    public int getWaitQueueLength(Guard guard)\n", "    private static long toSafeNanos(long time, TimeUnit unit)\n", "    private static long initNanoTime(long timeoutNanos)\n", "    private static long remainingNanos(long startTime, long timeoutNanos)\n", "    private void signalNextWaiter()\n", "    private boolean isSatisfied(Guard guard)\n", "    private void signalAllWaiters()\n", "    private void beginWaitingFor(Guard guard)\n", "    private void endWaitingFor(Guard guard)\n", "    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n", "    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n", "    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n"], "context": "/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.concurrent.GuardedBy;\nimport com.google.j2objc.annotations.Weak;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A synchronization abstraction supporting waiting on arbitrary boolean conditions.\n *\n * <p>This class is intended as a replacement for {@link ReentrantLock}. Code using {@code Monitor}\n * is less error-prone and more readable than code using {@code ReentrantLock}, without significant\n * performance loss. {@code Monitor} even has the potential for performance gain by optimizing the\n * evaluation and signaling of conditions. Signaling is entirely <a\n * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>. By\n * eliminating explicit signaling, this class can guarantee that only one thread is awakened when a\n * condition becomes true (no \"signaling storms\" due to use of {@link\n * java.util.concurrent.locks.Condition#signalAll Condition.signalAll}) and that no signals are lost\n * (no \"hangs\" due to incorrect use of {@link java.util.concurrent.locks.Condition#signal\n * Condition.signal}).\n *\n * <p>A thread is said to <i>occupy</i> a monitor if it has <i>entered</i> the monitor but not yet\n * <i>left</i>. Only one thread may occupy a given monitor at any moment. A monitor is also\n * reentrant, so a thread may enter a monitor any number of times, and then must leave the same\n * number of times. The <i>enter</i> and <i>leave</i> operations have the same synchronization\n * semantics as the built-in Java language synchronization primitives.\n *\n * <p>A call to any of the <i>enter</i> methods with <b>void</b> return type should always be\n * followed immediately by a <i>try/finally</i> block to ensure that the current thread leaves the\n * monitor cleanly:\n *\n * <pre>{@code\n * monitor.enter();\n * try {\n *   // do things while occupying the monitor\n * } finally {\n *   monitor.leave();\n * }\n * }</pre>\n *\n * <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear\n * as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that\n * the current thread leaves the monitor cleanly:\n *\n * <pre>{@code\n * if (monitor.tryEnter()) {\n *   try {\n *     // do things while occupying the monitor\n *   } finally {\n *     monitor.leave();\n *   }\n * } else {\n *   // do other things since the monitor was not available\n * }\n * }</pre>\n *\n * <h2>Comparison with {@code synchronized} and {@code ReentrantLock}</h2>\n *\n * <p>The following examples show a simple threadsafe holder expressed using {@code synchronized},\n * {@link ReentrantLock}, and {@code Monitor}.\n *\n * <h3>{@code synchronized}</h3>\n *\n * <p>This version is the fewest lines of code, largely because the synchronization mechanism used\n * is built into the language and runtime. But the programmer has to remember to avoid a couple of\n * common bugs: The {@code wait()} must be inside a {@code while} instead of an {@code if}, and\n * {@code notifyAll()} must be used instead of {@code notify()} because there are two different\n * logical conditions being awaited.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *\n *   public synchronized V get() throws InterruptedException {\n *     while (value == null) {\n *       wait();\n *     }\n *     V result = value;\n *     value = null;\n *     notifyAll();\n *     return result;\n *   }\n *\n *   public synchronized void set(V newValue) throws InterruptedException {\n *     while (value != null) {\n *       wait();\n *     }\n *     value = newValue;\n *     notifyAll();\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code ReentrantLock}</h3>\n *\n * <p>This version is much more verbose than the {@code synchronized} version, and still suffers\n * from the need for the programmer to remember to use {@code while} instead of {@code if}. However,\n * one advantage is that we can introduce two separate {@code Condition} objects, which allows us to\n * use {@code signal()} instead of {@code signalAll()}, which may be a performance benefit.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final ReentrantLock lock = new ReentrantLock();\n *   private final Condition valuePresent = lock.newCondition();\n *   private final Condition valueAbsent = lock.newCondition();\n *\n *   public V get() throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value == null) {\n *         valuePresent.await();\n *       }\n *       V result = value;\n *       value = null;\n *       valueAbsent.signal();\n *       return result;\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value != null) {\n *         valueAbsent.await();\n *       }\n *       value = newValue;\n *       valuePresent.signal();\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code Monitor}</h3>\n *\n * <p>This version adds some verbosity around the {@code Guard} objects, but removes that same\n * verbosity, and more, from the {@code get} and {@code set} methods. {@code Monitor} implements the\n * same efficient signaling as we had to hand-code in the {@code ReentrantLock} version above.\n * Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to\n * remember to use {@code while} instead of {@code if}.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final Monitor monitor = new Monitor();\n *   private final Monitor.Guard valuePresent = monitor.newGuard(() -> value != null);\n *   private final Monitor.Guard valueAbsent = monitor.newGuard(() -> value == null);\n *\n *   public V get() throws InterruptedException {\n *     monitor.enterWhen(valuePresent);\n *     try {\n *       V result = value;\n *       value = null;\n *       return result;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     monitor.enterWhen(valueAbsent);\n *     try {\n *       value = newValue;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n * }\n * }</pre>\n *\n * @author Justin T. Sampson\n * @author Martin Buchholz\n * @since 10.0\n */\n@Beta\n@GwtIncompatible\n@SuppressWarnings(\"GuardedBy\") // TODO(b/35466881): Fix or suppress.\npublic final class Monitor\n{\n    // TODO(user): Use raw LockSupport or AbstractQueuedSynchronizer instead of ReentrantLock.\n    // TODO(user): \"Port\" jsr166 tests for ReentrantLock.\n    //\n    // TODO(user): Change API to make it impossible to use a Guard with the \"wrong\" monitor,\n    //    by making the monitor implicit, and to eliminate other sources of IMSE.\n    //    Imagine:\n    //    guard.lock();\n    //    try { /* monitor locked and guard satisfied here */ }\n    //    finally { guard.unlock(); }\n    // Here are Justin's design notes about this:\n    //\n    // This idea has come up from time to time, and I think one of my\n    // earlier versions of Monitor even did something like this. I ended\n    // up strongly favoring the current interface.\n    //\n    // I probably can't remember all the reasons (it's possible you\n    // could find them in the code review archives), but here are a few:\n    //\n    // 1. What about leaving/unlocking? Are you going to do\n    //    guard.enter() paired with monitor.leave()? That might get\n    //    confusing. It's nice for the finally block to look as close as\n    //    possible to the thing right before the try. You could have\n    //    guard.leave(), but that's a little odd as well because the\n    //    guard doesn't have anything to do with leaving. You can't\n    //    really enforce that the guard you're leaving is the same one\n    //    you entered with, and it doesn't actually matter.\n    //\n    // 2. Since you can enter the monitor without a guard at all, some\n    //    places you'll have monitor.enter()/monitor.leave() and other\n    //    places you'll have guard.enter()/guard.leave() even though\n    //    it's the same lock being acquired underneath. Always using\n    //    monitor.enterXXX()/monitor.leave() will make it really clear\n    //    which lock is held at any point in the code.\n    //\n    // 3. I think \"enterWhen(notEmpty)\" reads better than \"notEmpty.enter()\".\n    //\n    // TODO(user): Implement ReentrantLock features:\n    //    - toString() method\n    //    - getOwner() method\n    //    - getQueuedThreads() method\n    //    - getWaitingThreads(Guard) method\n    //    - implement Serializable\n    //    - redo the API to be as close to identical to ReentrantLock as possible,\n    //      since, after all, this class is also a reentrant mutual exclusion lock!?\n\n    /*\n     * One of the key challenges of this class is to prevent lost signals, while trying hard to\n     * minimize unnecessary signals. One simple and correct algorithm is to signal some other waiter\n     * with a satisfied guard (if one exists) whenever any thread occupying the monitor exits the\n     * monitor, either by unlocking all of its held locks, or by starting to wait for a guard. This\n     * includes exceptional exits, so all control paths involving signalling must be protected by a\n     * finally block.\n     *\n     * Further optimizations of this algorithm become increasingly subtle. A wait that terminates\n     * without the guard being satisfied (due to timeout, but not interrupt) can then immediately exit\n     * the monitor without signalling. If it timed out without being signalled, it does not need to\n     * \"pass on\" the signal to another thread. If it *was* signalled, then its guard must have been\n     * satisfied at the time of signal, and has since been modified by some other thread to be\n     * non-satisfied before reacquiring the lock, and that other thread takes over the responsibility\n     * of signaling the next waiter.\n     *\n     * Unlike the underlying Condition, if we are not careful, an interrupt *can* cause a signal to be\n     * lost, because the signal may be sent to a condition whose sole waiter has just been\n     * interrupted.\n     *\n     * Imagine a monitor with multiple guards. A thread enters the monitor, satisfies all the guards,\n     * and leaves, calling signalNextWaiter. With traditional locks and conditions, all the conditions\n     * need to be signalled because it is not known which if any of them have waiters (and hasWaiters\n     * can't be used reliably because of a check-then-act race). With our Monitor guards, we only\n     * signal the first active guard that is satisfied. But the corresponding thread may have already\n     * been interrupted and is waiting to reacquire the lock while still registered in activeGuards,\n     * in which case the signal is a no-op, and the bigger-picture signal is lost unless interrupted\n     * threads take special action by participating in the signal-passing game.\n     */\n\n    /*\n     * Timeout handling is intricate, especially given our ambitious goals:\n     * - Avoid underflow and overflow of timeout values when specified timeouts are close to\n     *   Long.MIN_VALUE or Long.MAX_VALUE.\n     * - Favor responding to interrupts over timeouts.\n     * - System.nanoTime() is expensive enough that we want to call it the minimum required number of\n     *   times, typically once before invoking a blocking method. This often requires keeping track of\n     *   the first time in a method that nanoTime() has been invoked, for which the special value 0L\n     *   is reserved to mean \"uninitialized\". If timeout is non-positive, then nanoTime need never be\n     *   called.\n     * - Keep behavior of fair and non-fair instances consistent.\n     */\n\n    /**\n     * A boolean condition for which a thread may wait. A {@code Guard} is associated with a single\n     * {@code Monitor}. The monitor may check the guard at arbitrary times from any thread occupying\n     * the monitor, so code should not be written to rely on how often a guard might or might not be\n     * checked.\n     *\n     * <p>If a {@code Guard} is passed into any method of a {@code Monitor} other than the one it is\n     * associated with, an {@link IllegalMonitorStateException} is thrown.\n     *\n     * @since 10.0\n     */\n    @Beta\n    public abstract static class Guard\n    {\n\n        @Weak final Monitor monitor;\n        final Condition condition;\n\n        @GuardedBy(\"monitor.lock\")\n        int waiterCount = 0;\n\n        /** The next active guard */\n        @GuardedBy(\"monitor.lock\")\n        @NullableDecl\n        Guard next;\n\n        protected Guard(Monitor monitor)\n        {\n            this.monitor = checkNotNull(monitor, \"monitor\");\n            this.condition = monitor.lock.newCondition();\n        }\n\n        /**\n         * Evaluates this guard's boolean condition. This method is always called with the associated\n         * monitor already occupied. Implementations of this method must depend only on state protected\n         * by the associated monitor, and must not modify that state.\n         */\n        public abstract boolean isSatisfied();\n    }\n\n    /** Whether this monitor is fair. */\n    private final boolean fair;\n\n    /** The lock underlying this monitor. */\n    private final ReentrantLock lock;\n\n    /**\n     * The guards associated with this monitor that currently have waiters ({@code waiterCount > 0}).\n     * A linked list threaded through the Guard.next field.\n     */\n    @GuardedBy(\"lock\")\n    private Guard activeGuards = null;\n\n    /**\n     * Creates a monitor with a non-fair (but fast) ordering policy. Equivalent to {@code\n     * Monitor(false)}.\n     */\n    public Monitor()\n    {\n        this(false);\n    }\n\n    /**\n     * Creates a monitor with the given ordering policy.\n     *\n     * @param fair whether this monitor should use a fair ordering policy rather than a non-fair (but\n     *     fast) one\n     */\n    public Monitor(boolean fair)\n    {\n        this.fair = fair;\n        this.lock = new ReentrantLock(fair);\n    }\n\n    /** Enters this monitor. Blocks indefinitely. */\n    public void enter()\n    {\n        lock.lock();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time.\n     *\n     * @return whether the monitor was entered\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enter(long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        final ReentrantLock lock = this.lock;\n        if (!fair && lock.tryLock())\n        {\n            return true;\n        }\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            final long startTime = System.nanoTime();\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterInterruptibly() throws InterruptedException\n    {\n        lock.lockInterruptibly();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time, and may be interrupted.\n     *\n     * @return whether the monitor was entered\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n    {\n        return lock.tryLock(time, unit);\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately. Does not block.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered\n     */\n    public boolean tryEnter()\n    {\n        return lock.tryLock();\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterWhen(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                await(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied, and may be\n     * interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean reentrant = lock.isHeldByCurrentThread();\n        long startTime = 0L;\n\n        locked:\n        {\n            if (!fair)\n            {\n                // Check interrupt status to get behavior consistent with fair case.\n                if (Thread.interrupted())\n                {\n                    throw new InterruptedException();\n                }\n                if (lock.tryLock())\n                {\n                    break locked;\n                }\n            }\n            startTime = initNanoTime(timeoutNanos);\n            if (!lock.tryLock(time, unit))\n            {\n                return false;\n            }\n        }\n\n        boolean satisfied = false;\n        boolean threw = true;\n        try\n        {\n            satisfied =\n                guard.isSatisfied()\n                || awaitNanos(\n                    guard,\n                    (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),\n                    reentrant);\n            threw = false;\n            return satisfied;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                try\n                {\n                    // Don't need to signal if timed out, but do if interrupted\n                    if (threw && !reentrant)\n                    {\n                        signalNextWaiter();\n                    }\n                }\n                finally\n                {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n\n    /** Enters this monitor when the guard is satisfied. Blocks indefinitely. */\n    public void enterWhenUninterruptibly(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                awaitUninterruptibly(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        long startTime = 0L;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            if (fair || !lock.tryLock())\n            {\n                startTime = initNanoTime(timeoutNanos);\n                for (long remainingNanos = timeoutNanos; ; )\n                {\n                    try\n                    {\n                        if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS))\n                        {\n                            break;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        remainingNanos = remainingNanos(startTime, timeoutNanos);\n                    }\n                }\n            }\n\n            boolean satisfied = false;\n            try\n            {\n                while (true)\n                {\n                    try\n                    {\n                        if (guard.isSatisfied())\n                        {\n                            satisfied = true;\n                        }\n                        else\n                        {\n                            final long remainingNanos;\n                            if (startTime == 0L)\n                            {\n                                startTime = initNanoTime(timeoutNanos);\n                                remainingNanos = timeoutNanos;\n                            }\n                            else\n                            {\n                                remainingNanos = remainingNanos(startTime, timeoutNanos);\n                            }\n                            satisfied = awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                        }\n                        return satisfied;\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        signalBeforeWaiting = false;\n                    }\n                }\n            }\n            finally\n            {\n                if (!satisfied)\n                {\n                    lock.unlock(); // No need to signal if timed out\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean enterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n    throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not\n     * block acquiring the lock and does not wait for the guard to be satisfied.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean tryEnterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock())\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be called\n     * only by a thread currently occupying this monitor.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void waitFor(Guard guard) throws InterruptedException\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            await(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted. May\n     * be called only by a thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        if (Thread.interrupted())\n        {\n            throw new InterruptedException();\n        }\n        return awaitNanos(guard, timeoutNanos, true);\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread\n     * currently occupying this monitor.\n     */\n    public void waitForUninterruptibly(Guard guard)\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            awaitUninterruptibly(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time. May be called only by a\n     * thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        boolean signalBeforeWaiting = true;\n        final long startTime = initNanoTime(timeoutNanos);\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    if (guard.isSatisfied())\n                    {\n                        return true;\n                    }\n                    signalBeforeWaiting = false;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /** Leaves this monitor. May be called only by a thread currently occupying this monitor. */\n    public void leave()\n    {\n        final ReentrantLock lock = this.lock;\n        try\n        {\n            // No need to signal if we will still be holding the lock when we return\n            if (lock.getHoldCount() == 1)\n            {\n                signalNextWaiter();\n            }\n        }\n        finally\n        {\n            lock.unlock(); // Will throw IllegalMonitorStateException if not held\n        }\n    }\n\n    /** Returns whether this monitor is using a fair ordering policy. */\n    public boolean isFair()\n    {\n        return fair;\n    }\n\n    /**\n     * Returns whether this monitor is occupied by any thread. This method is designed for use in\n     * monitoring of the system state, not for synchronization control.\n     */\n    public boolean isOccupied()\n    {\n        return lock.isLocked();\n    }\n\n    /**\n     * Returns whether the current thread is occupying this monitor (has entered more times than it\n     * has left).\n     */\n    public boolean isOccupiedByCurrentThread()\n    {\n        return lock.isHeldByCurrentThread();\n    }\n\n    /**\n     * Returns the number of times the current thread has entered this monitor in excess of the number\n     * of times it has left. Returns 0 if the current thread is not occupying this monitor.\n     */\n    public int getOccupiedDepth()\n    {\n        return lock.getHoldCount();\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting to enter this monitor. The value is only\n     * an estimate because the number of threads may change dynamically while this method traverses\n     * internal data structures. This method is designed for use in monitoring of the system state,\n     * not for synchronization control.\n     */\n    public int getQueueLength()\n    {\n        return lock.getQueueLength();\n    }\n\n    /**\n     * Returns whether any threads are waiting to enter this monitor. Note that because cancellations\n     * may occur at any time, a {@code true} return does not guarantee that any other thread will ever\n     * enter this monitor. This method is designed primarily for use in monitoring of the system\n     * state.\n     */\n    public boolean hasQueuedThreads()\n    {\n        return lock.hasQueuedThreads();\n    }\n\n    /**\n     * Queries whether the given thread is waiting to enter this monitor. Note that because\n     * cancellations may occur at any time, a {@code true} return does not guarantee that this thread\n     * will ever enter this monitor. This method is designed primarily for use in monitoring of the\n     * system state.\n     */\n    public boolean hasQueuedThread(Thread thread)\n    {\n        return lock.hasQueuedThread(thread);\n    }\n\n    /**\n     * Queries whether any threads are waiting for the given guard to become satisfied. Note that\n     * because timeouts and interrupts may occur at any time, a {@code true} return does not guarantee\n     * that the guard becoming satisfied in the future will awaken any threads. This method is\n     * designed primarily for use in monitoring of the system state.\n     */\n    public boolean hasWaiters(Guard guard)\n    {\n        return getWaitQueueLength(guard) > 0;\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting for the given guard to become satisfied.\n     * Note that because timeouts and interrupts may occur at any time, the estimate serves only as an\n     * upper bound on the actual number of waiters. This method is designed for use in monitoring of\n     * the system state, not for synchronization control.\n     */\n    public int getWaitQueueLength(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        lock.lock();\n        try\n        {\n            return guard.waiterCount;\n        }\n        finally\n        {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Returns unit.toNanos(time), additionally ensuring the returned value is not at risk of\n     * overflowing or underflowing, by bounding the value between 0 and (Long.MAX_VALUE / 4) * 3.\n     * Actually waiting for more than 219 years is not supported!\n     */\n    private static long toSafeNanos(long time, TimeUnit unit)\n    {\n        long timeoutNanos = unit.toNanos(time);\n        return (timeoutNanos <= 0L)\n               ? 0L\n               : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3 : timeoutNanos;\n    }\n\n    /**\n     * Returns System.nanoTime() unless the timeout has already elapsed. Returns 0L if and only if the\n     * timeout has already elapsed.\n     */\n    private static long initNanoTime(long timeoutNanos)\n    {\n        if (timeoutNanos <= 0L)\n        {\n            return 0L;\n        }\n        else\n        {\n            long startTime = System.nanoTime();\n            return (startTime == 0L) ? 1L : startTime;\n        }\n    }\n\n    /**\n     * Returns the remaining nanos until the given timeout, or 0L if the timeout has already elapsed.\n     * Caller must have previously sanitized timeoutNanos using toSafeNanos.\n     */\n    private static long remainingNanos(long startTime, long timeoutNanos)\n    {\n        // assert timeoutNanos == 0L || startTime != 0L;\n\n        // TODO : NOT CORRECT, BUT TESTS PASS ANYWAYS!\n        // if (true) return timeoutNanos;\n        // ONLY 2 TESTS FAIL IF WE DO:\n        // if (true) return 0;\n\n        return (timeoutNanos <= 0L) ? 0L : timeoutNanos - (System.nanoTime() - startTime);\n    }\n\n    /**\n     * Signals some other thread waiting on a satisfied guard, if one exists.\n     *\n     * <p>We manage calls to this method carefully, to signal only when necessary, but never losing a\n     * signal, which is the classic problem of this kind of concurrency construct. We must signal if\n     * the current thread is about to relinquish the lock and may have changed the state protected by\n     * the monitor, thereby causing some guard to be satisfied.\n     *\n     * <p>In addition, any thread that has been signalled when its guard was satisfied acquires the\n     * responsibility of signalling the next thread when it again relinquishes the lock. Unlike a\n     * normal Condition, there is no guarantee that an interrupted thread has not been signalled,\n     * since the concurrency control must manage multiple Conditions. So this method must generally be\n     * called when waits are interrupted.\n     *\n     * <p>On the other hand, if a signalled thread wakes up to discover that its guard is still not\n     * satisfied, it does *not* need to call this method before returning to wait. This can only\n     * happen due to spurious wakeup (ignorable) or another thread acquiring the lock before the\n     * current thread can and returning the guard to the unsatisfied state. In the latter case the\n     * other thread (last thread modifying the state protected by the monitor) takes over the\n     * responsibility of signalling the next waiter.\n     *\n     * <p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else\n     * the current thread's guard might be mistakenly signalled, leading to a lost signal.\n     */\n    @GuardedBy(\"lock\")\n    private void signalNextWaiter()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            if (isSatisfied(guard))\n            {\n                guard.condition.signal();\n                break;\n            }\n        }\n    }\n\n    /**\n     * Exactly like signalNextWaiter, but caller guarantees that guardToSkip need not be considered,\n     * because caller has previously checked that guardToSkip.isSatisfied() returned false. An\n     * optimization for the case that guardToSkip.isSatisfied() may be expensive.\n     *\n     * <p>We decided against using this method, since in practice, isSatisfied() is likely to be very\n     * cheap (typically one field read). Resurrect this method if you find that not to be true.\n     */\n    //   @GuardedBy(\"lock\")\n    //   private void signalNextWaiterSkipping(Guard guardToSkip) {\n    //     for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n    //       if (guard != guardToSkip && isSatisfied(guard)) {\n    //         guard.condition.signal();\n    //         break;\n    //       }\n    //     }\n    //   }\n\n    /**\n     * Exactly like guard.isSatisfied(), but in addition signals all waiting threads in the (hopefully\n     * unlikely) event that isSatisfied() throws.\n     */\n    @GuardedBy(\"lock\")\n    private boolean isSatisfied(Guard guard)\n    {\n        try\n        {\n            return guard.isSatisfied();\n        }\n        catch (Throwable throwable)\n        {\n            signalAllWaiters();\n            throw throwable;\n        }\n    }\n\n    /** Signals all threads waiting on guards. */\n    @GuardedBy(\"lock\")\n    private void signalAllWaiters()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            guard.condition.signalAll();\n        }\n    }\n\n    /** Records that the current thread is about to wait on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void beginWaitingFor(Guard guard)\n    {\n        int waiters = guard.waiterCount++;\n        if (waiters == 0)\n        {\n            // push guard onto activeGuards\n            guard.next = activeGuards;\n            activeGuards = guard;\n        }\n    }\n\n    /** Records that the current thread is no longer waiting on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void endWaitingFor(Guard guard)\n    {\n        int waiters = --guard.waiterCount;\n        if (waiters == 0)\n        {\n            // unlink guard from activeGuards\n            for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next)\n            {\n                if (p == guard)\n                {\n                    if (pred == null)\n                    {\n                        activeGuards = p.next;\n                    }\n                    else\n                    {\n                        pred.next = p.next;\n                    }\n                    p.next = null; // help GC\n                    break;\n                }\n            }\n        }\n    }\n\n    /*\n     * Methods that loop waiting on a guard's condition until the guard is satisfied, while recording\n     * this fact so that other threads know to check our guard and signal us. It's caller's\n     * responsibility to ensure that the guard is *not* currently satisfied.\n     */\n\n    @GuardedBy(\"lock\")\n    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.await();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    @GuardedBy(\"lock\")\n    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.awaitUninterruptibly();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    /** Caller should check before calling that guard is not satisfied. */\n    @GuardedBy(\"lock\")\n    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n    throws InterruptedException\n    {\n        boolean firstTime = true;\n        try\n        {\n            do\n            {\n                if (nanos <= 0L)\n                {\n                    return false;\n                }\n                if (firstTime)\n                {\n                    if (signalBeforeWaiting)\n                    {\n                        signalNextWaiter();\n                    }\n                    beginWaitingFor(guard);\n                    firstTime = false;\n                }\n                nanos = guard.condition.awaitNanos(nanos);\n            }\n            while (!guard.isSatisfied());\n            return true;\n        }\n        finally\n        {\n            if (!firstTime)\n            {\n                endWaitingFor(guard);\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.enterIfInterruptibly", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\nnot wait for the guard to be satisfied, and may be interrupted.\n\n@return whether the monitor was entered, which guarantees that the guard is now satisfied\n@throws InterruptedException if interrupted while waiting", "docstring_tokens": ["Enters", "this", "monitor", "if", "the", "guard", "is", "satisfied", ".", "Blocks", "indefinitely", "acquiring", "the", "lock", "but", "does", "not", "wait", "for", "the", "guard", "to", "be", "satisfied", "and", "may", "be", "interrupted", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L657-L672", "partition": "valid", "up_fun_num": 13, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.errorprone.annotations.concurrent.GuardedBy;", "import com.google.j2objc.annotations.Weak;", "import java.util.concurrent.TimeUnit;", "import java.util.concurrent.locks.Condition;", "import java.util.concurrent.locks.ReentrantLock;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Monitor\n", "    public void enter()\n", "    public boolean enter(long time, TimeUnit unit)\n", "    public void enterInterruptibly() throws InterruptedException\n", "    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n", "    public boolean tryEnter()\n", "    public void enterWhen(Guard guard) throws InterruptedException\n", "    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void enterWhenUninterruptibly(Guard guard)\n", "    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIf(Guard guard)\n", "    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean tryEnterIf(Guard guard)\n", "    public void waitFor(Guard guard) throws InterruptedException\n", "    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void waitForUninterruptibly(Guard guard)\n", "    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public void leave()\n", "    public boolean isFair()\n", "    public boolean isOccupied()\n", "    public boolean isOccupiedByCurrentThread()\n", "    public int getOccupiedDepth()\n", "    public int getQueueLength()\n", "    public boolean hasQueuedThreads()\n", "    public boolean hasQueuedThread(Thread thread)\n", "    public boolean hasWaiters(Guard guard)\n", "    public int getWaitQueueLength(Guard guard)\n", "    private static long toSafeNanos(long time, TimeUnit unit)\n", "    private static long initNanoTime(long timeoutNanos)\n", "    private static long remainingNanos(long startTime, long timeoutNanos)\n", "    private void signalNextWaiter()\n", "    private boolean isSatisfied(Guard guard)\n", "    private void signalAllWaiters()\n", "    private void beginWaitingFor(Guard guard)\n", "    private void endWaitingFor(Guard guard)\n", "    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n", "    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n", "    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n"], "context": "/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.concurrent.GuardedBy;\nimport com.google.j2objc.annotations.Weak;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A synchronization abstraction supporting waiting on arbitrary boolean conditions.\n *\n * <p>This class is intended as a replacement for {@link ReentrantLock}. Code using {@code Monitor}\n * is less error-prone and more readable than code using {@code ReentrantLock}, without significant\n * performance loss. {@code Monitor} even has the potential for performance gain by optimizing the\n * evaluation and signaling of conditions. Signaling is entirely <a\n * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>. By\n * eliminating explicit signaling, this class can guarantee that only one thread is awakened when a\n * condition becomes true (no \"signaling storms\" due to use of {@link\n * java.util.concurrent.locks.Condition#signalAll Condition.signalAll}) and that no signals are lost\n * (no \"hangs\" due to incorrect use of {@link java.util.concurrent.locks.Condition#signal\n * Condition.signal}).\n *\n * <p>A thread is said to <i>occupy</i> a monitor if it has <i>entered</i> the monitor but not yet\n * <i>left</i>. Only one thread may occupy a given monitor at any moment. A monitor is also\n * reentrant, so a thread may enter a monitor any number of times, and then must leave the same\n * number of times. The <i>enter</i> and <i>leave</i> operations have the same synchronization\n * semantics as the built-in Java language synchronization primitives.\n *\n * <p>A call to any of the <i>enter</i> methods with <b>void</b> return type should always be\n * followed immediately by a <i>try/finally</i> block to ensure that the current thread leaves the\n * monitor cleanly:\n *\n * <pre>{@code\n * monitor.enter();\n * try {\n *   // do things while occupying the monitor\n * } finally {\n *   monitor.leave();\n * }\n * }</pre>\n *\n * <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear\n * as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that\n * the current thread leaves the monitor cleanly:\n *\n * <pre>{@code\n * if (monitor.tryEnter()) {\n *   try {\n *     // do things while occupying the monitor\n *   } finally {\n *     monitor.leave();\n *   }\n * } else {\n *   // do other things since the monitor was not available\n * }\n * }</pre>\n *\n * <h2>Comparison with {@code synchronized} and {@code ReentrantLock}</h2>\n *\n * <p>The following examples show a simple threadsafe holder expressed using {@code synchronized},\n * {@link ReentrantLock}, and {@code Monitor}.\n *\n * <h3>{@code synchronized}</h3>\n *\n * <p>This version is the fewest lines of code, largely because the synchronization mechanism used\n * is built into the language and runtime. But the programmer has to remember to avoid a couple of\n * common bugs: The {@code wait()} must be inside a {@code while} instead of an {@code if}, and\n * {@code notifyAll()} must be used instead of {@code notify()} because there are two different\n * logical conditions being awaited.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *\n *   public synchronized V get() throws InterruptedException {\n *     while (value == null) {\n *       wait();\n *     }\n *     V result = value;\n *     value = null;\n *     notifyAll();\n *     return result;\n *   }\n *\n *   public synchronized void set(V newValue) throws InterruptedException {\n *     while (value != null) {\n *       wait();\n *     }\n *     value = newValue;\n *     notifyAll();\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code ReentrantLock}</h3>\n *\n * <p>This version is much more verbose than the {@code synchronized} version, and still suffers\n * from the need for the programmer to remember to use {@code while} instead of {@code if}. However,\n * one advantage is that we can introduce two separate {@code Condition} objects, which allows us to\n * use {@code signal()} instead of {@code signalAll()}, which may be a performance benefit.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final ReentrantLock lock = new ReentrantLock();\n *   private final Condition valuePresent = lock.newCondition();\n *   private final Condition valueAbsent = lock.newCondition();\n *\n *   public V get() throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value == null) {\n *         valuePresent.await();\n *       }\n *       V result = value;\n *       value = null;\n *       valueAbsent.signal();\n *       return result;\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value != null) {\n *         valueAbsent.await();\n *       }\n *       value = newValue;\n *       valuePresent.signal();\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code Monitor}</h3>\n *\n * <p>This version adds some verbosity around the {@code Guard} objects, but removes that same\n * verbosity, and more, from the {@code get} and {@code set} methods. {@code Monitor} implements the\n * same efficient signaling as we had to hand-code in the {@code ReentrantLock} version above.\n * Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to\n * remember to use {@code while} instead of {@code if}.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final Monitor monitor = new Monitor();\n *   private final Monitor.Guard valuePresent = monitor.newGuard(() -> value != null);\n *   private final Monitor.Guard valueAbsent = monitor.newGuard(() -> value == null);\n *\n *   public V get() throws InterruptedException {\n *     monitor.enterWhen(valuePresent);\n *     try {\n *       V result = value;\n *       value = null;\n *       return result;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     monitor.enterWhen(valueAbsent);\n *     try {\n *       value = newValue;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n * }\n * }</pre>\n *\n * @author Justin T. Sampson\n * @author Martin Buchholz\n * @since 10.0\n */\n@Beta\n@GwtIncompatible\n@SuppressWarnings(\"GuardedBy\") // TODO(b/35466881): Fix or suppress.\npublic final class Monitor\n{\n    // TODO(user): Use raw LockSupport or AbstractQueuedSynchronizer instead of ReentrantLock.\n    // TODO(user): \"Port\" jsr166 tests for ReentrantLock.\n    //\n    // TODO(user): Change API to make it impossible to use a Guard with the \"wrong\" monitor,\n    //    by making the monitor implicit, and to eliminate other sources of IMSE.\n    //    Imagine:\n    //    guard.lock();\n    //    try { /* monitor locked and guard satisfied here */ }\n    //    finally { guard.unlock(); }\n    // Here are Justin's design notes about this:\n    //\n    // This idea has come up from time to time, and I think one of my\n    // earlier versions of Monitor even did something like this. I ended\n    // up strongly favoring the current interface.\n    //\n    // I probably can't remember all the reasons (it's possible you\n    // could find them in the code review archives), but here are a few:\n    //\n    // 1. What about leaving/unlocking? Are you going to do\n    //    guard.enter() paired with monitor.leave()? That might get\n    //    confusing. It's nice for the finally block to look as close as\n    //    possible to the thing right before the try. You could have\n    //    guard.leave(), but that's a little odd as well because the\n    //    guard doesn't have anything to do with leaving. You can't\n    //    really enforce that the guard you're leaving is the same one\n    //    you entered with, and it doesn't actually matter.\n    //\n    // 2. Since you can enter the monitor without a guard at all, some\n    //    places you'll have monitor.enter()/monitor.leave() and other\n    //    places you'll have guard.enter()/guard.leave() even though\n    //    it's the same lock being acquired underneath. Always using\n    //    monitor.enterXXX()/monitor.leave() will make it really clear\n    //    which lock is held at any point in the code.\n    //\n    // 3. I think \"enterWhen(notEmpty)\" reads better than \"notEmpty.enter()\".\n    //\n    // TODO(user): Implement ReentrantLock features:\n    //    - toString() method\n    //    - getOwner() method\n    //    - getQueuedThreads() method\n    //    - getWaitingThreads(Guard) method\n    //    - implement Serializable\n    //    - redo the API to be as close to identical to ReentrantLock as possible,\n    //      since, after all, this class is also a reentrant mutual exclusion lock!?\n\n    /*\n     * One of the key challenges of this class is to prevent lost signals, while trying hard to\n     * minimize unnecessary signals. One simple and correct algorithm is to signal some other waiter\n     * with a satisfied guard (if one exists) whenever any thread occupying the monitor exits the\n     * monitor, either by unlocking all of its held locks, or by starting to wait for a guard. This\n     * includes exceptional exits, so all control paths involving signalling must be protected by a\n     * finally block.\n     *\n     * Further optimizations of this algorithm become increasingly subtle. A wait that terminates\n     * without the guard being satisfied (due to timeout, but not interrupt) can then immediately exit\n     * the monitor without signalling. If it timed out without being signalled, it does not need to\n     * \"pass on\" the signal to another thread. If it *was* signalled, then its guard must have been\n     * satisfied at the time of signal, and has since been modified by some other thread to be\n     * non-satisfied before reacquiring the lock, and that other thread takes over the responsibility\n     * of signaling the next waiter.\n     *\n     * Unlike the underlying Condition, if we are not careful, an interrupt *can* cause a signal to be\n     * lost, because the signal may be sent to a condition whose sole waiter has just been\n     * interrupted.\n     *\n     * Imagine a monitor with multiple guards. A thread enters the monitor, satisfies all the guards,\n     * and leaves, calling signalNextWaiter. With traditional locks and conditions, all the conditions\n     * need to be signalled because it is not known which if any of them have waiters (and hasWaiters\n     * can't be used reliably because of a check-then-act race). With our Monitor guards, we only\n     * signal the first active guard that is satisfied. But the corresponding thread may have already\n     * been interrupted and is waiting to reacquire the lock while still registered in activeGuards,\n     * in which case the signal is a no-op, and the bigger-picture signal is lost unless interrupted\n     * threads take special action by participating in the signal-passing game.\n     */\n\n    /*\n     * Timeout handling is intricate, especially given our ambitious goals:\n     * - Avoid underflow and overflow of timeout values when specified timeouts are close to\n     *   Long.MIN_VALUE or Long.MAX_VALUE.\n     * - Favor responding to interrupts over timeouts.\n     * - System.nanoTime() is expensive enough that we want to call it the minimum required number of\n     *   times, typically once before invoking a blocking method. This often requires keeping track of\n     *   the first time in a method that nanoTime() has been invoked, for which the special value 0L\n     *   is reserved to mean \"uninitialized\". If timeout is non-positive, then nanoTime need never be\n     *   called.\n     * - Keep behavior of fair and non-fair instances consistent.\n     */\n\n    /**\n     * A boolean condition for which a thread may wait. A {@code Guard} is associated with a single\n     * {@code Monitor}. The monitor may check the guard at arbitrary times from any thread occupying\n     * the monitor, so code should not be written to rely on how often a guard might or might not be\n     * checked.\n     *\n     * <p>If a {@code Guard} is passed into any method of a {@code Monitor} other than the one it is\n     * associated with, an {@link IllegalMonitorStateException} is thrown.\n     *\n     * @since 10.0\n     */\n    @Beta\n    public abstract static class Guard\n    {\n\n        @Weak final Monitor monitor;\n        final Condition condition;\n\n        @GuardedBy(\"monitor.lock\")\n        int waiterCount = 0;\n\n        /** The next active guard */\n        @GuardedBy(\"monitor.lock\")\n        @NullableDecl\n        Guard next;\n\n        protected Guard(Monitor monitor)\n        {\n            this.monitor = checkNotNull(monitor, \"monitor\");\n            this.condition = monitor.lock.newCondition();\n        }\n\n        /**\n         * Evaluates this guard's boolean condition. This method is always called with the associated\n         * monitor already occupied. Implementations of this method must depend only on state protected\n         * by the associated monitor, and must not modify that state.\n         */\n        public abstract boolean isSatisfied();\n    }\n\n    /** Whether this monitor is fair. */\n    private final boolean fair;\n\n    /** The lock underlying this monitor. */\n    private final ReentrantLock lock;\n\n    /**\n     * The guards associated with this monitor that currently have waiters ({@code waiterCount > 0}).\n     * A linked list threaded through the Guard.next field.\n     */\n    @GuardedBy(\"lock\")\n    private Guard activeGuards = null;\n\n    /**\n     * Creates a monitor with a non-fair (but fast) ordering policy. Equivalent to {@code\n     * Monitor(false)}.\n     */\n    public Monitor()\n    {\n        this(false);\n    }\n\n    /**\n     * Creates a monitor with the given ordering policy.\n     *\n     * @param fair whether this monitor should use a fair ordering policy rather than a non-fair (but\n     *     fast) one\n     */\n    public Monitor(boolean fair)\n    {\n        this.fair = fair;\n        this.lock = new ReentrantLock(fair);\n    }\n\n    /** Enters this monitor. Blocks indefinitely. */\n    public void enter()\n    {\n        lock.lock();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time.\n     *\n     * @return whether the monitor was entered\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enter(long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        final ReentrantLock lock = this.lock;\n        if (!fair && lock.tryLock())\n        {\n            return true;\n        }\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            final long startTime = System.nanoTime();\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterInterruptibly() throws InterruptedException\n    {\n        lock.lockInterruptibly();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time, and may be interrupted.\n     *\n     * @return whether the monitor was entered\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n    {\n        return lock.tryLock(time, unit);\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately. Does not block.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered\n     */\n    public boolean tryEnter()\n    {\n        return lock.tryLock();\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterWhen(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                await(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied, and may be\n     * interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean reentrant = lock.isHeldByCurrentThread();\n        long startTime = 0L;\n\n        locked:\n        {\n            if (!fair)\n            {\n                // Check interrupt status to get behavior consistent with fair case.\n                if (Thread.interrupted())\n                {\n                    throw new InterruptedException();\n                }\n                if (lock.tryLock())\n                {\n                    break locked;\n                }\n            }\n            startTime = initNanoTime(timeoutNanos);\n            if (!lock.tryLock(time, unit))\n            {\n                return false;\n            }\n        }\n\n        boolean satisfied = false;\n        boolean threw = true;\n        try\n        {\n            satisfied =\n                guard.isSatisfied()\n                || awaitNanos(\n                    guard,\n                    (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),\n                    reentrant);\n            threw = false;\n            return satisfied;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                try\n                {\n                    // Don't need to signal if timed out, but do if interrupted\n                    if (threw && !reentrant)\n                    {\n                        signalNextWaiter();\n                    }\n                }\n                finally\n                {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n\n    /** Enters this monitor when the guard is satisfied. Blocks indefinitely. */\n    public void enterWhenUninterruptibly(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                awaitUninterruptibly(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        long startTime = 0L;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            if (fair || !lock.tryLock())\n            {\n                startTime = initNanoTime(timeoutNanos);\n                for (long remainingNanos = timeoutNanos; ; )\n                {\n                    try\n                    {\n                        if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS))\n                        {\n                            break;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        remainingNanos = remainingNanos(startTime, timeoutNanos);\n                    }\n                }\n            }\n\n            boolean satisfied = false;\n            try\n            {\n                while (true)\n                {\n                    try\n                    {\n                        if (guard.isSatisfied())\n                        {\n                            satisfied = true;\n                        }\n                        else\n                        {\n                            final long remainingNanos;\n                            if (startTime == 0L)\n                            {\n                                startTime = initNanoTime(timeoutNanos);\n                                remainingNanos = timeoutNanos;\n                            }\n                            else\n                            {\n                                remainingNanos = remainingNanos(startTime, timeoutNanos);\n                            }\n                            satisfied = awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                        }\n                        return satisfied;\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        signalBeforeWaiting = false;\n                    }\n                }\n            }\n            finally\n            {\n                if (!satisfied)\n                {\n                    lock.unlock(); // No need to signal if timed out\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean enterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!enter(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n    throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not\n     * block acquiring the lock and does not wait for the guard to be satisfied.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean tryEnterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock())\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be called\n     * only by a thread currently occupying this monitor.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void waitFor(Guard guard) throws InterruptedException\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            await(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted. May\n     * be called only by a thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        if (Thread.interrupted())\n        {\n            throw new InterruptedException();\n        }\n        return awaitNanos(guard, timeoutNanos, true);\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread\n     * currently occupying this monitor.\n     */\n    public void waitForUninterruptibly(Guard guard)\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            awaitUninterruptibly(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time. May be called only by a\n     * thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        boolean signalBeforeWaiting = true;\n        final long startTime = initNanoTime(timeoutNanos);\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    if (guard.isSatisfied())\n                    {\n                        return true;\n                    }\n                    signalBeforeWaiting = false;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /** Leaves this monitor. May be called only by a thread currently occupying this monitor. */\n    public void leave()\n    {\n        final ReentrantLock lock = this.lock;\n        try\n        {\n            // No need to signal if we will still be holding the lock when we return\n            if (lock.getHoldCount() == 1)\n            {\n                signalNextWaiter();\n            }\n        }\n        finally\n        {\n            lock.unlock(); // Will throw IllegalMonitorStateException if not held\n        }\n    }\n\n    /** Returns whether this monitor is using a fair ordering policy. */\n    public boolean isFair()\n    {\n        return fair;\n    }\n\n    /**\n     * Returns whether this monitor is occupied by any thread. This method is designed for use in\n     * monitoring of the system state, not for synchronization control.\n     */\n    public boolean isOccupied()\n    {\n        return lock.isLocked();\n    }\n\n    /**\n     * Returns whether the current thread is occupying this monitor (has entered more times than it\n     * has left).\n     */\n    public boolean isOccupiedByCurrentThread()\n    {\n        return lock.isHeldByCurrentThread();\n    }\n\n    /**\n     * Returns the number of times the current thread has entered this monitor in excess of the number\n     * of times it has left. Returns 0 if the current thread is not occupying this monitor.\n     */\n    public int getOccupiedDepth()\n    {\n        return lock.getHoldCount();\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting to enter this monitor. The value is only\n     * an estimate because the number of threads may change dynamically while this method traverses\n     * internal data structures. This method is designed for use in monitoring of the system state,\n     * not for synchronization control.\n     */\n    public int getQueueLength()\n    {\n        return lock.getQueueLength();\n    }\n\n    /**\n     * Returns whether any threads are waiting to enter this monitor. Note that because cancellations\n     * may occur at any time, a {@code true} return does not guarantee that any other thread will ever\n     * enter this monitor. This method is designed primarily for use in monitoring of the system\n     * state.\n     */\n    public boolean hasQueuedThreads()\n    {\n        return lock.hasQueuedThreads();\n    }\n\n    /**\n     * Queries whether the given thread is waiting to enter this monitor. Note that because\n     * cancellations may occur at any time, a {@code true} return does not guarantee that this thread\n     * will ever enter this monitor. This method is designed primarily for use in monitoring of the\n     * system state.\n     */\n    public boolean hasQueuedThread(Thread thread)\n    {\n        return lock.hasQueuedThread(thread);\n    }\n\n    /**\n     * Queries whether any threads are waiting for the given guard to become satisfied. Note that\n     * because timeouts and interrupts may occur at any time, a {@code true} return does not guarantee\n     * that the guard becoming satisfied in the future will awaken any threads. This method is\n     * designed primarily for use in monitoring of the system state.\n     */\n    public boolean hasWaiters(Guard guard)\n    {\n        return getWaitQueueLength(guard) > 0;\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting for the given guard to become satisfied.\n     * Note that because timeouts and interrupts may occur at any time, the estimate serves only as an\n     * upper bound on the actual number of waiters. This method is designed for use in monitoring of\n     * the system state, not for synchronization control.\n     */\n    public int getWaitQueueLength(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        lock.lock();\n        try\n        {\n            return guard.waiterCount;\n        }\n        finally\n        {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Returns unit.toNanos(time), additionally ensuring the returned value is not at risk of\n     * overflowing or underflowing, by bounding the value between 0 and (Long.MAX_VALUE / 4) * 3.\n     * Actually waiting for more than 219 years is not supported!\n     */\n    private static long toSafeNanos(long time, TimeUnit unit)\n    {\n        long timeoutNanos = unit.toNanos(time);\n        return (timeoutNanos <= 0L)\n               ? 0L\n               : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3 : timeoutNanos;\n    }\n\n    /**\n     * Returns System.nanoTime() unless the timeout has already elapsed. Returns 0L if and only if the\n     * timeout has already elapsed.\n     */\n    private static long initNanoTime(long timeoutNanos)\n    {\n        if (timeoutNanos <= 0L)\n        {\n            return 0L;\n        }\n        else\n        {\n            long startTime = System.nanoTime();\n            return (startTime == 0L) ? 1L : startTime;\n        }\n    }\n\n    /**\n     * Returns the remaining nanos until the given timeout, or 0L if the timeout has already elapsed.\n     * Caller must have previously sanitized timeoutNanos using toSafeNanos.\n     */\n    private static long remainingNanos(long startTime, long timeoutNanos)\n    {\n        // assert timeoutNanos == 0L || startTime != 0L;\n\n        // TODO : NOT CORRECT, BUT TESTS PASS ANYWAYS!\n        // if (true) return timeoutNanos;\n        // ONLY 2 TESTS FAIL IF WE DO:\n        // if (true) return 0;\n\n        return (timeoutNanos <= 0L) ? 0L : timeoutNanos - (System.nanoTime() - startTime);\n    }\n\n    /**\n     * Signals some other thread waiting on a satisfied guard, if one exists.\n     *\n     * <p>We manage calls to this method carefully, to signal only when necessary, but never losing a\n     * signal, which is the classic problem of this kind of concurrency construct. We must signal if\n     * the current thread is about to relinquish the lock and may have changed the state protected by\n     * the monitor, thereby causing some guard to be satisfied.\n     *\n     * <p>In addition, any thread that has been signalled when its guard was satisfied acquires the\n     * responsibility of signalling the next thread when it again relinquishes the lock. Unlike a\n     * normal Condition, there is no guarantee that an interrupted thread has not been signalled,\n     * since the concurrency control must manage multiple Conditions. So this method must generally be\n     * called when waits are interrupted.\n     *\n     * <p>On the other hand, if a signalled thread wakes up to discover that its guard is still not\n     * satisfied, it does *not* need to call this method before returning to wait. This can only\n     * happen due to spurious wakeup (ignorable) or another thread acquiring the lock before the\n     * current thread can and returning the guard to the unsatisfied state. In the latter case the\n     * other thread (last thread modifying the state protected by the monitor) takes over the\n     * responsibility of signalling the next waiter.\n     *\n     * <p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else\n     * the current thread's guard might be mistakenly signalled, leading to a lost signal.\n     */\n    @GuardedBy(\"lock\")\n    private void signalNextWaiter()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            if (isSatisfied(guard))\n            {\n                guard.condition.signal();\n                break;\n            }\n        }\n    }\n\n    /**\n     * Exactly like signalNextWaiter, but caller guarantees that guardToSkip need not be considered,\n     * because caller has previously checked that guardToSkip.isSatisfied() returned false. An\n     * optimization for the case that guardToSkip.isSatisfied() may be expensive.\n     *\n     * <p>We decided against using this method, since in practice, isSatisfied() is likely to be very\n     * cheap (typically one field read). Resurrect this method if you find that not to be true.\n     */\n    //   @GuardedBy(\"lock\")\n    //   private void signalNextWaiterSkipping(Guard guardToSkip) {\n    //     for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n    //       if (guard != guardToSkip && isSatisfied(guard)) {\n    //         guard.condition.signal();\n    //         break;\n    //       }\n    //     }\n    //   }\n\n    /**\n     * Exactly like guard.isSatisfied(), but in addition signals all waiting threads in the (hopefully\n     * unlikely) event that isSatisfied() throws.\n     */\n    @GuardedBy(\"lock\")\n    private boolean isSatisfied(Guard guard)\n    {\n        try\n        {\n            return guard.isSatisfied();\n        }\n        catch (Throwable throwable)\n        {\n            signalAllWaiters();\n            throw throwable;\n        }\n    }\n\n    /** Signals all threads waiting on guards. */\n    @GuardedBy(\"lock\")\n    private void signalAllWaiters()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            guard.condition.signalAll();\n        }\n    }\n\n    /** Records that the current thread is about to wait on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void beginWaitingFor(Guard guard)\n    {\n        int waiters = guard.waiterCount++;\n        if (waiters == 0)\n        {\n            // push guard onto activeGuards\n            guard.next = activeGuards;\n            activeGuards = guard;\n        }\n    }\n\n    /** Records that the current thread is no longer waiting on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void endWaitingFor(Guard guard)\n    {\n        int waiters = --guard.waiterCount;\n        if (waiters == 0)\n        {\n            // unlink guard from activeGuards\n            for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next)\n            {\n                if (p == guard)\n                {\n                    if (pred == null)\n                    {\n                        activeGuards = p.next;\n                    }\n                    else\n                    {\n                        pred.next = p.next;\n                    }\n                    p.next = null; // help GC\n                    break;\n                }\n            }\n        }\n    }\n\n    /*\n     * Methods that loop waiting on a guard's condition until the guard is satisfied, while recording\n     * this fact so that other threads know to check our guard and signal us. It's caller's\n     * responsibility to ensure that the guard is *not* currently satisfied.\n     */\n\n    @GuardedBy(\"lock\")\n    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.await();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    @GuardedBy(\"lock\")\n    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.awaitUninterruptibly();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    /** Caller should check before calling that guard is not satisfied. */\n    @GuardedBy(\"lock\")\n    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n    throws InterruptedException\n    {\n        boolean firstTime = true;\n        try\n        {\n            do\n            {\n                if (nanos <= 0L)\n                {\n                    return false;\n                }\n                if (firstTime)\n                {\n                    if (signalBeforeWaiting)\n                    {\n                        signalNextWaiter();\n                    }\n                    beginWaitingFor(guard);\n                    firstTime = false;\n                }\n                nanos = guard.condition.awaitNanos(nanos);\n            }\n            while (!guard.isSatisfied());\n            return true;\n        }\n        finally\n        {\n            if (!firstTime)\n            {\n                endWaitingFor(guard);\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.tryEnterIf", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not\nblock acquiring the lock and does not wait for the guard to be satisfied.\n\n<p><b>Note:</b> This method disregards the fairness setting of this monitor.\n\n@return whether the monitor was entered, which guarantees that the guard is now satisfied", "docstring_tokens": ["Enters", "this", "monitor", "if", "it", "is", "possible", "to", "do", "so", "immediately", "and", "the", "guard", "is", "satisfied", ".", "Does", "not", "block", "acquiring", "the", "lock", "and", "does", "not", "wait", "for", "the", "guard", "to", "be", "satisfied", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L709-L726", "partition": "valid", "up_fun_num": 15, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.errorprone.annotations.concurrent.GuardedBy;", "import com.google.j2objc.annotations.Weak;", "import java.util.concurrent.TimeUnit;", "import java.util.concurrent.locks.Condition;", "import java.util.concurrent.locks.ReentrantLock;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Monitor\n", "    public void enter()\n", "    public boolean enter(long time, TimeUnit unit)\n", "    public void enterInterruptibly() throws InterruptedException\n", "    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n", "    public boolean tryEnter()\n", "    public void enterWhen(Guard guard) throws InterruptedException\n", "    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void enterWhenUninterruptibly(Guard guard)\n", "    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIf(Guard guard)\n", "    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n", "    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public void waitFor(Guard guard) throws InterruptedException\n", "    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void waitForUninterruptibly(Guard guard)\n", "    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public void leave()\n", "    public boolean isFair()\n", "    public boolean isOccupied()\n", "    public boolean isOccupiedByCurrentThread()\n", "    public int getOccupiedDepth()\n", "    public int getQueueLength()\n", "    public boolean hasQueuedThreads()\n", "    public boolean hasQueuedThread(Thread thread)\n", "    public boolean hasWaiters(Guard guard)\n", "    public int getWaitQueueLength(Guard guard)\n", "    private static long toSafeNanos(long time, TimeUnit unit)\n", "    private static long initNanoTime(long timeoutNanos)\n", "    private static long remainingNanos(long startTime, long timeoutNanos)\n", "    private void signalNextWaiter()\n", "    private boolean isSatisfied(Guard guard)\n", "    private void signalAllWaiters()\n", "    private void beginWaitingFor(Guard guard)\n", "    private void endWaitingFor(Guard guard)\n", "    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n", "    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n", "    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n"], "context": "/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.concurrent.GuardedBy;\nimport com.google.j2objc.annotations.Weak;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A synchronization abstraction supporting waiting on arbitrary boolean conditions.\n *\n * <p>This class is intended as a replacement for {@link ReentrantLock}. Code using {@code Monitor}\n * is less error-prone and more readable than code using {@code ReentrantLock}, without significant\n * performance loss. {@code Monitor} even has the potential for performance gain by optimizing the\n * evaluation and signaling of conditions. Signaling is entirely <a\n * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>. By\n * eliminating explicit signaling, this class can guarantee that only one thread is awakened when a\n * condition becomes true (no \"signaling storms\" due to use of {@link\n * java.util.concurrent.locks.Condition#signalAll Condition.signalAll}) and that no signals are lost\n * (no \"hangs\" due to incorrect use of {@link java.util.concurrent.locks.Condition#signal\n * Condition.signal}).\n *\n * <p>A thread is said to <i>occupy</i> a monitor if it has <i>entered</i> the monitor but not yet\n * <i>left</i>. Only one thread may occupy a given monitor at any moment. A monitor is also\n * reentrant, so a thread may enter a monitor any number of times, and then must leave the same\n * number of times. The <i>enter</i> and <i>leave</i> operations have the same synchronization\n * semantics as the built-in Java language synchronization primitives.\n *\n * <p>A call to any of the <i>enter</i> methods with <b>void</b> return type should always be\n * followed immediately by a <i>try/finally</i> block to ensure that the current thread leaves the\n * monitor cleanly:\n *\n * <pre>{@code\n * monitor.enter();\n * try {\n *   // do things while occupying the monitor\n * } finally {\n *   monitor.leave();\n * }\n * }</pre>\n *\n * <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear\n * as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that\n * the current thread leaves the monitor cleanly:\n *\n * <pre>{@code\n * if (monitor.tryEnter()) {\n *   try {\n *     // do things while occupying the monitor\n *   } finally {\n *     monitor.leave();\n *   }\n * } else {\n *   // do other things since the monitor was not available\n * }\n * }</pre>\n *\n * <h2>Comparison with {@code synchronized} and {@code ReentrantLock}</h2>\n *\n * <p>The following examples show a simple threadsafe holder expressed using {@code synchronized},\n * {@link ReentrantLock}, and {@code Monitor}.\n *\n * <h3>{@code synchronized}</h3>\n *\n * <p>This version is the fewest lines of code, largely because the synchronization mechanism used\n * is built into the language and runtime. But the programmer has to remember to avoid a couple of\n * common bugs: The {@code wait()} must be inside a {@code while} instead of an {@code if}, and\n * {@code notifyAll()} must be used instead of {@code notify()} because there are two different\n * logical conditions being awaited.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *\n *   public synchronized V get() throws InterruptedException {\n *     while (value == null) {\n *       wait();\n *     }\n *     V result = value;\n *     value = null;\n *     notifyAll();\n *     return result;\n *   }\n *\n *   public synchronized void set(V newValue) throws InterruptedException {\n *     while (value != null) {\n *       wait();\n *     }\n *     value = newValue;\n *     notifyAll();\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code ReentrantLock}</h3>\n *\n * <p>This version is much more verbose than the {@code synchronized} version, and still suffers\n * from the need for the programmer to remember to use {@code while} instead of {@code if}. However,\n * one advantage is that we can introduce two separate {@code Condition} objects, which allows us to\n * use {@code signal()} instead of {@code signalAll()}, which may be a performance benefit.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final ReentrantLock lock = new ReentrantLock();\n *   private final Condition valuePresent = lock.newCondition();\n *   private final Condition valueAbsent = lock.newCondition();\n *\n *   public V get() throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value == null) {\n *         valuePresent.await();\n *       }\n *       V result = value;\n *       value = null;\n *       valueAbsent.signal();\n *       return result;\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value != null) {\n *         valueAbsent.await();\n *       }\n *       value = newValue;\n *       valuePresent.signal();\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code Monitor}</h3>\n *\n * <p>This version adds some verbosity around the {@code Guard} objects, but removes that same\n * verbosity, and more, from the {@code get} and {@code set} methods. {@code Monitor} implements the\n * same efficient signaling as we had to hand-code in the {@code ReentrantLock} version above.\n * Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to\n * remember to use {@code while} instead of {@code if}.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final Monitor monitor = new Monitor();\n *   private final Monitor.Guard valuePresent = monitor.newGuard(() -> value != null);\n *   private final Monitor.Guard valueAbsent = monitor.newGuard(() -> value == null);\n *\n *   public V get() throws InterruptedException {\n *     monitor.enterWhen(valuePresent);\n *     try {\n *       V result = value;\n *       value = null;\n *       return result;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     monitor.enterWhen(valueAbsent);\n *     try {\n *       value = newValue;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n * }\n * }</pre>\n *\n * @author Justin T. Sampson\n * @author Martin Buchholz\n * @since 10.0\n */\n@Beta\n@GwtIncompatible\n@SuppressWarnings(\"GuardedBy\") // TODO(b/35466881): Fix or suppress.\npublic final class Monitor\n{\n    // TODO(user): Use raw LockSupport or AbstractQueuedSynchronizer instead of ReentrantLock.\n    // TODO(user): \"Port\" jsr166 tests for ReentrantLock.\n    //\n    // TODO(user): Change API to make it impossible to use a Guard with the \"wrong\" monitor,\n    //    by making the monitor implicit, and to eliminate other sources of IMSE.\n    //    Imagine:\n    //    guard.lock();\n    //    try { /* monitor locked and guard satisfied here */ }\n    //    finally { guard.unlock(); }\n    // Here are Justin's design notes about this:\n    //\n    // This idea has come up from time to time, and I think one of my\n    // earlier versions of Monitor even did something like this. I ended\n    // up strongly favoring the current interface.\n    //\n    // I probably can't remember all the reasons (it's possible you\n    // could find them in the code review archives), but here are a few:\n    //\n    // 1. What about leaving/unlocking? Are you going to do\n    //    guard.enter() paired with monitor.leave()? That might get\n    //    confusing. It's nice for the finally block to look as close as\n    //    possible to the thing right before the try. You could have\n    //    guard.leave(), but that's a little odd as well because the\n    //    guard doesn't have anything to do with leaving. You can't\n    //    really enforce that the guard you're leaving is the same one\n    //    you entered with, and it doesn't actually matter.\n    //\n    // 2. Since you can enter the monitor without a guard at all, some\n    //    places you'll have monitor.enter()/monitor.leave() and other\n    //    places you'll have guard.enter()/guard.leave() even though\n    //    it's the same lock being acquired underneath. Always using\n    //    monitor.enterXXX()/monitor.leave() will make it really clear\n    //    which lock is held at any point in the code.\n    //\n    // 3. I think \"enterWhen(notEmpty)\" reads better than \"notEmpty.enter()\".\n    //\n    // TODO(user): Implement ReentrantLock features:\n    //    - toString() method\n    //    - getOwner() method\n    //    - getQueuedThreads() method\n    //    - getWaitingThreads(Guard) method\n    //    - implement Serializable\n    //    - redo the API to be as close to identical to ReentrantLock as possible,\n    //      since, after all, this class is also a reentrant mutual exclusion lock!?\n\n    /*\n     * One of the key challenges of this class is to prevent lost signals, while trying hard to\n     * minimize unnecessary signals. One simple and correct algorithm is to signal some other waiter\n     * with a satisfied guard (if one exists) whenever any thread occupying the monitor exits the\n     * monitor, either by unlocking all of its held locks, or by starting to wait for a guard. This\n     * includes exceptional exits, so all control paths involving signalling must be protected by a\n     * finally block.\n     *\n     * Further optimizations of this algorithm become increasingly subtle. A wait that terminates\n     * without the guard being satisfied (due to timeout, but not interrupt) can then immediately exit\n     * the monitor without signalling. If it timed out without being signalled, it does not need to\n     * \"pass on\" the signal to another thread. If it *was* signalled, then its guard must have been\n     * satisfied at the time of signal, and has since been modified by some other thread to be\n     * non-satisfied before reacquiring the lock, and that other thread takes over the responsibility\n     * of signaling the next waiter.\n     *\n     * Unlike the underlying Condition, if we are not careful, an interrupt *can* cause a signal to be\n     * lost, because the signal may be sent to a condition whose sole waiter has just been\n     * interrupted.\n     *\n     * Imagine a monitor with multiple guards. A thread enters the monitor, satisfies all the guards,\n     * and leaves, calling signalNextWaiter. With traditional locks and conditions, all the conditions\n     * need to be signalled because it is not known which if any of them have waiters (and hasWaiters\n     * can't be used reliably because of a check-then-act race). With our Monitor guards, we only\n     * signal the first active guard that is satisfied. But the corresponding thread may have already\n     * been interrupted and is waiting to reacquire the lock while still registered in activeGuards,\n     * in which case the signal is a no-op, and the bigger-picture signal is lost unless interrupted\n     * threads take special action by participating in the signal-passing game.\n     */\n\n    /*\n     * Timeout handling is intricate, especially given our ambitious goals:\n     * - Avoid underflow and overflow of timeout values when specified timeouts are close to\n     *   Long.MIN_VALUE or Long.MAX_VALUE.\n     * - Favor responding to interrupts over timeouts.\n     * - System.nanoTime() is expensive enough that we want to call it the minimum required number of\n     *   times, typically once before invoking a blocking method. This often requires keeping track of\n     *   the first time in a method that nanoTime() has been invoked, for which the special value 0L\n     *   is reserved to mean \"uninitialized\". If timeout is non-positive, then nanoTime need never be\n     *   called.\n     * - Keep behavior of fair and non-fair instances consistent.\n     */\n\n    /**\n     * A boolean condition for which a thread may wait. A {@code Guard} is associated with a single\n     * {@code Monitor}. The monitor may check the guard at arbitrary times from any thread occupying\n     * the monitor, so code should not be written to rely on how often a guard might or might not be\n     * checked.\n     *\n     * <p>If a {@code Guard} is passed into any method of a {@code Monitor} other than the one it is\n     * associated with, an {@link IllegalMonitorStateException} is thrown.\n     *\n     * @since 10.0\n     */\n    @Beta\n    public abstract static class Guard\n    {\n\n        @Weak final Monitor monitor;\n        final Condition condition;\n\n        @GuardedBy(\"monitor.lock\")\n        int waiterCount = 0;\n\n        /** The next active guard */\n        @GuardedBy(\"monitor.lock\")\n        @NullableDecl\n        Guard next;\n\n        protected Guard(Monitor monitor)\n        {\n            this.monitor = checkNotNull(monitor, \"monitor\");\n            this.condition = monitor.lock.newCondition();\n        }\n\n        /**\n         * Evaluates this guard's boolean condition. This method is always called with the associated\n         * monitor already occupied. Implementations of this method must depend only on state protected\n         * by the associated monitor, and must not modify that state.\n         */\n        public abstract boolean isSatisfied();\n    }\n\n    /** Whether this monitor is fair. */\n    private final boolean fair;\n\n    /** The lock underlying this monitor. */\n    private final ReentrantLock lock;\n\n    /**\n     * The guards associated with this monitor that currently have waiters ({@code waiterCount > 0}).\n     * A linked list threaded through the Guard.next field.\n     */\n    @GuardedBy(\"lock\")\n    private Guard activeGuards = null;\n\n    /**\n     * Creates a monitor with a non-fair (but fast) ordering policy. Equivalent to {@code\n     * Monitor(false)}.\n     */\n    public Monitor()\n    {\n        this(false);\n    }\n\n    /**\n     * Creates a monitor with the given ordering policy.\n     *\n     * @param fair whether this monitor should use a fair ordering policy rather than a non-fair (but\n     *     fast) one\n     */\n    public Monitor(boolean fair)\n    {\n        this.fair = fair;\n        this.lock = new ReentrantLock(fair);\n    }\n\n    /** Enters this monitor. Blocks indefinitely. */\n    public void enter()\n    {\n        lock.lock();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time.\n     *\n     * @return whether the monitor was entered\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enter(long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        final ReentrantLock lock = this.lock;\n        if (!fair && lock.tryLock())\n        {\n            return true;\n        }\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            final long startTime = System.nanoTime();\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterInterruptibly() throws InterruptedException\n    {\n        lock.lockInterruptibly();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time, and may be interrupted.\n     *\n     * @return whether the monitor was entered\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n    {\n        return lock.tryLock(time, unit);\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately. Does not block.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered\n     */\n    public boolean tryEnter()\n    {\n        return lock.tryLock();\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterWhen(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                await(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied, and may be\n     * interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean reentrant = lock.isHeldByCurrentThread();\n        long startTime = 0L;\n\n        locked:\n        {\n            if (!fair)\n            {\n                // Check interrupt status to get behavior consistent with fair case.\n                if (Thread.interrupted())\n                {\n                    throw new InterruptedException();\n                }\n                if (lock.tryLock())\n                {\n                    break locked;\n                }\n            }\n            startTime = initNanoTime(timeoutNanos);\n            if (!lock.tryLock(time, unit))\n            {\n                return false;\n            }\n        }\n\n        boolean satisfied = false;\n        boolean threw = true;\n        try\n        {\n            satisfied =\n                guard.isSatisfied()\n                || awaitNanos(\n                    guard,\n                    (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),\n                    reentrant);\n            threw = false;\n            return satisfied;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                try\n                {\n                    // Don't need to signal if timed out, but do if interrupted\n                    if (threw && !reentrant)\n                    {\n                        signalNextWaiter();\n                    }\n                }\n                finally\n                {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n\n    /** Enters this monitor when the guard is satisfied. Blocks indefinitely. */\n    public void enterWhenUninterruptibly(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                awaitUninterruptibly(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        long startTime = 0L;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            if (fair || !lock.tryLock())\n            {\n                startTime = initNanoTime(timeoutNanos);\n                for (long remainingNanos = timeoutNanos; ; )\n                {\n                    try\n                    {\n                        if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS))\n                        {\n                            break;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        remainingNanos = remainingNanos(startTime, timeoutNanos);\n                    }\n                }\n            }\n\n            boolean satisfied = false;\n            try\n            {\n                while (true)\n                {\n                    try\n                    {\n                        if (guard.isSatisfied())\n                        {\n                            satisfied = true;\n                        }\n                        else\n                        {\n                            final long remainingNanos;\n                            if (startTime == 0L)\n                            {\n                                startTime = initNanoTime(timeoutNanos);\n                                remainingNanos = timeoutNanos;\n                            }\n                            else\n                            {\n                                remainingNanos = remainingNanos(startTime, timeoutNanos);\n                            }\n                            satisfied = awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                        }\n                        return satisfied;\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        signalBeforeWaiting = false;\n                    }\n                }\n            }\n            finally\n            {\n                if (!satisfied)\n                {\n                    lock.unlock(); // No need to signal if timed out\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean enterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!enter(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n    throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not\n     * block acquiring the lock and does not wait for the guard to be satisfied.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be called\n     * only by a thread currently occupying this monitor.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void waitFor(Guard guard) throws InterruptedException\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            await(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted. May\n     * be called only by a thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        if (Thread.interrupted())\n        {\n            throw new InterruptedException();\n        }\n        return awaitNanos(guard, timeoutNanos, true);\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread\n     * currently occupying this monitor.\n     */\n    public void waitForUninterruptibly(Guard guard)\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            awaitUninterruptibly(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time. May be called only by a\n     * thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        boolean signalBeforeWaiting = true;\n        final long startTime = initNanoTime(timeoutNanos);\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    if (guard.isSatisfied())\n                    {\n                        return true;\n                    }\n                    signalBeforeWaiting = false;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /** Leaves this monitor. May be called only by a thread currently occupying this monitor. */\n    public void leave()\n    {\n        final ReentrantLock lock = this.lock;\n        try\n        {\n            // No need to signal if we will still be holding the lock when we return\n            if (lock.getHoldCount() == 1)\n            {\n                signalNextWaiter();\n            }\n        }\n        finally\n        {\n            lock.unlock(); // Will throw IllegalMonitorStateException if not held\n        }\n    }\n\n    /** Returns whether this monitor is using a fair ordering policy. */\n    public boolean isFair()\n    {\n        return fair;\n    }\n\n    /**\n     * Returns whether this monitor is occupied by any thread. This method is designed for use in\n     * monitoring of the system state, not for synchronization control.\n     */\n    public boolean isOccupied()\n    {\n        return lock.isLocked();\n    }\n\n    /**\n     * Returns whether the current thread is occupying this monitor (has entered more times than it\n     * has left).\n     */\n    public boolean isOccupiedByCurrentThread()\n    {\n        return lock.isHeldByCurrentThread();\n    }\n\n    /**\n     * Returns the number of times the current thread has entered this monitor in excess of the number\n     * of times it has left. Returns 0 if the current thread is not occupying this monitor.\n     */\n    public int getOccupiedDepth()\n    {\n        return lock.getHoldCount();\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting to enter this monitor. The value is only\n     * an estimate because the number of threads may change dynamically while this method traverses\n     * internal data structures. This method is designed for use in monitoring of the system state,\n     * not for synchronization control.\n     */\n    public int getQueueLength()\n    {\n        return lock.getQueueLength();\n    }\n\n    /**\n     * Returns whether any threads are waiting to enter this monitor. Note that because cancellations\n     * may occur at any time, a {@code true} return does not guarantee that any other thread will ever\n     * enter this monitor. This method is designed primarily for use in monitoring of the system\n     * state.\n     */\n    public boolean hasQueuedThreads()\n    {\n        return lock.hasQueuedThreads();\n    }\n\n    /**\n     * Queries whether the given thread is waiting to enter this monitor. Note that because\n     * cancellations may occur at any time, a {@code true} return does not guarantee that this thread\n     * will ever enter this monitor. This method is designed primarily for use in monitoring of the\n     * system state.\n     */\n    public boolean hasQueuedThread(Thread thread)\n    {\n        return lock.hasQueuedThread(thread);\n    }\n\n    /**\n     * Queries whether any threads are waiting for the given guard to become satisfied. Note that\n     * because timeouts and interrupts may occur at any time, a {@code true} return does not guarantee\n     * that the guard becoming satisfied in the future will awaken any threads. This method is\n     * designed primarily for use in monitoring of the system state.\n     */\n    public boolean hasWaiters(Guard guard)\n    {\n        return getWaitQueueLength(guard) > 0;\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting for the given guard to become satisfied.\n     * Note that because timeouts and interrupts may occur at any time, the estimate serves only as an\n     * upper bound on the actual number of waiters. This method is designed for use in monitoring of\n     * the system state, not for synchronization control.\n     */\n    public int getWaitQueueLength(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        lock.lock();\n        try\n        {\n            return guard.waiterCount;\n        }\n        finally\n        {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Returns unit.toNanos(time), additionally ensuring the returned value is not at risk of\n     * overflowing or underflowing, by bounding the value between 0 and (Long.MAX_VALUE / 4) * 3.\n     * Actually waiting for more than 219 years is not supported!\n     */\n    private static long toSafeNanos(long time, TimeUnit unit)\n    {\n        long timeoutNanos = unit.toNanos(time);\n        return (timeoutNanos <= 0L)\n               ? 0L\n               : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3 : timeoutNanos;\n    }\n\n    /**\n     * Returns System.nanoTime() unless the timeout has already elapsed. Returns 0L if and only if the\n     * timeout has already elapsed.\n     */\n    private static long initNanoTime(long timeoutNanos)\n    {\n        if (timeoutNanos <= 0L)\n        {\n            return 0L;\n        }\n        else\n        {\n            long startTime = System.nanoTime();\n            return (startTime == 0L) ? 1L : startTime;\n        }\n    }\n\n    /**\n     * Returns the remaining nanos until the given timeout, or 0L if the timeout has already elapsed.\n     * Caller must have previously sanitized timeoutNanos using toSafeNanos.\n     */\n    private static long remainingNanos(long startTime, long timeoutNanos)\n    {\n        // assert timeoutNanos == 0L || startTime != 0L;\n\n        // TODO : NOT CORRECT, BUT TESTS PASS ANYWAYS!\n        // if (true) return timeoutNanos;\n        // ONLY 2 TESTS FAIL IF WE DO:\n        // if (true) return 0;\n\n        return (timeoutNanos <= 0L) ? 0L : timeoutNanos - (System.nanoTime() - startTime);\n    }\n\n    /**\n     * Signals some other thread waiting on a satisfied guard, if one exists.\n     *\n     * <p>We manage calls to this method carefully, to signal only when necessary, but never losing a\n     * signal, which is the classic problem of this kind of concurrency construct. We must signal if\n     * the current thread is about to relinquish the lock and may have changed the state protected by\n     * the monitor, thereby causing some guard to be satisfied.\n     *\n     * <p>In addition, any thread that has been signalled when its guard was satisfied acquires the\n     * responsibility of signalling the next thread when it again relinquishes the lock. Unlike a\n     * normal Condition, there is no guarantee that an interrupted thread has not been signalled,\n     * since the concurrency control must manage multiple Conditions. So this method must generally be\n     * called when waits are interrupted.\n     *\n     * <p>On the other hand, if a signalled thread wakes up to discover that its guard is still not\n     * satisfied, it does *not* need to call this method before returning to wait. This can only\n     * happen due to spurious wakeup (ignorable) or another thread acquiring the lock before the\n     * current thread can and returning the guard to the unsatisfied state. In the latter case the\n     * other thread (last thread modifying the state protected by the monitor) takes over the\n     * responsibility of signalling the next waiter.\n     *\n     * <p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else\n     * the current thread's guard might be mistakenly signalled, leading to a lost signal.\n     */\n    @GuardedBy(\"lock\")\n    private void signalNextWaiter()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            if (isSatisfied(guard))\n            {\n                guard.condition.signal();\n                break;\n            }\n        }\n    }\n\n    /**\n     * Exactly like signalNextWaiter, but caller guarantees that guardToSkip need not be considered,\n     * because caller has previously checked that guardToSkip.isSatisfied() returned false. An\n     * optimization for the case that guardToSkip.isSatisfied() may be expensive.\n     *\n     * <p>We decided against using this method, since in practice, isSatisfied() is likely to be very\n     * cheap (typically one field read). Resurrect this method if you find that not to be true.\n     */\n    //   @GuardedBy(\"lock\")\n    //   private void signalNextWaiterSkipping(Guard guardToSkip) {\n    //     for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n    //       if (guard != guardToSkip && isSatisfied(guard)) {\n    //         guard.condition.signal();\n    //         break;\n    //       }\n    //     }\n    //   }\n\n    /**\n     * Exactly like guard.isSatisfied(), but in addition signals all waiting threads in the (hopefully\n     * unlikely) event that isSatisfied() throws.\n     */\n    @GuardedBy(\"lock\")\n    private boolean isSatisfied(Guard guard)\n    {\n        try\n        {\n            return guard.isSatisfied();\n        }\n        catch (Throwable throwable)\n        {\n            signalAllWaiters();\n            throw throwable;\n        }\n    }\n\n    /** Signals all threads waiting on guards. */\n    @GuardedBy(\"lock\")\n    private void signalAllWaiters()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            guard.condition.signalAll();\n        }\n    }\n\n    /** Records that the current thread is about to wait on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void beginWaitingFor(Guard guard)\n    {\n        int waiters = guard.waiterCount++;\n        if (waiters == 0)\n        {\n            // push guard onto activeGuards\n            guard.next = activeGuards;\n            activeGuards = guard;\n        }\n    }\n\n    /** Records that the current thread is no longer waiting on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void endWaitingFor(Guard guard)\n    {\n        int waiters = --guard.waiterCount;\n        if (waiters == 0)\n        {\n            // unlink guard from activeGuards\n            for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next)\n            {\n                if (p == guard)\n                {\n                    if (pred == null)\n                    {\n                        activeGuards = p.next;\n                    }\n                    else\n                    {\n                        pred.next = p.next;\n                    }\n                    p.next = null; // help GC\n                    break;\n                }\n            }\n        }\n    }\n\n    /*\n     * Methods that loop waiting on a guard's condition until the guard is satisfied, while recording\n     * this fact so that other threads know to check our guard and signal us. It's caller's\n     * responsibility to ensure that the guard is *not* currently satisfied.\n     */\n\n    @GuardedBy(\"lock\")\n    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.await();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    @GuardedBy(\"lock\")\n    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.awaitUninterruptibly();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    /** Caller should check before calling that guard is not satisfied. */\n    @GuardedBy(\"lock\")\n    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n    throws InterruptedException\n    {\n        boolean firstTime = true;\n        try\n        {\n            do\n            {\n                if (nanos <= 0L)\n                {\n                    return false;\n                }\n                if (firstTime)\n                {\n                    if (signalBeforeWaiting)\n                    {\n                        signalNextWaiter();\n                    }\n                    beginWaitingFor(guard);\n                    firstTime = false;\n                }\n                nanos = guard.condition.awaitNanos(nanos);\n            }\n            while (!guard.isSatisfied());\n            return true;\n        }\n        finally\n        {\n            if (!firstTime)\n            {\n                endWaitingFor(guard);\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.waitFor", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be called\nonly by a thread currently occupying this monitor.\n\n@throws InterruptedException if interrupted while waiting", "docstring_tokens": ["Waits", "for", "the", "guard", "to", "be", "satisfied", ".", "Waits", "indefinitely", "but", "may", "be", "interrupted", ".", "May", "be", "called", "only", "by", "a", "thread", "currently", "occupying", "this", "monitor", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L734-L741", "partition": "valid", "up_fun_num": 16, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.errorprone.annotations.concurrent.GuardedBy;", "import com.google.j2objc.annotations.Weak;", "import java.util.concurrent.TimeUnit;", "import java.util.concurrent.locks.Condition;", "import java.util.concurrent.locks.ReentrantLock;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Monitor\n", "    public void enter()\n", "    public boolean enter(long time, TimeUnit unit)\n", "    public void enterInterruptibly() throws InterruptedException\n", "    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n", "    public boolean tryEnter()\n", "    public void enterWhen(Guard guard) throws InterruptedException\n", "    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void enterWhenUninterruptibly(Guard guard)\n", "    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIf(Guard guard)\n", "    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n", "    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean tryEnterIf(Guard guard)\n", "    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void waitForUninterruptibly(Guard guard)\n", "    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public void leave()\n", "    public boolean isFair()\n", "    public boolean isOccupied()\n", "    public boolean isOccupiedByCurrentThread()\n", "    public int getOccupiedDepth()\n", "    public int getQueueLength()\n", "    public boolean hasQueuedThreads()\n", "    public boolean hasQueuedThread(Thread thread)\n", "    public boolean hasWaiters(Guard guard)\n", "    public int getWaitQueueLength(Guard guard)\n", "    private static long toSafeNanos(long time, TimeUnit unit)\n", "    private static long initNanoTime(long timeoutNanos)\n", "    private static long remainingNanos(long startTime, long timeoutNanos)\n", "    private void signalNextWaiter()\n", "    private boolean isSatisfied(Guard guard)\n", "    private void signalAllWaiters()\n", "    private void beginWaitingFor(Guard guard)\n", "    private void endWaitingFor(Guard guard)\n", "    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n", "    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n", "    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n"], "context": "/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.concurrent.GuardedBy;\nimport com.google.j2objc.annotations.Weak;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A synchronization abstraction supporting waiting on arbitrary boolean conditions.\n *\n * <p>This class is intended as a replacement for {@link ReentrantLock}. Code using {@code Monitor}\n * is less error-prone and more readable than code using {@code ReentrantLock}, without significant\n * performance loss. {@code Monitor} even has the potential for performance gain by optimizing the\n * evaluation and signaling of conditions. Signaling is entirely <a\n * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>. By\n * eliminating explicit signaling, this class can guarantee that only one thread is awakened when a\n * condition becomes true (no \"signaling storms\" due to use of {@link\n * java.util.concurrent.locks.Condition#signalAll Condition.signalAll}) and that no signals are lost\n * (no \"hangs\" due to incorrect use of {@link java.util.concurrent.locks.Condition#signal\n * Condition.signal}).\n *\n * <p>A thread is said to <i>occupy</i> a monitor if it has <i>entered</i> the monitor but not yet\n * <i>left</i>. Only one thread may occupy a given monitor at any moment. A monitor is also\n * reentrant, so a thread may enter a monitor any number of times, and then must leave the same\n * number of times. The <i>enter</i> and <i>leave</i> operations have the same synchronization\n * semantics as the built-in Java language synchronization primitives.\n *\n * <p>A call to any of the <i>enter</i> methods with <b>void</b> return type should always be\n * followed immediately by a <i>try/finally</i> block to ensure that the current thread leaves the\n * monitor cleanly:\n *\n * <pre>{@code\n * monitor.enter();\n * try {\n *   // do things while occupying the monitor\n * } finally {\n *   monitor.leave();\n * }\n * }</pre>\n *\n * <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear\n * as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that\n * the current thread leaves the monitor cleanly:\n *\n * <pre>{@code\n * if (monitor.tryEnter()) {\n *   try {\n *     // do things while occupying the monitor\n *   } finally {\n *     monitor.leave();\n *   }\n * } else {\n *   // do other things since the monitor was not available\n * }\n * }</pre>\n *\n * <h2>Comparison with {@code synchronized} and {@code ReentrantLock}</h2>\n *\n * <p>The following examples show a simple threadsafe holder expressed using {@code synchronized},\n * {@link ReentrantLock}, and {@code Monitor}.\n *\n * <h3>{@code synchronized}</h3>\n *\n * <p>This version is the fewest lines of code, largely because the synchronization mechanism used\n * is built into the language and runtime. But the programmer has to remember to avoid a couple of\n * common bugs: The {@code wait()} must be inside a {@code while} instead of an {@code if}, and\n * {@code notifyAll()} must be used instead of {@code notify()} because there are two different\n * logical conditions being awaited.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *\n *   public synchronized V get() throws InterruptedException {\n *     while (value == null) {\n *       wait();\n *     }\n *     V result = value;\n *     value = null;\n *     notifyAll();\n *     return result;\n *   }\n *\n *   public synchronized void set(V newValue) throws InterruptedException {\n *     while (value != null) {\n *       wait();\n *     }\n *     value = newValue;\n *     notifyAll();\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code ReentrantLock}</h3>\n *\n * <p>This version is much more verbose than the {@code synchronized} version, and still suffers\n * from the need for the programmer to remember to use {@code while} instead of {@code if}. However,\n * one advantage is that we can introduce two separate {@code Condition} objects, which allows us to\n * use {@code signal()} instead of {@code signalAll()}, which may be a performance benefit.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final ReentrantLock lock = new ReentrantLock();\n *   private final Condition valuePresent = lock.newCondition();\n *   private final Condition valueAbsent = lock.newCondition();\n *\n *   public V get() throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value == null) {\n *         valuePresent.await();\n *       }\n *       V result = value;\n *       value = null;\n *       valueAbsent.signal();\n *       return result;\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value != null) {\n *         valueAbsent.await();\n *       }\n *       value = newValue;\n *       valuePresent.signal();\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code Monitor}</h3>\n *\n * <p>This version adds some verbosity around the {@code Guard} objects, but removes that same\n * verbosity, and more, from the {@code get} and {@code set} methods. {@code Monitor} implements the\n * same efficient signaling as we had to hand-code in the {@code ReentrantLock} version above.\n * Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to\n * remember to use {@code while} instead of {@code if}.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final Monitor monitor = new Monitor();\n *   private final Monitor.Guard valuePresent = monitor.newGuard(() -> value != null);\n *   private final Monitor.Guard valueAbsent = monitor.newGuard(() -> value == null);\n *\n *   public V get() throws InterruptedException {\n *     monitor.enterWhen(valuePresent);\n *     try {\n *       V result = value;\n *       value = null;\n *       return result;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     monitor.enterWhen(valueAbsent);\n *     try {\n *       value = newValue;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n * }\n * }</pre>\n *\n * @author Justin T. Sampson\n * @author Martin Buchholz\n * @since 10.0\n */\n@Beta\n@GwtIncompatible\n@SuppressWarnings(\"GuardedBy\") // TODO(b/35466881): Fix or suppress.\npublic final class Monitor\n{\n    // TODO(user): Use raw LockSupport or AbstractQueuedSynchronizer instead of ReentrantLock.\n    // TODO(user): \"Port\" jsr166 tests for ReentrantLock.\n    //\n    // TODO(user): Change API to make it impossible to use a Guard with the \"wrong\" monitor,\n    //    by making the monitor implicit, and to eliminate other sources of IMSE.\n    //    Imagine:\n    //    guard.lock();\n    //    try { /* monitor locked and guard satisfied here */ }\n    //    finally { guard.unlock(); }\n    // Here are Justin's design notes about this:\n    //\n    // This idea has come up from time to time, and I think one of my\n    // earlier versions of Monitor even did something like this. I ended\n    // up strongly favoring the current interface.\n    //\n    // I probably can't remember all the reasons (it's possible you\n    // could find them in the code review archives), but here are a few:\n    //\n    // 1. What about leaving/unlocking? Are you going to do\n    //    guard.enter() paired with monitor.leave()? That might get\n    //    confusing. It's nice for the finally block to look as close as\n    //    possible to the thing right before the try. You could have\n    //    guard.leave(), but that's a little odd as well because the\n    //    guard doesn't have anything to do with leaving. You can't\n    //    really enforce that the guard you're leaving is the same one\n    //    you entered with, and it doesn't actually matter.\n    //\n    // 2. Since you can enter the monitor without a guard at all, some\n    //    places you'll have monitor.enter()/monitor.leave() and other\n    //    places you'll have guard.enter()/guard.leave() even though\n    //    it's the same lock being acquired underneath. Always using\n    //    monitor.enterXXX()/monitor.leave() will make it really clear\n    //    which lock is held at any point in the code.\n    //\n    // 3. I think \"enterWhen(notEmpty)\" reads better than \"notEmpty.enter()\".\n    //\n    // TODO(user): Implement ReentrantLock features:\n    //    - toString() method\n    //    - getOwner() method\n    //    - getQueuedThreads() method\n    //    - getWaitingThreads(Guard) method\n    //    - implement Serializable\n    //    - redo the API to be as close to identical to ReentrantLock as possible,\n    //      since, after all, this class is also a reentrant mutual exclusion lock!?\n\n    /*\n     * One of the key challenges of this class is to prevent lost signals, while trying hard to\n     * minimize unnecessary signals. One simple and correct algorithm is to signal some other waiter\n     * with a satisfied guard (if one exists) whenever any thread occupying the monitor exits the\n     * monitor, either by unlocking all of its held locks, or by starting to wait for a guard. This\n     * includes exceptional exits, so all control paths involving signalling must be protected by a\n     * finally block.\n     *\n     * Further optimizations of this algorithm become increasingly subtle. A wait that terminates\n     * without the guard being satisfied (due to timeout, but not interrupt) can then immediately exit\n     * the monitor without signalling. If it timed out without being signalled, it does not need to\n     * \"pass on\" the signal to another thread. If it *was* signalled, then its guard must have been\n     * satisfied at the time of signal, and has since been modified by some other thread to be\n     * non-satisfied before reacquiring the lock, and that other thread takes over the responsibility\n     * of signaling the next waiter.\n     *\n     * Unlike the underlying Condition, if we are not careful, an interrupt *can* cause a signal to be\n     * lost, because the signal may be sent to a condition whose sole waiter has just been\n     * interrupted.\n     *\n     * Imagine a monitor with multiple guards. A thread enters the monitor, satisfies all the guards,\n     * and leaves, calling signalNextWaiter. With traditional locks and conditions, all the conditions\n     * need to be signalled because it is not known which if any of them have waiters (and hasWaiters\n     * can't be used reliably because of a check-then-act race). With our Monitor guards, we only\n     * signal the first active guard that is satisfied. But the corresponding thread may have already\n     * been interrupted and is waiting to reacquire the lock while still registered in activeGuards,\n     * in which case the signal is a no-op, and the bigger-picture signal is lost unless interrupted\n     * threads take special action by participating in the signal-passing game.\n     */\n\n    /*\n     * Timeout handling is intricate, especially given our ambitious goals:\n     * - Avoid underflow and overflow of timeout values when specified timeouts are close to\n     *   Long.MIN_VALUE or Long.MAX_VALUE.\n     * - Favor responding to interrupts over timeouts.\n     * - System.nanoTime() is expensive enough that we want to call it the minimum required number of\n     *   times, typically once before invoking a blocking method. This often requires keeping track of\n     *   the first time in a method that nanoTime() has been invoked, for which the special value 0L\n     *   is reserved to mean \"uninitialized\". If timeout is non-positive, then nanoTime need never be\n     *   called.\n     * - Keep behavior of fair and non-fair instances consistent.\n     */\n\n    /**\n     * A boolean condition for which a thread may wait. A {@code Guard} is associated with a single\n     * {@code Monitor}. The monitor may check the guard at arbitrary times from any thread occupying\n     * the monitor, so code should not be written to rely on how often a guard might or might not be\n     * checked.\n     *\n     * <p>If a {@code Guard} is passed into any method of a {@code Monitor} other than the one it is\n     * associated with, an {@link IllegalMonitorStateException} is thrown.\n     *\n     * @since 10.0\n     */\n    @Beta\n    public abstract static class Guard\n    {\n\n        @Weak final Monitor monitor;\n        final Condition condition;\n\n        @GuardedBy(\"monitor.lock\")\n        int waiterCount = 0;\n\n        /** The next active guard */\n        @GuardedBy(\"monitor.lock\")\n        @NullableDecl\n        Guard next;\n\n        protected Guard(Monitor monitor)\n        {\n            this.monitor = checkNotNull(monitor, \"monitor\");\n            this.condition = monitor.lock.newCondition();\n        }\n\n        /**\n         * Evaluates this guard's boolean condition. This method is always called with the associated\n         * monitor already occupied. Implementations of this method must depend only on state protected\n         * by the associated monitor, and must not modify that state.\n         */\n        public abstract boolean isSatisfied();\n    }\n\n    /** Whether this monitor is fair. */\n    private final boolean fair;\n\n    /** The lock underlying this monitor. */\n    private final ReentrantLock lock;\n\n    /**\n     * The guards associated with this monitor that currently have waiters ({@code waiterCount > 0}).\n     * A linked list threaded through the Guard.next field.\n     */\n    @GuardedBy(\"lock\")\n    private Guard activeGuards = null;\n\n    /**\n     * Creates a monitor with a non-fair (but fast) ordering policy. Equivalent to {@code\n     * Monitor(false)}.\n     */\n    public Monitor()\n    {\n        this(false);\n    }\n\n    /**\n     * Creates a monitor with the given ordering policy.\n     *\n     * @param fair whether this monitor should use a fair ordering policy rather than a non-fair (but\n     *     fast) one\n     */\n    public Monitor(boolean fair)\n    {\n        this.fair = fair;\n        this.lock = new ReentrantLock(fair);\n    }\n\n    /** Enters this monitor. Blocks indefinitely. */\n    public void enter()\n    {\n        lock.lock();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time.\n     *\n     * @return whether the monitor was entered\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enter(long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        final ReentrantLock lock = this.lock;\n        if (!fair && lock.tryLock())\n        {\n            return true;\n        }\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            final long startTime = System.nanoTime();\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterInterruptibly() throws InterruptedException\n    {\n        lock.lockInterruptibly();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time, and may be interrupted.\n     *\n     * @return whether the monitor was entered\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n    {\n        return lock.tryLock(time, unit);\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately. Does not block.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered\n     */\n    public boolean tryEnter()\n    {\n        return lock.tryLock();\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterWhen(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                await(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied, and may be\n     * interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean reentrant = lock.isHeldByCurrentThread();\n        long startTime = 0L;\n\n        locked:\n        {\n            if (!fair)\n            {\n                // Check interrupt status to get behavior consistent with fair case.\n                if (Thread.interrupted())\n                {\n                    throw new InterruptedException();\n                }\n                if (lock.tryLock())\n                {\n                    break locked;\n                }\n            }\n            startTime = initNanoTime(timeoutNanos);\n            if (!lock.tryLock(time, unit))\n            {\n                return false;\n            }\n        }\n\n        boolean satisfied = false;\n        boolean threw = true;\n        try\n        {\n            satisfied =\n                guard.isSatisfied()\n                || awaitNanos(\n                    guard,\n                    (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),\n                    reentrant);\n            threw = false;\n            return satisfied;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                try\n                {\n                    // Don't need to signal if timed out, but do if interrupted\n                    if (threw && !reentrant)\n                    {\n                        signalNextWaiter();\n                    }\n                }\n                finally\n                {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n\n    /** Enters this monitor when the guard is satisfied. Blocks indefinitely. */\n    public void enterWhenUninterruptibly(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                awaitUninterruptibly(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        long startTime = 0L;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            if (fair || !lock.tryLock())\n            {\n                startTime = initNanoTime(timeoutNanos);\n                for (long remainingNanos = timeoutNanos; ; )\n                {\n                    try\n                    {\n                        if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS))\n                        {\n                            break;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        remainingNanos = remainingNanos(startTime, timeoutNanos);\n                    }\n                }\n            }\n\n            boolean satisfied = false;\n            try\n            {\n                while (true)\n                {\n                    try\n                    {\n                        if (guard.isSatisfied())\n                        {\n                            satisfied = true;\n                        }\n                        else\n                        {\n                            final long remainingNanos;\n                            if (startTime == 0L)\n                            {\n                                startTime = initNanoTime(timeoutNanos);\n                                remainingNanos = timeoutNanos;\n                            }\n                            else\n                            {\n                                remainingNanos = remainingNanos(startTime, timeoutNanos);\n                            }\n                            satisfied = awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                        }\n                        return satisfied;\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        signalBeforeWaiting = false;\n                    }\n                }\n            }\n            finally\n            {\n                if (!satisfied)\n                {\n                    lock.unlock(); // No need to signal if timed out\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean enterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!enter(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n    throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not\n     * block acquiring the lock and does not wait for the guard to be satisfied.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean tryEnterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock())\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be called\n     * only by a thread currently occupying this monitor.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted. May\n     * be called only by a thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        if (Thread.interrupted())\n        {\n            throw new InterruptedException();\n        }\n        return awaitNanos(guard, timeoutNanos, true);\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread\n     * currently occupying this monitor.\n     */\n    public void waitForUninterruptibly(Guard guard)\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            awaitUninterruptibly(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time. May be called only by a\n     * thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        boolean signalBeforeWaiting = true;\n        final long startTime = initNanoTime(timeoutNanos);\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    if (guard.isSatisfied())\n                    {\n                        return true;\n                    }\n                    signalBeforeWaiting = false;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /** Leaves this monitor. May be called only by a thread currently occupying this monitor. */\n    public void leave()\n    {\n        final ReentrantLock lock = this.lock;\n        try\n        {\n            // No need to signal if we will still be holding the lock when we return\n            if (lock.getHoldCount() == 1)\n            {\n                signalNextWaiter();\n            }\n        }\n        finally\n        {\n            lock.unlock(); // Will throw IllegalMonitorStateException if not held\n        }\n    }\n\n    /** Returns whether this monitor is using a fair ordering policy. */\n    public boolean isFair()\n    {\n        return fair;\n    }\n\n    /**\n     * Returns whether this monitor is occupied by any thread. This method is designed for use in\n     * monitoring of the system state, not for synchronization control.\n     */\n    public boolean isOccupied()\n    {\n        return lock.isLocked();\n    }\n\n    /**\n     * Returns whether the current thread is occupying this monitor (has entered more times than it\n     * has left).\n     */\n    public boolean isOccupiedByCurrentThread()\n    {\n        return lock.isHeldByCurrentThread();\n    }\n\n    /**\n     * Returns the number of times the current thread has entered this monitor in excess of the number\n     * of times it has left. Returns 0 if the current thread is not occupying this monitor.\n     */\n    public int getOccupiedDepth()\n    {\n        return lock.getHoldCount();\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting to enter this monitor. The value is only\n     * an estimate because the number of threads may change dynamically while this method traverses\n     * internal data structures. This method is designed for use in monitoring of the system state,\n     * not for synchronization control.\n     */\n    public int getQueueLength()\n    {\n        return lock.getQueueLength();\n    }\n\n    /**\n     * Returns whether any threads are waiting to enter this monitor. Note that because cancellations\n     * may occur at any time, a {@code true} return does not guarantee that any other thread will ever\n     * enter this monitor. This method is designed primarily for use in monitoring of the system\n     * state.\n     */\n    public boolean hasQueuedThreads()\n    {\n        return lock.hasQueuedThreads();\n    }\n\n    /**\n     * Queries whether the given thread is waiting to enter this monitor. Note that because\n     * cancellations may occur at any time, a {@code true} return does not guarantee that this thread\n     * will ever enter this monitor. This method is designed primarily for use in monitoring of the\n     * system state.\n     */\n    public boolean hasQueuedThread(Thread thread)\n    {\n        return lock.hasQueuedThread(thread);\n    }\n\n    /**\n     * Queries whether any threads are waiting for the given guard to become satisfied. Note that\n     * because timeouts and interrupts may occur at any time, a {@code true} return does not guarantee\n     * that the guard becoming satisfied in the future will awaken any threads. This method is\n     * designed primarily for use in monitoring of the system state.\n     */\n    public boolean hasWaiters(Guard guard)\n    {\n        return getWaitQueueLength(guard) > 0;\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting for the given guard to become satisfied.\n     * Note that because timeouts and interrupts may occur at any time, the estimate serves only as an\n     * upper bound on the actual number of waiters. This method is designed for use in monitoring of\n     * the system state, not for synchronization control.\n     */\n    public int getWaitQueueLength(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        lock.lock();\n        try\n        {\n            return guard.waiterCount;\n        }\n        finally\n        {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Returns unit.toNanos(time), additionally ensuring the returned value is not at risk of\n     * overflowing or underflowing, by bounding the value between 0 and (Long.MAX_VALUE / 4) * 3.\n     * Actually waiting for more than 219 years is not supported!\n     */\n    private static long toSafeNanos(long time, TimeUnit unit)\n    {\n        long timeoutNanos = unit.toNanos(time);\n        return (timeoutNanos <= 0L)\n               ? 0L\n               : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3 : timeoutNanos;\n    }\n\n    /**\n     * Returns System.nanoTime() unless the timeout has already elapsed. Returns 0L if and only if the\n     * timeout has already elapsed.\n     */\n    private static long initNanoTime(long timeoutNanos)\n    {\n        if (timeoutNanos <= 0L)\n        {\n            return 0L;\n        }\n        else\n        {\n            long startTime = System.nanoTime();\n            return (startTime == 0L) ? 1L : startTime;\n        }\n    }\n\n    /**\n     * Returns the remaining nanos until the given timeout, or 0L if the timeout has already elapsed.\n     * Caller must have previously sanitized timeoutNanos using toSafeNanos.\n     */\n    private static long remainingNanos(long startTime, long timeoutNanos)\n    {\n        // assert timeoutNanos == 0L || startTime != 0L;\n\n        // TODO : NOT CORRECT, BUT TESTS PASS ANYWAYS!\n        // if (true) return timeoutNanos;\n        // ONLY 2 TESTS FAIL IF WE DO:\n        // if (true) return 0;\n\n        return (timeoutNanos <= 0L) ? 0L : timeoutNanos - (System.nanoTime() - startTime);\n    }\n\n    /**\n     * Signals some other thread waiting on a satisfied guard, if one exists.\n     *\n     * <p>We manage calls to this method carefully, to signal only when necessary, but never losing a\n     * signal, which is the classic problem of this kind of concurrency construct. We must signal if\n     * the current thread is about to relinquish the lock and may have changed the state protected by\n     * the monitor, thereby causing some guard to be satisfied.\n     *\n     * <p>In addition, any thread that has been signalled when its guard was satisfied acquires the\n     * responsibility of signalling the next thread when it again relinquishes the lock. Unlike a\n     * normal Condition, there is no guarantee that an interrupted thread has not been signalled,\n     * since the concurrency control must manage multiple Conditions. So this method must generally be\n     * called when waits are interrupted.\n     *\n     * <p>On the other hand, if a signalled thread wakes up to discover that its guard is still not\n     * satisfied, it does *not* need to call this method before returning to wait. This can only\n     * happen due to spurious wakeup (ignorable) or another thread acquiring the lock before the\n     * current thread can and returning the guard to the unsatisfied state. In the latter case the\n     * other thread (last thread modifying the state protected by the monitor) takes over the\n     * responsibility of signalling the next waiter.\n     *\n     * <p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else\n     * the current thread's guard might be mistakenly signalled, leading to a lost signal.\n     */\n    @GuardedBy(\"lock\")\n    private void signalNextWaiter()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            if (isSatisfied(guard))\n            {\n                guard.condition.signal();\n                break;\n            }\n        }\n    }\n\n    /**\n     * Exactly like signalNextWaiter, but caller guarantees that guardToSkip need not be considered,\n     * because caller has previously checked that guardToSkip.isSatisfied() returned false. An\n     * optimization for the case that guardToSkip.isSatisfied() may be expensive.\n     *\n     * <p>We decided against using this method, since in practice, isSatisfied() is likely to be very\n     * cheap (typically one field read). Resurrect this method if you find that not to be true.\n     */\n    //   @GuardedBy(\"lock\")\n    //   private void signalNextWaiterSkipping(Guard guardToSkip) {\n    //     for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n    //       if (guard != guardToSkip && isSatisfied(guard)) {\n    //         guard.condition.signal();\n    //         break;\n    //       }\n    //     }\n    //   }\n\n    /**\n     * Exactly like guard.isSatisfied(), but in addition signals all waiting threads in the (hopefully\n     * unlikely) event that isSatisfied() throws.\n     */\n    @GuardedBy(\"lock\")\n    private boolean isSatisfied(Guard guard)\n    {\n        try\n        {\n            return guard.isSatisfied();\n        }\n        catch (Throwable throwable)\n        {\n            signalAllWaiters();\n            throw throwable;\n        }\n    }\n\n    /** Signals all threads waiting on guards. */\n    @GuardedBy(\"lock\")\n    private void signalAllWaiters()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            guard.condition.signalAll();\n        }\n    }\n\n    /** Records that the current thread is about to wait on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void beginWaitingFor(Guard guard)\n    {\n        int waiters = guard.waiterCount++;\n        if (waiters == 0)\n        {\n            // push guard onto activeGuards\n            guard.next = activeGuards;\n            activeGuards = guard;\n        }\n    }\n\n    /** Records that the current thread is no longer waiting on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void endWaitingFor(Guard guard)\n    {\n        int waiters = --guard.waiterCount;\n        if (waiters == 0)\n        {\n            // unlink guard from activeGuards\n            for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next)\n            {\n                if (p == guard)\n                {\n                    if (pred == null)\n                    {\n                        activeGuards = p.next;\n                    }\n                    else\n                    {\n                        pred.next = p.next;\n                    }\n                    p.next = null; // help GC\n                    break;\n                }\n            }\n        }\n    }\n\n    /*\n     * Methods that loop waiting on a guard's condition until the guard is satisfied, while recording\n     * this fact so that other threads know to check our guard and signal us. It's caller's\n     * responsibility to ensure that the guard is *not* currently satisfied.\n     */\n\n    @GuardedBy(\"lock\")\n    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.await();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    @GuardedBy(\"lock\")\n    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.awaitUninterruptibly();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    /** Caller should check before calling that guard is not satisfied. */\n    @GuardedBy(\"lock\")\n    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n    throws InterruptedException\n    {\n        boolean firstTime = true;\n        try\n        {\n            do\n            {\n                if (nanos <= 0L)\n                {\n                    return false;\n                }\n                if (firstTime)\n                {\n                    if (signalBeforeWaiting)\n                    {\n                        signalNextWaiter();\n                    }\n                    beginWaitingFor(guard);\n                    firstTime = false;\n                }\n                nanos = guard.condition.awaitNanos(nanos);\n            }\n            while (!guard.isSatisfied());\n            return true;\n        }\n        finally\n        {\n            if (!firstTime)\n            {\n                endWaitingFor(guard);\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.waitForUninterruptibly", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread\ncurrently occupying this monitor.", "docstring_tokens": ["Waits", "for", "the", "guard", "to", "be", "satisfied", ".", "Waits", "indefinitely", ".", "May", "be", "called", "only", "by", "a", "thread", "currently", "occupying", "this", "monitor", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L769-L776", "partition": "valid", "up_fun_num": 18, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.errorprone.annotations.concurrent.GuardedBy;", "import com.google.j2objc.annotations.Weak;", "import java.util.concurrent.TimeUnit;", "import java.util.concurrent.locks.Condition;", "import java.util.concurrent.locks.ReentrantLock;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Monitor\n", "    public void enter()\n", "    public boolean enter(long time, TimeUnit unit)\n", "    public void enterInterruptibly() throws InterruptedException\n", "    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n", "    public boolean tryEnter()\n", "    public void enterWhen(Guard guard) throws InterruptedException\n", "    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void enterWhenUninterruptibly(Guard guard)\n", "    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIf(Guard guard)\n", "    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n", "    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean tryEnterIf(Guard guard)\n", "    public void waitFor(Guard guard) throws InterruptedException\n", "    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public void leave()\n", "    public boolean isFair()\n", "    public boolean isOccupied()\n", "    public boolean isOccupiedByCurrentThread()\n", "    public int getOccupiedDepth()\n", "    public int getQueueLength()\n", "    public boolean hasQueuedThreads()\n", "    public boolean hasQueuedThread(Thread thread)\n", "    public boolean hasWaiters(Guard guard)\n", "    public int getWaitQueueLength(Guard guard)\n", "    private static long toSafeNanos(long time, TimeUnit unit)\n", "    private static long initNanoTime(long timeoutNanos)\n", "    private static long remainingNanos(long startTime, long timeoutNanos)\n", "    private void signalNextWaiter()\n", "    private boolean isSatisfied(Guard guard)\n", "    private void signalAllWaiters()\n", "    private void beginWaitingFor(Guard guard)\n", "    private void endWaitingFor(Guard guard)\n", "    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n", "    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n", "    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n"], "context": "/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.concurrent.GuardedBy;\nimport com.google.j2objc.annotations.Weak;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A synchronization abstraction supporting waiting on arbitrary boolean conditions.\n *\n * <p>This class is intended as a replacement for {@link ReentrantLock}. Code using {@code Monitor}\n * is less error-prone and more readable than code using {@code ReentrantLock}, without significant\n * performance loss. {@code Monitor} even has the potential for performance gain by optimizing the\n * evaluation and signaling of conditions. Signaling is entirely <a\n * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>. By\n * eliminating explicit signaling, this class can guarantee that only one thread is awakened when a\n * condition becomes true (no \"signaling storms\" due to use of {@link\n * java.util.concurrent.locks.Condition#signalAll Condition.signalAll}) and that no signals are lost\n * (no \"hangs\" due to incorrect use of {@link java.util.concurrent.locks.Condition#signal\n * Condition.signal}).\n *\n * <p>A thread is said to <i>occupy</i> a monitor if it has <i>entered</i> the monitor but not yet\n * <i>left</i>. Only one thread may occupy a given monitor at any moment. A monitor is also\n * reentrant, so a thread may enter a monitor any number of times, and then must leave the same\n * number of times. The <i>enter</i> and <i>leave</i> operations have the same synchronization\n * semantics as the built-in Java language synchronization primitives.\n *\n * <p>A call to any of the <i>enter</i> methods with <b>void</b> return type should always be\n * followed immediately by a <i>try/finally</i> block to ensure that the current thread leaves the\n * monitor cleanly:\n *\n * <pre>{@code\n * monitor.enter();\n * try {\n *   // do things while occupying the monitor\n * } finally {\n *   monitor.leave();\n * }\n * }</pre>\n *\n * <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear\n * as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that\n * the current thread leaves the monitor cleanly:\n *\n * <pre>{@code\n * if (monitor.tryEnter()) {\n *   try {\n *     // do things while occupying the monitor\n *   } finally {\n *     monitor.leave();\n *   }\n * } else {\n *   // do other things since the monitor was not available\n * }\n * }</pre>\n *\n * <h2>Comparison with {@code synchronized} and {@code ReentrantLock}</h2>\n *\n * <p>The following examples show a simple threadsafe holder expressed using {@code synchronized},\n * {@link ReentrantLock}, and {@code Monitor}.\n *\n * <h3>{@code synchronized}</h3>\n *\n * <p>This version is the fewest lines of code, largely because the synchronization mechanism used\n * is built into the language and runtime. But the programmer has to remember to avoid a couple of\n * common bugs: The {@code wait()} must be inside a {@code while} instead of an {@code if}, and\n * {@code notifyAll()} must be used instead of {@code notify()} because there are two different\n * logical conditions being awaited.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *\n *   public synchronized V get() throws InterruptedException {\n *     while (value == null) {\n *       wait();\n *     }\n *     V result = value;\n *     value = null;\n *     notifyAll();\n *     return result;\n *   }\n *\n *   public synchronized void set(V newValue) throws InterruptedException {\n *     while (value != null) {\n *       wait();\n *     }\n *     value = newValue;\n *     notifyAll();\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code ReentrantLock}</h3>\n *\n * <p>This version is much more verbose than the {@code synchronized} version, and still suffers\n * from the need for the programmer to remember to use {@code while} instead of {@code if}. However,\n * one advantage is that we can introduce two separate {@code Condition} objects, which allows us to\n * use {@code signal()} instead of {@code signalAll()}, which may be a performance benefit.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final ReentrantLock lock = new ReentrantLock();\n *   private final Condition valuePresent = lock.newCondition();\n *   private final Condition valueAbsent = lock.newCondition();\n *\n *   public V get() throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value == null) {\n *         valuePresent.await();\n *       }\n *       V result = value;\n *       value = null;\n *       valueAbsent.signal();\n *       return result;\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value != null) {\n *         valueAbsent.await();\n *       }\n *       value = newValue;\n *       valuePresent.signal();\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code Monitor}</h3>\n *\n * <p>This version adds some verbosity around the {@code Guard} objects, but removes that same\n * verbosity, and more, from the {@code get} and {@code set} methods. {@code Monitor} implements the\n * same efficient signaling as we had to hand-code in the {@code ReentrantLock} version above.\n * Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to\n * remember to use {@code while} instead of {@code if}.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final Monitor monitor = new Monitor();\n *   private final Monitor.Guard valuePresent = monitor.newGuard(() -> value != null);\n *   private final Monitor.Guard valueAbsent = monitor.newGuard(() -> value == null);\n *\n *   public V get() throws InterruptedException {\n *     monitor.enterWhen(valuePresent);\n *     try {\n *       V result = value;\n *       value = null;\n *       return result;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     monitor.enterWhen(valueAbsent);\n *     try {\n *       value = newValue;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n * }\n * }</pre>\n *\n * @author Justin T. Sampson\n * @author Martin Buchholz\n * @since 10.0\n */\n@Beta\n@GwtIncompatible\n@SuppressWarnings(\"GuardedBy\") // TODO(b/35466881): Fix or suppress.\npublic final class Monitor\n{\n    // TODO(user): Use raw LockSupport or AbstractQueuedSynchronizer instead of ReentrantLock.\n    // TODO(user): \"Port\" jsr166 tests for ReentrantLock.\n    //\n    // TODO(user): Change API to make it impossible to use a Guard with the \"wrong\" monitor,\n    //    by making the monitor implicit, and to eliminate other sources of IMSE.\n    //    Imagine:\n    //    guard.lock();\n    //    try { /* monitor locked and guard satisfied here */ }\n    //    finally { guard.unlock(); }\n    // Here are Justin's design notes about this:\n    //\n    // This idea has come up from time to time, and I think one of my\n    // earlier versions of Monitor even did something like this. I ended\n    // up strongly favoring the current interface.\n    //\n    // I probably can't remember all the reasons (it's possible you\n    // could find them in the code review archives), but here are a few:\n    //\n    // 1. What about leaving/unlocking? Are you going to do\n    //    guard.enter() paired with monitor.leave()? That might get\n    //    confusing. It's nice for the finally block to look as close as\n    //    possible to the thing right before the try. You could have\n    //    guard.leave(), but that's a little odd as well because the\n    //    guard doesn't have anything to do with leaving. You can't\n    //    really enforce that the guard you're leaving is the same one\n    //    you entered with, and it doesn't actually matter.\n    //\n    // 2. Since you can enter the monitor without a guard at all, some\n    //    places you'll have monitor.enter()/monitor.leave() and other\n    //    places you'll have guard.enter()/guard.leave() even though\n    //    it's the same lock being acquired underneath. Always using\n    //    monitor.enterXXX()/monitor.leave() will make it really clear\n    //    which lock is held at any point in the code.\n    //\n    // 3. I think \"enterWhen(notEmpty)\" reads better than \"notEmpty.enter()\".\n    //\n    // TODO(user): Implement ReentrantLock features:\n    //    - toString() method\n    //    - getOwner() method\n    //    - getQueuedThreads() method\n    //    - getWaitingThreads(Guard) method\n    //    - implement Serializable\n    //    - redo the API to be as close to identical to ReentrantLock as possible,\n    //      since, after all, this class is also a reentrant mutual exclusion lock!?\n\n    /*\n     * One of the key challenges of this class is to prevent lost signals, while trying hard to\n     * minimize unnecessary signals. One simple and correct algorithm is to signal some other waiter\n     * with a satisfied guard (if one exists) whenever any thread occupying the monitor exits the\n     * monitor, either by unlocking all of its held locks, or by starting to wait for a guard. This\n     * includes exceptional exits, so all control paths involving signalling must be protected by a\n     * finally block.\n     *\n     * Further optimizations of this algorithm become increasingly subtle. A wait that terminates\n     * without the guard being satisfied (due to timeout, but not interrupt) can then immediately exit\n     * the monitor without signalling. If it timed out without being signalled, it does not need to\n     * \"pass on\" the signal to another thread. If it *was* signalled, then its guard must have been\n     * satisfied at the time of signal, and has since been modified by some other thread to be\n     * non-satisfied before reacquiring the lock, and that other thread takes over the responsibility\n     * of signaling the next waiter.\n     *\n     * Unlike the underlying Condition, if we are not careful, an interrupt *can* cause a signal to be\n     * lost, because the signal may be sent to a condition whose sole waiter has just been\n     * interrupted.\n     *\n     * Imagine a monitor with multiple guards. A thread enters the monitor, satisfies all the guards,\n     * and leaves, calling signalNextWaiter. With traditional locks and conditions, all the conditions\n     * need to be signalled because it is not known which if any of them have waiters (and hasWaiters\n     * can't be used reliably because of a check-then-act race). With our Monitor guards, we only\n     * signal the first active guard that is satisfied. But the corresponding thread may have already\n     * been interrupted and is waiting to reacquire the lock while still registered in activeGuards,\n     * in which case the signal is a no-op, and the bigger-picture signal is lost unless interrupted\n     * threads take special action by participating in the signal-passing game.\n     */\n\n    /*\n     * Timeout handling is intricate, especially given our ambitious goals:\n     * - Avoid underflow and overflow of timeout values when specified timeouts are close to\n     *   Long.MIN_VALUE or Long.MAX_VALUE.\n     * - Favor responding to interrupts over timeouts.\n     * - System.nanoTime() is expensive enough that we want to call it the minimum required number of\n     *   times, typically once before invoking a blocking method. This often requires keeping track of\n     *   the first time in a method that nanoTime() has been invoked, for which the special value 0L\n     *   is reserved to mean \"uninitialized\". If timeout is non-positive, then nanoTime need never be\n     *   called.\n     * - Keep behavior of fair and non-fair instances consistent.\n     */\n\n    /**\n     * A boolean condition for which a thread may wait. A {@code Guard} is associated with a single\n     * {@code Monitor}. The monitor may check the guard at arbitrary times from any thread occupying\n     * the monitor, so code should not be written to rely on how often a guard might or might not be\n     * checked.\n     *\n     * <p>If a {@code Guard} is passed into any method of a {@code Monitor} other than the one it is\n     * associated with, an {@link IllegalMonitorStateException} is thrown.\n     *\n     * @since 10.0\n     */\n    @Beta\n    public abstract static class Guard\n    {\n\n        @Weak final Monitor monitor;\n        final Condition condition;\n\n        @GuardedBy(\"monitor.lock\")\n        int waiterCount = 0;\n\n        /** The next active guard */\n        @GuardedBy(\"monitor.lock\")\n        @NullableDecl\n        Guard next;\n\n        protected Guard(Monitor monitor)\n        {\n            this.monitor = checkNotNull(monitor, \"monitor\");\n            this.condition = monitor.lock.newCondition();\n        }\n\n        /**\n         * Evaluates this guard's boolean condition. This method is always called with the associated\n         * monitor already occupied. Implementations of this method must depend only on state protected\n         * by the associated monitor, and must not modify that state.\n         */\n        public abstract boolean isSatisfied();\n    }\n\n    /** Whether this monitor is fair. */\n    private final boolean fair;\n\n    /** The lock underlying this monitor. */\n    private final ReentrantLock lock;\n\n    /**\n     * The guards associated with this monitor that currently have waiters ({@code waiterCount > 0}).\n     * A linked list threaded through the Guard.next field.\n     */\n    @GuardedBy(\"lock\")\n    private Guard activeGuards = null;\n\n    /**\n     * Creates a monitor with a non-fair (but fast) ordering policy. Equivalent to {@code\n     * Monitor(false)}.\n     */\n    public Monitor()\n    {\n        this(false);\n    }\n\n    /**\n     * Creates a monitor with the given ordering policy.\n     *\n     * @param fair whether this monitor should use a fair ordering policy rather than a non-fair (but\n     *     fast) one\n     */\n    public Monitor(boolean fair)\n    {\n        this.fair = fair;\n        this.lock = new ReentrantLock(fair);\n    }\n\n    /** Enters this monitor. Blocks indefinitely. */\n    public void enter()\n    {\n        lock.lock();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time.\n     *\n     * @return whether the monitor was entered\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enter(long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        final ReentrantLock lock = this.lock;\n        if (!fair && lock.tryLock())\n        {\n            return true;\n        }\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            final long startTime = System.nanoTime();\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterInterruptibly() throws InterruptedException\n    {\n        lock.lockInterruptibly();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time, and may be interrupted.\n     *\n     * @return whether the monitor was entered\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n    {\n        return lock.tryLock(time, unit);\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately. Does not block.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered\n     */\n    public boolean tryEnter()\n    {\n        return lock.tryLock();\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterWhen(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                await(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied, and may be\n     * interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean reentrant = lock.isHeldByCurrentThread();\n        long startTime = 0L;\n\n        locked:\n        {\n            if (!fair)\n            {\n                // Check interrupt status to get behavior consistent with fair case.\n                if (Thread.interrupted())\n                {\n                    throw new InterruptedException();\n                }\n                if (lock.tryLock())\n                {\n                    break locked;\n                }\n            }\n            startTime = initNanoTime(timeoutNanos);\n            if (!lock.tryLock(time, unit))\n            {\n                return false;\n            }\n        }\n\n        boolean satisfied = false;\n        boolean threw = true;\n        try\n        {\n            satisfied =\n                guard.isSatisfied()\n                || awaitNanos(\n                    guard,\n                    (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),\n                    reentrant);\n            threw = false;\n            return satisfied;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                try\n                {\n                    // Don't need to signal if timed out, but do if interrupted\n                    if (threw && !reentrant)\n                    {\n                        signalNextWaiter();\n                    }\n                }\n                finally\n                {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n\n    /** Enters this monitor when the guard is satisfied. Blocks indefinitely. */\n    public void enterWhenUninterruptibly(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                awaitUninterruptibly(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        long startTime = 0L;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            if (fair || !lock.tryLock())\n            {\n                startTime = initNanoTime(timeoutNanos);\n                for (long remainingNanos = timeoutNanos; ; )\n                {\n                    try\n                    {\n                        if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS))\n                        {\n                            break;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        remainingNanos = remainingNanos(startTime, timeoutNanos);\n                    }\n                }\n            }\n\n            boolean satisfied = false;\n            try\n            {\n                while (true)\n                {\n                    try\n                    {\n                        if (guard.isSatisfied())\n                        {\n                            satisfied = true;\n                        }\n                        else\n                        {\n                            final long remainingNanos;\n                            if (startTime == 0L)\n                            {\n                                startTime = initNanoTime(timeoutNanos);\n                                remainingNanos = timeoutNanos;\n                            }\n                            else\n                            {\n                                remainingNanos = remainingNanos(startTime, timeoutNanos);\n                            }\n                            satisfied = awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                        }\n                        return satisfied;\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        signalBeforeWaiting = false;\n                    }\n                }\n            }\n            finally\n            {\n                if (!satisfied)\n                {\n                    lock.unlock(); // No need to signal if timed out\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean enterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!enter(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n    throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not\n     * block acquiring the lock and does not wait for the guard to be satisfied.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean tryEnterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock())\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be called\n     * only by a thread currently occupying this monitor.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void waitFor(Guard guard) throws InterruptedException\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            await(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted. May\n     * be called only by a thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        if (Thread.interrupted())\n        {\n            throw new InterruptedException();\n        }\n        return awaitNanos(guard, timeoutNanos, true);\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread\n     * currently occupying this monitor.\n     */\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time. May be called only by a\n     * thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        boolean signalBeforeWaiting = true;\n        final long startTime = initNanoTime(timeoutNanos);\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    if (guard.isSatisfied())\n                    {\n                        return true;\n                    }\n                    signalBeforeWaiting = false;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /** Leaves this monitor. May be called only by a thread currently occupying this monitor. */\n    public void leave()\n    {\n        final ReentrantLock lock = this.lock;\n        try\n        {\n            // No need to signal if we will still be holding the lock when we return\n            if (lock.getHoldCount() == 1)\n            {\n                signalNextWaiter();\n            }\n        }\n        finally\n        {\n            lock.unlock(); // Will throw IllegalMonitorStateException if not held\n        }\n    }\n\n    /** Returns whether this monitor is using a fair ordering policy. */\n    public boolean isFair()\n    {\n        return fair;\n    }\n\n    /**\n     * Returns whether this monitor is occupied by any thread. This method is designed for use in\n     * monitoring of the system state, not for synchronization control.\n     */\n    public boolean isOccupied()\n    {\n        return lock.isLocked();\n    }\n\n    /**\n     * Returns whether the current thread is occupying this monitor (has entered more times than it\n     * has left).\n     */\n    public boolean isOccupiedByCurrentThread()\n    {\n        return lock.isHeldByCurrentThread();\n    }\n\n    /**\n     * Returns the number of times the current thread has entered this monitor in excess of the number\n     * of times it has left. Returns 0 if the current thread is not occupying this monitor.\n     */\n    public int getOccupiedDepth()\n    {\n        return lock.getHoldCount();\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting to enter this monitor. The value is only\n     * an estimate because the number of threads may change dynamically while this method traverses\n     * internal data structures. This method is designed for use in monitoring of the system state,\n     * not for synchronization control.\n     */\n    public int getQueueLength()\n    {\n        return lock.getQueueLength();\n    }\n\n    /**\n     * Returns whether any threads are waiting to enter this monitor. Note that because cancellations\n     * may occur at any time, a {@code true} return does not guarantee that any other thread will ever\n     * enter this monitor. This method is designed primarily for use in monitoring of the system\n     * state.\n     */\n    public boolean hasQueuedThreads()\n    {\n        return lock.hasQueuedThreads();\n    }\n\n    /**\n     * Queries whether the given thread is waiting to enter this monitor. Note that because\n     * cancellations may occur at any time, a {@code true} return does not guarantee that this thread\n     * will ever enter this monitor. This method is designed primarily for use in monitoring of the\n     * system state.\n     */\n    public boolean hasQueuedThread(Thread thread)\n    {\n        return lock.hasQueuedThread(thread);\n    }\n\n    /**\n     * Queries whether any threads are waiting for the given guard to become satisfied. Note that\n     * because timeouts and interrupts may occur at any time, a {@code true} return does not guarantee\n     * that the guard becoming satisfied in the future will awaken any threads. This method is\n     * designed primarily for use in monitoring of the system state.\n     */\n    public boolean hasWaiters(Guard guard)\n    {\n        return getWaitQueueLength(guard) > 0;\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting for the given guard to become satisfied.\n     * Note that because timeouts and interrupts may occur at any time, the estimate serves only as an\n     * upper bound on the actual number of waiters. This method is designed for use in monitoring of\n     * the system state, not for synchronization control.\n     */\n    public int getWaitQueueLength(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        lock.lock();\n        try\n        {\n            return guard.waiterCount;\n        }\n        finally\n        {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Returns unit.toNanos(time), additionally ensuring the returned value is not at risk of\n     * overflowing or underflowing, by bounding the value between 0 and (Long.MAX_VALUE / 4) * 3.\n     * Actually waiting for more than 219 years is not supported!\n     */\n    private static long toSafeNanos(long time, TimeUnit unit)\n    {\n        long timeoutNanos = unit.toNanos(time);\n        return (timeoutNanos <= 0L)\n               ? 0L\n               : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3 : timeoutNanos;\n    }\n\n    /**\n     * Returns System.nanoTime() unless the timeout has already elapsed. Returns 0L if and only if the\n     * timeout has already elapsed.\n     */\n    private static long initNanoTime(long timeoutNanos)\n    {\n        if (timeoutNanos <= 0L)\n        {\n            return 0L;\n        }\n        else\n        {\n            long startTime = System.nanoTime();\n            return (startTime == 0L) ? 1L : startTime;\n        }\n    }\n\n    /**\n     * Returns the remaining nanos until the given timeout, or 0L if the timeout has already elapsed.\n     * Caller must have previously sanitized timeoutNanos using toSafeNanos.\n     */\n    private static long remainingNanos(long startTime, long timeoutNanos)\n    {\n        // assert timeoutNanos == 0L || startTime != 0L;\n\n        // TODO : NOT CORRECT, BUT TESTS PASS ANYWAYS!\n        // if (true) return timeoutNanos;\n        // ONLY 2 TESTS FAIL IF WE DO:\n        // if (true) return 0;\n\n        return (timeoutNanos <= 0L) ? 0L : timeoutNanos - (System.nanoTime() - startTime);\n    }\n\n    /**\n     * Signals some other thread waiting on a satisfied guard, if one exists.\n     *\n     * <p>We manage calls to this method carefully, to signal only when necessary, but never losing a\n     * signal, which is the classic problem of this kind of concurrency construct. We must signal if\n     * the current thread is about to relinquish the lock and may have changed the state protected by\n     * the monitor, thereby causing some guard to be satisfied.\n     *\n     * <p>In addition, any thread that has been signalled when its guard was satisfied acquires the\n     * responsibility of signalling the next thread when it again relinquishes the lock. Unlike a\n     * normal Condition, there is no guarantee that an interrupted thread has not been signalled,\n     * since the concurrency control must manage multiple Conditions. So this method must generally be\n     * called when waits are interrupted.\n     *\n     * <p>On the other hand, if a signalled thread wakes up to discover that its guard is still not\n     * satisfied, it does *not* need to call this method before returning to wait. This can only\n     * happen due to spurious wakeup (ignorable) or another thread acquiring the lock before the\n     * current thread can and returning the guard to the unsatisfied state. In the latter case the\n     * other thread (last thread modifying the state protected by the monitor) takes over the\n     * responsibility of signalling the next waiter.\n     *\n     * <p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else\n     * the current thread's guard might be mistakenly signalled, leading to a lost signal.\n     */\n    @GuardedBy(\"lock\")\n    private void signalNextWaiter()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            if (isSatisfied(guard))\n            {\n                guard.condition.signal();\n                break;\n            }\n        }\n    }\n\n    /**\n     * Exactly like signalNextWaiter, but caller guarantees that guardToSkip need not be considered,\n     * because caller has previously checked that guardToSkip.isSatisfied() returned false. An\n     * optimization for the case that guardToSkip.isSatisfied() may be expensive.\n     *\n     * <p>We decided against using this method, since in practice, isSatisfied() is likely to be very\n     * cheap (typically one field read). Resurrect this method if you find that not to be true.\n     */\n    //   @GuardedBy(\"lock\")\n    //   private void signalNextWaiterSkipping(Guard guardToSkip) {\n    //     for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n    //       if (guard != guardToSkip && isSatisfied(guard)) {\n    //         guard.condition.signal();\n    //         break;\n    //       }\n    //     }\n    //   }\n\n    /**\n     * Exactly like guard.isSatisfied(), but in addition signals all waiting threads in the (hopefully\n     * unlikely) event that isSatisfied() throws.\n     */\n    @GuardedBy(\"lock\")\n    private boolean isSatisfied(Guard guard)\n    {\n        try\n        {\n            return guard.isSatisfied();\n        }\n        catch (Throwable throwable)\n        {\n            signalAllWaiters();\n            throw throwable;\n        }\n    }\n\n    /** Signals all threads waiting on guards. */\n    @GuardedBy(\"lock\")\n    private void signalAllWaiters()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            guard.condition.signalAll();\n        }\n    }\n\n    /** Records that the current thread is about to wait on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void beginWaitingFor(Guard guard)\n    {\n        int waiters = guard.waiterCount++;\n        if (waiters == 0)\n        {\n            // push guard onto activeGuards\n            guard.next = activeGuards;\n            activeGuards = guard;\n        }\n    }\n\n    /** Records that the current thread is no longer waiting on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void endWaitingFor(Guard guard)\n    {\n        int waiters = --guard.waiterCount;\n        if (waiters == 0)\n        {\n            // unlink guard from activeGuards\n            for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next)\n            {\n                if (p == guard)\n                {\n                    if (pred == null)\n                    {\n                        activeGuards = p.next;\n                    }\n                    else\n                    {\n                        pred.next = p.next;\n                    }\n                    p.next = null; // help GC\n                    break;\n                }\n            }\n        }\n    }\n\n    /*\n     * Methods that loop waiting on a guard's condition until the guard is satisfied, while recording\n     * this fact so that other threads know to check our guard and signal us. It's caller's\n     * responsibility to ensure that the guard is *not* currently satisfied.\n     */\n\n    @GuardedBy(\"lock\")\n    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.await();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    @GuardedBy(\"lock\")\n    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.awaitUninterruptibly();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    /** Caller should check before calling that guard is not satisfied. */\n    @GuardedBy(\"lock\")\n    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n    throws InterruptedException\n    {\n        boolean firstTime = true;\n        try\n        {\n            do\n            {\n                if (nanos <= 0L)\n                {\n                    return false;\n                }\n                if (firstTime)\n                {\n                    if (signalBeforeWaiting)\n                    {\n                        signalNextWaiter();\n                    }\n                    beginWaitingFor(guard);\n                    firstTime = false;\n                }\n                nanos = guard.condition.awaitNanos(nanos);\n            }\n            while (!guard.isSatisfied());\n            return true;\n        }\n        finally\n        {\n            if (!firstTime)\n            {\n                endWaitingFor(guard);\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.waitForUninterruptibly", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Waits for the guard to be satisfied. Waits at most the given time. May be called only by a\nthread currently occupying this monitor.\n\n@return whether the guard is now satisfied", "docstring_tokens": ["Waits", "for", "the", "guard", "to", "be", "satisfied", ".", "Waits", "at", "most", "the", "given", "time", ".", "May", "be", "called", "only", "by", "a", "thread", "currently", "occupying", "this", "monitor", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L784-L814", "partition": "valid", "up_fun_num": 18, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.errorprone.annotations.concurrent.GuardedBy;", "import com.google.j2objc.annotations.Weak;", "import java.util.concurrent.TimeUnit;", "import java.util.concurrent.locks.Condition;", "import java.util.concurrent.locks.ReentrantLock;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Monitor\n", "    public void enter()\n", "    public boolean enter(long time, TimeUnit unit)\n", "    public void enterInterruptibly() throws InterruptedException\n", "    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n", "    public boolean tryEnter()\n", "    public void enterWhen(Guard guard) throws InterruptedException\n", "    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void enterWhenUninterruptibly(Guard guard)\n", "    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIf(Guard guard)\n", "    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n", "    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean tryEnterIf(Guard guard)\n", "    public void waitFor(Guard guard) throws InterruptedException\n", "    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void waitForUninterruptibly(Guard guard)\n", "    public void leave()\n", "    public boolean isFair()\n", "    public boolean isOccupied()\n", "    public boolean isOccupiedByCurrentThread()\n", "    public int getOccupiedDepth()\n", "    public int getQueueLength()\n", "    public boolean hasQueuedThreads()\n", "    public boolean hasQueuedThread(Thread thread)\n", "    public boolean hasWaiters(Guard guard)\n", "    public int getWaitQueueLength(Guard guard)\n", "    private static long toSafeNanos(long time, TimeUnit unit)\n", "    private static long initNanoTime(long timeoutNanos)\n", "    private static long remainingNanos(long startTime, long timeoutNanos)\n", "    private void signalNextWaiter()\n", "    private boolean isSatisfied(Guard guard)\n", "    private void signalAllWaiters()\n", "    private void beginWaitingFor(Guard guard)\n", "    private void endWaitingFor(Guard guard)\n", "    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n", "    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n", "    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n"], "context": "/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.concurrent.GuardedBy;\nimport com.google.j2objc.annotations.Weak;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A synchronization abstraction supporting waiting on arbitrary boolean conditions.\n *\n * <p>This class is intended as a replacement for {@link ReentrantLock}. Code using {@code Monitor}\n * is less error-prone and more readable than code using {@code ReentrantLock}, without significant\n * performance loss. {@code Monitor} even has the potential for performance gain by optimizing the\n * evaluation and signaling of conditions. Signaling is entirely <a\n * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>. By\n * eliminating explicit signaling, this class can guarantee that only one thread is awakened when a\n * condition becomes true (no \"signaling storms\" due to use of {@link\n * java.util.concurrent.locks.Condition#signalAll Condition.signalAll}) and that no signals are lost\n * (no \"hangs\" due to incorrect use of {@link java.util.concurrent.locks.Condition#signal\n * Condition.signal}).\n *\n * <p>A thread is said to <i>occupy</i> a monitor if it has <i>entered</i> the monitor but not yet\n * <i>left</i>. Only one thread may occupy a given monitor at any moment. A monitor is also\n * reentrant, so a thread may enter a monitor any number of times, and then must leave the same\n * number of times. The <i>enter</i> and <i>leave</i> operations have the same synchronization\n * semantics as the built-in Java language synchronization primitives.\n *\n * <p>A call to any of the <i>enter</i> methods with <b>void</b> return type should always be\n * followed immediately by a <i>try/finally</i> block to ensure that the current thread leaves the\n * monitor cleanly:\n *\n * <pre>{@code\n * monitor.enter();\n * try {\n *   // do things while occupying the monitor\n * } finally {\n *   monitor.leave();\n * }\n * }</pre>\n *\n * <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear\n * as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that\n * the current thread leaves the monitor cleanly:\n *\n * <pre>{@code\n * if (monitor.tryEnter()) {\n *   try {\n *     // do things while occupying the monitor\n *   } finally {\n *     monitor.leave();\n *   }\n * } else {\n *   // do other things since the monitor was not available\n * }\n * }</pre>\n *\n * <h2>Comparison with {@code synchronized} and {@code ReentrantLock}</h2>\n *\n * <p>The following examples show a simple threadsafe holder expressed using {@code synchronized},\n * {@link ReentrantLock}, and {@code Monitor}.\n *\n * <h3>{@code synchronized}</h3>\n *\n * <p>This version is the fewest lines of code, largely because the synchronization mechanism used\n * is built into the language and runtime. But the programmer has to remember to avoid a couple of\n * common bugs: The {@code wait()} must be inside a {@code while} instead of an {@code if}, and\n * {@code notifyAll()} must be used instead of {@code notify()} because there are two different\n * logical conditions being awaited.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *\n *   public synchronized V get() throws InterruptedException {\n *     while (value == null) {\n *       wait();\n *     }\n *     V result = value;\n *     value = null;\n *     notifyAll();\n *     return result;\n *   }\n *\n *   public synchronized void set(V newValue) throws InterruptedException {\n *     while (value != null) {\n *       wait();\n *     }\n *     value = newValue;\n *     notifyAll();\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code ReentrantLock}</h3>\n *\n * <p>This version is much more verbose than the {@code synchronized} version, and still suffers\n * from the need for the programmer to remember to use {@code while} instead of {@code if}. However,\n * one advantage is that we can introduce two separate {@code Condition} objects, which allows us to\n * use {@code signal()} instead of {@code signalAll()}, which may be a performance benefit.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final ReentrantLock lock = new ReentrantLock();\n *   private final Condition valuePresent = lock.newCondition();\n *   private final Condition valueAbsent = lock.newCondition();\n *\n *   public V get() throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value == null) {\n *         valuePresent.await();\n *       }\n *       V result = value;\n *       value = null;\n *       valueAbsent.signal();\n *       return result;\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value != null) {\n *         valueAbsent.await();\n *       }\n *       value = newValue;\n *       valuePresent.signal();\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code Monitor}</h3>\n *\n * <p>This version adds some verbosity around the {@code Guard} objects, but removes that same\n * verbosity, and more, from the {@code get} and {@code set} methods. {@code Monitor} implements the\n * same efficient signaling as we had to hand-code in the {@code ReentrantLock} version above.\n * Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to\n * remember to use {@code while} instead of {@code if}.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final Monitor monitor = new Monitor();\n *   private final Monitor.Guard valuePresent = monitor.newGuard(() -> value != null);\n *   private final Monitor.Guard valueAbsent = monitor.newGuard(() -> value == null);\n *\n *   public V get() throws InterruptedException {\n *     monitor.enterWhen(valuePresent);\n *     try {\n *       V result = value;\n *       value = null;\n *       return result;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     monitor.enterWhen(valueAbsent);\n *     try {\n *       value = newValue;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n * }\n * }</pre>\n *\n * @author Justin T. Sampson\n * @author Martin Buchholz\n * @since 10.0\n */\n@Beta\n@GwtIncompatible\n@SuppressWarnings(\"GuardedBy\") // TODO(b/35466881): Fix or suppress.\npublic final class Monitor\n{\n    // TODO(user): Use raw LockSupport or AbstractQueuedSynchronizer instead of ReentrantLock.\n    // TODO(user): \"Port\" jsr166 tests for ReentrantLock.\n    //\n    // TODO(user): Change API to make it impossible to use a Guard with the \"wrong\" monitor,\n    //    by making the monitor implicit, and to eliminate other sources of IMSE.\n    //    Imagine:\n    //    guard.lock();\n    //    try { /* monitor locked and guard satisfied here */ }\n    //    finally { guard.unlock(); }\n    // Here are Justin's design notes about this:\n    //\n    // This idea has come up from time to time, and I think one of my\n    // earlier versions of Monitor even did something like this. I ended\n    // up strongly favoring the current interface.\n    //\n    // I probably can't remember all the reasons (it's possible you\n    // could find them in the code review archives), but here are a few:\n    //\n    // 1. What about leaving/unlocking? Are you going to do\n    //    guard.enter() paired with monitor.leave()? That might get\n    //    confusing. It's nice for the finally block to look as close as\n    //    possible to the thing right before the try. You could have\n    //    guard.leave(), but that's a little odd as well because the\n    //    guard doesn't have anything to do with leaving. You can't\n    //    really enforce that the guard you're leaving is the same one\n    //    you entered with, and it doesn't actually matter.\n    //\n    // 2. Since you can enter the monitor without a guard at all, some\n    //    places you'll have monitor.enter()/monitor.leave() and other\n    //    places you'll have guard.enter()/guard.leave() even though\n    //    it's the same lock being acquired underneath. Always using\n    //    monitor.enterXXX()/monitor.leave() will make it really clear\n    //    which lock is held at any point in the code.\n    //\n    // 3. I think \"enterWhen(notEmpty)\" reads better than \"notEmpty.enter()\".\n    //\n    // TODO(user): Implement ReentrantLock features:\n    //    - toString() method\n    //    - getOwner() method\n    //    - getQueuedThreads() method\n    //    - getWaitingThreads(Guard) method\n    //    - implement Serializable\n    //    - redo the API to be as close to identical to ReentrantLock as possible,\n    //      since, after all, this class is also a reentrant mutual exclusion lock!?\n\n    /*\n     * One of the key challenges of this class is to prevent lost signals, while trying hard to\n     * minimize unnecessary signals. One simple and correct algorithm is to signal some other waiter\n     * with a satisfied guard (if one exists) whenever any thread occupying the monitor exits the\n     * monitor, either by unlocking all of its held locks, or by starting to wait for a guard. This\n     * includes exceptional exits, so all control paths involving signalling must be protected by a\n     * finally block.\n     *\n     * Further optimizations of this algorithm become increasingly subtle. A wait that terminates\n     * without the guard being satisfied (due to timeout, but not interrupt) can then immediately exit\n     * the monitor without signalling. If it timed out without being signalled, it does not need to\n     * \"pass on\" the signal to another thread. If it *was* signalled, then its guard must have been\n     * satisfied at the time of signal, and has since been modified by some other thread to be\n     * non-satisfied before reacquiring the lock, and that other thread takes over the responsibility\n     * of signaling the next waiter.\n     *\n     * Unlike the underlying Condition, if we are not careful, an interrupt *can* cause a signal to be\n     * lost, because the signal may be sent to a condition whose sole waiter has just been\n     * interrupted.\n     *\n     * Imagine a monitor with multiple guards. A thread enters the monitor, satisfies all the guards,\n     * and leaves, calling signalNextWaiter. With traditional locks and conditions, all the conditions\n     * need to be signalled because it is not known which if any of them have waiters (and hasWaiters\n     * can't be used reliably because of a check-then-act race). With our Monitor guards, we only\n     * signal the first active guard that is satisfied. But the corresponding thread may have already\n     * been interrupted and is waiting to reacquire the lock while still registered in activeGuards,\n     * in which case the signal is a no-op, and the bigger-picture signal is lost unless interrupted\n     * threads take special action by participating in the signal-passing game.\n     */\n\n    /*\n     * Timeout handling is intricate, especially given our ambitious goals:\n     * - Avoid underflow and overflow of timeout values when specified timeouts are close to\n     *   Long.MIN_VALUE or Long.MAX_VALUE.\n     * - Favor responding to interrupts over timeouts.\n     * - System.nanoTime() is expensive enough that we want to call it the minimum required number of\n     *   times, typically once before invoking a blocking method. This often requires keeping track of\n     *   the first time in a method that nanoTime() has been invoked, for which the special value 0L\n     *   is reserved to mean \"uninitialized\". If timeout is non-positive, then nanoTime need never be\n     *   called.\n     * - Keep behavior of fair and non-fair instances consistent.\n     */\n\n    /**\n     * A boolean condition for which a thread may wait. A {@code Guard} is associated with a single\n     * {@code Monitor}. The monitor may check the guard at arbitrary times from any thread occupying\n     * the monitor, so code should not be written to rely on how often a guard might or might not be\n     * checked.\n     *\n     * <p>If a {@code Guard} is passed into any method of a {@code Monitor} other than the one it is\n     * associated with, an {@link IllegalMonitorStateException} is thrown.\n     *\n     * @since 10.0\n     */\n    @Beta\n    public abstract static class Guard\n    {\n\n        @Weak final Monitor monitor;\n        final Condition condition;\n\n        @GuardedBy(\"monitor.lock\")\n        int waiterCount = 0;\n\n        /** The next active guard */\n        @GuardedBy(\"monitor.lock\")\n        @NullableDecl\n        Guard next;\n\n        protected Guard(Monitor monitor)\n        {\n            this.monitor = checkNotNull(monitor, \"monitor\");\n            this.condition = monitor.lock.newCondition();\n        }\n\n        /**\n         * Evaluates this guard's boolean condition. This method is always called with the associated\n         * monitor already occupied. Implementations of this method must depend only on state protected\n         * by the associated monitor, and must not modify that state.\n         */\n        public abstract boolean isSatisfied();\n    }\n\n    /** Whether this monitor is fair. */\n    private final boolean fair;\n\n    /** The lock underlying this monitor. */\n    private final ReentrantLock lock;\n\n    /**\n     * The guards associated with this monitor that currently have waiters ({@code waiterCount > 0}).\n     * A linked list threaded through the Guard.next field.\n     */\n    @GuardedBy(\"lock\")\n    private Guard activeGuards = null;\n\n    /**\n     * Creates a monitor with a non-fair (but fast) ordering policy. Equivalent to {@code\n     * Monitor(false)}.\n     */\n    public Monitor()\n    {\n        this(false);\n    }\n\n    /**\n     * Creates a monitor with the given ordering policy.\n     *\n     * @param fair whether this monitor should use a fair ordering policy rather than a non-fair (but\n     *     fast) one\n     */\n    public Monitor(boolean fair)\n    {\n        this.fair = fair;\n        this.lock = new ReentrantLock(fair);\n    }\n\n    /** Enters this monitor. Blocks indefinitely. */\n    public void enter()\n    {\n        lock.lock();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time.\n     *\n     * @return whether the monitor was entered\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enter(long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        final ReentrantLock lock = this.lock;\n        if (!fair && lock.tryLock())\n        {\n            return true;\n        }\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            final long startTime = System.nanoTime();\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterInterruptibly() throws InterruptedException\n    {\n        lock.lockInterruptibly();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time, and may be interrupted.\n     *\n     * @return whether the monitor was entered\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n    {\n        return lock.tryLock(time, unit);\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately. Does not block.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered\n     */\n    public boolean tryEnter()\n    {\n        return lock.tryLock();\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterWhen(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                await(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied, and may be\n     * interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean reentrant = lock.isHeldByCurrentThread();\n        long startTime = 0L;\n\n        locked:\n        {\n            if (!fair)\n            {\n                // Check interrupt status to get behavior consistent with fair case.\n                if (Thread.interrupted())\n                {\n                    throw new InterruptedException();\n                }\n                if (lock.tryLock())\n                {\n                    break locked;\n                }\n            }\n            startTime = initNanoTime(timeoutNanos);\n            if (!lock.tryLock(time, unit))\n            {\n                return false;\n            }\n        }\n\n        boolean satisfied = false;\n        boolean threw = true;\n        try\n        {\n            satisfied =\n                guard.isSatisfied()\n                || awaitNanos(\n                    guard,\n                    (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),\n                    reentrant);\n            threw = false;\n            return satisfied;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                try\n                {\n                    // Don't need to signal if timed out, but do if interrupted\n                    if (threw && !reentrant)\n                    {\n                        signalNextWaiter();\n                    }\n                }\n                finally\n                {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n\n    /** Enters this monitor when the guard is satisfied. Blocks indefinitely. */\n    public void enterWhenUninterruptibly(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                awaitUninterruptibly(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        long startTime = 0L;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            if (fair || !lock.tryLock())\n            {\n                startTime = initNanoTime(timeoutNanos);\n                for (long remainingNanos = timeoutNanos; ; )\n                {\n                    try\n                    {\n                        if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS))\n                        {\n                            break;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        remainingNanos = remainingNanos(startTime, timeoutNanos);\n                    }\n                }\n            }\n\n            boolean satisfied = false;\n            try\n            {\n                while (true)\n                {\n                    try\n                    {\n                        if (guard.isSatisfied())\n                        {\n                            satisfied = true;\n                        }\n                        else\n                        {\n                            final long remainingNanos;\n                            if (startTime == 0L)\n                            {\n                                startTime = initNanoTime(timeoutNanos);\n                                remainingNanos = timeoutNanos;\n                            }\n                            else\n                            {\n                                remainingNanos = remainingNanos(startTime, timeoutNanos);\n                            }\n                            satisfied = awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                        }\n                        return satisfied;\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        signalBeforeWaiting = false;\n                    }\n                }\n            }\n            finally\n            {\n                if (!satisfied)\n                {\n                    lock.unlock(); // No need to signal if timed out\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean enterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!enter(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n    throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not\n     * block acquiring the lock and does not wait for the guard to be satisfied.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean tryEnterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock())\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be called\n     * only by a thread currently occupying this monitor.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void waitFor(Guard guard) throws InterruptedException\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            await(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted. May\n     * be called only by a thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        if (Thread.interrupted())\n        {\n            throw new InterruptedException();\n        }\n        return awaitNanos(guard, timeoutNanos, true);\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread\n     * currently occupying this monitor.\n     */\n    public void waitForUninterruptibly(Guard guard)\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            awaitUninterruptibly(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time. May be called only by a\n     * thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     */\n\n    /** Leaves this monitor. May be called only by a thread currently occupying this monitor. */\n    public void leave()\n    {\n        final ReentrantLock lock = this.lock;\n        try\n        {\n            // No need to signal if we will still be holding the lock when we return\n            if (lock.getHoldCount() == 1)\n            {\n                signalNextWaiter();\n            }\n        }\n        finally\n        {\n            lock.unlock(); // Will throw IllegalMonitorStateException if not held\n        }\n    }\n\n    /** Returns whether this monitor is using a fair ordering policy. */\n    public boolean isFair()\n    {\n        return fair;\n    }\n\n    /**\n     * Returns whether this monitor is occupied by any thread. This method is designed for use in\n     * monitoring of the system state, not for synchronization control.\n     */\n    public boolean isOccupied()\n    {\n        return lock.isLocked();\n    }\n\n    /**\n     * Returns whether the current thread is occupying this monitor (has entered more times than it\n     * has left).\n     */\n    public boolean isOccupiedByCurrentThread()\n    {\n        return lock.isHeldByCurrentThread();\n    }\n\n    /**\n     * Returns the number of times the current thread has entered this monitor in excess of the number\n     * of times it has left. Returns 0 if the current thread is not occupying this monitor.\n     */\n    public int getOccupiedDepth()\n    {\n        return lock.getHoldCount();\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting to enter this monitor. The value is only\n     * an estimate because the number of threads may change dynamically while this method traverses\n     * internal data structures. This method is designed for use in monitoring of the system state,\n     * not for synchronization control.\n     */\n    public int getQueueLength()\n    {\n        return lock.getQueueLength();\n    }\n\n    /**\n     * Returns whether any threads are waiting to enter this monitor. Note that because cancellations\n     * may occur at any time, a {@code true} return does not guarantee that any other thread will ever\n     * enter this monitor. This method is designed primarily for use in monitoring of the system\n     * state.\n     */\n    public boolean hasQueuedThreads()\n    {\n        return lock.hasQueuedThreads();\n    }\n\n    /**\n     * Queries whether the given thread is waiting to enter this monitor. Note that because\n     * cancellations may occur at any time, a {@code true} return does not guarantee that this thread\n     * will ever enter this monitor. This method is designed primarily for use in monitoring of the\n     * system state.\n     */\n    public boolean hasQueuedThread(Thread thread)\n    {\n        return lock.hasQueuedThread(thread);\n    }\n\n    /**\n     * Queries whether any threads are waiting for the given guard to become satisfied. Note that\n     * because timeouts and interrupts may occur at any time, a {@code true} return does not guarantee\n     * that the guard becoming satisfied in the future will awaken any threads. This method is\n     * designed primarily for use in monitoring of the system state.\n     */\n    public boolean hasWaiters(Guard guard)\n    {\n        return getWaitQueueLength(guard) > 0;\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting for the given guard to become satisfied.\n     * Note that because timeouts and interrupts may occur at any time, the estimate serves only as an\n     * upper bound on the actual number of waiters. This method is designed for use in monitoring of\n     * the system state, not for synchronization control.\n     */\n    public int getWaitQueueLength(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        lock.lock();\n        try\n        {\n            return guard.waiterCount;\n        }\n        finally\n        {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Returns unit.toNanos(time), additionally ensuring the returned value is not at risk of\n     * overflowing or underflowing, by bounding the value between 0 and (Long.MAX_VALUE / 4) * 3.\n     * Actually waiting for more than 219 years is not supported!\n     */\n    private static long toSafeNanos(long time, TimeUnit unit)\n    {\n        long timeoutNanos = unit.toNanos(time);\n        return (timeoutNanos <= 0L)\n               ? 0L\n               : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3 : timeoutNanos;\n    }\n\n    /**\n     * Returns System.nanoTime() unless the timeout has already elapsed. Returns 0L if and only if the\n     * timeout has already elapsed.\n     */\n    private static long initNanoTime(long timeoutNanos)\n    {\n        if (timeoutNanos <= 0L)\n        {\n            return 0L;\n        }\n        else\n        {\n            long startTime = System.nanoTime();\n            return (startTime == 0L) ? 1L : startTime;\n        }\n    }\n\n    /**\n     * Returns the remaining nanos until the given timeout, or 0L if the timeout has already elapsed.\n     * Caller must have previously sanitized timeoutNanos using toSafeNanos.\n     */\n    private static long remainingNanos(long startTime, long timeoutNanos)\n    {\n        // assert timeoutNanos == 0L || startTime != 0L;\n\n        // TODO : NOT CORRECT, BUT TESTS PASS ANYWAYS!\n        // if (true) return timeoutNanos;\n        // ONLY 2 TESTS FAIL IF WE DO:\n        // if (true) return 0;\n\n        return (timeoutNanos <= 0L) ? 0L : timeoutNanos - (System.nanoTime() - startTime);\n    }\n\n    /**\n     * Signals some other thread waiting on a satisfied guard, if one exists.\n     *\n     * <p>We manage calls to this method carefully, to signal only when necessary, but never losing a\n     * signal, which is the classic problem of this kind of concurrency construct. We must signal if\n     * the current thread is about to relinquish the lock and may have changed the state protected by\n     * the monitor, thereby causing some guard to be satisfied.\n     *\n     * <p>In addition, any thread that has been signalled when its guard was satisfied acquires the\n     * responsibility of signalling the next thread when it again relinquishes the lock. Unlike a\n     * normal Condition, there is no guarantee that an interrupted thread has not been signalled,\n     * since the concurrency control must manage multiple Conditions. So this method must generally be\n     * called when waits are interrupted.\n     *\n     * <p>On the other hand, if a signalled thread wakes up to discover that its guard is still not\n     * satisfied, it does *not* need to call this method before returning to wait. This can only\n     * happen due to spurious wakeup (ignorable) or another thread acquiring the lock before the\n     * current thread can and returning the guard to the unsatisfied state. In the latter case the\n     * other thread (last thread modifying the state protected by the monitor) takes over the\n     * responsibility of signalling the next waiter.\n     *\n     * <p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else\n     * the current thread's guard might be mistakenly signalled, leading to a lost signal.\n     */\n    @GuardedBy(\"lock\")\n    private void signalNextWaiter()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            if (isSatisfied(guard))\n            {\n                guard.condition.signal();\n                break;\n            }\n        }\n    }\n\n    /**\n     * Exactly like signalNextWaiter, but caller guarantees that guardToSkip need not be considered,\n     * because caller has previously checked that guardToSkip.isSatisfied() returned false. An\n     * optimization for the case that guardToSkip.isSatisfied() may be expensive.\n     *\n     * <p>We decided against using this method, since in practice, isSatisfied() is likely to be very\n     * cheap (typically one field read). Resurrect this method if you find that not to be true.\n     */\n    //   @GuardedBy(\"lock\")\n    //   private void signalNextWaiterSkipping(Guard guardToSkip) {\n    //     for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n    //       if (guard != guardToSkip && isSatisfied(guard)) {\n    //         guard.condition.signal();\n    //         break;\n    //       }\n    //     }\n    //   }\n\n    /**\n     * Exactly like guard.isSatisfied(), but in addition signals all waiting threads in the (hopefully\n     * unlikely) event that isSatisfied() throws.\n     */\n    @GuardedBy(\"lock\")\n    private boolean isSatisfied(Guard guard)\n    {\n        try\n        {\n            return guard.isSatisfied();\n        }\n        catch (Throwable throwable)\n        {\n            signalAllWaiters();\n            throw throwable;\n        }\n    }\n\n    /** Signals all threads waiting on guards. */\n    @GuardedBy(\"lock\")\n    private void signalAllWaiters()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            guard.condition.signalAll();\n        }\n    }\n\n    /** Records that the current thread is about to wait on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void beginWaitingFor(Guard guard)\n    {\n        int waiters = guard.waiterCount++;\n        if (waiters == 0)\n        {\n            // push guard onto activeGuards\n            guard.next = activeGuards;\n            activeGuards = guard;\n        }\n    }\n\n    /** Records that the current thread is no longer waiting on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void endWaitingFor(Guard guard)\n    {\n        int waiters = --guard.waiterCount;\n        if (waiters == 0)\n        {\n            // unlink guard from activeGuards\n            for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next)\n            {\n                if (p == guard)\n                {\n                    if (pred == null)\n                    {\n                        activeGuards = p.next;\n                    }\n                    else\n                    {\n                        pred.next = p.next;\n                    }\n                    p.next = null; // help GC\n                    break;\n                }\n            }\n        }\n    }\n\n    /*\n     * Methods that loop waiting on a guard's condition until the guard is satisfied, while recording\n     * this fact so that other threads know to check our guard and signal us. It's caller's\n     * responsibility to ensure that the guard is *not* currently satisfied.\n     */\n\n    @GuardedBy(\"lock\")\n    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.await();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    @GuardedBy(\"lock\")\n    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.awaitUninterruptibly();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    /** Caller should check before calling that guard is not satisfied. */\n    @GuardedBy(\"lock\")\n    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n    throws InterruptedException\n    {\n        boolean firstTime = true;\n        try\n        {\n            do\n            {\n                if (nanos <= 0L)\n                {\n                    return false;\n                }\n                if (firstTime)\n                {\n                    if (signalBeforeWaiting)\n                    {\n                        signalNextWaiter();\n                    }\n                    beginWaitingFor(guard);\n                    firstTime = false;\n                }\n                nanos = guard.condition.awaitNanos(nanos);\n            }\n            while (!guard.isSatisfied());\n            return true;\n        }\n        finally\n        {\n            if (!firstTime)\n            {\n                endWaitingFor(guard);\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.getWaitQueueLength", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns an estimate of the number of threads waiting for the given guard to become satisfied.\nNote that because timeouts and interrupts may occur at any time, the estimate serves only as an\nupper bound on the actual number of waiters. This method is designed for use in monitoring of\nthe system state, not for synchronization control.", "docstring_tokens": ["Returns", "an", "estimate", "of", "the", "number", "of", "threads", "waiting", "for", "the", "given", "guard", "to", "become", "satisfied", ".", "Note", "that", "because", "timeouts", "and", "interrupts", "may", "occur", "at", "any", "time", "the", "estimate", "serves", "only", "as", "an", "upper", "bound", "on", "the", "actual", "number", "of", "waiters", ".", "This", "method", "is", "designed", "for", "use", "in", "monitoring", "of", "the", "system", "state", "not", "for", "synchronization", "control", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L904-L914", "partition": "valid", "up_fun_num": 29, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.errorprone.annotations.concurrent.GuardedBy;", "import com.google.j2objc.annotations.Weak;", "import java.util.concurrent.TimeUnit;", "import java.util.concurrent.locks.Condition;", "import java.util.concurrent.locks.ReentrantLock;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Monitor\n", "    public void enter()\n", "    public boolean enter(long time, TimeUnit unit)\n", "    public void enterInterruptibly() throws InterruptedException\n", "    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n", "    public boolean tryEnter()\n", "    public void enterWhen(Guard guard) throws InterruptedException\n", "    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void enterWhenUninterruptibly(Guard guard)\n", "    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIf(Guard guard)\n", "    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n", "    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean tryEnterIf(Guard guard)\n", "    public void waitFor(Guard guard) throws InterruptedException\n", "    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void waitForUninterruptibly(Guard guard)\n", "    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public void leave()\n", "    public boolean isFair()\n", "    public boolean isOccupied()\n", "    public boolean isOccupiedByCurrentThread()\n", "    public int getOccupiedDepth()\n", "    public int getQueueLength()\n", "    public boolean hasQueuedThreads()\n", "    public boolean hasQueuedThread(Thread thread)\n", "    public boolean hasWaiters(Guard guard)\n", "    private static long toSafeNanos(long time, TimeUnit unit)\n", "    private static long initNanoTime(long timeoutNanos)\n", "    private static long remainingNanos(long startTime, long timeoutNanos)\n", "    private void signalNextWaiter()\n", "    private boolean isSatisfied(Guard guard)\n", "    private void signalAllWaiters()\n", "    private void beginWaitingFor(Guard guard)\n", "    private void endWaitingFor(Guard guard)\n", "    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n", "    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n", "    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n"], "context": "/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.concurrent.GuardedBy;\nimport com.google.j2objc.annotations.Weak;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A synchronization abstraction supporting waiting on arbitrary boolean conditions.\n *\n * <p>This class is intended as a replacement for {@link ReentrantLock}. Code using {@code Monitor}\n * is less error-prone and more readable than code using {@code ReentrantLock}, without significant\n * performance loss. {@code Monitor} even has the potential for performance gain by optimizing the\n * evaluation and signaling of conditions. Signaling is entirely <a\n * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>. By\n * eliminating explicit signaling, this class can guarantee that only one thread is awakened when a\n * condition becomes true (no \"signaling storms\" due to use of {@link\n * java.util.concurrent.locks.Condition#signalAll Condition.signalAll}) and that no signals are lost\n * (no \"hangs\" due to incorrect use of {@link java.util.concurrent.locks.Condition#signal\n * Condition.signal}).\n *\n * <p>A thread is said to <i>occupy</i> a monitor if it has <i>entered</i> the monitor but not yet\n * <i>left</i>. Only one thread may occupy a given monitor at any moment. A monitor is also\n * reentrant, so a thread may enter a monitor any number of times, and then must leave the same\n * number of times. The <i>enter</i> and <i>leave</i> operations have the same synchronization\n * semantics as the built-in Java language synchronization primitives.\n *\n * <p>A call to any of the <i>enter</i> methods with <b>void</b> return type should always be\n * followed immediately by a <i>try/finally</i> block to ensure that the current thread leaves the\n * monitor cleanly:\n *\n * <pre>{@code\n * monitor.enter();\n * try {\n *   // do things while occupying the monitor\n * } finally {\n *   monitor.leave();\n * }\n * }</pre>\n *\n * <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear\n * as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that\n * the current thread leaves the monitor cleanly:\n *\n * <pre>{@code\n * if (monitor.tryEnter()) {\n *   try {\n *     // do things while occupying the monitor\n *   } finally {\n *     monitor.leave();\n *   }\n * } else {\n *   // do other things since the monitor was not available\n * }\n * }</pre>\n *\n * <h2>Comparison with {@code synchronized} and {@code ReentrantLock}</h2>\n *\n * <p>The following examples show a simple threadsafe holder expressed using {@code synchronized},\n * {@link ReentrantLock}, and {@code Monitor}.\n *\n * <h3>{@code synchronized}</h3>\n *\n * <p>This version is the fewest lines of code, largely because the synchronization mechanism used\n * is built into the language and runtime. But the programmer has to remember to avoid a couple of\n * common bugs: The {@code wait()} must be inside a {@code while} instead of an {@code if}, and\n * {@code notifyAll()} must be used instead of {@code notify()} because there are two different\n * logical conditions being awaited.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *\n *   public synchronized V get() throws InterruptedException {\n *     while (value == null) {\n *       wait();\n *     }\n *     V result = value;\n *     value = null;\n *     notifyAll();\n *     return result;\n *   }\n *\n *   public synchronized void set(V newValue) throws InterruptedException {\n *     while (value != null) {\n *       wait();\n *     }\n *     value = newValue;\n *     notifyAll();\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code ReentrantLock}</h3>\n *\n * <p>This version is much more verbose than the {@code synchronized} version, and still suffers\n * from the need for the programmer to remember to use {@code while} instead of {@code if}. However,\n * one advantage is that we can introduce two separate {@code Condition} objects, which allows us to\n * use {@code signal()} instead of {@code signalAll()}, which may be a performance benefit.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final ReentrantLock lock = new ReentrantLock();\n *   private final Condition valuePresent = lock.newCondition();\n *   private final Condition valueAbsent = lock.newCondition();\n *\n *   public V get() throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value == null) {\n *         valuePresent.await();\n *       }\n *       V result = value;\n *       value = null;\n *       valueAbsent.signal();\n *       return result;\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value != null) {\n *         valueAbsent.await();\n *       }\n *       value = newValue;\n *       valuePresent.signal();\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code Monitor}</h3>\n *\n * <p>This version adds some verbosity around the {@code Guard} objects, but removes that same\n * verbosity, and more, from the {@code get} and {@code set} methods. {@code Monitor} implements the\n * same efficient signaling as we had to hand-code in the {@code ReentrantLock} version above.\n * Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to\n * remember to use {@code while} instead of {@code if}.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final Monitor monitor = new Monitor();\n *   private final Monitor.Guard valuePresent = monitor.newGuard(() -> value != null);\n *   private final Monitor.Guard valueAbsent = monitor.newGuard(() -> value == null);\n *\n *   public V get() throws InterruptedException {\n *     monitor.enterWhen(valuePresent);\n *     try {\n *       V result = value;\n *       value = null;\n *       return result;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     monitor.enterWhen(valueAbsent);\n *     try {\n *       value = newValue;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n * }\n * }</pre>\n *\n * @author Justin T. Sampson\n * @author Martin Buchholz\n * @since 10.0\n */\n@Beta\n@GwtIncompatible\n@SuppressWarnings(\"GuardedBy\") // TODO(b/35466881): Fix or suppress.\npublic final class Monitor\n{\n    // TODO(user): Use raw LockSupport or AbstractQueuedSynchronizer instead of ReentrantLock.\n    // TODO(user): \"Port\" jsr166 tests for ReentrantLock.\n    //\n    // TODO(user): Change API to make it impossible to use a Guard with the \"wrong\" monitor,\n    //    by making the monitor implicit, and to eliminate other sources of IMSE.\n    //    Imagine:\n    //    guard.lock();\n    //    try { /* monitor locked and guard satisfied here */ }\n    //    finally { guard.unlock(); }\n    // Here are Justin's design notes about this:\n    //\n    // This idea has come up from time to time, and I think one of my\n    // earlier versions of Monitor even did something like this. I ended\n    // up strongly favoring the current interface.\n    //\n    // I probably can't remember all the reasons (it's possible you\n    // could find them in the code review archives), but here are a few:\n    //\n    // 1. What about leaving/unlocking? Are you going to do\n    //    guard.enter() paired with monitor.leave()? That might get\n    //    confusing. It's nice for the finally block to look as close as\n    //    possible to the thing right before the try. You could have\n    //    guard.leave(), but that's a little odd as well because the\n    //    guard doesn't have anything to do with leaving. You can't\n    //    really enforce that the guard you're leaving is the same one\n    //    you entered with, and it doesn't actually matter.\n    //\n    // 2. Since you can enter the monitor without a guard at all, some\n    //    places you'll have monitor.enter()/monitor.leave() and other\n    //    places you'll have guard.enter()/guard.leave() even though\n    //    it's the same lock being acquired underneath. Always using\n    //    monitor.enterXXX()/monitor.leave() will make it really clear\n    //    which lock is held at any point in the code.\n    //\n    // 3. I think \"enterWhen(notEmpty)\" reads better than \"notEmpty.enter()\".\n    //\n    // TODO(user): Implement ReentrantLock features:\n    //    - toString() method\n    //    - getOwner() method\n    //    - getQueuedThreads() method\n    //    - getWaitingThreads(Guard) method\n    //    - implement Serializable\n    //    - redo the API to be as close to identical to ReentrantLock as possible,\n    //      since, after all, this class is also a reentrant mutual exclusion lock!?\n\n    /*\n     * One of the key challenges of this class is to prevent lost signals, while trying hard to\n     * minimize unnecessary signals. One simple and correct algorithm is to signal some other waiter\n     * with a satisfied guard (if one exists) whenever any thread occupying the monitor exits the\n     * monitor, either by unlocking all of its held locks, or by starting to wait for a guard. This\n     * includes exceptional exits, so all control paths involving signalling must be protected by a\n     * finally block.\n     *\n     * Further optimizations of this algorithm become increasingly subtle. A wait that terminates\n     * without the guard being satisfied (due to timeout, but not interrupt) can then immediately exit\n     * the monitor without signalling. If it timed out without being signalled, it does not need to\n     * \"pass on\" the signal to another thread. If it *was* signalled, then its guard must have been\n     * satisfied at the time of signal, and has since been modified by some other thread to be\n     * non-satisfied before reacquiring the lock, and that other thread takes over the responsibility\n     * of signaling the next waiter.\n     *\n     * Unlike the underlying Condition, if we are not careful, an interrupt *can* cause a signal to be\n     * lost, because the signal may be sent to a condition whose sole waiter has just been\n     * interrupted.\n     *\n     * Imagine a monitor with multiple guards. A thread enters the monitor, satisfies all the guards,\n     * and leaves, calling signalNextWaiter. With traditional locks and conditions, all the conditions\n     * need to be signalled because it is not known which if any of them have waiters (and hasWaiters\n     * can't be used reliably because of a check-then-act race). With our Monitor guards, we only\n     * signal the first active guard that is satisfied. But the corresponding thread may have already\n     * been interrupted and is waiting to reacquire the lock while still registered in activeGuards,\n     * in which case the signal is a no-op, and the bigger-picture signal is lost unless interrupted\n     * threads take special action by participating in the signal-passing game.\n     */\n\n    /*\n     * Timeout handling is intricate, especially given our ambitious goals:\n     * - Avoid underflow and overflow of timeout values when specified timeouts are close to\n     *   Long.MIN_VALUE or Long.MAX_VALUE.\n     * - Favor responding to interrupts over timeouts.\n     * - System.nanoTime() is expensive enough that we want to call it the minimum required number of\n     *   times, typically once before invoking a blocking method. This often requires keeping track of\n     *   the first time in a method that nanoTime() has been invoked, for which the special value 0L\n     *   is reserved to mean \"uninitialized\". If timeout is non-positive, then nanoTime need never be\n     *   called.\n     * - Keep behavior of fair and non-fair instances consistent.\n     */\n\n    /**\n     * A boolean condition for which a thread may wait. A {@code Guard} is associated with a single\n     * {@code Monitor}. The monitor may check the guard at arbitrary times from any thread occupying\n     * the monitor, so code should not be written to rely on how often a guard might or might not be\n     * checked.\n     *\n     * <p>If a {@code Guard} is passed into any method of a {@code Monitor} other than the one it is\n     * associated with, an {@link IllegalMonitorStateException} is thrown.\n     *\n     * @since 10.0\n     */\n    @Beta\n    public abstract static class Guard\n    {\n\n        @Weak final Monitor monitor;\n        final Condition condition;\n\n        @GuardedBy(\"monitor.lock\")\n        int waiterCount = 0;\n\n        /** The next active guard */\n        @GuardedBy(\"monitor.lock\")\n        @NullableDecl\n        Guard next;\n\n        protected Guard(Monitor monitor)\n        {\n            this.monitor = checkNotNull(monitor, \"monitor\");\n            this.condition = monitor.lock.newCondition();\n        }\n\n        /**\n         * Evaluates this guard's boolean condition. This method is always called with the associated\n         * monitor already occupied. Implementations of this method must depend only on state protected\n         * by the associated monitor, and must not modify that state.\n         */\n        public abstract boolean isSatisfied();\n    }\n\n    /** Whether this monitor is fair. */\n    private final boolean fair;\n\n    /** The lock underlying this monitor. */\n    private final ReentrantLock lock;\n\n    /**\n     * The guards associated with this monitor that currently have waiters ({@code waiterCount > 0}).\n     * A linked list threaded through the Guard.next field.\n     */\n    @GuardedBy(\"lock\")\n    private Guard activeGuards = null;\n\n    /**\n     * Creates a monitor with a non-fair (but fast) ordering policy. Equivalent to {@code\n     * Monitor(false)}.\n     */\n    public Monitor()\n    {\n        this(false);\n    }\n\n    /**\n     * Creates a monitor with the given ordering policy.\n     *\n     * @param fair whether this monitor should use a fair ordering policy rather than a non-fair (but\n     *     fast) one\n     */\n    public Monitor(boolean fair)\n    {\n        this.fair = fair;\n        this.lock = new ReentrantLock(fair);\n    }\n\n    /** Enters this monitor. Blocks indefinitely. */\n    public void enter()\n    {\n        lock.lock();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time.\n     *\n     * @return whether the monitor was entered\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enter(long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        final ReentrantLock lock = this.lock;\n        if (!fair && lock.tryLock())\n        {\n            return true;\n        }\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            final long startTime = System.nanoTime();\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterInterruptibly() throws InterruptedException\n    {\n        lock.lockInterruptibly();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time, and may be interrupted.\n     *\n     * @return whether the monitor was entered\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n    {\n        return lock.tryLock(time, unit);\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately. Does not block.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered\n     */\n    public boolean tryEnter()\n    {\n        return lock.tryLock();\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterWhen(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                await(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied, and may be\n     * interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean reentrant = lock.isHeldByCurrentThread();\n        long startTime = 0L;\n\n        locked:\n        {\n            if (!fair)\n            {\n                // Check interrupt status to get behavior consistent with fair case.\n                if (Thread.interrupted())\n                {\n                    throw new InterruptedException();\n                }\n                if (lock.tryLock())\n                {\n                    break locked;\n                }\n            }\n            startTime = initNanoTime(timeoutNanos);\n            if (!lock.tryLock(time, unit))\n            {\n                return false;\n            }\n        }\n\n        boolean satisfied = false;\n        boolean threw = true;\n        try\n        {\n            satisfied =\n                guard.isSatisfied()\n                || awaitNanos(\n                    guard,\n                    (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),\n                    reentrant);\n            threw = false;\n            return satisfied;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                try\n                {\n                    // Don't need to signal if timed out, but do if interrupted\n                    if (threw && !reentrant)\n                    {\n                        signalNextWaiter();\n                    }\n                }\n                finally\n                {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n\n    /** Enters this monitor when the guard is satisfied. Blocks indefinitely. */\n    public void enterWhenUninterruptibly(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                awaitUninterruptibly(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        long startTime = 0L;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            if (fair || !lock.tryLock())\n            {\n                startTime = initNanoTime(timeoutNanos);\n                for (long remainingNanos = timeoutNanos; ; )\n                {\n                    try\n                    {\n                        if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS))\n                        {\n                            break;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        remainingNanos = remainingNanos(startTime, timeoutNanos);\n                    }\n                }\n            }\n\n            boolean satisfied = false;\n            try\n            {\n                while (true)\n                {\n                    try\n                    {\n                        if (guard.isSatisfied())\n                        {\n                            satisfied = true;\n                        }\n                        else\n                        {\n                            final long remainingNanos;\n                            if (startTime == 0L)\n                            {\n                                startTime = initNanoTime(timeoutNanos);\n                                remainingNanos = timeoutNanos;\n                            }\n                            else\n                            {\n                                remainingNanos = remainingNanos(startTime, timeoutNanos);\n                            }\n                            satisfied = awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                        }\n                        return satisfied;\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        signalBeforeWaiting = false;\n                    }\n                }\n            }\n            finally\n            {\n                if (!satisfied)\n                {\n                    lock.unlock(); // No need to signal if timed out\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean enterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!enter(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n    throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not\n     * block acquiring the lock and does not wait for the guard to be satisfied.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean tryEnterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock())\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be called\n     * only by a thread currently occupying this monitor.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void waitFor(Guard guard) throws InterruptedException\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            await(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted. May\n     * be called only by a thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        if (Thread.interrupted())\n        {\n            throw new InterruptedException();\n        }\n        return awaitNanos(guard, timeoutNanos, true);\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread\n     * currently occupying this monitor.\n     */\n    public void waitForUninterruptibly(Guard guard)\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            awaitUninterruptibly(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time. May be called only by a\n     * thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        boolean signalBeforeWaiting = true;\n        final long startTime = initNanoTime(timeoutNanos);\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    if (guard.isSatisfied())\n                    {\n                        return true;\n                    }\n                    signalBeforeWaiting = false;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /** Leaves this monitor. May be called only by a thread currently occupying this monitor. */\n    public void leave()\n    {\n        final ReentrantLock lock = this.lock;\n        try\n        {\n            // No need to signal if we will still be holding the lock when we return\n            if (lock.getHoldCount() == 1)\n            {\n                signalNextWaiter();\n            }\n        }\n        finally\n        {\n            lock.unlock(); // Will throw IllegalMonitorStateException if not held\n        }\n    }\n\n    /** Returns whether this monitor is using a fair ordering policy. */\n    public boolean isFair()\n    {\n        return fair;\n    }\n\n    /**\n     * Returns whether this monitor is occupied by any thread. This method is designed for use in\n     * monitoring of the system state, not for synchronization control.\n     */\n    public boolean isOccupied()\n    {\n        return lock.isLocked();\n    }\n\n    /**\n     * Returns whether the current thread is occupying this monitor (has entered more times than it\n     * has left).\n     */\n    public boolean isOccupiedByCurrentThread()\n    {\n        return lock.isHeldByCurrentThread();\n    }\n\n    /**\n     * Returns the number of times the current thread has entered this monitor in excess of the number\n     * of times it has left. Returns 0 if the current thread is not occupying this monitor.\n     */\n    public int getOccupiedDepth()\n    {\n        return lock.getHoldCount();\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting to enter this monitor. The value is only\n     * an estimate because the number of threads may change dynamically while this method traverses\n     * internal data structures. This method is designed for use in monitoring of the system state,\n     * not for synchronization control.\n     */\n    public int getQueueLength()\n    {\n        return lock.getQueueLength();\n    }\n\n    /**\n     * Returns whether any threads are waiting to enter this monitor. Note that because cancellations\n     * may occur at any time, a {@code true} return does not guarantee that any other thread will ever\n     * enter this monitor. This method is designed primarily for use in monitoring of the system\n     * state.\n     */\n    public boolean hasQueuedThreads()\n    {\n        return lock.hasQueuedThreads();\n    }\n\n    /**\n     * Queries whether the given thread is waiting to enter this monitor. Note that because\n     * cancellations may occur at any time, a {@code true} return does not guarantee that this thread\n     * will ever enter this monitor. This method is designed primarily for use in monitoring of the\n     * system state.\n     */\n    public boolean hasQueuedThread(Thread thread)\n    {\n        return lock.hasQueuedThread(thread);\n    }\n\n    /**\n     * Queries whether any threads are waiting for the given guard to become satisfied. Note that\n     * because timeouts and interrupts may occur at any time, a {@code true} return does not guarantee\n     * that the guard becoming satisfied in the future will awaken any threads. This method is\n     * designed primarily for use in monitoring of the system state.\n     */\n    public boolean hasWaiters(Guard guard)\n    {\n        return getWaitQueueLength(guard) > 0;\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting for the given guard to become satisfied.\n     * Note that because timeouts and interrupts may occur at any time, the estimate serves only as an\n     * upper bound on the actual number of waiters. This method is designed for use in monitoring of\n     * the system state, not for synchronization control.\n     */\n\n    /**\n     * Returns unit.toNanos(time), additionally ensuring the returned value is not at risk of\n     * overflowing or underflowing, by bounding the value between 0 and (Long.MAX_VALUE / 4) * 3.\n     * Actually waiting for more than 219 years is not supported!\n     */\n    private static long toSafeNanos(long time, TimeUnit unit)\n    {\n        long timeoutNanos = unit.toNanos(time);\n        return (timeoutNanos <= 0L)\n               ? 0L\n               : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3 : timeoutNanos;\n    }\n\n    /**\n     * Returns System.nanoTime() unless the timeout has already elapsed. Returns 0L if and only if the\n     * timeout has already elapsed.\n     */\n    private static long initNanoTime(long timeoutNanos)\n    {\n        if (timeoutNanos <= 0L)\n        {\n            return 0L;\n        }\n        else\n        {\n            long startTime = System.nanoTime();\n            return (startTime == 0L) ? 1L : startTime;\n        }\n    }\n\n    /**\n     * Returns the remaining nanos until the given timeout, or 0L if the timeout has already elapsed.\n     * Caller must have previously sanitized timeoutNanos using toSafeNanos.\n     */\n    private static long remainingNanos(long startTime, long timeoutNanos)\n    {\n        // assert timeoutNanos == 0L || startTime != 0L;\n\n        // TODO : NOT CORRECT, BUT TESTS PASS ANYWAYS!\n        // if (true) return timeoutNanos;\n        // ONLY 2 TESTS FAIL IF WE DO:\n        // if (true) return 0;\n\n        return (timeoutNanos <= 0L) ? 0L : timeoutNanos - (System.nanoTime() - startTime);\n    }\n\n    /**\n     * Signals some other thread waiting on a satisfied guard, if one exists.\n     *\n     * <p>We manage calls to this method carefully, to signal only when necessary, but never losing a\n     * signal, which is the classic problem of this kind of concurrency construct. We must signal if\n     * the current thread is about to relinquish the lock and may have changed the state protected by\n     * the monitor, thereby causing some guard to be satisfied.\n     *\n     * <p>In addition, any thread that has been signalled when its guard was satisfied acquires the\n     * responsibility of signalling the next thread when it again relinquishes the lock. Unlike a\n     * normal Condition, there is no guarantee that an interrupted thread has not been signalled,\n     * since the concurrency control must manage multiple Conditions. So this method must generally be\n     * called when waits are interrupted.\n     *\n     * <p>On the other hand, if a signalled thread wakes up to discover that its guard is still not\n     * satisfied, it does *not* need to call this method before returning to wait. This can only\n     * happen due to spurious wakeup (ignorable) or another thread acquiring the lock before the\n     * current thread can and returning the guard to the unsatisfied state. In the latter case the\n     * other thread (last thread modifying the state protected by the monitor) takes over the\n     * responsibility of signalling the next waiter.\n     *\n     * <p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else\n     * the current thread's guard might be mistakenly signalled, leading to a lost signal.\n     */\n    @GuardedBy(\"lock\")\n    private void signalNextWaiter()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            if (isSatisfied(guard))\n            {\n                guard.condition.signal();\n                break;\n            }\n        }\n    }\n\n    /**\n     * Exactly like signalNextWaiter, but caller guarantees that guardToSkip need not be considered,\n     * because caller has previously checked that guardToSkip.isSatisfied() returned false. An\n     * optimization for the case that guardToSkip.isSatisfied() may be expensive.\n     *\n     * <p>We decided against using this method, since in practice, isSatisfied() is likely to be very\n     * cheap (typically one field read). Resurrect this method if you find that not to be true.\n     */\n    //   @GuardedBy(\"lock\")\n    //   private void signalNextWaiterSkipping(Guard guardToSkip) {\n    //     for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n    //       if (guard != guardToSkip && isSatisfied(guard)) {\n    //         guard.condition.signal();\n    //         break;\n    //       }\n    //     }\n    //   }\n\n    /**\n     * Exactly like guard.isSatisfied(), but in addition signals all waiting threads in the (hopefully\n     * unlikely) event that isSatisfied() throws.\n     */\n    @GuardedBy(\"lock\")\n    private boolean isSatisfied(Guard guard)\n    {\n        try\n        {\n            return guard.isSatisfied();\n        }\n        catch (Throwable throwable)\n        {\n            signalAllWaiters();\n            throw throwable;\n        }\n    }\n\n    /** Signals all threads waiting on guards. */\n    @GuardedBy(\"lock\")\n    private void signalAllWaiters()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            guard.condition.signalAll();\n        }\n    }\n\n    /** Records that the current thread is about to wait on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void beginWaitingFor(Guard guard)\n    {\n        int waiters = guard.waiterCount++;\n        if (waiters == 0)\n        {\n            // push guard onto activeGuards\n            guard.next = activeGuards;\n            activeGuards = guard;\n        }\n    }\n\n    /** Records that the current thread is no longer waiting on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void endWaitingFor(Guard guard)\n    {\n        int waiters = --guard.waiterCount;\n        if (waiters == 0)\n        {\n            // unlink guard from activeGuards\n            for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next)\n            {\n                if (p == guard)\n                {\n                    if (pred == null)\n                    {\n                        activeGuards = p.next;\n                    }\n                    else\n                    {\n                        pred.next = p.next;\n                    }\n                    p.next = null; // help GC\n                    break;\n                }\n            }\n        }\n    }\n\n    /*\n     * Methods that loop waiting on a guard's condition until the guard is satisfied, while recording\n     * this fact so that other threads know to check our guard and signal us. It's caller's\n     * responsibility to ensure that the guard is *not* currently satisfied.\n     */\n\n    @GuardedBy(\"lock\")\n    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.await();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    @GuardedBy(\"lock\")\n    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.awaitUninterruptibly();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    /** Caller should check before calling that guard is not satisfied. */\n    @GuardedBy(\"lock\")\n    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n    throws InterruptedException\n    {\n        boolean firstTime = true;\n        try\n        {\n            do\n            {\n                if (nanos <= 0L)\n                {\n                    return false;\n                }\n                if (firstTime)\n                {\n                    if (signalBeforeWaiting)\n                    {\n                        signalNextWaiter();\n                    }\n                    beginWaitingFor(guard);\n                    firstTime = false;\n                }\n                nanos = guard.condition.awaitNanos(nanos);\n            }\n            while (!guard.isSatisfied());\n            return true;\n        }\n        finally\n        {\n            if (!firstTime)\n            {\n                endWaitingFor(guard);\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.signalNextWaiter", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Signals some other thread waiting on a satisfied guard, if one exists.\n\n<p>We manage calls to this method carefully, to signal only when necessary, but never losing a\nsignal, which is the classic problem of this kind of concurrency construct. We must signal if\nthe current thread is about to relinquish the lock and may have changed the state protected by\nthe monitor, thereby causing some guard to be satisfied.\n\n<p>In addition, any thread that has been signalled when its guard was satisfied acquires the\nresponsibility of signalling the next thread when it again relinquishes the lock. Unlike a\nnormal Condition, there is no guarantee that an interrupted thread has not been signalled,\nsince the concurrency control must manage multiple Conditions. So this method must generally be\ncalled when waits are interrupted.\n\n<p>On the other hand, if a signalled thread wakes up to discover that its guard is still not\nsatisfied, it does *not* need to call this method before returning to wait. This can only\nhappen due to spurious wakeup (ignorable) or another thread acquiring the lock before the\ncurrent thread can and returning the guard to the unsatisfied state. In the latter case the\nother thread (last thread modifying the state protected by the monitor) takes over the\nresponsibility of signalling the next waiter.\n\n<p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else\nthe current thread's guard might be mistakenly signalled, leading to a lost signal.", "docstring_tokens": ["Signals", "some", "other", "thread", "waiting", "on", "a", "satisfied", "guard", "if", "one", "exists", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L980-L988", "partition": "valid", "up_fun_num": 32, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.errorprone.annotations.concurrent.GuardedBy;", "import com.google.j2objc.annotations.Weak;", "import java.util.concurrent.TimeUnit;", "import java.util.concurrent.locks.Condition;", "import java.util.concurrent.locks.ReentrantLock;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Monitor\n", "    public void enter()\n", "    public boolean enter(long time, TimeUnit unit)\n", "    public void enterInterruptibly() throws InterruptedException\n", "    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n", "    public boolean tryEnter()\n", "    public void enterWhen(Guard guard) throws InterruptedException\n", "    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void enterWhenUninterruptibly(Guard guard)\n", "    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIf(Guard guard)\n", "    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n", "    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean tryEnterIf(Guard guard)\n", "    public void waitFor(Guard guard) throws InterruptedException\n", "    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void waitForUninterruptibly(Guard guard)\n", "    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public void leave()\n", "    public boolean isFair()\n", "    public boolean isOccupied()\n", "    public boolean isOccupiedByCurrentThread()\n", "    public int getOccupiedDepth()\n", "    public int getQueueLength()\n", "    public boolean hasQueuedThreads()\n", "    public boolean hasQueuedThread(Thread thread)\n", "    public boolean hasWaiters(Guard guard)\n", "    public int getWaitQueueLength(Guard guard)\n", "    private static long toSafeNanos(long time, TimeUnit unit)\n", "    private static long initNanoTime(long timeoutNanos)\n", "    private static long remainingNanos(long startTime, long timeoutNanos)\n", "    private boolean isSatisfied(Guard guard)\n", "    private void signalAllWaiters()\n", "    private void beginWaitingFor(Guard guard)\n", "    private void endWaitingFor(Guard guard)\n", "    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n", "    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n", "    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n"], "context": "/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.concurrent.GuardedBy;\nimport com.google.j2objc.annotations.Weak;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A synchronization abstraction supporting waiting on arbitrary boolean conditions.\n *\n * <p>This class is intended as a replacement for {@link ReentrantLock}. Code using {@code Monitor}\n * is less error-prone and more readable than code using {@code ReentrantLock}, without significant\n * performance loss. {@code Monitor} even has the potential for performance gain by optimizing the\n * evaluation and signaling of conditions. Signaling is entirely <a\n * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>. By\n * eliminating explicit signaling, this class can guarantee that only one thread is awakened when a\n * condition becomes true (no \"signaling storms\" due to use of {@link\n * java.util.concurrent.locks.Condition#signalAll Condition.signalAll}) and that no signals are lost\n * (no \"hangs\" due to incorrect use of {@link java.util.concurrent.locks.Condition#signal\n * Condition.signal}).\n *\n * <p>A thread is said to <i>occupy</i> a monitor if it has <i>entered</i> the monitor but not yet\n * <i>left</i>. Only one thread may occupy a given monitor at any moment. A monitor is also\n * reentrant, so a thread may enter a monitor any number of times, and then must leave the same\n * number of times. The <i>enter</i> and <i>leave</i> operations have the same synchronization\n * semantics as the built-in Java language synchronization primitives.\n *\n * <p>A call to any of the <i>enter</i> methods with <b>void</b> return type should always be\n * followed immediately by a <i>try/finally</i> block to ensure that the current thread leaves the\n * monitor cleanly:\n *\n * <pre>{@code\n * monitor.enter();\n * try {\n *   // do things while occupying the monitor\n * } finally {\n *   monitor.leave();\n * }\n * }</pre>\n *\n * <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear\n * as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that\n * the current thread leaves the monitor cleanly:\n *\n * <pre>{@code\n * if (monitor.tryEnter()) {\n *   try {\n *     // do things while occupying the monitor\n *   } finally {\n *     monitor.leave();\n *   }\n * } else {\n *   // do other things since the monitor was not available\n * }\n * }</pre>\n *\n * <h2>Comparison with {@code synchronized} and {@code ReentrantLock}</h2>\n *\n * <p>The following examples show a simple threadsafe holder expressed using {@code synchronized},\n * {@link ReentrantLock}, and {@code Monitor}.\n *\n * <h3>{@code synchronized}</h3>\n *\n * <p>This version is the fewest lines of code, largely because the synchronization mechanism used\n * is built into the language and runtime. But the programmer has to remember to avoid a couple of\n * common bugs: The {@code wait()} must be inside a {@code while} instead of an {@code if}, and\n * {@code notifyAll()} must be used instead of {@code notify()} because there are two different\n * logical conditions being awaited.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *\n *   public synchronized V get() throws InterruptedException {\n *     while (value == null) {\n *       wait();\n *     }\n *     V result = value;\n *     value = null;\n *     notifyAll();\n *     return result;\n *   }\n *\n *   public synchronized void set(V newValue) throws InterruptedException {\n *     while (value != null) {\n *       wait();\n *     }\n *     value = newValue;\n *     notifyAll();\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code ReentrantLock}</h3>\n *\n * <p>This version is much more verbose than the {@code synchronized} version, and still suffers\n * from the need for the programmer to remember to use {@code while} instead of {@code if}. However,\n * one advantage is that we can introduce two separate {@code Condition} objects, which allows us to\n * use {@code signal()} instead of {@code signalAll()}, which may be a performance benefit.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final ReentrantLock lock = new ReentrantLock();\n *   private final Condition valuePresent = lock.newCondition();\n *   private final Condition valueAbsent = lock.newCondition();\n *\n *   public V get() throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value == null) {\n *         valuePresent.await();\n *       }\n *       V result = value;\n *       value = null;\n *       valueAbsent.signal();\n *       return result;\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value != null) {\n *         valueAbsent.await();\n *       }\n *       value = newValue;\n *       valuePresent.signal();\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code Monitor}</h3>\n *\n * <p>This version adds some verbosity around the {@code Guard} objects, but removes that same\n * verbosity, and more, from the {@code get} and {@code set} methods. {@code Monitor} implements the\n * same efficient signaling as we had to hand-code in the {@code ReentrantLock} version above.\n * Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to\n * remember to use {@code while} instead of {@code if}.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final Monitor monitor = new Monitor();\n *   private final Monitor.Guard valuePresent = monitor.newGuard(() -> value != null);\n *   private final Monitor.Guard valueAbsent = monitor.newGuard(() -> value == null);\n *\n *   public V get() throws InterruptedException {\n *     monitor.enterWhen(valuePresent);\n *     try {\n *       V result = value;\n *       value = null;\n *       return result;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     monitor.enterWhen(valueAbsent);\n *     try {\n *       value = newValue;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n * }\n * }</pre>\n *\n * @author Justin T. Sampson\n * @author Martin Buchholz\n * @since 10.0\n */\n@Beta\n@GwtIncompatible\n@SuppressWarnings(\"GuardedBy\") // TODO(b/35466881): Fix or suppress.\npublic final class Monitor\n{\n    // TODO(user): Use raw LockSupport or AbstractQueuedSynchronizer instead of ReentrantLock.\n    // TODO(user): \"Port\" jsr166 tests for ReentrantLock.\n    //\n    // TODO(user): Change API to make it impossible to use a Guard with the \"wrong\" monitor,\n    //    by making the monitor implicit, and to eliminate other sources of IMSE.\n    //    Imagine:\n    //    guard.lock();\n    //    try { /* monitor locked and guard satisfied here */ }\n    //    finally { guard.unlock(); }\n    // Here are Justin's design notes about this:\n    //\n    // This idea has come up from time to time, and I think one of my\n    // earlier versions of Monitor even did something like this. I ended\n    // up strongly favoring the current interface.\n    //\n    // I probably can't remember all the reasons (it's possible you\n    // could find them in the code review archives), but here are a few:\n    //\n    // 1. What about leaving/unlocking? Are you going to do\n    //    guard.enter() paired with monitor.leave()? That might get\n    //    confusing. It's nice for the finally block to look as close as\n    //    possible to the thing right before the try. You could have\n    //    guard.leave(), but that's a little odd as well because the\n    //    guard doesn't have anything to do with leaving. You can't\n    //    really enforce that the guard you're leaving is the same one\n    //    you entered with, and it doesn't actually matter.\n    //\n    // 2. Since you can enter the monitor without a guard at all, some\n    //    places you'll have monitor.enter()/monitor.leave() and other\n    //    places you'll have guard.enter()/guard.leave() even though\n    //    it's the same lock being acquired underneath. Always using\n    //    monitor.enterXXX()/monitor.leave() will make it really clear\n    //    which lock is held at any point in the code.\n    //\n    // 3. I think \"enterWhen(notEmpty)\" reads better than \"notEmpty.enter()\".\n    //\n    // TODO(user): Implement ReentrantLock features:\n    //    - toString() method\n    //    - getOwner() method\n    //    - getQueuedThreads() method\n    //    - getWaitingThreads(Guard) method\n    //    - implement Serializable\n    //    - redo the API to be as close to identical to ReentrantLock as possible,\n    //      since, after all, this class is also a reentrant mutual exclusion lock!?\n\n    /*\n     * One of the key challenges of this class is to prevent lost signals, while trying hard to\n     * minimize unnecessary signals. One simple and correct algorithm is to signal some other waiter\n     * with a satisfied guard (if one exists) whenever any thread occupying the monitor exits the\n     * monitor, either by unlocking all of its held locks, or by starting to wait for a guard. This\n     * includes exceptional exits, so all control paths involving signalling must be protected by a\n     * finally block.\n     *\n     * Further optimizations of this algorithm become increasingly subtle. A wait that terminates\n     * without the guard being satisfied (due to timeout, but not interrupt) can then immediately exit\n     * the monitor without signalling. If it timed out without being signalled, it does not need to\n     * \"pass on\" the signal to another thread. If it *was* signalled, then its guard must have been\n     * satisfied at the time of signal, and has since been modified by some other thread to be\n     * non-satisfied before reacquiring the lock, and that other thread takes over the responsibility\n     * of signaling the next waiter.\n     *\n     * Unlike the underlying Condition, if we are not careful, an interrupt *can* cause a signal to be\n     * lost, because the signal may be sent to a condition whose sole waiter has just been\n     * interrupted.\n     *\n     * Imagine a monitor with multiple guards. A thread enters the monitor, satisfies all the guards,\n     * and leaves, calling signalNextWaiter. With traditional locks and conditions, all the conditions\n     * need to be signalled because it is not known which if any of them have waiters (and hasWaiters\n     * can't be used reliably because of a check-then-act race). With our Monitor guards, we only\n     * signal the first active guard that is satisfied. But the corresponding thread may have already\n     * been interrupted and is waiting to reacquire the lock while still registered in activeGuards,\n     * in which case the signal is a no-op, and the bigger-picture signal is lost unless interrupted\n     * threads take special action by participating in the signal-passing game.\n     */\n\n    /*\n     * Timeout handling is intricate, especially given our ambitious goals:\n     * - Avoid underflow and overflow of timeout values when specified timeouts are close to\n     *   Long.MIN_VALUE or Long.MAX_VALUE.\n     * - Favor responding to interrupts over timeouts.\n     * - System.nanoTime() is expensive enough that we want to call it the minimum required number of\n     *   times, typically once before invoking a blocking method. This often requires keeping track of\n     *   the first time in a method that nanoTime() has been invoked, for which the special value 0L\n     *   is reserved to mean \"uninitialized\". If timeout is non-positive, then nanoTime need never be\n     *   called.\n     * - Keep behavior of fair and non-fair instances consistent.\n     */\n\n    /**\n     * A boolean condition for which a thread may wait. A {@code Guard} is associated with a single\n     * {@code Monitor}. The monitor may check the guard at arbitrary times from any thread occupying\n     * the monitor, so code should not be written to rely on how often a guard might or might not be\n     * checked.\n     *\n     * <p>If a {@code Guard} is passed into any method of a {@code Monitor} other than the one it is\n     * associated with, an {@link IllegalMonitorStateException} is thrown.\n     *\n     * @since 10.0\n     */\n    @Beta\n    public abstract static class Guard\n    {\n\n        @Weak final Monitor monitor;\n        final Condition condition;\n\n        @GuardedBy(\"monitor.lock\")\n        int waiterCount = 0;\n\n        /** The next active guard */\n        @GuardedBy(\"monitor.lock\")\n        @NullableDecl\n        Guard next;\n\n        protected Guard(Monitor monitor)\n        {\n            this.monitor = checkNotNull(monitor, \"monitor\");\n            this.condition = monitor.lock.newCondition();\n        }\n\n        /**\n         * Evaluates this guard's boolean condition. This method is always called with the associated\n         * monitor already occupied. Implementations of this method must depend only on state protected\n         * by the associated monitor, and must not modify that state.\n         */\n        public abstract boolean isSatisfied();\n    }\n\n    /** Whether this monitor is fair. */\n    private final boolean fair;\n\n    /** The lock underlying this monitor. */\n    private final ReentrantLock lock;\n\n    /**\n     * The guards associated with this monitor that currently have waiters ({@code waiterCount > 0}).\n     * A linked list threaded through the Guard.next field.\n     */\n    @GuardedBy(\"lock\")\n    private Guard activeGuards = null;\n\n    /**\n     * Creates a monitor with a non-fair (but fast) ordering policy. Equivalent to {@code\n     * Monitor(false)}.\n     */\n    public Monitor()\n    {\n        this(false);\n    }\n\n    /**\n     * Creates a monitor with the given ordering policy.\n     *\n     * @param fair whether this monitor should use a fair ordering policy rather than a non-fair (but\n     *     fast) one\n     */\n    public Monitor(boolean fair)\n    {\n        this.fair = fair;\n        this.lock = new ReentrantLock(fair);\n    }\n\n    /** Enters this monitor. Blocks indefinitely. */\n    public void enter()\n    {\n        lock.lock();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time.\n     *\n     * @return whether the monitor was entered\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enter(long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        final ReentrantLock lock = this.lock;\n        if (!fair && lock.tryLock())\n        {\n            return true;\n        }\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            final long startTime = System.nanoTime();\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterInterruptibly() throws InterruptedException\n    {\n        lock.lockInterruptibly();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time, and may be interrupted.\n     *\n     * @return whether the monitor was entered\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n    {\n        return lock.tryLock(time, unit);\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately. Does not block.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered\n     */\n    public boolean tryEnter()\n    {\n        return lock.tryLock();\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterWhen(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                await(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied, and may be\n     * interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean reentrant = lock.isHeldByCurrentThread();\n        long startTime = 0L;\n\n        locked:\n        {\n            if (!fair)\n            {\n                // Check interrupt status to get behavior consistent with fair case.\n                if (Thread.interrupted())\n                {\n                    throw new InterruptedException();\n                }\n                if (lock.tryLock())\n                {\n                    break locked;\n                }\n            }\n            startTime = initNanoTime(timeoutNanos);\n            if (!lock.tryLock(time, unit))\n            {\n                return false;\n            }\n        }\n\n        boolean satisfied = false;\n        boolean threw = true;\n        try\n        {\n            satisfied =\n                guard.isSatisfied()\n                || awaitNanos(\n                    guard,\n                    (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),\n                    reentrant);\n            threw = false;\n            return satisfied;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                try\n                {\n                    // Don't need to signal if timed out, but do if interrupted\n                    if (threw && !reentrant)\n                    {\n                        signalNextWaiter();\n                    }\n                }\n                finally\n                {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n\n    /** Enters this monitor when the guard is satisfied. Blocks indefinitely. */\n    public void enterWhenUninterruptibly(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                awaitUninterruptibly(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        long startTime = 0L;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            if (fair || !lock.tryLock())\n            {\n                startTime = initNanoTime(timeoutNanos);\n                for (long remainingNanos = timeoutNanos; ; )\n                {\n                    try\n                    {\n                        if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS))\n                        {\n                            break;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        remainingNanos = remainingNanos(startTime, timeoutNanos);\n                    }\n                }\n            }\n\n            boolean satisfied = false;\n            try\n            {\n                while (true)\n                {\n                    try\n                    {\n                        if (guard.isSatisfied())\n                        {\n                            satisfied = true;\n                        }\n                        else\n                        {\n                            final long remainingNanos;\n                            if (startTime == 0L)\n                            {\n                                startTime = initNanoTime(timeoutNanos);\n                                remainingNanos = timeoutNanos;\n                            }\n                            else\n                            {\n                                remainingNanos = remainingNanos(startTime, timeoutNanos);\n                            }\n                            satisfied = awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                        }\n                        return satisfied;\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        signalBeforeWaiting = false;\n                    }\n                }\n            }\n            finally\n            {\n                if (!satisfied)\n                {\n                    lock.unlock(); // No need to signal if timed out\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean enterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!enter(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n    throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not\n     * block acquiring the lock and does not wait for the guard to be satisfied.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean tryEnterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock())\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be called\n     * only by a thread currently occupying this monitor.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void waitFor(Guard guard) throws InterruptedException\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            await(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted. May\n     * be called only by a thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        if (Thread.interrupted())\n        {\n            throw new InterruptedException();\n        }\n        return awaitNanos(guard, timeoutNanos, true);\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread\n     * currently occupying this monitor.\n     */\n    public void waitForUninterruptibly(Guard guard)\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            awaitUninterruptibly(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time. May be called only by a\n     * thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        boolean signalBeforeWaiting = true;\n        final long startTime = initNanoTime(timeoutNanos);\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    if (guard.isSatisfied())\n                    {\n                        return true;\n                    }\n                    signalBeforeWaiting = false;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /** Leaves this monitor. May be called only by a thread currently occupying this monitor. */\n    public void leave()\n    {\n        final ReentrantLock lock = this.lock;\n        try\n        {\n            // No need to signal if we will still be holding the lock when we return\n            if (lock.getHoldCount() == 1)\n            {\n                signalNextWaiter();\n            }\n        }\n        finally\n        {\n            lock.unlock(); // Will throw IllegalMonitorStateException if not held\n        }\n    }\n\n    /** Returns whether this monitor is using a fair ordering policy. */\n    public boolean isFair()\n    {\n        return fair;\n    }\n\n    /**\n     * Returns whether this monitor is occupied by any thread. This method is designed for use in\n     * monitoring of the system state, not for synchronization control.\n     */\n    public boolean isOccupied()\n    {\n        return lock.isLocked();\n    }\n\n    /**\n     * Returns whether the current thread is occupying this monitor (has entered more times than it\n     * has left).\n     */\n    public boolean isOccupiedByCurrentThread()\n    {\n        return lock.isHeldByCurrentThread();\n    }\n\n    /**\n     * Returns the number of times the current thread has entered this monitor in excess of the number\n     * of times it has left. Returns 0 if the current thread is not occupying this monitor.\n     */\n    public int getOccupiedDepth()\n    {\n        return lock.getHoldCount();\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting to enter this monitor. The value is only\n     * an estimate because the number of threads may change dynamically while this method traverses\n     * internal data structures. This method is designed for use in monitoring of the system state,\n     * not for synchronization control.\n     */\n    public int getQueueLength()\n    {\n        return lock.getQueueLength();\n    }\n\n    /**\n     * Returns whether any threads are waiting to enter this monitor. Note that because cancellations\n     * may occur at any time, a {@code true} return does not guarantee that any other thread will ever\n     * enter this monitor. This method is designed primarily for use in monitoring of the system\n     * state.\n     */\n    public boolean hasQueuedThreads()\n    {\n        return lock.hasQueuedThreads();\n    }\n\n    /**\n     * Queries whether the given thread is waiting to enter this monitor. Note that because\n     * cancellations may occur at any time, a {@code true} return does not guarantee that this thread\n     * will ever enter this monitor. This method is designed primarily for use in monitoring of the\n     * system state.\n     */\n    public boolean hasQueuedThread(Thread thread)\n    {\n        return lock.hasQueuedThread(thread);\n    }\n\n    /**\n     * Queries whether any threads are waiting for the given guard to become satisfied. Note that\n     * because timeouts and interrupts may occur at any time, a {@code true} return does not guarantee\n     * that the guard becoming satisfied in the future will awaken any threads. This method is\n     * designed primarily for use in monitoring of the system state.\n     */\n    public boolean hasWaiters(Guard guard)\n    {\n        return getWaitQueueLength(guard) > 0;\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting for the given guard to become satisfied.\n     * Note that because timeouts and interrupts may occur at any time, the estimate serves only as an\n     * upper bound on the actual number of waiters. This method is designed for use in monitoring of\n     * the system state, not for synchronization control.\n     */\n    public int getWaitQueueLength(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        lock.lock();\n        try\n        {\n            return guard.waiterCount;\n        }\n        finally\n        {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Returns unit.toNanos(time), additionally ensuring the returned value is not at risk of\n     * overflowing or underflowing, by bounding the value between 0 and (Long.MAX_VALUE / 4) * 3.\n     * Actually waiting for more than 219 years is not supported!\n     */\n    private static long toSafeNanos(long time, TimeUnit unit)\n    {\n        long timeoutNanos = unit.toNanos(time);\n        return (timeoutNanos <= 0L)\n               ? 0L\n               : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3 : timeoutNanos;\n    }\n\n    /**\n     * Returns System.nanoTime() unless the timeout has already elapsed. Returns 0L if and only if the\n     * timeout has already elapsed.\n     */\n    private static long initNanoTime(long timeoutNanos)\n    {\n        if (timeoutNanos <= 0L)\n        {\n            return 0L;\n        }\n        else\n        {\n            long startTime = System.nanoTime();\n            return (startTime == 0L) ? 1L : startTime;\n        }\n    }\n\n    /**\n     * Returns the remaining nanos until the given timeout, or 0L if the timeout has already elapsed.\n     * Caller must have previously sanitized timeoutNanos using toSafeNanos.\n     */\n    private static long remainingNanos(long startTime, long timeoutNanos)\n    {\n        // assert timeoutNanos == 0L || startTime != 0L;\n\n        // TODO : NOT CORRECT, BUT TESTS PASS ANYWAYS!\n        // if (true) return timeoutNanos;\n        // ONLY 2 TESTS FAIL IF WE DO:\n        // if (true) return 0;\n\n        return (timeoutNanos <= 0L) ? 0L : timeoutNanos - (System.nanoTime() - startTime);\n    }\n\n    /**\n     * Signals some other thread waiting on a satisfied guard, if one exists.\n     *\n     * <p>We manage calls to this method carefully, to signal only when necessary, but never losing a\n     * signal, which is the classic problem of this kind of concurrency construct. We must signal if\n     * the current thread is about to relinquish the lock and may have changed the state protected by\n     * the monitor, thereby causing some guard to be satisfied.\n     *\n     * <p>In addition, any thread that has been signalled when its guard was satisfied acquires the\n     * responsibility of signalling the next thread when it again relinquishes the lock. Unlike a\n     * normal Condition, there is no guarantee that an interrupted thread has not been signalled,\n     * since the concurrency control must manage multiple Conditions. So this method must generally be\n     * called when waits are interrupted.\n     *\n     * <p>On the other hand, if a signalled thread wakes up to discover that its guard is still not\n     * satisfied, it does *not* need to call this method before returning to wait. This can only\n     * happen due to spurious wakeup (ignorable) or another thread acquiring the lock before the\n     * current thread can and returning the guard to the unsatisfied state. In the latter case the\n     * other thread (last thread modifying the state protected by the monitor) takes over the\n     * responsibility of signalling the next waiter.\n     *\n     * <p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else\n     * the current thread's guard might be mistakenly signalled, leading to a lost signal.\n     */\n\n    /**\n     * Exactly like signalNextWaiter, but caller guarantees that guardToSkip need not be considered,\n     * because caller has previously checked that guardToSkip.isSatisfied() returned false. An\n     * optimization for the case that guardToSkip.isSatisfied() may be expensive.\n     *\n     * <p>We decided against using this method, since in practice, isSatisfied() is likely to be very\n     * cheap (typically one field read). Resurrect this method if you find that not to be true.\n     */\n    //   @GuardedBy(\"lock\")\n    //   private void signalNextWaiterSkipping(Guard guardToSkip) {\n    //     for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n    //       if (guard != guardToSkip && isSatisfied(guard)) {\n    //         guard.condition.signal();\n    //         break;\n    //       }\n    //     }\n    //   }\n\n    /**\n     * Exactly like guard.isSatisfied(), but in addition signals all waiting threads in the (hopefully\n     * unlikely) event that isSatisfied() throws.\n     */\n    @GuardedBy(\"lock\")\n    private boolean isSatisfied(Guard guard)\n    {\n        try\n        {\n            return guard.isSatisfied();\n        }\n        catch (Throwable throwable)\n        {\n            signalAllWaiters();\n            throw throwable;\n        }\n    }\n\n    /** Signals all threads waiting on guards. */\n    @GuardedBy(\"lock\")\n    private void signalAllWaiters()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            guard.condition.signalAll();\n        }\n    }\n\n    /** Records that the current thread is about to wait on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void beginWaitingFor(Guard guard)\n    {\n        int waiters = guard.waiterCount++;\n        if (waiters == 0)\n        {\n            // push guard onto activeGuards\n            guard.next = activeGuards;\n            activeGuards = guard;\n        }\n    }\n\n    /** Records that the current thread is no longer waiting on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void endWaitingFor(Guard guard)\n    {\n        int waiters = --guard.waiterCount;\n        if (waiters == 0)\n        {\n            // unlink guard from activeGuards\n            for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next)\n            {\n                if (p == guard)\n                {\n                    if (pred == null)\n                    {\n                        activeGuards = p.next;\n                    }\n                    else\n                    {\n                        pred.next = p.next;\n                    }\n                    p.next = null; // help GC\n                    break;\n                }\n            }\n        }\n    }\n\n    /*\n     * Methods that loop waiting on a guard's condition until the guard is satisfied, while recording\n     * this fact so that other threads know to check our guard and signal us. It's caller's\n     * responsibility to ensure that the guard is *not* currently satisfied.\n     */\n\n    @GuardedBy(\"lock\")\n    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.await();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    @GuardedBy(\"lock\")\n    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.awaitUninterruptibly();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    /** Caller should check before calling that guard is not satisfied. */\n    @GuardedBy(\"lock\")\n    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n    throws InterruptedException\n    {\n        boolean firstTime = true;\n        try\n        {\n            do\n            {\n                if (nanos <= 0L)\n                {\n                    return false;\n                }\n                if (firstTime)\n                {\n                    if (signalBeforeWaiting)\n                    {\n                        signalNextWaiter();\n                    }\n                    beginWaitingFor(guard);\n                    firstTime = false;\n                }\n                nanos = guard.condition.awaitNanos(nanos);\n            }\n            while (!guard.isSatisfied());\n            return true;\n        }\n        finally\n        {\n            if (!firstTime)\n            {\n                endWaitingFor(guard);\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.signalAllWaiters", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Signals all threads waiting on guards.", "docstring_tokens": ["Signals", "all", "threads", "waiting", "on", "guards", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L1023-L1028", "partition": "valid", "up_fun_num": 34, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.errorprone.annotations.concurrent.GuardedBy;", "import com.google.j2objc.annotations.Weak;", "import java.util.concurrent.TimeUnit;", "import java.util.concurrent.locks.Condition;", "import java.util.concurrent.locks.ReentrantLock;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Monitor\n", "    public void enter()\n", "    public boolean enter(long time, TimeUnit unit)\n", "    public void enterInterruptibly() throws InterruptedException\n", "    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n", "    public boolean tryEnter()\n", "    public void enterWhen(Guard guard) throws InterruptedException\n", "    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void enterWhenUninterruptibly(Guard guard)\n", "    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIf(Guard guard)\n", "    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n", "    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean tryEnterIf(Guard guard)\n", "    public void waitFor(Guard guard) throws InterruptedException\n", "    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void waitForUninterruptibly(Guard guard)\n", "    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public void leave()\n", "    public boolean isFair()\n", "    public boolean isOccupied()\n", "    public boolean isOccupiedByCurrentThread()\n", "    public int getOccupiedDepth()\n", "    public int getQueueLength()\n", "    public boolean hasQueuedThreads()\n", "    public boolean hasQueuedThread(Thread thread)\n", "    public boolean hasWaiters(Guard guard)\n", "    public int getWaitQueueLength(Guard guard)\n", "    private static long toSafeNanos(long time, TimeUnit unit)\n", "    private static long initNanoTime(long timeoutNanos)\n", "    private static long remainingNanos(long startTime, long timeoutNanos)\n", "    private void signalNextWaiter()\n", "    private boolean isSatisfied(Guard guard)\n", "    private void beginWaitingFor(Guard guard)\n", "    private void endWaitingFor(Guard guard)\n", "    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n", "    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n", "    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n"], "context": "/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.concurrent.GuardedBy;\nimport com.google.j2objc.annotations.Weak;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A synchronization abstraction supporting waiting on arbitrary boolean conditions.\n *\n * <p>This class is intended as a replacement for {@link ReentrantLock}. Code using {@code Monitor}\n * is less error-prone and more readable than code using {@code ReentrantLock}, without significant\n * performance loss. {@code Monitor} even has the potential for performance gain by optimizing the\n * evaluation and signaling of conditions. Signaling is entirely <a\n * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>. By\n * eliminating explicit signaling, this class can guarantee that only one thread is awakened when a\n * condition becomes true (no \"signaling storms\" due to use of {@link\n * java.util.concurrent.locks.Condition#signalAll Condition.signalAll}) and that no signals are lost\n * (no \"hangs\" due to incorrect use of {@link java.util.concurrent.locks.Condition#signal\n * Condition.signal}).\n *\n * <p>A thread is said to <i>occupy</i> a monitor if it has <i>entered</i> the monitor but not yet\n * <i>left</i>. Only one thread may occupy a given monitor at any moment. A monitor is also\n * reentrant, so a thread may enter a monitor any number of times, and then must leave the same\n * number of times. The <i>enter</i> and <i>leave</i> operations have the same synchronization\n * semantics as the built-in Java language synchronization primitives.\n *\n * <p>A call to any of the <i>enter</i> methods with <b>void</b> return type should always be\n * followed immediately by a <i>try/finally</i> block to ensure that the current thread leaves the\n * monitor cleanly:\n *\n * <pre>{@code\n * monitor.enter();\n * try {\n *   // do things while occupying the monitor\n * } finally {\n *   monitor.leave();\n * }\n * }</pre>\n *\n * <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear\n * as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that\n * the current thread leaves the monitor cleanly:\n *\n * <pre>{@code\n * if (monitor.tryEnter()) {\n *   try {\n *     // do things while occupying the monitor\n *   } finally {\n *     monitor.leave();\n *   }\n * } else {\n *   // do other things since the monitor was not available\n * }\n * }</pre>\n *\n * <h2>Comparison with {@code synchronized} and {@code ReentrantLock}</h2>\n *\n * <p>The following examples show a simple threadsafe holder expressed using {@code synchronized},\n * {@link ReentrantLock}, and {@code Monitor}.\n *\n * <h3>{@code synchronized}</h3>\n *\n * <p>This version is the fewest lines of code, largely because the synchronization mechanism used\n * is built into the language and runtime. But the programmer has to remember to avoid a couple of\n * common bugs: The {@code wait()} must be inside a {@code while} instead of an {@code if}, and\n * {@code notifyAll()} must be used instead of {@code notify()} because there are two different\n * logical conditions being awaited.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *\n *   public synchronized V get() throws InterruptedException {\n *     while (value == null) {\n *       wait();\n *     }\n *     V result = value;\n *     value = null;\n *     notifyAll();\n *     return result;\n *   }\n *\n *   public synchronized void set(V newValue) throws InterruptedException {\n *     while (value != null) {\n *       wait();\n *     }\n *     value = newValue;\n *     notifyAll();\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code ReentrantLock}</h3>\n *\n * <p>This version is much more verbose than the {@code synchronized} version, and still suffers\n * from the need for the programmer to remember to use {@code while} instead of {@code if}. However,\n * one advantage is that we can introduce two separate {@code Condition} objects, which allows us to\n * use {@code signal()} instead of {@code signalAll()}, which may be a performance benefit.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final ReentrantLock lock = new ReentrantLock();\n *   private final Condition valuePresent = lock.newCondition();\n *   private final Condition valueAbsent = lock.newCondition();\n *\n *   public V get() throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value == null) {\n *         valuePresent.await();\n *       }\n *       V result = value;\n *       value = null;\n *       valueAbsent.signal();\n *       return result;\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value != null) {\n *         valueAbsent.await();\n *       }\n *       value = newValue;\n *       valuePresent.signal();\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code Monitor}</h3>\n *\n * <p>This version adds some verbosity around the {@code Guard} objects, but removes that same\n * verbosity, and more, from the {@code get} and {@code set} methods. {@code Monitor} implements the\n * same efficient signaling as we had to hand-code in the {@code ReentrantLock} version above.\n * Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to\n * remember to use {@code while} instead of {@code if}.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final Monitor monitor = new Monitor();\n *   private final Monitor.Guard valuePresent = monitor.newGuard(() -> value != null);\n *   private final Monitor.Guard valueAbsent = monitor.newGuard(() -> value == null);\n *\n *   public V get() throws InterruptedException {\n *     monitor.enterWhen(valuePresent);\n *     try {\n *       V result = value;\n *       value = null;\n *       return result;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     monitor.enterWhen(valueAbsent);\n *     try {\n *       value = newValue;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n * }\n * }</pre>\n *\n * @author Justin T. Sampson\n * @author Martin Buchholz\n * @since 10.0\n */\n@Beta\n@GwtIncompatible\n@SuppressWarnings(\"GuardedBy\") // TODO(b/35466881): Fix or suppress.\npublic final class Monitor\n{\n    // TODO(user): Use raw LockSupport or AbstractQueuedSynchronizer instead of ReentrantLock.\n    // TODO(user): \"Port\" jsr166 tests for ReentrantLock.\n    //\n    // TODO(user): Change API to make it impossible to use a Guard with the \"wrong\" monitor,\n    //    by making the monitor implicit, and to eliminate other sources of IMSE.\n    //    Imagine:\n    //    guard.lock();\n    //    try { /* monitor locked and guard satisfied here */ }\n    //    finally { guard.unlock(); }\n    // Here are Justin's design notes about this:\n    //\n    // This idea has come up from time to time, and I think one of my\n    // earlier versions of Monitor even did something like this. I ended\n    // up strongly favoring the current interface.\n    //\n    // I probably can't remember all the reasons (it's possible you\n    // could find them in the code review archives), but here are a few:\n    //\n    // 1. What about leaving/unlocking? Are you going to do\n    //    guard.enter() paired with monitor.leave()? That might get\n    //    confusing. It's nice for the finally block to look as close as\n    //    possible to the thing right before the try. You could have\n    //    guard.leave(), but that's a little odd as well because the\n    //    guard doesn't have anything to do with leaving. You can't\n    //    really enforce that the guard you're leaving is the same one\n    //    you entered with, and it doesn't actually matter.\n    //\n    // 2. Since you can enter the monitor without a guard at all, some\n    //    places you'll have monitor.enter()/monitor.leave() and other\n    //    places you'll have guard.enter()/guard.leave() even though\n    //    it's the same lock being acquired underneath. Always using\n    //    monitor.enterXXX()/monitor.leave() will make it really clear\n    //    which lock is held at any point in the code.\n    //\n    // 3. I think \"enterWhen(notEmpty)\" reads better than \"notEmpty.enter()\".\n    //\n    // TODO(user): Implement ReentrantLock features:\n    //    - toString() method\n    //    - getOwner() method\n    //    - getQueuedThreads() method\n    //    - getWaitingThreads(Guard) method\n    //    - implement Serializable\n    //    - redo the API to be as close to identical to ReentrantLock as possible,\n    //      since, after all, this class is also a reentrant mutual exclusion lock!?\n\n    /*\n     * One of the key challenges of this class is to prevent lost signals, while trying hard to\n     * minimize unnecessary signals. One simple and correct algorithm is to signal some other waiter\n     * with a satisfied guard (if one exists) whenever any thread occupying the monitor exits the\n     * monitor, either by unlocking all of its held locks, or by starting to wait for a guard. This\n     * includes exceptional exits, so all control paths involving signalling must be protected by a\n     * finally block.\n     *\n     * Further optimizations of this algorithm become increasingly subtle. A wait that terminates\n     * without the guard being satisfied (due to timeout, but not interrupt) can then immediately exit\n     * the monitor without signalling. If it timed out without being signalled, it does not need to\n     * \"pass on\" the signal to another thread. If it *was* signalled, then its guard must have been\n     * satisfied at the time of signal, and has since been modified by some other thread to be\n     * non-satisfied before reacquiring the lock, and that other thread takes over the responsibility\n     * of signaling the next waiter.\n     *\n     * Unlike the underlying Condition, if we are not careful, an interrupt *can* cause a signal to be\n     * lost, because the signal may be sent to a condition whose sole waiter has just been\n     * interrupted.\n     *\n     * Imagine a monitor with multiple guards. A thread enters the monitor, satisfies all the guards,\n     * and leaves, calling signalNextWaiter. With traditional locks and conditions, all the conditions\n     * need to be signalled because it is not known which if any of them have waiters (and hasWaiters\n     * can't be used reliably because of a check-then-act race). With our Monitor guards, we only\n     * signal the first active guard that is satisfied. But the corresponding thread may have already\n     * been interrupted and is waiting to reacquire the lock while still registered in activeGuards,\n     * in which case the signal is a no-op, and the bigger-picture signal is lost unless interrupted\n     * threads take special action by participating in the signal-passing game.\n     */\n\n    /*\n     * Timeout handling is intricate, especially given our ambitious goals:\n     * - Avoid underflow and overflow of timeout values when specified timeouts are close to\n     *   Long.MIN_VALUE or Long.MAX_VALUE.\n     * - Favor responding to interrupts over timeouts.\n     * - System.nanoTime() is expensive enough that we want to call it the minimum required number of\n     *   times, typically once before invoking a blocking method. This often requires keeping track of\n     *   the first time in a method that nanoTime() has been invoked, for which the special value 0L\n     *   is reserved to mean \"uninitialized\". If timeout is non-positive, then nanoTime need never be\n     *   called.\n     * - Keep behavior of fair and non-fair instances consistent.\n     */\n\n    /**\n     * A boolean condition for which a thread may wait. A {@code Guard} is associated with a single\n     * {@code Monitor}. The monitor may check the guard at arbitrary times from any thread occupying\n     * the monitor, so code should not be written to rely on how often a guard might or might not be\n     * checked.\n     *\n     * <p>If a {@code Guard} is passed into any method of a {@code Monitor} other than the one it is\n     * associated with, an {@link IllegalMonitorStateException} is thrown.\n     *\n     * @since 10.0\n     */\n    @Beta\n    public abstract static class Guard\n    {\n\n        @Weak final Monitor monitor;\n        final Condition condition;\n\n        @GuardedBy(\"monitor.lock\")\n        int waiterCount = 0;\n\n        /** The next active guard */\n        @GuardedBy(\"monitor.lock\")\n        @NullableDecl\n        Guard next;\n\n        protected Guard(Monitor monitor)\n        {\n            this.monitor = checkNotNull(monitor, \"monitor\");\n            this.condition = monitor.lock.newCondition();\n        }\n\n        /**\n         * Evaluates this guard's boolean condition. This method is always called with the associated\n         * monitor already occupied. Implementations of this method must depend only on state protected\n         * by the associated monitor, and must not modify that state.\n         */\n        public abstract boolean isSatisfied();\n    }\n\n    /** Whether this monitor is fair. */\n    private final boolean fair;\n\n    /** The lock underlying this monitor. */\n    private final ReentrantLock lock;\n\n    /**\n     * The guards associated with this monitor that currently have waiters ({@code waiterCount > 0}).\n     * A linked list threaded through the Guard.next field.\n     */\n    @GuardedBy(\"lock\")\n    private Guard activeGuards = null;\n\n    /**\n     * Creates a monitor with a non-fair (but fast) ordering policy. Equivalent to {@code\n     * Monitor(false)}.\n     */\n    public Monitor()\n    {\n        this(false);\n    }\n\n    /**\n     * Creates a monitor with the given ordering policy.\n     *\n     * @param fair whether this monitor should use a fair ordering policy rather than a non-fair (but\n     *     fast) one\n     */\n    public Monitor(boolean fair)\n    {\n        this.fair = fair;\n        this.lock = new ReentrantLock(fair);\n    }\n\n    /** Enters this monitor. Blocks indefinitely. */\n    public void enter()\n    {\n        lock.lock();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time.\n     *\n     * @return whether the monitor was entered\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enter(long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        final ReentrantLock lock = this.lock;\n        if (!fair && lock.tryLock())\n        {\n            return true;\n        }\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            final long startTime = System.nanoTime();\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterInterruptibly() throws InterruptedException\n    {\n        lock.lockInterruptibly();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time, and may be interrupted.\n     *\n     * @return whether the monitor was entered\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n    {\n        return lock.tryLock(time, unit);\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately. Does not block.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered\n     */\n    public boolean tryEnter()\n    {\n        return lock.tryLock();\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterWhen(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                await(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied, and may be\n     * interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean reentrant = lock.isHeldByCurrentThread();\n        long startTime = 0L;\n\n        locked:\n        {\n            if (!fair)\n            {\n                // Check interrupt status to get behavior consistent with fair case.\n                if (Thread.interrupted())\n                {\n                    throw new InterruptedException();\n                }\n                if (lock.tryLock())\n                {\n                    break locked;\n                }\n            }\n            startTime = initNanoTime(timeoutNanos);\n            if (!lock.tryLock(time, unit))\n            {\n                return false;\n            }\n        }\n\n        boolean satisfied = false;\n        boolean threw = true;\n        try\n        {\n            satisfied =\n                guard.isSatisfied()\n                || awaitNanos(\n                    guard,\n                    (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),\n                    reentrant);\n            threw = false;\n            return satisfied;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                try\n                {\n                    // Don't need to signal if timed out, but do if interrupted\n                    if (threw && !reentrant)\n                    {\n                        signalNextWaiter();\n                    }\n                }\n                finally\n                {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n\n    /** Enters this monitor when the guard is satisfied. Blocks indefinitely. */\n    public void enterWhenUninterruptibly(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                awaitUninterruptibly(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        long startTime = 0L;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            if (fair || !lock.tryLock())\n            {\n                startTime = initNanoTime(timeoutNanos);\n                for (long remainingNanos = timeoutNanos; ; )\n                {\n                    try\n                    {\n                        if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS))\n                        {\n                            break;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        remainingNanos = remainingNanos(startTime, timeoutNanos);\n                    }\n                }\n            }\n\n            boolean satisfied = false;\n            try\n            {\n                while (true)\n                {\n                    try\n                    {\n                        if (guard.isSatisfied())\n                        {\n                            satisfied = true;\n                        }\n                        else\n                        {\n                            final long remainingNanos;\n                            if (startTime == 0L)\n                            {\n                                startTime = initNanoTime(timeoutNanos);\n                                remainingNanos = timeoutNanos;\n                            }\n                            else\n                            {\n                                remainingNanos = remainingNanos(startTime, timeoutNanos);\n                            }\n                            satisfied = awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                        }\n                        return satisfied;\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        signalBeforeWaiting = false;\n                    }\n                }\n            }\n            finally\n            {\n                if (!satisfied)\n                {\n                    lock.unlock(); // No need to signal if timed out\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean enterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!enter(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n    throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not\n     * block acquiring the lock and does not wait for the guard to be satisfied.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean tryEnterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock())\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be called\n     * only by a thread currently occupying this monitor.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void waitFor(Guard guard) throws InterruptedException\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            await(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted. May\n     * be called only by a thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        if (Thread.interrupted())\n        {\n            throw new InterruptedException();\n        }\n        return awaitNanos(guard, timeoutNanos, true);\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread\n     * currently occupying this monitor.\n     */\n    public void waitForUninterruptibly(Guard guard)\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            awaitUninterruptibly(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time. May be called only by a\n     * thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        boolean signalBeforeWaiting = true;\n        final long startTime = initNanoTime(timeoutNanos);\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    if (guard.isSatisfied())\n                    {\n                        return true;\n                    }\n                    signalBeforeWaiting = false;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /** Leaves this monitor. May be called only by a thread currently occupying this monitor. */\n    public void leave()\n    {\n        final ReentrantLock lock = this.lock;\n        try\n        {\n            // No need to signal if we will still be holding the lock when we return\n            if (lock.getHoldCount() == 1)\n            {\n                signalNextWaiter();\n            }\n        }\n        finally\n        {\n            lock.unlock(); // Will throw IllegalMonitorStateException if not held\n        }\n    }\n\n    /** Returns whether this monitor is using a fair ordering policy. */\n    public boolean isFair()\n    {\n        return fair;\n    }\n\n    /**\n     * Returns whether this monitor is occupied by any thread. This method is designed for use in\n     * monitoring of the system state, not for synchronization control.\n     */\n    public boolean isOccupied()\n    {\n        return lock.isLocked();\n    }\n\n    /**\n     * Returns whether the current thread is occupying this monitor (has entered more times than it\n     * has left).\n     */\n    public boolean isOccupiedByCurrentThread()\n    {\n        return lock.isHeldByCurrentThread();\n    }\n\n    /**\n     * Returns the number of times the current thread has entered this monitor in excess of the number\n     * of times it has left. Returns 0 if the current thread is not occupying this monitor.\n     */\n    public int getOccupiedDepth()\n    {\n        return lock.getHoldCount();\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting to enter this monitor. The value is only\n     * an estimate because the number of threads may change dynamically while this method traverses\n     * internal data structures. This method is designed for use in monitoring of the system state,\n     * not for synchronization control.\n     */\n    public int getQueueLength()\n    {\n        return lock.getQueueLength();\n    }\n\n    /**\n     * Returns whether any threads are waiting to enter this monitor. Note that because cancellations\n     * may occur at any time, a {@code true} return does not guarantee that any other thread will ever\n     * enter this monitor. This method is designed primarily for use in monitoring of the system\n     * state.\n     */\n    public boolean hasQueuedThreads()\n    {\n        return lock.hasQueuedThreads();\n    }\n\n    /**\n     * Queries whether the given thread is waiting to enter this monitor. Note that because\n     * cancellations may occur at any time, a {@code true} return does not guarantee that this thread\n     * will ever enter this monitor. This method is designed primarily for use in monitoring of the\n     * system state.\n     */\n    public boolean hasQueuedThread(Thread thread)\n    {\n        return lock.hasQueuedThread(thread);\n    }\n\n    /**\n     * Queries whether any threads are waiting for the given guard to become satisfied. Note that\n     * because timeouts and interrupts may occur at any time, a {@code true} return does not guarantee\n     * that the guard becoming satisfied in the future will awaken any threads. This method is\n     * designed primarily for use in monitoring of the system state.\n     */\n    public boolean hasWaiters(Guard guard)\n    {\n        return getWaitQueueLength(guard) > 0;\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting for the given guard to become satisfied.\n     * Note that because timeouts and interrupts may occur at any time, the estimate serves only as an\n     * upper bound on the actual number of waiters. This method is designed for use in monitoring of\n     * the system state, not for synchronization control.\n     */\n    public int getWaitQueueLength(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        lock.lock();\n        try\n        {\n            return guard.waiterCount;\n        }\n        finally\n        {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Returns unit.toNanos(time), additionally ensuring the returned value is not at risk of\n     * overflowing or underflowing, by bounding the value between 0 and (Long.MAX_VALUE / 4) * 3.\n     * Actually waiting for more than 219 years is not supported!\n     */\n    private static long toSafeNanos(long time, TimeUnit unit)\n    {\n        long timeoutNanos = unit.toNanos(time);\n        return (timeoutNanos <= 0L)\n               ? 0L\n               : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3 : timeoutNanos;\n    }\n\n    /**\n     * Returns System.nanoTime() unless the timeout has already elapsed. Returns 0L if and only if the\n     * timeout has already elapsed.\n     */\n    private static long initNanoTime(long timeoutNanos)\n    {\n        if (timeoutNanos <= 0L)\n        {\n            return 0L;\n        }\n        else\n        {\n            long startTime = System.nanoTime();\n            return (startTime == 0L) ? 1L : startTime;\n        }\n    }\n\n    /**\n     * Returns the remaining nanos until the given timeout, or 0L if the timeout has already elapsed.\n     * Caller must have previously sanitized timeoutNanos using toSafeNanos.\n     */\n    private static long remainingNanos(long startTime, long timeoutNanos)\n    {\n        // assert timeoutNanos == 0L || startTime != 0L;\n\n        // TODO : NOT CORRECT, BUT TESTS PASS ANYWAYS!\n        // if (true) return timeoutNanos;\n        // ONLY 2 TESTS FAIL IF WE DO:\n        // if (true) return 0;\n\n        return (timeoutNanos <= 0L) ? 0L : timeoutNanos - (System.nanoTime() - startTime);\n    }\n\n    /**\n     * Signals some other thread waiting on a satisfied guard, if one exists.\n     *\n     * <p>We manage calls to this method carefully, to signal only when necessary, but never losing a\n     * signal, which is the classic problem of this kind of concurrency construct. We must signal if\n     * the current thread is about to relinquish the lock and may have changed the state protected by\n     * the monitor, thereby causing some guard to be satisfied.\n     *\n     * <p>In addition, any thread that has been signalled when its guard was satisfied acquires the\n     * responsibility of signalling the next thread when it again relinquishes the lock. Unlike a\n     * normal Condition, there is no guarantee that an interrupted thread has not been signalled,\n     * since the concurrency control must manage multiple Conditions. So this method must generally be\n     * called when waits are interrupted.\n     *\n     * <p>On the other hand, if a signalled thread wakes up to discover that its guard is still not\n     * satisfied, it does *not* need to call this method before returning to wait. This can only\n     * happen due to spurious wakeup (ignorable) or another thread acquiring the lock before the\n     * current thread can and returning the guard to the unsatisfied state. In the latter case the\n     * other thread (last thread modifying the state protected by the monitor) takes over the\n     * responsibility of signalling the next waiter.\n     *\n     * <p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else\n     * the current thread's guard might be mistakenly signalled, leading to a lost signal.\n     */\n    @GuardedBy(\"lock\")\n    private void signalNextWaiter()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            if (isSatisfied(guard))\n            {\n                guard.condition.signal();\n                break;\n            }\n        }\n    }\n\n    /**\n     * Exactly like signalNextWaiter, but caller guarantees that guardToSkip need not be considered,\n     * because caller has previously checked that guardToSkip.isSatisfied() returned false. An\n     * optimization for the case that guardToSkip.isSatisfied() may be expensive.\n     *\n     * <p>We decided against using this method, since in practice, isSatisfied() is likely to be very\n     * cheap (typically one field read). Resurrect this method if you find that not to be true.\n     */\n    //   @GuardedBy(\"lock\")\n    //   private void signalNextWaiterSkipping(Guard guardToSkip) {\n    //     for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n    //       if (guard != guardToSkip && isSatisfied(guard)) {\n    //         guard.condition.signal();\n    //         break;\n    //       }\n    //     }\n    //   }\n\n    /**\n     * Exactly like guard.isSatisfied(), but in addition signals all waiting threads in the (hopefully\n     * unlikely) event that isSatisfied() throws.\n     */\n    @GuardedBy(\"lock\")\n    private boolean isSatisfied(Guard guard)\n    {\n        try\n        {\n            return guard.isSatisfied();\n        }\n        catch (Throwable throwable)\n        {\n            signalAllWaiters();\n            throw throwable;\n        }\n    }\n\n    /** Signals all threads waiting on guards. */\n\n    /** Records that the current thread is about to wait on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void beginWaitingFor(Guard guard)\n    {\n        int waiters = guard.waiterCount++;\n        if (waiters == 0)\n        {\n            // push guard onto activeGuards\n            guard.next = activeGuards;\n            activeGuards = guard;\n        }\n    }\n\n    /** Records that the current thread is no longer waiting on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void endWaitingFor(Guard guard)\n    {\n        int waiters = --guard.waiterCount;\n        if (waiters == 0)\n        {\n            // unlink guard from activeGuards\n            for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next)\n            {\n                if (p == guard)\n                {\n                    if (pred == null)\n                    {\n                        activeGuards = p.next;\n                    }\n                    else\n                    {\n                        pred.next = p.next;\n                    }\n                    p.next = null; // help GC\n                    break;\n                }\n            }\n        }\n    }\n\n    /*\n     * Methods that loop waiting on a guard's condition until the guard is satisfied, while recording\n     * this fact so that other threads know to check our guard and signal us. It's caller's\n     * responsibility to ensure that the guard is *not* currently satisfied.\n     */\n\n    @GuardedBy(\"lock\")\n    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.await();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    @GuardedBy(\"lock\")\n    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.awaitUninterruptibly();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    /** Caller should check before calling that guard is not satisfied. */\n    @GuardedBy(\"lock\")\n    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n    throws InterruptedException\n    {\n        boolean firstTime = true;\n        try\n        {\n            do\n            {\n                if (nanos <= 0L)\n                {\n                    return false;\n                }\n                if (firstTime)\n                {\n                    if (signalBeforeWaiting)\n                    {\n                        signalNextWaiter();\n                    }\n                    beginWaitingFor(guard);\n                    firstTime = false;\n                }\n                nanos = guard.condition.awaitNanos(nanos);\n            }\n            while (!guard.isSatisfied());\n            return true;\n        }\n        finally\n        {\n            if (!firstTime)\n            {\n                endWaitingFor(guard);\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.beginWaitingFor", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Records that the current thread is about to wait on the specified guard.", "docstring_tokens": ["Records", "that", "the", "current", "thread", "is", "about", "to", "wait", "on", "the", "specified", "guard", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L1031-L1039", "partition": "valid", "up_fun_num": 35, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.errorprone.annotations.concurrent.GuardedBy;", "import com.google.j2objc.annotations.Weak;", "import java.util.concurrent.TimeUnit;", "import java.util.concurrent.locks.Condition;", "import java.util.concurrent.locks.ReentrantLock;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Monitor\n", "    public void enter()\n", "    public boolean enter(long time, TimeUnit unit)\n", "    public void enterInterruptibly() throws InterruptedException\n", "    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n", "    public boolean tryEnter()\n", "    public void enterWhen(Guard guard) throws InterruptedException\n", "    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void enterWhenUninterruptibly(Guard guard)\n", "    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIf(Guard guard)\n", "    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n", "    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean tryEnterIf(Guard guard)\n", "    public void waitFor(Guard guard) throws InterruptedException\n", "    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void waitForUninterruptibly(Guard guard)\n", "    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public void leave()\n", "    public boolean isFair()\n", "    public boolean isOccupied()\n", "    public boolean isOccupiedByCurrentThread()\n", "    public int getOccupiedDepth()\n", "    public int getQueueLength()\n", "    public boolean hasQueuedThreads()\n", "    public boolean hasQueuedThread(Thread thread)\n", "    public boolean hasWaiters(Guard guard)\n", "    public int getWaitQueueLength(Guard guard)\n", "    private static long toSafeNanos(long time, TimeUnit unit)\n", "    private static long initNanoTime(long timeoutNanos)\n", "    private static long remainingNanos(long startTime, long timeoutNanos)\n", "    private void signalNextWaiter()\n", "    private boolean isSatisfied(Guard guard)\n", "    private void signalAllWaiters()\n", "    private void endWaitingFor(Guard guard)\n", "    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n", "    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n", "    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n"], "context": "/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.concurrent.GuardedBy;\nimport com.google.j2objc.annotations.Weak;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A synchronization abstraction supporting waiting on arbitrary boolean conditions.\n *\n * <p>This class is intended as a replacement for {@link ReentrantLock}. Code using {@code Monitor}\n * is less error-prone and more readable than code using {@code ReentrantLock}, without significant\n * performance loss. {@code Monitor} even has the potential for performance gain by optimizing the\n * evaluation and signaling of conditions. Signaling is entirely <a\n * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>. By\n * eliminating explicit signaling, this class can guarantee that only one thread is awakened when a\n * condition becomes true (no \"signaling storms\" due to use of {@link\n * java.util.concurrent.locks.Condition#signalAll Condition.signalAll}) and that no signals are lost\n * (no \"hangs\" due to incorrect use of {@link java.util.concurrent.locks.Condition#signal\n * Condition.signal}).\n *\n * <p>A thread is said to <i>occupy</i> a monitor if it has <i>entered</i> the monitor but not yet\n * <i>left</i>. Only one thread may occupy a given monitor at any moment. A monitor is also\n * reentrant, so a thread may enter a monitor any number of times, and then must leave the same\n * number of times. The <i>enter</i> and <i>leave</i> operations have the same synchronization\n * semantics as the built-in Java language synchronization primitives.\n *\n * <p>A call to any of the <i>enter</i> methods with <b>void</b> return type should always be\n * followed immediately by a <i>try/finally</i> block to ensure that the current thread leaves the\n * monitor cleanly:\n *\n * <pre>{@code\n * monitor.enter();\n * try {\n *   // do things while occupying the monitor\n * } finally {\n *   monitor.leave();\n * }\n * }</pre>\n *\n * <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear\n * as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that\n * the current thread leaves the monitor cleanly:\n *\n * <pre>{@code\n * if (monitor.tryEnter()) {\n *   try {\n *     // do things while occupying the monitor\n *   } finally {\n *     monitor.leave();\n *   }\n * } else {\n *   // do other things since the monitor was not available\n * }\n * }</pre>\n *\n * <h2>Comparison with {@code synchronized} and {@code ReentrantLock}</h2>\n *\n * <p>The following examples show a simple threadsafe holder expressed using {@code synchronized},\n * {@link ReentrantLock}, and {@code Monitor}.\n *\n * <h3>{@code synchronized}</h3>\n *\n * <p>This version is the fewest lines of code, largely because the synchronization mechanism used\n * is built into the language and runtime. But the programmer has to remember to avoid a couple of\n * common bugs: The {@code wait()} must be inside a {@code while} instead of an {@code if}, and\n * {@code notifyAll()} must be used instead of {@code notify()} because there are two different\n * logical conditions being awaited.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *\n *   public synchronized V get() throws InterruptedException {\n *     while (value == null) {\n *       wait();\n *     }\n *     V result = value;\n *     value = null;\n *     notifyAll();\n *     return result;\n *   }\n *\n *   public synchronized void set(V newValue) throws InterruptedException {\n *     while (value != null) {\n *       wait();\n *     }\n *     value = newValue;\n *     notifyAll();\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code ReentrantLock}</h3>\n *\n * <p>This version is much more verbose than the {@code synchronized} version, and still suffers\n * from the need for the programmer to remember to use {@code while} instead of {@code if}. However,\n * one advantage is that we can introduce two separate {@code Condition} objects, which allows us to\n * use {@code signal()} instead of {@code signalAll()}, which may be a performance benefit.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final ReentrantLock lock = new ReentrantLock();\n *   private final Condition valuePresent = lock.newCondition();\n *   private final Condition valueAbsent = lock.newCondition();\n *\n *   public V get() throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value == null) {\n *         valuePresent.await();\n *       }\n *       V result = value;\n *       value = null;\n *       valueAbsent.signal();\n *       return result;\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value != null) {\n *         valueAbsent.await();\n *       }\n *       value = newValue;\n *       valuePresent.signal();\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code Monitor}</h3>\n *\n * <p>This version adds some verbosity around the {@code Guard} objects, but removes that same\n * verbosity, and more, from the {@code get} and {@code set} methods. {@code Monitor} implements the\n * same efficient signaling as we had to hand-code in the {@code ReentrantLock} version above.\n * Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to\n * remember to use {@code while} instead of {@code if}.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final Monitor monitor = new Monitor();\n *   private final Monitor.Guard valuePresent = monitor.newGuard(() -> value != null);\n *   private final Monitor.Guard valueAbsent = monitor.newGuard(() -> value == null);\n *\n *   public V get() throws InterruptedException {\n *     monitor.enterWhen(valuePresent);\n *     try {\n *       V result = value;\n *       value = null;\n *       return result;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     monitor.enterWhen(valueAbsent);\n *     try {\n *       value = newValue;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n * }\n * }</pre>\n *\n * @author Justin T. Sampson\n * @author Martin Buchholz\n * @since 10.0\n */\n@Beta\n@GwtIncompatible\n@SuppressWarnings(\"GuardedBy\") // TODO(b/35466881): Fix or suppress.\npublic final class Monitor\n{\n    // TODO(user): Use raw LockSupport or AbstractQueuedSynchronizer instead of ReentrantLock.\n    // TODO(user): \"Port\" jsr166 tests for ReentrantLock.\n    //\n    // TODO(user): Change API to make it impossible to use a Guard with the \"wrong\" monitor,\n    //    by making the monitor implicit, and to eliminate other sources of IMSE.\n    //    Imagine:\n    //    guard.lock();\n    //    try { /* monitor locked and guard satisfied here */ }\n    //    finally { guard.unlock(); }\n    // Here are Justin's design notes about this:\n    //\n    // This idea has come up from time to time, and I think one of my\n    // earlier versions of Monitor even did something like this. I ended\n    // up strongly favoring the current interface.\n    //\n    // I probably can't remember all the reasons (it's possible you\n    // could find them in the code review archives), but here are a few:\n    //\n    // 1. What about leaving/unlocking? Are you going to do\n    //    guard.enter() paired with monitor.leave()? That might get\n    //    confusing. It's nice for the finally block to look as close as\n    //    possible to the thing right before the try. You could have\n    //    guard.leave(), but that's a little odd as well because the\n    //    guard doesn't have anything to do with leaving. You can't\n    //    really enforce that the guard you're leaving is the same one\n    //    you entered with, and it doesn't actually matter.\n    //\n    // 2. Since you can enter the monitor without a guard at all, some\n    //    places you'll have monitor.enter()/monitor.leave() and other\n    //    places you'll have guard.enter()/guard.leave() even though\n    //    it's the same lock being acquired underneath. Always using\n    //    monitor.enterXXX()/monitor.leave() will make it really clear\n    //    which lock is held at any point in the code.\n    //\n    // 3. I think \"enterWhen(notEmpty)\" reads better than \"notEmpty.enter()\".\n    //\n    // TODO(user): Implement ReentrantLock features:\n    //    - toString() method\n    //    - getOwner() method\n    //    - getQueuedThreads() method\n    //    - getWaitingThreads(Guard) method\n    //    - implement Serializable\n    //    - redo the API to be as close to identical to ReentrantLock as possible,\n    //      since, after all, this class is also a reentrant mutual exclusion lock!?\n\n    /*\n     * One of the key challenges of this class is to prevent lost signals, while trying hard to\n     * minimize unnecessary signals. One simple and correct algorithm is to signal some other waiter\n     * with a satisfied guard (if one exists) whenever any thread occupying the monitor exits the\n     * monitor, either by unlocking all of its held locks, or by starting to wait for a guard. This\n     * includes exceptional exits, so all control paths involving signalling must be protected by a\n     * finally block.\n     *\n     * Further optimizations of this algorithm become increasingly subtle. A wait that terminates\n     * without the guard being satisfied (due to timeout, but not interrupt) can then immediately exit\n     * the monitor without signalling. If it timed out without being signalled, it does not need to\n     * \"pass on\" the signal to another thread. If it *was* signalled, then its guard must have been\n     * satisfied at the time of signal, and has since been modified by some other thread to be\n     * non-satisfied before reacquiring the lock, and that other thread takes over the responsibility\n     * of signaling the next waiter.\n     *\n     * Unlike the underlying Condition, if we are not careful, an interrupt *can* cause a signal to be\n     * lost, because the signal may be sent to a condition whose sole waiter has just been\n     * interrupted.\n     *\n     * Imagine a monitor with multiple guards. A thread enters the monitor, satisfies all the guards,\n     * and leaves, calling signalNextWaiter. With traditional locks and conditions, all the conditions\n     * need to be signalled because it is not known which if any of them have waiters (and hasWaiters\n     * can't be used reliably because of a check-then-act race). With our Monitor guards, we only\n     * signal the first active guard that is satisfied. But the corresponding thread may have already\n     * been interrupted and is waiting to reacquire the lock while still registered in activeGuards,\n     * in which case the signal is a no-op, and the bigger-picture signal is lost unless interrupted\n     * threads take special action by participating in the signal-passing game.\n     */\n\n    /*\n     * Timeout handling is intricate, especially given our ambitious goals:\n     * - Avoid underflow and overflow of timeout values when specified timeouts are close to\n     *   Long.MIN_VALUE or Long.MAX_VALUE.\n     * - Favor responding to interrupts over timeouts.\n     * - System.nanoTime() is expensive enough that we want to call it the minimum required number of\n     *   times, typically once before invoking a blocking method. This often requires keeping track of\n     *   the first time in a method that nanoTime() has been invoked, for which the special value 0L\n     *   is reserved to mean \"uninitialized\". If timeout is non-positive, then nanoTime need never be\n     *   called.\n     * - Keep behavior of fair and non-fair instances consistent.\n     */\n\n    /**\n     * A boolean condition for which a thread may wait. A {@code Guard} is associated with a single\n     * {@code Monitor}. The monitor may check the guard at arbitrary times from any thread occupying\n     * the monitor, so code should not be written to rely on how often a guard might or might not be\n     * checked.\n     *\n     * <p>If a {@code Guard} is passed into any method of a {@code Monitor} other than the one it is\n     * associated with, an {@link IllegalMonitorStateException} is thrown.\n     *\n     * @since 10.0\n     */\n    @Beta\n    public abstract static class Guard\n    {\n\n        @Weak final Monitor monitor;\n        final Condition condition;\n\n        @GuardedBy(\"monitor.lock\")\n        int waiterCount = 0;\n\n        /** The next active guard */\n        @GuardedBy(\"monitor.lock\")\n        @NullableDecl\n        Guard next;\n\n        protected Guard(Monitor monitor)\n        {\n            this.monitor = checkNotNull(monitor, \"monitor\");\n            this.condition = monitor.lock.newCondition();\n        }\n\n        /**\n         * Evaluates this guard's boolean condition. This method is always called with the associated\n         * monitor already occupied. Implementations of this method must depend only on state protected\n         * by the associated monitor, and must not modify that state.\n         */\n        public abstract boolean isSatisfied();\n    }\n\n    /** Whether this monitor is fair. */\n    private final boolean fair;\n\n    /** The lock underlying this monitor. */\n    private final ReentrantLock lock;\n\n    /**\n     * The guards associated with this monitor that currently have waiters ({@code waiterCount > 0}).\n     * A linked list threaded through the Guard.next field.\n     */\n    @GuardedBy(\"lock\")\n    private Guard activeGuards = null;\n\n    /**\n     * Creates a monitor with a non-fair (but fast) ordering policy. Equivalent to {@code\n     * Monitor(false)}.\n     */\n    public Monitor()\n    {\n        this(false);\n    }\n\n    /**\n     * Creates a monitor with the given ordering policy.\n     *\n     * @param fair whether this monitor should use a fair ordering policy rather than a non-fair (but\n     *     fast) one\n     */\n    public Monitor(boolean fair)\n    {\n        this.fair = fair;\n        this.lock = new ReentrantLock(fair);\n    }\n\n    /** Enters this monitor. Blocks indefinitely. */\n    public void enter()\n    {\n        lock.lock();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time.\n     *\n     * @return whether the monitor was entered\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enter(long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        final ReentrantLock lock = this.lock;\n        if (!fair && lock.tryLock())\n        {\n            return true;\n        }\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            final long startTime = System.nanoTime();\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterInterruptibly() throws InterruptedException\n    {\n        lock.lockInterruptibly();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time, and may be interrupted.\n     *\n     * @return whether the monitor was entered\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n    {\n        return lock.tryLock(time, unit);\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately. Does not block.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered\n     */\n    public boolean tryEnter()\n    {\n        return lock.tryLock();\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterWhen(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                await(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied, and may be\n     * interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean reentrant = lock.isHeldByCurrentThread();\n        long startTime = 0L;\n\n        locked:\n        {\n            if (!fair)\n            {\n                // Check interrupt status to get behavior consistent with fair case.\n                if (Thread.interrupted())\n                {\n                    throw new InterruptedException();\n                }\n                if (lock.tryLock())\n                {\n                    break locked;\n                }\n            }\n            startTime = initNanoTime(timeoutNanos);\n            if (!lock.tryLock(time, unit))\n            {\n                return false;\n            }\n        }\n\n        boolean satisfied = false;\n        boolean threw = true;\n        try\n        {\n            satisfied =\n                guard.isSatisfied()\n                || awaitNanos(\n                    guard,\n                    (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),\n                    reentrant);\n            threw = false;\n            return satisfied;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                try\n                {\n                    // Don't need to signal if timed out, but do if interrupted\n                    if (threw && !reentrant)\n                    {\n                        signalNextWaiter();\n                    }\n                }\n                finally\n                {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n\n    /** Enters this monitor when the guard is satisfied. Blocks indefinitely. */\n    public void enterWhenUninterruptibly(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                awaitUninterruptibly(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        long startTime = 0L;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            if (fair || !lock.tryLock())\n            {\n                startTime = initNanoTime(timeoutNanos);\n                for (long remainingNanos = timeoutNanos; ; )\n                {\n                    try\n                    {\n                        if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS))\n                        {\n                            break;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        remainingNanos = remainingNanos(startTime, timeoutNanos);\n                    }\n                }\n            }\n\n            boolean satisfied = false;\n            try\n            {\n                while (true)\n                {\n                    try\n                    {\n                        if (guard.isSatisfied())\n                        {\n                            satisfied = true;\n                        }\n                        else\n                        {\n                            final long remainingNanos;\n                            if (startTime == 0L)\n                            {\n                                startTime = initNanoTime(timeoutNanos);\n                                remainingNanos = timeoutNanos;\n                            }\n                            else\n                            {\n                                remainingNanos = remainingNanos(startTime, timeoutNanos);\n                            }\n                            satisfied = awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                        }\n                        return satisfied;\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        signalBeforeWaiting = false;\n                    }\n                }\n            }\n            finally\n            {\n                if (!satisfied)\n                {\n                    lock.unlock(); // No need to signal if timed out\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean enterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!enter(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n    throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not\n     * block acquiring the lock and does not wait for the guard to be satisfied.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean tryEnterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock())\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be called\n     * only by a thread currently occupying this monitor.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void waitFor(Guard guard) throws InterruptedException\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            await(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted. May\n     * be called only by a thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        if (Thread.interrupted())\n        {\n            throw new InterruptedException();\n        }\n        return awaitNanos(guard, timeoutNanos, true);\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread\n     * currently occupying this monitor.\n     */\n    public void waitForUninterruptibly(Guard guard)\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            awaitUninterruptibly(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time. May be called only by a\n     * thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        boolean signalBeforeWaiting = true;\n        final long startTime = initNanoTime(timeoutNanos);\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    if (guard.isSatisfied())\n                    {\n                        return true;\n                    }\n                    signalBeforeWaiting = false;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /** Leaves this monitor. May be called only by a thread currently occupying this monitor. */\n    public void leave()\n    {\n        final ReentrantLock lock = this.lock;\n        try\n        {\n            // No need to signal if we will still be holding the lock when we return\n            if (lock.getHoldCount() == 1)\n            {\n                signalNextWaiter();\n            }\n        }\n        finally\n        {\n            lock.unlock(); // Will throw IllegalMonitorStateException if not held\n        }\n    }\n\n    /** Returns whether this monitor is using a fair ordering policy. */\n    public boolean isFair()\n    {\n        return fair;\n    }\n\n    /**\n     * Returns whether this monitor is occupied by any thread. This method is designed for use in\n     * monitoring of the system state, not for synchronization control.\n     */\n    public boolean isOccupied()\n    {\n        return lock.isLocked();\n    }\n\n    /**\n     * Returns whether the current thread is occupying this monitor (has entered more times than it\n     * has left).\n     */\n    public boolean isOccupiedByCurrentThread()\n    {\n        return lock.isHeldByCurrentThread();\n    }\n\n    /**\n     * Returns the number of times the current thread has entered this monitor in excess of the number\n     * of times it has left. Returns 0 if the current thread is not occupying this monitor.\n     */\n    public int getOccupiedDepth()\n    {\n        return lock.getHoldCount();\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting to enter this monitor. The value is only\n     * an estimate because the number of threads may change dynamically while this method traverses\n     * internal data structures. This method is designed for use in monitoring of the system state,\n     * not for synchronization control.\n     */\n    public int getQueueLength()\n    {\n        return lock.getQueueLength();\n    }\n\n    /**\n     * Returns whether any threads are waiting to enter this monitor. Note that because cancellations\n     * may occur at any time, a {@code true} return does not guarantee that any other thread will ever\n     * enter this monitor. This method is designed primarily for use in monitoring of the system\n     * state.\n     */\n    public boolean hasQueuedThreads()\n    {\n        return lock.hasQueuedThreads();\n    }\n\n    /**\n     * Queries whether the given thread is waiting to enter this monitor. Note that because\n     * cancellations may occur at any time, a {@code true} return does not guarantee that this thread\n     * will ever enter this monitor. This method is designed primarily for use in monitoring of the\n     * system state.\n     */\n    public boolean hasQueuedThread(Thread thread)\n    {\n        return lock.hasQueuedThread(thread);\n    }\n\n    /**\n     * Queries whether any threads are waiting for the given guard to become satisfied. Note that\n     * because timeouts and interrupts may occur at any time, a {@code true} return does not guarantee\n     * that the guard becoming satisfied in the future will awaken any threads. This method is\n     * designed primarily for use in monitoring of the system state.\n     */\n    public boolean hasWaiters(Guard guard)\n    {\n        return getWaitQueueLength(guard) > 0;\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting for the given guard to become satisfied.\n     * Note that because timeouts and interrupts may occur at any time, the estimate serves only as an\n     * upper bound on the actual number of waiters. This method is designed for use in monitoring of\n     * the system state, not for synchronization control.\n     */\n    public int getWaitQueueLength(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        lock.lock();\n        try\n        {\n            return guard.waiterCount;\n        }\n        finally\n        {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Returns unit.toNanos(time), additionally ensuring the returned value is not at risk of\n     * overflowing or underflowing, by bounding the value between 0 and (Long.MAX_VALUE / 4) * 3.\n     * Actually waiting for more than 219 years is not supported!\n     */\n    private static long toSafeNanos(long time, TimeUnit unit)\n    {\n        long timeoutNanos = unit.toNanos(time);\n        return (timeoutNanos <= 0L)\n               ? 0L\n               : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3 : timeoutNanos;\n    }\n\n    /**\n     * Returns System.nanoTime() unless the timeout has already elapsed. Returns 0L if and only if the\n     * timeout has already elapsed.\n     */\n    private static long initNanoTime(long timeoutNanos)\n    {\n        if (timeoutNanos <= 0L)\n        {\n            return 0L;\n        }\n        else\n        {\n            long startTime = System.nanoTime();\n            return (startTime == 0L) ? 1L : startTime;\n        }\n    }\n\n    /**\n     * Returns the remaining nanos until the given timeout, or 0L if the timeout has already elapsed.\n     * Caller must have previously sanitized timeoutNanos using toSafeNanos.\n     */\n    private static long remainingNanos(long startTime, long timeoutNanos)\n    {\n        // assert timeoutNanos == 0L || startTime != 0L;\n\n        // TODO : NOT CORRECT, BUT TESTS PASS ANYWAYS!\n        // if (true) return timeoutNanos;\n        // ONLY 2 TESTS FAIL IF WE DO:\n        // if (true) return 0;\n\n        return (timeoutNanos <= 0L) ? 0L : timeoutNanos - (System.nanoTime() - startTime);\n    }\n\n    /**\n     * Signals some other thread waiting on a satisfied guard, if one exists.\n     *\n     * <p>We manage calls to this method carefully, to signal only when necessary, but never losing a\n     * signal, which is the classic problem of this kind of concurrency construct. We must signal if\n     * the current thread is about to relinquish the lock and may have changed the state protected by\n     * the monitor, thereby causing some guard to be satisfied.\n     *\n     * <p>In addition, any thread that has been signalled when its guard was satisfied acquires the\n     * responsibility of signalling the next thread when it again relinquishes the lock. Unlike a\n     * normal Condition, there is no guarantee that an interrupted thread has not been signalled,\n     * since the concurrency control must manage multiple Conditions. So this method must generally be\n     * called when waits are interrupted.\n     *\n     * <p>On the other hand, if a signalled thread wakes up to discover that its guard is still not\n     * satisfied, it does *not* need to call this method before returning to wait. This can only\n     * happen due to spurious wakeup (ignorable) or another thread acquiring the lock before the\n     * current thread can and returning the guard to the unsatisfied state. In the latter case the\n     * other thread (last thread modifying the state protected by the monitor) takes over the\n     * responsibility of signalling the next waiter.\n     *\n     * <p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else\n     * the current thread's guard might be mistakenly signalled, leading to a lost signal.\n     */\n    @GuardedBy(\"lock\")\n    private void signalNextWaiter()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            if (isSatisfied(guard))\n            {\n                guard.condition.signal();\n                break;\n            }\n        }\n    }\n\n    /**\n     * Exactly like signalNextWaiter, but caller guarantees that guardToSkip need not be considered,\n     * because caller has previously checked that guardToSkip.isSatisfied() returned false. An\n     * optimization for the case that guardToSkip.isSatisfied() may be expensive.\n     *\n     * <p>We decided against using this method, since in practice, isSatisfied() is likely to be very\n     * cheap (typically one field read). Resurrect this method if you find that not to be true.\n     */\n    //   @GuardedBy(\"lock\")\n    //   private void signalNextWaiterSkipping(Guard guardToSkip) {\n    //     for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n    //       if (guard != guardToSkip && isSatisfied(guard)) {\n    //         guard.condition.signal();\n    //         break;\n    //       }\n    //     }\n    //   }\n\n    /**\n     * Exactly like guard.isSatisfied(), but in addition signals all waiting threads in the (hopefully\n     * unlikely) event that isSatisfied() throws.\n     */\n    @GuardedBy(\"lock\")\n    private boolean isSatisfied(Guard guard)\n    {\n        try\n        {\n            return guard.isSatisfied();\n        }\n        catch (Throwable throwable)\n        {\n            signalAllWaiters();\n            throw throwable;\n        }\n    }\n\n    /** Signals all threads waiting on guards. */\n    @GuardedBy(\"lock\")\n    private void signalAllWaiters()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            guard.condition.signalAll();\n        }\n    }\n\n    /** Records that the current thread is about to wait on the specified guard. */\n\n    /** Records that the current thread is no longer waiting on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void endWaitingFor(Guard guard)\n    {\n        int waiters = --guard.waiterCount;\n        if (waiters == 0)\n        {\n            // unlink guard from activeGuards\n            for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next)\n            {\n                if (p == guard)\n                {\n                    if (pred == null)\n                    {\n                        activeGuards = p.next;\n                    }\n                    else\n                    {\n                        pred.next = p.next;\n                    }\n                    p.next = null; // help GC\n                    break;\n                }\n            }\n        }\n    }\n\n    /*\n     * Methods that loop waiting on a guard's condition until the guard is satisfied, while recording\n     * this fact so that other threads know to check our guard and signal us. It's caller's\n     * responsibility to ensure that the guard is *not* currently satisfied.\n     */\n\n    @GuardedBy(\"lock\")\n    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.await();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    @GuardedBy(\"lock\")\n    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.awaitUninterruptibly();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    /** Caller should check before calling that guard is not satisfied. */\n    @GuardedBy(\"lock\")\n    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n    throws InterruptedException\n    {\n        boolean firstTime = true;\n        try\n        {\n            do\n            {\n                if (nanos <= 0L)\n                {\n                    return false;\n                }\n                if (firstTime)\n                {\n                    if (signalBeforeWaiting)\n                    {\n                        signalNextWaiter();\n                    }\n                    beginWaitingFor(guard);\n                    firstTime = false;\n                }\n                nanos = guard.condition.awaitNanos(nanos);\n            }\n            while (!guard.isSatisfied());\n            return true;\n        }\n        finally\n        {\n            if (!firstTime)\n            {\n                endWaitingFor(guard);\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.endWaitingFor", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Records that the current thread is no longer waiting on the specified guard.", "docstring_tokens": ["Records", "that", "the", "current", "thread", "is", "no", "longer", "waiting", "on", "the", "specified", "guard", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L1042-L1059", "partition": "valid", "up_fun_num": 36, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.errorprone.annotations.concurrent.GuardedBy;", "import com.google.j2objc.annotations.Weak;", "import java.util.concurrent.TimeUnit;", "import java.util.concurrent.locks.Condition;", "import java.util.concurrent.locks.ReentrantLock;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Monitor\n", "    public void enter()\n", "    public boolean enter(long time, TimeUnit unit)\n", "    public void enterInterruptibly() throws InterruptedException\n", "    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n", "    public boolean tryEnter()\n", "    public void enterWhen(Guard guard) throws InterruptedException\n", "    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void enterWhenUninterruptibly(Guard guard)\n", "    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIf(Guard guard)\n", "    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n", "    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean tryEnterIf(Guard guard)\n", "    public void waitFor(Guard guard) throws InterruptedException\n", "    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void waitForUninterruptibly(Guard guard)\n", "    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public void leave()\n", "    public boolean isFair()\n", "    public boolean isOccupied()\n", "    public boolean isOccupiedByCurrentThread()\n", "    public int getOccupiedDepth()\n", "    public int getQueueLength()\n", "    public boolean hasQueuedThreads()\n", "    public boolean hasQueuedThread(Thread thread)\n", "    public boolean hasWaiters(Guard guard)\n", "    public int getWaitQueueLength(Guard guard)\n", "    private static long toSafeNanos(long time, TimeUnit unit)\n", "    private static long initNanoTime(long timeoutNanos)\n", "    private static long remainingNanos(long startTime, long timeoutNanos)\n", "    private void signalNextWaiter()\n", "    private boolean isSatisfied(Guard guard)\n", "    private void signalAllWaiters()\n", "    private void beginWaitingFor(Guard guard)\n", "    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n", "    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n", "    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n"], "context": "/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.concurrent.GuardedBy;\nimport com.google.j2objc.annotations.Weak;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A synchronization abstraction supporting waiting on arbitrary boolean conditions.\n *\n * <p>This class is intended as a replacement for {@link ReentrantLock}. Code using {@code Monitor}\n * is less error-prone and more readable than code using {@code ReentrantLock}, without significant\n * performance loss. {@code Monitor} even has the potential for performance gain by optimizing the\n * evaluation and signaling of conditions. Signaling is entirely <a\n * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>. By\n * eliminating explicit signaling, this class can guarantee that only one thread is awakened when a\n * condition becomes true (no \"signaling storms\" due to use of {@link\n * java.util.concurrent.locks.Condition#signalAll Condition.signalAll}) and that no signals are lost\n * (no \"hangs\" due to incorrect use of {@link java.util.concurrent.locks.Condition#signal\n * Condition.signal}).\n *\n * <p>A thread is said to <i>occupy</i> a monitor if it has <i>entered</i> the monitor but not yet\n * <i>left</i>. Only one thread may occupy a given monitor at any moment. A monitor is also\n * reentrant, so a thread may enter a monitor any number of times, and then must leave the same\n * number of times. The <i>enter</i> and <i>leave</i> operations have the same synchronization\n * semantics as the built-in Java language synchronization primitives.\n *\n * <p>A call to any of the <i>enter</i> methods with <b>void</b> return type should always be\n * followed immediately by a <i>try/finally</i> block to ensure that the current thread leaves the\n * monitor cleanly:\n *\n * <pre>{@code\n * monitor.enter();\n * try {\n *   // do things while occupying the monitor\n * } finally {\n *   monitor.leave();\n * }\n * }</pre>\n *\n * <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear\n * as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that\n * the current thread leaves the monitor cleanly:\n *\n * <pre>{@code\n * if (monitor.tryEnter()) {\n *   try {\n *     // do things while occupying the monitor\n *   } finally {\n *     monitor.leave();\n *   }\n * } else {\n *   // do other things since the monitor was not available\n * }\n * }</pre>\n *\n * <h2>Comparison with {@code synchronized} and {@code ReentrantLock}</h2>\n *\n * <p>The following examples show a simple threadsafe holder expressed using {@code synchronized},\n * {@link ReentrantLock}, and {@code Monitor}.\n *\n * <h3>{@code synchronized}</h3>\n *\n * <p>This version is the fewest lines of code, largely because the synchronization mechanism used\n * is built into the language and runtime. But the programmer has to remember to avoid a couple of\n * common bugs: The {@code wait()} must be inside a {@code while} instead of an {@code if}, and\n * {@code notifyAll()} must be used instead of {@code notify()} because there are two different\n * logical conditions being awaited.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *\n *   public synchronized V get() throws InterruptedException {\n *     while (value == null) {\n *       wait();\n *     }\n *     V result = value;\n *     value = null;\n *     notifyAll();\n *     return result;\n *   }\n *\n *   public synchronized void set(V newValue) throws InterruptedException {\n *     while (value != null) {\n *       wait();\n *     }\n *     value = newValue;\n *     notifyAll();\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code ReentrantLock}</h3>\n *\n * <p>This version is much more verbose than the {@code synchronized} version, and still suffers\n * from the need for the programmer to remember to use {@code while} instead of {@code if}. However,\n * one advantage is that we can introduce two separate {@code Condition} objects, which allows us to\n * use {@code signal()} instead of {@code signalAll()}, which may be a performance benefit.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final ReentrantLock lock = new ReentrantLock();\n *   private final Condition valuePresent = lock.newCondition();\n *   private final Condition valueAbsent = lock.newCondition();\n *\n *   public V get() throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value == null) {\n *         valuePresent.await();\n *       }\n *       V result = value;\n *       value = null;\n *       valueAbsent.signal();\n *       return result;\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value != null) {\n *         valueAbsent.await();\n *       }\n *       value = newValue;\n *       valuePresent.signal();\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code Monitor}</h3>\n *\n * <p>This version adds some verbosity around the {@code Guard} objects, but removes that same\n * verbosity, and more, from the {@code get} and {@code set} methods. {@code Monitor} implements the\n * same efficient signaling as we had to hand-code in the {@code ReentrantLock} version above.\n * Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to\n * remember to use {@code while} instead of {@code if}.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final Monitor monitor = new Monitor();\n *   private final Monitor.Guard valuePresent = monitor.newGuard(() -> value != null);\n *   private final Monitor.Guard valueAbsent = monitor.newGuard(() -> value == null);\n *\n *   public V get() throws InterruptedException {\n *     monitor.enterWhen(valuePresent);\n *     try {\n *       V result = value;\n *       value = null;\n *       return result;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     monitor.enterWhen(valueAbsent);\n *     try {\n *       value = newValue;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n * }\n * }</pre>\n *\n * @author Justin T. Sampson\n * @author Martin Buchholz\n * @since 10.0\n */\n@Beta\n@GwtIncompatible\n@SuppressWarnings(\"GuardedBy\") // TODO(b/35466881): Fix or suppress.\npublic final class Monitor\n{\n    // TODO(user): Use raw LockSupport or AbstractQueuedSynchronizer instead of ReentrantLock.\n    // TODO(user): \"Port\" jsr166 tests for ReentrantLock.\n    //\n    // TODO(user): Change API to make it impossible to use a Guard with the \"wrong\" monitor,\n    //    by making the monitor implicit, and to eliminate other sources of IMSE.\n    //    Imagine:\n    //    guard.lock();\n    //    try { /* monitor locked and guard satisfied here */ }\n    //    finally { guard.unlock(); }\n    // Here are Justin's design notes about this:\n    //\n    // This idea has come up from time to time, and I think one of my\n    // earlier versions of Monitor even did something like this. I ended\n    // up strongly favoring the current interface.\n    //\n    // I probably can't remember all the reasons (it's possible you\n    // could find them in the code review archives), but here are a few:\n    //\n    // 1. What about leaving/unlocking? Are you going to do\n    //    guard.enter() paired with monitor.leave()? That might get\n    //    confusing. It's nice for the finally block to look as close as\n    //    possible to the thing right before the try. You could have\n    //    guard.leave(), but that's a little odd as well because the\n    //    guard doesn't have anything to do with leaving. You can't\n    //    really enforce that the guard you're leaving is the same one\n    //    you entered with, and it doesn't actually matter.\n    //\n    // 2. Since you can enter the monitor without a guard at all, some\n    //    places you'll have monitor.enter()/monitor.leave() and other\n    //    places you'll have guard.enter()/guard.leave() even though\n    //    it's the same lock being acquired underneath. Always using\n    //    monitor.enterXXX()/monitor.leave() will make it really clear\n    //    which lock is held at any point in the code.\n    //\n    // 3. I think \"enterWhen(notEmpty)\" reads better than \"notEmpty.enter()\".\n    //\n    // TODO(user): Implement ReentrantLock features:\n    //    - toString() method\n    //    - getOwner() method\n    //    - getQueuedThreads() method\n    //    - getWaitingThreads(Guard) method\n    //    - implement Serializable\n    //    - redo the API to be as close to identical to ReentrantLock as possible,\n    //      since, after all, this class is also a reentrant mutual exclusion lock!?\n\n    /*\n     * One of the key challenges of this class is to prevent lost signals, while trying hard to\n     * minimize unnecessary signals. One simple and correct algorithm is to signal some other waiter\n     * with a satisfied guard (if one exists) whenever any thread occupying the monitor exits the\n     * monitor, either by unlocking all of its held locks, or by starting to wait for a guard. This\n     * includes exceptional exits, so all control paths involving signalling must be protected by a\n     * finally block.\n     *\n     * Further optimizations of this algorithm become increasingly subtle. A wait that terminates\n     * without the guard being satisfied (due to timeout, but not interrupt) can then immediately exit\n     * the monitor without signalling. If it timed out without being signalled, it does not need to\n     * \"pass on\" the signal to another thread. If it *was* signalled, then its guard must have been\n     * satisfied at the time of signal, and has since been modified by some other thread to be\n     * non-satisfied before reacquiring the lock, and that other thread takes over the responsibility\n     * of signaling the next waiter.\n     *\n     * Unlike the underlying Condition, if we are not careful, an interrupt *can* cause a signal to be\n     * lost, because the signal may be sent to a condition whose sole waiter has just been\n     * interrupted.\n     *\n     * Imagine a monitor with multiple guards. A thread enters the monitor, satisfies all the guards,\n     * and leaves, calling signalNextWaiter. With traditional locks and conditions, all the conditions\n     * need to be signalled because it is not known which if any of them have waiters (and hasWaiters\n     * can't be used reliably because of a check-then-act race). With our Monitor guards, we only\n     * signal the first active guard that is satisfied. But the corresponding thread may have already\n     * been interrupted and is waiting to reacquire the lock while still registered in activeGuards,\n     * in which case the signal is a no-op, and the bigger-picture signal is lost unless interrupted\n     * threads take special action by participating in the signal-passing game.\n     */\n\n    /*\n     * Timeout handling is intricate, especially given our ambitious goals:\n     * - Avoid underflow and overflow of timeout values when specified timeouts are close to\n     *   Long.MIN_VALUE or Long.MAX_VALUE.\n     * - Favor responding to interrupts over timeouts.\n     * - System.nanoTime() is expensive enough that we want to call it the minimum required number of\n     *   times, typically once before invoking a blocking method. This often requires keeping track of\n     *   the first time in a method that nanoTime() has been invoked, for which the special value 0L\n     *   is reserved to mean \"uninitialized\". If timeout is non-positive, then nanoTime need never be\n     *   called.\n     * - Keep behavior of fair and non-fair instances consistent.\n     */\n\n    /**\n     * A boolean condition for which a thread may wait. A {@code Guard} is associated with a single\n     * {@code Monitor}. The monitor may check the guard at arbitrary times from any thread occupying\n     * the monitor, so code should not be written to rely on how often a guard might or might not be\n     * checked.\n     *\n     * <p>If a {@code Guard} is passed into any method of a {@code Monitor} other than the one it is\n     * associated with, an {@link IllegalMonitorStateException} is thrown.\n     *\n     * @since 10.0\n     */\n    @Beta\n    public abstract static class Guard\n    {\n\n        @Weak final Monitor monitor;\n        final Condition condition;\n\n        @GuardedBy(\"monitor.lock\")\n        int waiterCount = 0;\n\n        /** The next active guard */\n        @GuardedBy(\"monitor.lock\")\n        @NullableDecl\n        Guard next;\n\n        protected Guard(Monitor monitor)\n        {\n            this.monitor = checkNotNull(monitor, \"monitor\");\n            this.condition = monitor.lock.newCondition();\n        }\n\n        /**\n         * Evaluates this guard's boolean condition. This method is always called with the associated\n         * monitor already occupied. Implementations of this method must depend only on state protected\n         * by the associated monitor, and must not modify that state.\n         */\n        public abstract boolean isSatisfied();\n    }\n\n    /** Whether this monitor is fair. */\n    private final boolean fair;\n\n    /** The lock underlying this monitor. */\n    private final ReentrantLock lock;\n\n    /**\n     * The guards associated with this monitor that currently have waiters ({@code waiterCount > 0}).\n     * A linked list threaded through the Guard.next field.\n     */\n    @GuardedBy(\"lock\")\n    private Guard activeGuards = null;\n\n    /**\n     * Creates a monitor with a non-fair (but fast) ordering policy. Equivalent to {@code\n     * Monitor(false)}.\n     */\n    public Monitor()\n    {\n        this(false);\n    }\n\n    /**\n     * Creates a monitor with the given ordering policy.\n     *\n     * @param fair whether this monitor should use a fair ordering policy rather than a non-fair (but\n     *     fast) one\n     */\n    public Monitor(boolean fair)\n    {\n        this.fair = fair;\n        this.lock = new ReentrantLock(fair);\n    }\n\n    /** Enters this monitor. Blocks indefinitely. */\n    public void enter()\n    {\n        lock.lock();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time.\n     *\n     * @return whether the monitor was entered\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enter(long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        final ReentrantLock lock = this.lock;\n        if (!fair && lock.tryLock())\n        {\n            return true;\n        }\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            final long startTime = System.nanoTime();\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterInterruptibly() throws InterruptedException\n    {\n        lock.lockInterruptibly();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time, and may be interrupted.\n     *\n     * @return whether the monitor was entered\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n    {\n        return lock.tryLock(time, unit);\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately. Does not block.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered\n     */\n    public boolean tryEnter()\n    {\n        return lock.tryLock();\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterWhen(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                await(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied, and may be\n     * interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean reentrant = lock.isHeldByCurrentThread();\n        long startTime = 0L;\n\n        locked:\n        {\n            if (!fair)\n            {\n                // Check interrupt status to get behavior consistent with fair case.\n                if (Thread.interrupted())\n                {\n                    throw new InterruptedException();\n                }\n                if (lock.tryLock())\n                {\n                    break locked;\n                }\n            }\n            startTime = initNanoTime(timeoutNanos);\n            if (!lock.tryLock(time, unit))\n            {\n                return false;\n            }\n        }\n\n        boolean satisfied = false;\n        boolean threw = true;\n        try\n        {\n            satisfied =\n                guard.isSatisfied()\n                || awaitNanos(\n                    guard,\n                    (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),\n                    reentrant);\n            threw = false;\n            return satisfied;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                try\n                {\n                    // Don't need to signal if timed out, but do if interrupted\n                    if (threw && !reentrant)\n                    {\n                        signalNextWaiter();\n                    }\n                }\n                finally\n                {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n\n    /** Enters this monitor when the guard is satisfied. Blocks indefinitely. */\n    public void enterWhenUninterruptibly(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                awaitUninterruptibly(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        long startTime = 0L;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            if (fair || !lock.tryLock())\n            {\n                startTime = initNanoTime(timeoutNanos);\n                for (long remainingNanos = timeoutNanos; ; )\n                {\n                    try\n                    {\n                        if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS))\n                        {\n                            break;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        remainingNanos = remainingNanos(startTime, timeoutNanos);\n                    }\n                }\n            }\n\n            boolean satisfied = false;\n            try\n            {\n                while (true)\n                {\n                    try\n                    {\n                        if (guard.isSatisfied())\n                        {\n                            satisfied = true;\n                        }\n                        else\n                        {\n                            final long remainingNanos;\n                            if (startTime == 0L)\n                            {\n                                startTime = initNanoTime(timeoutNanos);\n                                remainingNanos = timeoutNanos;\n                            }\n                            else\n                            {\n                                remainingNanos = remainingNanos(startTime, timeoutNanos);\n                            }\n                            satisfied = awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                        }\n                        return satisfied;\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        signalBeforeWaiting = false;\n                    }\n                }\n            }\n            finally\n            {\n                if (!satisfied)\n                {\n                    lock.unlock(); // No need to signal if timed out\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean enterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!enter(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n    throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not\n     * block acquiring the lock and does not wait for the guard to be satisfied.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean tryEnterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock())\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be called\n     * only by a thread currently occupying this monitor.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void waitFor(Guard guard) throws InterruptedException\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            await(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted. May\n     * be called only by a thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        if (Thread.interrupted())\n        {\n            throw new InterruptedException();\n        }\n        return awaitNanos(guard, timeoutNanos, true);\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread\n     * currently occupying this monitor.\n     */\n    public void waitForUninterruptibly(Guard guard)\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            awaitUninterruptibly(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time. May be called only by a\n     * thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        boolean signalBeforeWaiting = true;\n        final long startTime = initNanoTime(timeoutNanos);\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    if (guard.isSatisfied())\n                    {\n                        return true;\n                    }\n                    signalBeforeWaiting = false;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /** Leaves this monitor. May be called only by a thread currently occupying this monitor. */\n    public void leave()\n    {\n        final ReentrantLock lock = this.lock;\n        try\n        {\n            // No need to signal if we will still be holding the lock when we return\n            if (lock.getHoldCount() == 1)\n            {\n                signalNextWaiter();\n            }\n        }\n        finally\n        {\n            lock.unlock(); // Will throw IllegalMonitorStateException if not held\n        }\n    }\n\n    /** Returns whether this monitor is using a fair ordering policy. */\n    public boolean isFair()\n    {\n        return fair;\n    }\n\n    /**\n     * Returns whether this monitor is occupied by any thread. This method is designed for use in\n     * monitoring of the system state, not for synchronization control.\n     */\n    public boolean isOccupied()\n    {\n        return lock.isLocked();\n    }\n\n    /**\n     * Returns whether the current thread is occupying this monitor (has entered more times than it\n     * has left).\n     */\n    public boolean isOccupiedByCurrentThread()\n    {\n        return lock.isHeldByCurrentThread();\n    }\n\n    /**\n     * Returns the number of times the current thread has entered this monitor in excess of the number\n     * of times it has left. Returns 0 if the current thread is not occupying this monitor.\n     */\n    public int getOccupiedDepth()\n    {\n        return lock.getHoldCount();\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting to enter this monitor. The value is only\n     * an estimate because the number of threads may change dynamically while this method traverses\n     * internal data structures. This method is designed for use in monitoring of the system state,\n     * not for synchronization control.\n     */\n    public int getQueueLength()\n    {\n        return lock.getQueueLength();\n    }\n\n    /**\n     * Returns whether any threads are waiting to enter this monitor. Note that because cancellations\n     * may occur at any time, a {@code true} return does not guarantee that any other thread will ever\n     * enter this monitor. This method is designed primarily for use in monitoring of the system\n     * state.\n     */\n    public boolean hasQueuedThreads()\n    {\n        return lock.hasQueuedThreads();\n    }\n\n    /**\n     * Queries whether the given thread is waiting to enter this monitor. Note that because\n     * cancellations may occur at any time, a {@code true} return does not guarantee that this thread\n     * will ever enter this monitor. This method is designed primarily for use in monitoring of the\n     * system state.\n     */\n    public boolean hasQueuedThread(Thread thread)\n    {\n        return lock.hasQueuedThread(thread);\n    }\n\n    /**\n     * Queries whether any threads are waiting for the given guard to become satisfied. Note that\n     * because timeouts and interrupts may occur at any time, a {@code true} return does not guarantee\n     * that the guard becoming satisfied in the future will awaken any threads. This method is\n     * designed primarily for use in monitoring of the system state.\n     */\n    public boolean hasWaiters(Guard guard)\n    {\n        return getWaitQueueLength(guard) > 0;\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting for the given guard to become satisfied.\n     * Note that because timeouts and interrupts may occur at any time, the estimate serves only as an\n     * upper bound on the actual number of waiters. This method is designed for use in monitoring of\n     * the system state, not for synchronization control.\n     */\n    public int getWaitQueueLength(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        lock.lock();\n        try\n        {\n            return guard.waiterCount;\n        }\n        finally\n        {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Returns unit.toNanos(time), additionally ensuring the returned value is not at risk of\n     * overflowing or underflowing, by bounding the value between 0 and (Long.MAX_VALUE / 4) * 3.\n     * Actually waiting for more than 219 years is not supported!\n     */\n    private static long toSafeNanos(long time, TimeUnit unit)\n    {\n        long timeoutNanos = unit.toNanos(time);\n        return (timeoutNanos <= 0L)\n               ? 0L\n               : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3 : timeoutNanos;\n    }\n\n    /**\n     * Returns System.nanoTime() unless the timeout has already elapsed. Returns 0L if and only if the\n     * timeout has already elapsed.\n     */\n    private static long initNanoTime(long timeoutNanos)\n    {\n        if (timeoutNanos <= 0L)\n        {\n            return 0L;\n        }\n        else\n        {\n            long startTime = System.nanoTime();\n            return (startTime == 0L) ? 1L : startTime;\n        }\n    }\n\n    /**\n     * Returns the remaining nanos until the given timeout, or 0L if the timeout has already elapsed.\n     * Caller must have previously sanitized timeoutNanos using toSafeNanos.\n     */\n    private static long remainingNanos(long startTime, long timeoutNanos)\n    {\n        // assert timeoutNanos == 0L || startTime != 0L;\n\n        // TODO : NOT CORRECT, BUT TESTS PASS ANYWAYS!\n        // if (true) return timeoutNanos;\n        // ONLY 2 TESTS FAIL IF WE DO:\n        // if (true) return 0;\n\n        return (timeoutNanos <= 0L) ? 0L : timeoutNanos - (System.nanoTime() - startTime);\n    }\n\n    /**\n     * Signals some other thread waiting on a satisfied guard, if one exists.\n     *\n     * <p>We manage calls to this method carefully, to signal only when necessary, but never losing a\n     * signal, which is the classic problem of this kind of concurrency construct. We must signal if\n     * the current thread is about to relinquish the lock and may have changed the state protected by\n     * the monitor, thereby causing some guard to be satisfied.\n     *\n     * <p>In addition, any thread that has been signalled when its guard was satisfied acquires the\n     * responsibility of signalling the next thread when it again relinquishes the lock. Unlike a\n     * normal Condition, there is no guarantee that an interrupted thread has not been signalled,\n     * since the concurrency control must manage multiple Conditions. So this method must generally be\n     * called when waits are interrupted.\n     *\n     * <p>On the other hand, if a signalled thread wakes up to discover that its guard is still not\n     * satisfied, it does *not* need to call this method before returning to wait. This can only\n     * happen due to spurious wakeup (ignorable) or another thread acquiring the lock before the\n     * current thread can and returning the guard to the unsatisfied state. In the latter case the\n     * other thread (last thread modifying the state protected by the monitor) takes over the\n     * responsibility of signalling the next waiter.\n     *\n     * <p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else\n     * the current thread's guard might be mistakenly signalled, leading to a lost signal.\n     */\n    @GuardedBy(\"lock\")\n    private void signalNextWaiter()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            if (isSatisfied(guard))\n            {\n                guard.condition.signal();\n                break;\n            }\n        }\n    }\n\n    /**\n     * Exactly like signalNextWaiter, but caller guarantees that guardToSkip need not be considered,\n     * because caller has previously checked that guardToSkip.isSatisfied() returned false. An\n     * optimization for the case that guardToSkip.isSatisfied() may be expensive.\n     *\n     * <p>We decided against using this method, since in practice, isSatisfied() is likely to be very\n     * cheap (typically one field read). Resurrect this method if you find that not to be true.\n     */\n    //   @GuardedBy(\"lock\")\n    //   private void signalNextWaiterSkipping(Guard guardToSkip) {\n    //     for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n    //       if (guard != guardToSkip && isSatisfied(guard)) {\n    //         guard.condition.signal();\n    //         break;\n    //       }\n    //     }\n    //   }\n\n    /**\n     * Exactly like guard.isSatisfied(), but in addition signals all waiting threads in the (hopefully\n     * unlikely) event that isSatisfied() throws.\n     */\n    @GuardedBy(\"lock\")\n    private boolean isSatisfied(Guard guard)\n    {\n        try\n        {\n            return guard.isSatisfied();\n        }\n        catch (Throwable throwable)\n        {\n            signalAllWaiters();\n            throw throwable;\n        }\n    }\n\n    /** Signals all threads waiting on guards. */\n    @GuardedBy(\"lock\")\n    private void signalAllWaiters()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            guard.condition.signalAll();\n        }\n    }\n\n    /** Records that the current thread is about to wait on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void beginWaitingFor(Guard guard)\n    {\n        int waiters = guard.waiterCount++;\n        if (waiters == 0)\n        {\n            // push guard onto activeGuards\n            guard.next = activeGuards;\n            activeGuards = guard;\n        }\n    }\n\n    /** Records that the current thread is no longer waiting on the specified guard. */\n\n    /*\n     * Methods that loop waiting on a guard's condition until the guard is satisfied, while recording\n     * this fact so that other threads know to check our guard and signal us. It's caller's\n     * responsibility to ensure that the guard is *not* currently satisfied.\n     */\n\n    @GuardedBy(\"lock\")\n    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.await();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    @GuardedBy(\"lock\")\n    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.awaitUninterruptibly();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    /** Caller should check before calling that guard is not satisfied. */\n    @GuardedBy(\"lock\")\n    private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n    throws InterruptedException\n    {\n        boolean firstTime = true;\n        try\n        {\n            do\n            {\n                if (nanos <= 0L)\n                {\n                    return false;\n                }\n                if (firstTime)\n                {\n                    if (signalBeforeWaiting)\n                    {\n                        signalNextWaiter();\n                    }\n                    beginWaitingFor(guard);\n                    firstTime = false;\n                }\n                nanos = guard.condition.awaitNanos(nanos);\n            }\n            while (!guard.isSatisfied());\n            return true;\n        }\n        finally\n        {\n            if (!firstTime)\n            {\n                endWaitingFor(guard);\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.awaitNanos", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Caller should check before calling that guard is not satisfied.", "docstring_tokens": ["Caller", "should", "check", "before", "calling", "that", "guard", "is", "not", "satisfied", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L1098-L1122", "partition": "valid", "up_fun_num": 39, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.errorprone.annotations.concurrent.GuardedBy;", "import com.google.j2objc.annotations.Weak;", "import java.util.concurrent.TimeUnit;", "import java.util.concurrent.locks.Condition;", "import java.util.concurrent.locks.ReentrantLock;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Monitor\n", "    public void enter()\n", "    public boolean enter(long time, TimeUnit unit)\n", "    public void enterInterruptibly() throws InterruptedException\n", "    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n", "    public boolean tryEnter()\n", "    public void enterWhen(Guard guard) throws InterruptedException\n", "    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void enterWhenUninterruptibly(Guard guard)\n", "    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIf(Guard guard)\n", "    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n", "    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n", "    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public boolean tryEnterIf(Guard guard)\n", "    public void waitFor(Guard guard) throws InterruptedException\n", "    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n", "    public void waitForUninterruptibly(Guard guard)\n", "    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n", "    public void leave()\n", "    public boolean isFair()\n", "    public boolean isOccupied()\n", "    public boolean isOccupiedByCurrentThread()\n", "    public int getOccupiedDepth()\n", "    public int getQueueLength()\n", "    public boolean hasQueuedThreads()\n", "    public boolean hasQueuedThread(Thread thread)\n", "    public boolean hasWaiters(Guard guard)\n", "    public int getWaitQueueLength(Guard guard)\n", "    private static long toSafeNanos(long time, TimeUnit unit)\n", "    private static long initNanoTime(long timeoutNanos)\n", "    private static long remainingNanos(long startTime, long timeoutNanos)\n", "    private void signalNextWaiter()\n", "    private boolean isSatisfied(Guard guard)\n", "    private void signalAllWaiters()\n", "    private void beginWaitingFor(Guard guard)\n", "    private void endWaitingFor(Guard guard)\n", "    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n", "    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n"], "context": "/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.concurrent.GuardedBy;\nimport com.google.j2objc.annotations.Weak;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A synchronization abstraction supporting waiting on arbitrary boolean conditions.\n *\n * <p>This class is intended as a replacement for {@link ReentrantLock}. Code using {@code Monitor}\n * is less error-prone and more readable than code using {@code ReentrantLock}, without significant\n * performance loss. {@code Monitor} even has the potential for performance gain by optimizing the\n * evaluation and signaling of conditions. Signaling is entirely <a\n * href=\"http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling\">implicit</a>. By\n * eliminating explicit signaling, this class can guarantee that only one thread is awakened when a\n * condition becomes true (no \"signaling storms\" due to use of {@link\n * java.util.concurrent.locks.Condition#signalAll Condition.signalAll}) and that no signals are lost\n * (no \"hangs\" due to incorrect use of {@link java.util.concurrent.locks.Condition#signal\n * Condition.signal}).\n *\n * <p>A thread is said to <i>occupy</i> a monitor if it has <i>entered</i> the monitor but not yet\n * <i>left</i>. Only one thread may occupy a given monitor at any moment. A monitor is also\n * reentrant, so a thread may enter a monitor any number of times, and then must leave the same\n * number of times. The <i>enter</i> and <i>leave</i> operations have the same synchronization\n * semantics as the built-in Java language synchronization primitives.\n *\n * <p>A call to any of the <i>enter</i> methods with <b>void</b> return type should always be\n * followed immediately by a <i>try/finally</i> block to ensure that the current thread leaves the\n * monitor cleanly:\n *\n * <pre>{@code\n * monitor.enter();\n * try {\n *   // do things while occupying the monitor\n * } finally {\n *   monitor.leave();\n * }\n * }</pre>\n *\n * <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear\n * as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that\n * the current thread leaves the monitor cleanly:\n *\n * <pre>{@code\n * if (monitor.tryEnter()) {\n *   try {\n *     // do things while occupying the monitor\n *   } finally {\n *     monitor.leave();\n *   }\n * } else {\n *   // do other things since the monitor was not available\n * }\n * }</pre>\n *\n * <h2>Comparison with {@code synchronized} and {@code ReentrantLock}</h2>\n *\n * <p>The following examples show a simple threadsafe holder expressed using {@code synchronized},\n * {@link ReentrantLock}, and {@code Monitor}.\n *\n * <h3>{@code synchronized}</h3>\n *\n * <p>This version is the fewest lines of code, largely because the synchronization mechanism used\n * is built into the language and runtime. But the programmer has to remember to avoid a couple of\n * common bugs: The {@code wait()} must be inside a {@code while} instead of an {@code if}, and\n * {@code notifyAll()} must be used instead of {@code notify()} because there are two different\n * logical conditions being awaited.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *\n *   public synchronized V get() throws InterruptedException {\n *     while (value == null) {\n *       wait();\n *     }\n *     V result = value;\n *     value = null;\n *     notifyAll();\n *     return result;\n *   }\n *\n *   public synchronized void set(V newValue) throws InterruptedException {\n *     while (value != null) {\n *       wait();\n *     }\n *     value = newValue;\n *     notifyAll();\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code ReentrantLock}</h3>\n *\n * <p>This version is much more verbose than the {@code synchronized} version, and still suffers\n * from the need for the programmer to remember to use {@code while} instead of {@code if}. However,\n * one advantage is that we can introduce two separate {@code Condition} objects, which allows us to\n * use {@code signal()} instead of {@code signalAll()}, which may be a performance benefit.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final ReentrantLock lock = new ReentrantLock();\n *   private final Condition valuePresent = lock.newCondition();\n *   private final Condition valueAbsent = lock.newCondition();\n *\n *   public V get() throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value == null) {\n *         valuePresent.await();\n *       }\n *       V result = value;\n *       value = null;\n *       valueAbsent.signal();\n *       return result;\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     lock.lock();\n *     try {\n *       while (value != null) {\n *         valueAbsent.await();\n *       }\n *       value = newValue;\n *       valuePresent.signal();\n *     } finally {\n *       lock.unlock();\n *     }\n *   }\n * }\n * }</pre>\n *\n * <h3>{@code Monitor}</h3>\n *\n * <p>This version adds some verbosity around the {@code Guard} objects, but removes that same\n * verbosity, and more, from the {@code get} and {@code set} methods. {@code Monitor} implements the\n * same efficient signaling as we had to hand-code in the {@code ReentrantLock} version above.\n * Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to\n * remember to use {@code while} instead of {@code if}.\n *\n * <pre>{@code\n * public class SafeBox<V> {\n *   private V value;\n *   private final Monitor monitor = new Monitor();\n *   private final Monitor.Guard valuePresent = monitor.newGuard(() -> value != null);\n *   private final Monitor.Guard valueAbsent = monitor.newGuard(() -> value == null);\n *\n *   public V get() throws InterruptedException {\n *     monitor.enterWhen(valuePresent);\n *     try {\n *       V result = value;\n *       value = null;\n *       return result;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n *\n *   public void set(V newValue) throws InterruptedException {\n *     monitor.enterWhen(valueAbsent);\n *     try {\n *       value = newValue;\n *     } finally {\n *       monitor.leave();\n *     }\n *   }\n * }\n * }</pre>\n *\n * @author Justin T. Sampson\n * @author Martin Buchholz\n * @since 10.0\n */\n@Beta\n@GwtIncompatible\n@SuppressWarnings(\"GuardedBy\") // TODO(b/35466881): Fix or suppress.\npublic final class Monitor\n{\n    // TODO(user): Use raw LockSupport or AbstractQueuedSynchronizer instead of ReentrantLock.\n    // TODO(user): \"Port\" jsr166 tests for ReentrantLock.\n    //\n    // TODO(user): Change API to make it impossible to use a Guard with the \"wrong\" monitor,\n    //    by making the monitor implicit, and to eliminate other sources of IMSE.\n    //    Imagine:\n    //    guard.lock();\n    //    try { /* monitor locked and guard satisfied here */ }\n    //    finally { guard.unlock(); }\n    // Here are Justin's design notes about this:\n    //\n    // This idea has come up from time to time, and I think one of my\n    // earlier versions of Monitor even did something like this. I ended\n    // up strongly favoring the current interface.\n    //\n    // I probably can't remember all the reasons (it's possible you\n    // could find them in the code review archives), but here are a few:\n    //\n    // 1. What about leaving/unlocking? Are you going to do\n    //    guard.enter() paired with monitor.leave()? That might get\n    //    confusing. It's nice for the finally block to look as close as\n    //    possible to the thing right before the try. You could have\n    //    guard.leave(), but that's a little odd as well because the\n    //    guard doesn't have anything to do with leaving. You can't\n    //    really enforce that the guard you're leaving is the same one\n    //    you entered with, and it doesn't actually matter.\n    //\n    // 2. Since you can enter the monitor without a guard at all, some\n    //    places you'll have monitor.enter()/monitor.leave() and other\n    //    places you'll have guard.enter()/guard.leave() even though\n    //    it's the same lock being acquired underneath. Always using\n    //    monitor.enterXXX()/monitor.leave() will make it really clear\n    //    which lock is held at any point in the code.\n    //\n    // 3. I think \"enterWhen(notEmpty)\" reads better than \"notEmpty.enter()\".\n    //\n    // TODO(user): Implement ReentrantLock features:\n    //    - toString() method\n    //    - getOwner() method\n    //    - getQueuedThreads() method\n    //    - getWaitingThreads(Guard) method\n    //    - implement Serializable\n    //    - redo the API to be as close to identical to ReentrantLock as possible,\n    //      since, after all, this class is also a reentrant mutual exclusion lock!?\n\n    /*\n     * One of the key challenges of this class is to prevent lost signals, while trying hard to\n     * minimize unnecessary signals. One simple and correct algorithm is to signal some other waiter\n     * with a satisfied guard (if one exists) whenever any thread occupying the monitor exits the\n     * monitor, either by unlocking all of its held locks, or by starting to wait for a guard. This\n     * includes exceptional exits, so all control paths involving signalling must be protected by a\n     * finally block.\n     *\n     * Further optimizations of this algorithm become increasingly subtle. A wait that terminates\n     * without the guard being satisfied (due to timeout, but not interrupt) can then immediately exit\n     * the monitor without signalling. If it timed out without being signalled, it does not need to\n     * \"pass on\" the signal to another thread. If it *was* signalled, then its guard must have been\n     * satisfied at the time of signal, and has since been modified by some other thread to be\n     * non-satisfied before reacquiring the lock, and that other thread takes over the responsibility\n     * of signaling the next waiter.\n     *\n     * Unlike the underlying Condition, if we are not careful, an interrupt *can* cause a signal to be\n     * lost, because the signal may be sent to a condition whose sole waiter has just been\n     * interrupted.\n     *\n     * Imagine a monitor with multiple guards. A thread enters the monitor, satisfies all the guards,\n     * and leaves, calling signalNextWaiter. With traditional locks and conditions, all the conditions\n     * need to be signalled because it is not known which if any of them have waiters (and hasWaiters\n     * can't be used reliably because of a check-then-act race). With our Monitor guards, we only\n     * signal the first active guard that is satisfied. But the corresponding thread may have already\n     * been interrupted and is waiting to reacquire the lock while still registered in activeGuards,\n     * in which case the signal is a no-op, and the bigger-picture signal is lost unless interrupted\n     * threads take special action by participating in the signal-passing game.\n     */\n\n    /*\n     * Timeout handling is intricate, especially given our ambitious goals:\n     * - Avoid underflow and overflow of timeout values when specified timeouts are close to\n     *   Long.MIN_VALUE or Long.MAX_VALUE.\n     * - Favor responding to interrupts over timeouts.\n     * - System.nanoTime() is expensive enough that we want to call it the minimum required number of\n     *   times, typically once before invoking a blocking method. This often requires keeping track of\n     *   the first time in a method that nanoTime() has been invoked, for which the special value 0L\n     *   is reserved to mean \"uninitialized\". If timeout is non-positive, then nanoTime need never be\n     *   called.\n     * - Keep behavior of fair and non-fair instances consistent.\n     */\n\n    /**\n     * A boolean condition for which a thread may wait. A {@code Guard} is associated with a single\n     * {@code Monitor}. The monitor may check the guard at arbitrary times from any thread occupying\n     * the monitor, so code should not be written to rely on how often a guard might or might not be\n     * checked.\n     *\n     * <p>If a {@code Guard} is passed into any method of a {@code Monitor} other than the one it is\n     * associated with, an {@link IllegalMonitorStateException} is thrown.\n     *\n     * @since 10.0\n     */\n    @Beta\n    public abstract static class Guard\n    {\n\n        @Weak final Monitor monitor;\n        final Condition condition;\n\n        @GuardedBy(\"monitor.lock\")\n        int waiterCount = 0;\n\n        /** The next active guard */\n        @GuardedBy(\"monitor.lock\")\n        @NullableDecl\n        Guard next;\n\n        protected Guard(Monitor monitor)\n        {\n            this.monitor = checkNotNull(monitor, \"monitor\");\n            this.condition = monitor.lock.newCondition();\n        }\n\n        /**\n         * Evaluates this guard's boolean condition. This method is always called with the associated\n         * monitor already occupied. Implementations of this method must depend only on state protected\n         * by the associated monitor, and must not modify that state.\n         */\n        public abstract boolean isSatisfied();\n    }\n\n    /** Whether this monitor is fair. */\n    private final boolean fair;\n\n    /** The lock underlying this monitor. */\n    private final ReentrantLock lock;\n\n    /**\n     * The guards associated with this monitor that currently have waiters ({@code waiterCount > 0}).\n     * A linked list threaded through the Guard.next field.\n     */\n    @GuardedBy(\"lock\")\n    private Guard activeGuards = null;\n\n    /**\n     * Creates a monitor with a non-fair (but fast) ordering policy. Equivalent to {@code\n     * Monitor(false)}.\n     */\n    public Monitor()\n    {\n        this(false);\n    }\n\n    /**\n     * Creates a monitor with the given ordering policy.\n     *\n     * @param fair whether this monitor should use a fair ordering policy rather than a non-fair (but\n     *     fast) one\n     */\n    public Monitor(boolean fair)\n    {\n        this.fair = fair;\n        this.lock = new ReentrantLock(fair);\n    }\n\n    /** Enters this monitor. Blocks indefinitely. */\n    public void enter()\n    {\n        lock.lock();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time.\n     *\n     * @return whether the monitor was entered\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enter(long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        final ReentrantLock lock = this.lock;\n        if (!fair && lock.tryLock())\n        {\n            return true;\n        }\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            final long startTime = System.nanoTime();\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterInterruptibly() throws InterruptedException\n    {\n        lock.lockInterruptibly();\n    }\n\n    /**\n     * Enters this monitor. Blocks at most the given time, and may be interrupted.\n     *\n     * @return whether the monitor was entered\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException\n    {\n        return lock.tryLock(time, unit);\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately. Does not block.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered\n     */\n    public boolean tryEnter()\n    {\n        return lock.tryLock();\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void enterWhen(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                await(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied, and may be\n     * interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean reentrant = lock.isHeldByCurrentThread();\n        long startTime = 0L;\n\n        locked:\n        {\n            if (!fair)\n            {\n                // Check interrupt status to get behavior consistent with fair case.\n                if (Thread.interrupted())\n                {\n                    throw new InterruptedException();\n                }\n                if (lock.tryLock())\n                {\n                    break locked;\n                }\n            }\n            startTime = initNanoTime(timeoutNanos);\n            if (!lock.tryLock(time, unit))\n            {\n                return false;\n            }\n        }\n\n        boolean satisfied = false;\n        boolean threw = true;\n        try\n        {\n            satisfied =\n                guard.isSatisfied()\n                || awaitNanos(\n                    guard,\n                    (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),\n                    reentrant);\n            threw = false;\n            return satisfied;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                try\n                {\n                    // Don't need to signal if timed out, but do if interrupted\n                    if (threw && !reentrant)\n                    {\n                        signalNextWaiter();\n                    }\n                }\n                finally\n                {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n\n    /** Enters this monitor when the guard is satisfied. Blocks indefinitely. */\n    public void enterWhenUninterruptibly(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            if (!guard.isSatisfied())\n            {\n                awaitUninterruptibly(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                leave();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n     * the time to acquire the lock and the time to wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        long startTime = 0L;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            if (fair || !lock.tryLock())\n            {\n                startTime = initNanoTime(timeoutNanos);\n                for (long remainingNanos = timeoutNanos; ; )\n                {\n                    try\n                    {\n                        if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS))\n                        {\n                            break;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        remainingNanos = remainingNanos(startTime, timeoutNanos);\n                    }\n                }\n            }\n\n            boolean satisfied = false;\n            try\n            {\n                while (true)\n                {\n                    try\n                    {\n                        if (guard.isSatisfied())\n                        {\n                            satisfied = true;\n                        }\n                        else\n                        {\n                            final long remainingNanos;\n                            if (startTime == 0L)\n                            {\n                                startTime = initNanoTime(timeoutNanos);\n                                remainingNanos = timeoutNanos;\n                            }\n                            else\n                            {\n                                remainingNanos = remainingNanos(startTime, timeoutNanos);\n                            }\n                            satisfied = awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                        }\n                        return satisfied;\n                    }\n                    catch (InterruptedException interrupt)\n                    {\n                        interrupted = true;\n                        signalBeforeWaiting = false;\n                    }\n                }\n            }\n            finally\n            {\n                if (!satisfied)\n                {\n                    lock.unlock(); // No need to signal if timed out\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean enterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIf(Guard guard, long time, TimeUnit unit)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!enter(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\n     * not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public boolean enterIfInterruptibly(Guard guard) throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\n     * lock, but does not wait for the guard to be satisfied, and may be interrupted.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n    throws InterruptedException\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock(time, unit))\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not\n     * block acquiring the lock and does not wait for the guard to be satisfied.\n     *\n     * <p><b>Note:</b> This method disregards the fairness setting of this monitor.\n     *\n     * @return whether the monitor was entered, which guarantees that the guard is now satisfied\n     */\n    public boolean tryEnterIf(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock())\n        {\n            return false;\n        }\n\n        boolean satisfied = false;\n        try\n        {\n            return satisfied = guard.isSatisfied();\n        }\n        finally\n        {\n            if (!satisfied)\n            {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be called\n     * only by a thread currently occupying this monitor.\n     *\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public void waitFor(Guard guard) throws InterruptedException\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            await(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted. May\n     * be called only by a thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     * @throws InterruptedException if interrupted while waiting\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        if (Thread.interrupted())\n        {\n            throw new InterruptedException();\n        }\n        return awaitNanos(guard, timeoutNanos, true);\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread\n     * currently occupying this monitor.\n     */\n    public void waitForUninterruptibly(Guard guard)\n    {\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied())\n        {\n            awaitUninterruptibly(guard, true);\n        }\n    }\n\n    /**\n     * Waits for the guard to be satisfied. Waits at most the given time. May be called only by a\n     * thread currently occupying this monitor.\n     *\n     * @return whether the guard is now satisfied\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit)\n    {\n        final long timeoutNanos = toSafeNanos(time, unit);\n        if (!((guard.monitor == this) & lock.isHeldByCurrentThread()))\n        {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied())\n        {\n            return true;\n        }\n        boolean signalBeforeWaiting = true;\n        final long startTime = initNanoTime(timeoutNanos);\n        boolean interrupted = Thread.interrupted();\n        try\n        {\n            for (long remainingNanos = timeoutNanos; ; )\n            {\n                try\n                {\n                    return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n                }\n                catch (InterruptedException interrupt)\n                {\n                    interrupted = true;\n                    if (guard.isSatisfied())\n                    {\n                        return true;\n                    }\n                    signalBeforeWaiting = false;\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\n                }\n            }\n        }\n        finally\n        {\n            if (interrupted)\n            {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /** Leaves this monitor. May be called only by a thread currently occupying this monitor. */\n    public void leave()\n    {\n        final ReentrantLock lock = this.lock;\n        try\n        {\n            // No need to signal if we will still be holding the lock when we return\n            if (lock.getHoldCount() == 1)\n            {\n                signalNextWaiter();\n            }\n        }\n        finally\n        {\n            lock.unlock(); // Will throw IllegalMonitorStateException if not held\n        }\n    }\n\n    /** Returns whether this monitor is using a fair ordering policy. */\n    public boolean isFair()\n    {\n        return fair;\n    }\n\n    /**\n     * Returns whether this monitor is occupied by any thread. This method is designed for use in\n     * monitoring of the system state, not for synchronization control.\n     */\n    public boolean isOccupied()\n    {\n        return lock.isLocked();\n    }\n\n    /**\n     * Returns whether the current thread is occupying this monitor (has entered more times than it\n     * has left).\n     */\n    public boolean isOccupiedByCurrentThread()\n    {\n        return lock.isHeldByCurrentThread();\n    }\n\n    /**\n     * Returns the number of times the current thread has entered this monitor in excess of the number\n     * of times it has left. Returns 0 if the current thread is not occupying this monitor.\n     */\n    public int getOccupiedDepth()\n    {\n        return lock.getHoldCount();\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting to enter this monitor. The value is only\n     * an estimate because the number of threads may change dynamically while this method traverses\n     * internal data structures. This method is designed for use in monitoring of the system state,\n     * not for synchronization control.\n     */\n    public int getQueueLength()\n    {\n        return lock.getQueueLength();\n    }\n\n    /**\n     * Returns whether any threads are waiting to enter this monitor. Note that because cancellations\n     * may occur at any time, a {@code true} return does not guarantee that any other thread will ever\n     * enter this monitor. This method is designed primarily for use in monitoring of the system\n     * state.\n     */\n    public boolean hasQueuedThreads()\n    {\n        return lock.hasQueuedThreads();\n    }\n\n    /**\n     * Queries whether the given thread is waiting to enter this monitor. Note that because\n     * cancellations may occur at any time, a {@code true} return does not guarantee that this thread\n     * will ever enter this monitor. This method is designed primarily for use in monitoring of the\n     * system state.\n     */\n    public boolean hasQueuedThread(Thread thread)\n    {\n        return lock.hasQueuedThread(thread);\n    }\n\n    /**\n     * Queries whether any threads are waiting for the given guard to become satisfied. Note that\n     * because timeouts and interrupts may occur at any time, a {@code true} return does not guarantee\n     * that the guard becoming satisfied in the future will awaken any threads. This method is\n     * designed primarily for use in monitoring of the system state.\n     */\n    public boolean hasWaiters(Guard guard)\n    {\n        return getWaitQueueLength(guard) > 0;\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting for the given guard to become satisfied.\n     * Note that because timeouts and interrupts may occur at any time, the estimate serves only as an\n     * upper bound on the actual number of waiters. This method is designed for use in monitoring of\n     * the system state, not for synchronization control.\n     */\n    public int getWaitQueueLength(Guard guard)\n    {\n        if (guard.monitor != this)\n        {\n            throw new IllegalMonitorStateException();\n        }\n        lock.lock();\n        try\n        {\n            return guard.waiterCount;\n        }\n        finally\n        {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Returns unit.toNanos(time), additionally ensuring the returned value is not at risk of\n     * overflowing or underflowing, by bounding the value between 0 and (Long.MAX_VALUE / 4) * 3.\n     * Actually waiting for more than 219 years is not supported!\n     */\n    private static long toSafeNanos(long time, TimeUnit unit)\n    {\n        long timeoutNanos = unit.toNanos(time);\n        return (timeoutNanos <= 0L)\n               ? 0L\n               : (timeoutNanos > (Long.MAX_VALUE / 4) * 3) ? (Long.MAX_VALUE / 4) * 3 : timeoutNanos;\n    }\n\n    /**\n     * Returns System.nanoTime() unless the timeout has already elapsed. Returns 0L if and only if the\n     * timeout has already elapsed.\n     */\n    private static long initNanoTime(long timeoutNanos)\n    {\n        if (timeoutNanos <= 0L)\n        {\n            return 0L;\n        }\n        else\n        {\n            long startTime = System.nanoTime();\n            return (startTime == 0L) ? 1L : startTime;\n        }\n    }\n\n    /**\n     * Returns the remaining nanos until the given timeout, or 0L if the timeout has already elapsed.\n     * Caller must have previously sanitized timeoutNanos using toSafeNanos.\n     */\n    private static long remainingNanos(long startTime, long timeoutNanos)\n    {\n        // assert timeoutNanos == 0L || startTime != 0L;\n\n        // TODO : NOT CORRECT, BUT TESTS PASS ANYWAYS!\n        // if (true) return timeoutNanos;\n        // ONLY 2 TESTS FAIL IF WE DO:\n        // if (true) return 0;\n\n        return (timeoutNanos <= 0L) ? 0L : timeoutNanos - (System.nanoTime() - startTime);\n    }\n\n    /**\n     * Signals some other thread waiting on a satisfied guard, if one exists.\n     *\n     * <p>We manage calls to this method carefully, to signal only when necessary, but never losing a\n     * signal, which is the classic problem of this kind of concurrency construct. We must signal if\n     * the current thread is about to relinquish the lock and may have changed the state protected by\n     * the monitor, thereby causing some guard to be satisfied.\n     *\n     * <p>In addition, any thread that has been signalled when its guard was satisfied acquires the\n     * responsibility of signalling the next thread when it again relinquishes the lock. Unlike a\n     * normal Condition, there is no guarantee that an interrupted thread has not been signalled,\n     * since the concurrency control must manage multiple Conditions. So this method must generally be\n     * called when waits are interrupted.\n     *\n     * <p>On the other hand, if a signalled thread wakes up to discover that its guard is still not\n     * satisfied, it does *not* need to call this method before returning to wait. This can only\n     * happen due to spurious wakeup (ignorable) or another thread acquiring the lock before the\n     * current thread can and returning the guard to the unsatisfied state. In the latter case the\n     * other thread (last thread modifying the state protected by the monitor) takes over the\n     * responsibility of signalling the next waiter.\n     *\n     * <p>This method must not be called from within a beginWaitingFor/endWaitingFor block, or else\n     * the current thread's guard might be mistakenly signalled, leading to a lost signal.\n     */\n    @GuardedBy(\"lock\")\n    private void signalNextWaiter()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            if (isSatisfied(guard))\n            {\n                guard.condition.signal();\n                break;\n            }\n        }\n    }\n\n    /**\n     * Exactly like signalNextWaiter, but caller guarantees that guardToSkip need not be considered,\n     * because caller has previously checked that guardToSkip.isSatisfied() returned false. An\n     * optimization for the case that guardToSkip.isSatisfied() may be expensive.\n     *\n     * <p>We decided against using this method, since in practice, isSatisfied() is likely to be very\n     * cheap (typically one field read). Resurrect this method if you find that not to be true.\n     */\n    //   @GuardedBy(\"lock\")\n    //   private void signalNextWaiterSkipping(Guard guardToSkip) {\n    //     for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n    //       if (guard != guardToSkip && isSatisfied(guard)) {\n    //         guard.condition.signal();\n    //         break;\n    //       }\n    //     }\n    //   }\n\n    /**\n     * Exactly like guard.isSatisfied(), but in addition signals all waiting threads in the (hopefully\n     * unlikely) event that isSatisfied() throws.\n     */\n    @GuardedBy(\"lock\")\n    private boolean isSatisfied(Guard guard)\n    {\n        try\n        {\n            return guard.isSatisfied();\n        }\n        catch (Throwable throwable)\n        {\n            signalAllWaiters();\n            throw throwable;\n        }\n    }\n\n    /** Signals all threads waiting on guards. */\n    @GuardedBy(\"lock\")\n    private void signalAllWaiters()\n    {\n        for (Guard guard = activeGuards; guard != null; guard = guard.next)\n        {\n            guard.condition.signalAll();\n        }\n    }\n\n    /** Records that the current thread is about to wait on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void beginWaitingFor(Guard guard)\n    {\n        int waiters = guard.waiterCount++;\n        if (waiters == 0)\n        {\n            // push guard onto activeGuards\n            guard.next = activeGuards;\n            activeGuards = guard;\n        }\n    }\n\n    /** Records that the current thread is no longer waiting on the specified guard. */\n    @GuardedBy(\"lock\")\n    private void endWaitingFor(Guard guard)\n    {\n        int waiters = --guard.waiterCount;\n        if (waiters == 0)\n        {\n            // unlink guard from activeGuards\n            for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next)\n            {\n                if (p == guard)\n                {\n                    if (pred == null)\n                    {\n                        activeGuards = p.next;\n                    }\n                    else\n                    {\n                        pred.next = p.next;\n                    }\n                    p.next = null; // help GC\n                    break;\n                }\n            }\n        }\n    }\n\n    /*\n     * Methods that loop waiting on a guard's condition until the guard is satisfied, while recording\n     * this fact so that other threads know to check our guard and signal us. It's caller's\n     * responsibility to ensure that the guard is *not* currently satisfied.\n     */\n\n    @GuardedBy(\"lock\")\n    private void await(Guard guard, boolean signalBeforeWaiting) throws InterruptedException\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.await();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    @GuardedBy(\"lock\")\n    private void awaitUninterruptibly(Guard guard, boolean signalBeforeWaiting)\n    {\n        if (signalBeforeWaiting)\n        {\n            signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        try\n        {\n            do\n            {\n                guard.condition.awaitUninterruptibly();\n            }\n            while (!guard.isSatisfied());\n        }\n        finally\n        {\n            endWaitingFor(guard);\n        }\n    }\n\n    /** Caller should check before calling that guard is not satisfied. */\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/MoreExecutors.java", "func_name": "MoreExecutors.shutdownAndAwaitTermination", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Shuts down the given executor service gradually, first disabling new submissions and later, if\nnecessary, cancelling remaining tasks.\n\n<p>The method takes the following steps:\n\n<ol>\n<li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n<li>awaits executor service termination for half of the specified timeout.\n<li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\npending tasks and interrupting running tasks.\n<li>awaits executor service termination for the other half of the specified timeout.\n</ol>\n\n<p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\nExecutorService#shutdownNow()} and returns.\n\n@param service the {@code ExecutorService} to shut down\n@param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n@param unit the time unit of the timeout argument\n@return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\nif the call timed out or was interrupted\n@since 17.0", "docstring_tokens": ["Shuts", "down", "the", "given", "executor", "service", "gradually", "first", "disabling", "new", "submissions", "and", "later", "if", "necessary", "cancelling", "remaining", "tasks", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/MoreExecutors.java#L931-L955", "partition": "valid", "up_fun_num": 20, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.annotations.VisibleForTesting;", "import com.google.common.base.Supplier;", "import com.google.common.base.Throwables;", "import com.google.common.collect.Lists;", "import com.google.common.collect.Queues;", "import com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import com.google.errorprone.annotations.concurrent.GuardedBy;", "import java.lang.reflect.InvocationTargetException;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.Iterator;", "import java.util.List;", "import java.util.concurrent.BlockingQueue;", "import java.util.concurrent.Callable;", "import java.util.concurrent.Delayed;", "import java.util.concurrent.ExecutionException;", "import java.util.concurrent.Executor;", "import java.util.concurrent.ExecutorService;", "import java.util.concurrent.Executors;", "import java.util.concurrent.Future;", "import java.util.concurrent.RejectedExecutionException;", "import java.util.concurrent.ScheduledExecutorService;", "import java.util.concurrent.ScheduledFuture;", "import java.util.concurrent.ScheduledThreadPoolExecutor;", "import java.util.concurrent.ThreadFactory;", "import java.util.concurrent.ThreadPoolExecutor;", "import java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;", "import java.util.concurrent.TimeUnit;", "import java.util.concurrent.TimeoutException;"], "function": ["public final class MoreExecutors\n", "    public static ExecutorService getExitingExecutorService(\n", "    public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor)\n", "    public static ScheduledExecutorService getExitingScheduledExecutorService(\n", "    public static ScheduledExecutorService getExitingScheduledExecutorService(\n", "    public static void addDelayedShutdownHook(\n", "    private static void useDaemonThreadFactory(ThreadPoolExecutor executor)\n", "    public static ListeningExecutorService newDirectExecutorService()\n", "    public static Executor directExecutor()\n", "    public static Executor newSequentialExecutor(Executor delegate)\n", "    public static ListeningExecutorService listeningDecorator(ExecutorService delegate)\n", "    public static ListeningScheduledExecutorService listeningDecorator(\n", "    @GwtIncompatible static <T> T invokeAnyImpl(\n", "    private static <T> ListenableFuture<T> submitAndAddQueueListener(\n", "    public static ThreadFactory platformThreadFactory()\n", "    private static boolean isAppEngine()\n", "    static Thread newThread(String name, Runnable runnable)\n", "    static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier)\n", "    static ExecutorService renamingDecorator(\n", "    static ScheduledExecutorService renamingDecorator(\n", "    static Executor rejectionPropagatingExecutor(\n"], "context": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Queues;\nimport com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.google.errorprone.annotations.concurrent.GuardedBy;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link ExecutorService},\n * and {@link ThreadFactory}.\n *\n * @author Eric Fellheimer\n * @author Kyle Littlefield\n * @author Justin Mahoney\n * @since 3.0\n */\n@GwtCompatible(emulated = true)\npublic final class MoreExecutors\n{\n    private MoreExecutors() {}\n\n    /**\n     * Converts the given ThreadPoolExecutor into an ExecutorService that exits when the application\n     * is complete. It does so by using daemon threads and adding a shutdown hook to wait for their\n     * completion.\n     *\n     * <p>This is mainly for fixed thread pools. See {@link Executors#newFixedThreadPool(int)}.\n     *\n     * @param executor the executor to modify to make sure it exits when the application is finished\n     * @param terminationTimeout how long to wait for the executor to finish before terminating the\n     *     JVM\n     * @param timeUnit unit of time for the time parameter\n     * @return an unmodifiable version of the input which will not hang the JVM\n     */\n    @Beta\n    @GwtIncompatible // TODO\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public static ExecutorService getExitingExecutorService(\n        ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit)\n    {\n        return new Application().getExitingExecutorService(executor, terminationTimeout, timeUnit);\n    }\n\n    /**\n     * Converts the given ThreadPoolExecutor into an ExecutorService that exits when the application\n     * is complete. It does so by using daemon threads and adding a shutdown hook to wait for their\n     * completion.\n     *\n     * <p>This method waits 120 seconds before continuing with JVM termination, even if the executor\n     * has not finished its work.\n     *\n     * <p>This is mainly for fixed thread pools. See {@link Executors#newFixedThreadPool(int)}.\n     *\n     * @param executor the executor to modify to make sure it exits when the application is finished\n     * @return an unmodifiable version of the input which will not hang the JVM\n     */\n    @Beta\n    @GwtIncompatible // concurrency\n    public static ExecutorService getExitingExecutorService(ThreadPoolExecutor executor)\n    {\n        return new Application().getExitingExecutorService(executor);\n    }\n\n    /**\n     * Converts the given ScheduledThreadPoolExecutor into a ScheduledExecutorService that exits when\n     * the application is complete. It does so by using daemon threads and adding a shutdown hook to\n     * wait for their completion.\n     *\n     * <p>This is mainly for fixed thread pools. See {@link Executors#newScheduledThreadPool(int)}.\n     *\n     * @param executor the executor to modify to make sure it exits when the application is finished\n     * @param terminationTimeout how long to wait for the executor to finish before terminating the\n     *     JVM\n     * @param timeUnit unit of time for the time parameter\n     * @return an unmodifiable version of the input which will not hang the JVM\n     */\n    @Beta\n    @GwtIncompatible // TODO\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public static ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit)\n    {\n        return new Application()\n               .getExitingScheduledExecutorService(executor, terminationTimeout, timeUnit);\n    }\n\n    /**\n     * Converts the given ScheduledThreadPoolExecutor into a ScheduledExecutorService that exits when\n     * the application is complete. It does so by using daemon threads and adding a shutdown hook to\n     * wait for their completion.\n     *\n     * <p>This method waits 120 seconds before continuing with JVM termination, even if the executor\n     * has not finished its work.\n     *\n     * <p>This is mainly for fixed thread pools. See {@link Executors#newScheduledThreadPool(int)}.\n     *\n     * @param executor the executor to modify to make sure it exits when the application is finished\n     * @return an unmodifiable version of the input which will not hang the JVM\n     */\n    @Beta\n    @GwtIncompatible // TODO\n    public static ScheduledExecutorService getExitingScheduledExecutorService(\n        ScheduledThreadPoolExecutor executor)\n    {\n        return new Application().getExitingScheduledExecutorService(executor);\n    }\n\n    /**\n     * Add a shutdown hook to wait for thread completion in the given {@link ExecutorService service}.\n     * This is useful if the given service uses daemon threads, and we want to keep the JVM from\n     * exiting immediately on shutdown, instead giving these daemon threads a chance to terminate\n     * normally.\n     *\n     * @param service ExecutorService which uses daemon threads\n     * @param terminationTimeout how long to wait for the executor to finish before terminating the\n     *     JVM\n     * @param timeUnit unit of time for the time parameter\n     */\n    @Beta\n    @GwtIncompatible // TODO\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public static void addDelayedShutdownHook(\n        ExecutorService service, long terminationTimeout, TimeUnit timeUnit)\n    {\n        new Application().addDelayedShutdownHook(service, terminationTimeout, timeUnit);\n    }\n\n    /** Represents the current application to register shutdown hooks. */\n    @GwtIncompatible // TODO\n    @VisibleForTesting\n    static class Application\n    {\n\n        final ExecutorService getExitingExecutorService(\n            ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit)\n        {\n            useDaemonThreadFactory(executor);\n            ExecutorService service = Executors.unconfigurableExecutorService(executor);\n            addDelayedShutdownHook(executor, terminationTimeout, timeUnit);\n            return service;\n        }\n\n        final ExecutorService getExitingExecutorService(ThreadPoolExecutor executor)\n        {\n            return getExitingExecutorService(executor, 120, TimeUnit.SECONDS);\n        }\n\n        final ScheduledExecutorService getExitingScheduledExecutorService(\n            ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit)\n        {\n            useDaemonThreadFactory(executor);\n            ScheduledExecutorService service = Executors.unconfigurableScheduledExecutorService(executor);\n            addDelayedShutdownHook(executor, terminationTimeout, timeUnit);\n            return service;\n        }\n\n        final ScheduledExecutorService getExitingScheduledExecutorService(\n            ScheduledThreadPoolExecutor executor)\n        {\n            return getExitingScheduledExecutorService(executor, 120, TimeUnit.SECONDS);\n        }\n\n        final void addDelayedShutdownHook(\n            final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit)\n        {\n            checkNotNull(service);\n            checkNotNull(timeUnit);\n            addShutdownHook(\n                MoreExecutors.newThread(\n                    \"DelayedShutdownHook-for-\" + service,\n                    new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    try\n                    {\n                        // We'd like to log progress and failures that may arise in the\n                        // following code, but unfortunately the behavior of logging\n                        // is undefined in shutdown hooks.\n                        // This is because the logging code installs a shutdown hook of its\n                        // own. See Cleaner class inside {@link LogManager}.\n                        service.shutdown();\n                        service.awaitTermination(terminationTimeout, timeUnit);\n                    }\n                    catch (InterruptedException ignored)\n                    {\n                        // We're shutting down anyway, so just ignore.\n                    }\n                }\n            }));\n        }\n\n        @VisibleForTesting\n        void addShutdownHook(Thread hook)\n        {\n            Runtime.getRuntime().addShutdownHook(hook);\n        }\n    }\n\n    @GwtIncompatible // TODO\n    private static void useDaemonThreadFactory(ThreadPoolExecutor executor)\n    {\n        executor.setThreadFactory(\n            new ThreadFactoryBuilder()\n            .setDaemon(true)\n            .setThreadFactory(executor.getThreadFactory())\n            .build());\n    }\n\n    // See newDirectExecutorService javadoc for behavioral notes.\n    @GwtIncompatible // TODO\n    private static final class DirectExecutorService extends AbstractListeningExecutorService\n    {\n        /** Lock used whenever accessing the state variables (runningTasks, shutdown) of the executor */\n        private final Object lock = new Object();\n\n        /*\n         * Conceptually, these two variables describe the executor being in\n         * one of three states:\n         *   - Active: shutdown == false\n         *   - Shutdown: runningTasks > 0 and shutdown == true\n         *   - Terminated: runningTasks == 0 and shutdown == true\n         */\n        @GuardedBy(\"lock\")\n        private int runningTasks = 0;\n\n        @GuardedBy(\"lock\")\n        private boolean shutdown = false;\n\n        @Override\n        public void execute(Runnable command)\n        {\n            startTask();\n            try\n            {\n                command.run();\n            }\n            finally\n            {\n                endTask();\n            }\n        }\n\n        @Override\n        public boolean isShutdown()\n        {\n            synchronized (lock)\n            {\n                return shutdown;\n            }\n        }\n\n        @Override\n        public void shutdown()\n        {\n            synchronized (lock)\n            {\n                shutdown = true;\n                if (runningTasks == 0)\n                {\n                    lock.notifyAll();\n                }\n            }\n        }\n\n        // See newDirectExecutorService javadoc for unusual behavior of this method.\n        @Override\n        public List<Runnable> shutdownNow()\n        {\n            shutdown();\n            return Collections.emptyList();\n        }\n\n        @Override\n        public boolean isTerminated()\n        {\n            synchronized (lock)\n            {\n                return shutdown && runningTasks == 0;\n            }\n        }\n\n        @Override\n        public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException\n        {\n            long nanos = unit.toNanos(timeout);\n            synchronized (lock)\n            {\n                while (true)\n                {\n                    if (shutdown && runningTasks == 0)\n                    {\n                        return true;\n                    }\n                    else if (nanos <= 0)\n                    {\n                        return false;\n                    }\n                    else\n                    {\n                        long now = System.nanoTime();\n                        TimeUnit.NANOSECONDS.timedWait(lock, nanos);\n                        nanos -= System.nanoTime() - now; // subtract the actual time we waited\n                    }\n                }\n            }\n        }\n\n        /**\n         * Checks if the executor has been shut down and increments the running task count.\n         *\n         * @throws RejectedExecutionException if the executor has been previously shutdown\n         */\n        private void startTask()\n        {\n            synchronized (lock)\n            {\n                if (shutdown)\n                {\n                    throw new RejectedExecutionException(\"Executor already shutdown\");\n                }\n                runningTasks++;\n            }\n        }\n\n        /** Decrements the running task count. */\n        private void endTask()\n        {\n            synchronized (lock)\n            {\n                int numRunning = --runningTasks;\n                if (numRunning == 0)\n                {\n                    lock.notifyAll();\n                }\n            }\n        }\n    }\n\n    /**\n     * Creates an executor service that runs each task in the thread that invokes {@code\n     * execute/submit}, as in {@link CallerRunsPolicy} This applies both to individually submitted\n     * tasks and to collections of tasks submitted via {@code invokeAll} or {@code invokeAny}. In the\n     * latter case, tasks will run serially on the calling thread. Tasks are run to completion before\n     * a {@code Future} is returned to the caller (unless the executor has been shutdown).\n     *\n     * <p>Although all tasks are immediately executed in the thread that submitted the task, this\n     * {@code ExecutorService} imposes a small locking overhead on each task submission in order to\n     * implement shutdown and termination behavior.\n     *\n     * <p>The implementation deviates from the {@code ExecutorService} specification with regards to\n     * the {@code shutdownNow} method. First, \"best-effort\" with regards to canceling running tasks is\n     * implemented as \"no-effort\". No interrupts or other attempts are made to stop threads executing\n     * tasks. Second, the returned list will always be empty, as any submitted task is considered to\n     * have started execution. This applies also to tasks given to {@code invokeAll} or {@code\n     * invokeAny} which are pending serial execution, even the subset of the tasks that have not yet\n     * started execution. It is unclear from the {@code ExecutorService} specification if these should\n     * be included, and it's much easier to implement the interpretation that they not be. Finally, a\n     * call to {@code shutdown} or {@code shutdownNow} may result in concurrent calls to {@code\n     * invokeAll/invokeAny} throwing RejectedExecutionException, although a subset of the tasks may\n     * already have been executed.\n     *\n     * @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)\n     */\n    @GwtIncompatible // TODO\n    public static ListeningExecutorService newDirectExecutorService()\n    {\n        return new DirectExecutorService();\n    }\n\n    /**\n     * Returns an {@link Executor} that runs each task in the thread that invokes {@link\n     * Executor#execute execute}, as in {@link CallerRunsPolicy}.\n     *\n     * <p>This instance is equivalent to:\n     *\n     * <pre>{@code\n     * final class DirectExecutor implements Executor {\n     *   public void execute(Runnable r) {\n     *     r.run();\n     *   }\n     * }\n     * }</pre>\n     *\n     * <p>This should be preferred to {@link #newDirectExecutorService()} because implementing the\n     * {@link ExecutorService} subinterface necessitates significant performance overhead.\n     *\n     *\n     * @since 18.0\n     */\n    public static Executor directExecutor()\n    {\n        return DirectExecutor.INSTANCE;\n    }\n\n    /**\n     * Returns an {@link Executor} that runs each task executed sequentially, such that no two tasks\n     * are running concurrently. Submitted tasks have a happens-before order as defined in the Java\n     * Language Specification.\n     *\n     * <p>The executor uses {@code delegate} in order to {@link Executor#execute execute} each task in\n     * turn, and does not create any threads of its own.\n     *\n     * <p>After execution begins on a thread from the {@code delegate} {@link Executor}, tasks are\n     * polled and executed from a task queue until there are no more tasks. The thread will not be\n     * released until there are no more tasks to run.\n     *\n     * <p>If a task is submitted while a thread is executing tasks from the task queue, the thread\n     * will not be released until that submitted task is also complete.\n     *\n     * <p>If a task is {@linkplain Thread#interrupt interrupted} while a task is running:\n     *\n     * <ol>\n     *   <li>execution will not stop until the task queue is empty.\n     *   <li>tasks will begin execution with the thread marked as not interrupted - any interruption\n     *       applies only to the task that was running at the point of interruption.\n     *   <li>if the thread was interrupted before the SequentialExecutor's worker begins execution,\n     *       the interrupt will be restored to the thread after it completes so that its {@code\n     *       delegate} Executor may process the interrupt.\n     *   <li>subtasks are run with the thread uninterrupted and interrupts received during execution\n     *       of a task are ignored.\n     * </ol>\n     *\n     * <p>{@code RuntimeException}s thrown by tasks are simply logged and the executor keeps trucking.\n     * If an {@code Error} is thrown, the error will propagate and execution will stop until the next\n     * time a task is submitted.\n     *\n     * <p>When an {@code Error} is thrown by an executed task, previously submitted tasks may never\n     * run. An attempt will be made to restart execution on the next call to {@code execute}. If the\n     * {@code delegate} has begun to reject execution, the previously submitted tasks may never run,\n     * despite not throwing a RejectedExecutionException synchronously with the call to {@code\n     * execute}. If this behaviour is problematic, use an Executor with a single thread (e.g. {@link\n     * Executors#newSingleThreadExecutor}).\n     *\n     * @since 23.3 (since 23.1 as {@code sequentialExecutor})\n     */\n    @Beta\n    @GwtIncompatible\n    public static Executor newSequentialExecutor(Executor delegate)\n    {\n        return new SequentialExecutor(delegate);\n    }\n\n    /**\n     * Creates an {@link ExecutorService} whose {@code submit} and {@code invokeAll} methods submit\n     * {@link ListenableFutureTask} instances to the given delegate executor. Those methods, as well\n     * as {@code execute} and {@code invokeAny}, are implemented in terms of calls to {@code\n     * delegate.execute}. All other methods are forwarded unchanged to the delegate. This implies that\n     * the returned {@code ListeningExecutorService} never calls the delegate's {@code submit}, {@code\n     * invokeAll}, and {@code invokeAny} methods, so any special handling of tasks must be implemented\n     * in the delegate's {@code execute} method or by wrapping the returned {@code\n     * ListeningExecutorService}.\n     *\n     * <p>If the delegate executor was already an instance of {@code ListeningExecutorService}, it is\n     * returned untouched, and the rest of this documentation does not apply.\n     *\n     * @since 10.0\n     */\n    @GwtIncompatible // TODO\n    public static ListeningExecutorService listeningDecorator(ExecutorService delegate)\n    {\n        return (delegate instanceof ListeningExecutorService)\n               ? (ListeningExecutorService) delegate\n               : (delegate instanceof ScheduledExecutorService)\n               ? new ScheduledListeningDecorator((ScheduledExecutorService) delegate)\n               : new ListeningDecorator(delegate);\n    }\n\n    /**\n     * Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code invokeAll} methods\n     * submit {@link ListenableFutureTask} instances to the given delegate executor. Those methods, as\n     * well as {@code execute} and {@code invokeAny}, are implemented in terms of calls to {@code\n     * delegate.execute}. All other methods are forwarded unchanged to the delegate. This implies that\n     * the returned {@code ListeningScheduledExecutorService} never calls the delegate's {@code\n     * submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special handling of tasks\n     * must be implemented in the delegate's {@code execute} method or by wrapping the returned {@code\n     * ListeningScheduledExecutorService}.\n     *\n     * <p>If the delegate executor was already an instance of {@code\n     * ListeningScheduledExecutorService}, it is returned untouched, and the rest of this\n     * documentation does not apply.\n     *\n     * @since 10.0\n     */\n    @GwtIncompatible // TODO\n    public static ListeningScheduledExecutorService listeningDecorator(\n        ScheduledExecutorService delegate)\n    {\n        return (delegate instanceof ListeningScheduledExecutorService)\n               ? (ListeningScheduledExecutorService) delegate\n               : new ScheduledListeningDecorator(delegate);\n    }\n\n    @GwtIncompatible // TODO\n    private static class ListeningDecorator extends AbstractListeningExecutorService\n    {\n        private final ExecutorService delegate;\n\n        ListeningDecorator(ExecutorService delegate)\n        {\n            this.delegate = checkNotNull(delegate);\n        }\n\n        @Override\n        public final boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException\n        {\n            return delegate.awaitTermination(timeout, unit);\n        }\n\n        @Override\n        public final boolean isShutdown()\n        {\n            return delegate.isShutdown();\n        }\n\n        @Override\n        public final boolean isTerminated()\n        {\n            return delegate.isTerminated();\n        }\n\n        @Override\n        public final void shutdown()\n        {\n            delegate.shutdown();\n        }\n\n        @Override\n        public final List<Runnable> shutdownNow()\n        {\n            return delegate.shutdownNow();\n        }\n\n        @Override\n        public final void execute(Runnable command)\n        {\n            delegate.execute(command);\n        }\n    }\n\n    @GwtIncompatible // TODO\n    private static final class ScheduledListeningDecorator extends ListeningDecorator\n        implements ListeningScheduledExecutorService\n    {\n        @SuppressWarnings(\"hiding\")\n        final ScheduledExecutorService delegate;\n\n        ScheduledListeningDecorator(ScheduledExecutorService delegate)\n        {\n            super(delegate);\n            this.delegate = checkNotNull(delegate);\n        }\n\n        @Override\n        public ListenableScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit)\n        {\n            TrustedListenableFutureTask<Void> task = TrustedListenableFutureTask.create(command, null);\n            ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n            return new ListenableScheduledTask<>(task, scheduled);\n        }\n\n        @Override\n        public <V> ListenableScheduledFuture<V> schedule(\n            Callable<V> callable, long delay, TimeUnit unit)\n        {\n            TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n            ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n            return new ListenableScheduledTask<V>(task, scheduled);\n        }\n\n        @Override\n        public ListenableScheduledFuture<?> scheduleAtFixedRate(\n            Runnable command, long initialDelay, long period, TimeUnit unit)\n        {\n            NeverSuccessfulListenableFutureTask task = new NeverSuccessfulListenableFutureTask(command);\n            ScheduledFuture<?> scheduled = delegate.scheduleAtFixedRate(task, initialDelay, period, unit);\n            return new ListenableScheduledTask<>(task, scheduled);\n        }\n\n        @Override\n        public ListenableScheduledFuture<?> scheduleWithFixedDelay(\n            Runnable command, long initialDelay, long delay, TimeUnit unit)\n        {\n            NeverSuccessfulListenableFutureTask task = new NeverSuccessfulListenableFutureTask(command);\n            ScheduledFuture<?> scheduled =\n                delegate.scheduleWithFixedDelay(task, initialDelay, delay, unit);\n            return new ListenableScheduledTask<>(task, scheduled);\n        }\n\n        private static final class ListenableScheduledTask<V>\n            extends SimpleForwardingListenableFuture<V> implements ListenableScheduledFuture<V>\n        {\n\n            private final ScheduledFuture<?> scheduledDelegate;\n\n            public ListenableScheduledTask(\n                ListenableFuture<V> listenableDelegate, ScheduledFuture<?> scheduledDelegate)\n            {\n                super(listenableDelegate);\n                this.scheduledDelegate = scheduledDelegate;\n            }\n\n            @Override\n            public boolean cancel(boolean mayInterruptIfRunning)\n            {\n                boolean cancelled = super.cancel(mayInterruptIfRunning);\n                if (cancelled)\n                {\n                    // Unless it is cancelled, the delegate may continue being scheduled\n                    scheduledDelegate.cancel(mayInterruptIfRunning);\n\n                    // TODO(user): Cancel \"this\" if \"scheduledDelegate\" is cancelled.\n                }\n                return cancelled;\n            }\n\n            @Override\n            public long getDelay(TimeUnit unit)\n            {\n                return scheduledDelegate.getDelay(unit);\n            }\n\n            @Override\n            public int compareTo(Delayed other)\n            {\n                return scheduledDelegate.compareTo(other);\n            }\n        }\n\n        @GwtIncompatible // TODO\n        private static final class NeverSuccessfulListenableFutureTask\n            extends AbstractFuture.TrustedFuture<Void> implements Runnable\n        {\n            private final Runnable delegate;\n\n            public NeverSuccessfulListenableFutureTask(Runnable delegate)\n            {\n                this.delegate = checkNotNull(delegate);\n            }\n\n            @Override\n            public void run()\n            {\n                try\n                {\n                    delegate.run();\n                }\n                catch (Throwable t)\n                {\n                    setException(t);\n                    throw Throwables.propagate(t);\n                }\n            }\n        }\n    }\n\n    /*\n     * This following method is a modified version of one found in\n     * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/AbstractExecutorServiceTest.java?revision=1.30\n     * which contained the following notice:\n     *\n     * Written by Doug Lea with assistance from members of JCP JSR-166 Expert Group and released to\n     * the public domain, as explained at http://creativecommons.org/publicdomain/zero/1.0/\n     *\n     * Other contributors include Andrew Wright, Jeffrey Hayes, Pat Fisher, Mike Judd.\n     */\n\n    /**\n     * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}\n     * implementations.\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    @GwtIncompatible static <T> T invokeAnyImpl(\n        ListeningExecutorService executorService,\n        Collection<? extends Callable<T>> tasks,\n        boolean timed,\n        long timeout,\n        TimeUnit unit)\n    throws InterruptedException, ExecutionException, TimeoutException\n    {\n        checkNotNull(executorService);\n        checkNotNull(unit);\n        int ntasks = tasks.size();\n        checkArgument(ntasks > 0);\n        List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);\n        BlockingQueue<Future<T>> futureQueue = Queues.newLinkedBlockingQueue();\n        long timeoutNanos = unit.toNanos(timeout);\n\n        // For efficiency, especially in executors with limited\n        // parallelism, check to see if previously submitted tasks are\n        // done before submitting more of them. This interleaving\n        // plus the exception mechanics account for messiness of main\n        // loop.\n\n        try\n        {\n            // Record exceptions so that if we fail to obtain any\n            // result, we can throw the last exception we got.\n            ExecutionException ee = null;\n            long lastTime = timed ? System.nanoTime() : 0;\n            Iterator<? extends Callable<T>> it = tasks.iterator();\n\n            futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n            --ntasks;\n            int active = 1;\n\n            while (true)\n            {\n                Future<T> f = futureQueue.poll();\n                if (f == null)\n                {\n                    if (ntasks > 0)\n                    {\n                        --ntasks;\n                        futures.add(submitAndAddQueueListener(executorService, it.next(), futureQueue));\n                        ++active;\n                    }\n                    else if (active == 0)\n                    {\n                        break;\n                    }\n                    else if (timed)\n                    {\n                        f = futureQueue.poll(timeoutNanos, TimeUnit.NANOSECONDS);\n                        if (f == null)\n                        {\n                            throw new TimeoutException();\n                        }\n                        long now = System.nanoTime();\n                        timeoutNanos -= now - lastTime;\n                        lastTime = now;\n                    }\n                    else\n                    {\n                        f = futureQueue.take();\n                    }\n                }\n                if (f != null)\n                {\n                    --active;\n                    try\n                    {\n                        return f.get();\n                    }\n                    catch (ExecutionException eex)\n                    {\n                        ee = eex;\n                    }\n                    catch (RuntimeException rex)\n                    {\n                        ee = new ExecutionException(rex);\n                    }\n                }\n            }\n\n            if (ee == null)\n            {\n                ee = new ExecutionException(null);\n            }\n            throw ee;\n        }\n        finally\n        {\n            for (Future<T> f : futures)\n            {\n                f.cancel(true);\n            }\n        }\n    }\n\n    /**\n     * Submits the task and adds a listener that adds the future to {@code queue} when it completes.\n     */\n    @GwtIncompatible // TODO\n    private static <T> ListenableFuture<T> submitAndAddQueueListener(\n        ListeningExecutorService executorService,\n        Callable<T> task,\n        final BlockingQueue<Future<T>> queue)\n    {\n        final ListenableFuture<T> future = executorService.submit(task);\n        future.addListener(\n            new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                queue.add(future);\n            }\n        },\n        directExecutor());\n        return future;\n    }\n\n    /**\n     * Returns a default thread factory used to create new threads.\n     *\n     * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}. Otherwise,\n     * returns {@link Executors#defaultThreadFactory()}.\n     *\n     * @since 14.0\n     */\n    @Beta\n    @GwtIncompatible // concurrency\n    public static ThreadFactory platformThreadFactory()\n    {\n        if (!isAppEngine())\n        {\n            return Executors.defaultThreadFactory();\n        }\n        try\n        {\n            return (ThreadFactory)\n                   Class.forName(\"com.google.appengine.api.ThreadManager\")\n                   .getMethod(\"currentRequestThreadFactory\")\n                   .invoke(null);\n        }\n        catch (IllegalAccessException | ClassNotFoundException | NoSuchMethodException e)\n        {\n            throw new RuntimeException(\"Couldn't invoke ThreadManager.currentRequestThreadFactory\", e);\n        }\n        catch (InvocationTargetException e)\n        {\n            throw Throwables.propagate(e.getCause());\n        }\n    }\n\n    @GwtIncompatible // TODO\n    private static boolean isAppEngine()\n    {\n        if (System.getProperty(\"com.google.appengine.runtime.environment\") == null)\n        {\n            return false;\n        }\n        try\n        {\n            // If the current environment is null, we're not inside AppEngine.\n            return Class.forName(\"com.google.apphosting.api.ApiProxy\")\n                   .getMethod(\"getCurrentEnvironment\")\n                   .invoke(null)\n                   != null;\n        }\n        catch (ClassNotFoundException e)\n        {\n            // If ApiProxy doesn't exist, we're not on AppEngine at all.\n            return false;\n        }\n        catch (InvocationTargetException e)\n        {\n            // If ApiProxy throws an exception, we're not in a proper AppEngine environment.\n            return false;\n        }\n        catch (IllegalAccessException e)\n        {\n            // If the method isn't accessible, we're not on a supported version of AppEngine;\n            return false;\n        }\n        catch (NoSuchMethodException e)\n        {\n            // If the method doesn't exist, we're not on a supported version of AppEngine;\n            return false;\n        }\n    }\n\n    /**\n     * Creates a thread using {@link #platformThreadFactory}, and sets its name to {@code name} unless\n     * changing the name is forbidden by the security manager.\n     */\n    @GwtIncompatible // concurrency\n    static Thread newThread(String name, Runnable runnable)\n    {\n        checkNotNull(name);\n        checkNotNull(runnable);\n        Thread result = platformThreadFactory().newThread(runnable);\n        try\n        {\n            result.setName(name);\n        }\n        catch (SecurityException e)\n        {\n            // OK if we can't set the name in this environment.\n        }\n        return result;\n    }\n\n    // TODO(lukes): provide overloads for ListeningExecutorService? ListeningScheduledExecutorService?\n    // TODO(lukes): provide overloads that take constant strings? Function<Runnable, String>s to\n    // calculate names?\n\n    /**\n     * Creates an {@link Executor} that renames the {@link Thread threads} that its tasks run in.\n     *\n     * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n     * right before each task is run. The renaming is best effort, if a {@link SecurityManager}\n     * prevents the renaming then it will be skipped but the tasks will still execute.\n     *\n     *\n     * @param executor The executor to decorate\n     * @param nameSupplier The source of names for each task\n     */\n    @GwtIncompatible // concurrency\n    static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier)\n    {\n        checkNotNull(executor);\n        checkNotNull(nameSupplier);\n        if (isAppEngine())\n        {\n            // AppEngine doesn't support thread renaming, so don't even try\n            return executor;\n        }\n        return new Executor()\n        {\n            @Override\n            public void execute(Runnable command)\n            {\n                executor.execute(Callables.threadRenaming(command, nameSupplier));\n            }\n        };\n    }\n\n    /**\n     * Creates an {@link ExecutorService} that renames the {@link Thread threads} that its tasks run\n     * in.\n     *\n     * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n     * right before each task is run. The renaming is best effort, if a {@link SecurityManager}\n     * prevents the renaming then it will be skipped but the tasks will still execute.\n     *\n     *\n     * @param service The executor to decorate\n     * @param nameSupplier The source of names for each task\n     */\n    @GwtIncompatible // concurrency\n    static ExecutorService renamingDecorator(\n        final ExecutorService service, final Supplier<String> nameSupplier)\n    {\n        checkNotNull(service);\n        checkNotNull(nameSupplier);\n        if (isAppEngine())\n        {\n            // AppEngine doesn't support thread renaming, so don't even try.\n            return service;\n        }\n        return new WrappingExecutorService(service)\n        {\n            @Override\n            protected <T> Callable<T> wrapTask(Callable<T> callable)\n            {\n                return Callables.threadRenaming(callable, nameSupplier);\n            }\n\n            @Override\n            protected Runnable wrapTask(Runnable command)\n            {\n                return Callables.threadRenaming(command, nameSupplier);\n            }\n        };\n    }\n\n    /**\n     * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its\n     * tasks run in.\n     *\n     * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed\n     * right before each task is run. The renaming is best effort, if a {@link SecurityManager}\n     * prevents the renaming then it will be skipped but the tasks will still execute.\n     *\n     *\n     * @param service The executor to decorate\n     * @param nameSupplier The source of names for each task\n     */\n    @GwtIncompatible // concurrency\n    static ScheduledExecutorService renamingDecorator(\n        final ScheduledExecutorService service, final Supplier<String> nameSupplier)\n    {\n        checkNotNull(service);\n        checkNotNull(nameSupplier);\n        if (isAppEngine())\n        {\n            // AppEngine doesn't support thread renaming, so don't even try.\n            return service;\n        }\n        return new WrappingScheduledExecutorService(service)\n        {\n            @Override\n            protected <T> Callable<T> wrapTask(Callable<T> callable)\n            {\n                return Callables.threadRenaming(callable, nameSupplier);\n            }\n\n            @Override\n            protected Runnable wrapTask(Runnable command)\n            {\n                return Callables.threadRenaming(command, nameSupplier);\n            }\n        };\n    }\n\n    /**\n     * Shuts down the given executor service gradually, first disabling new submissions and later, if\n     * necessary, cancelling remaining tasks.\n     *\n     * <p>The method takes the following steps:\n     *\n     * <ol>\n     *   <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.\n     *   <li>awaits executor service termination for half of the specified timeout.\n     *   <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling\n     *       pending tasks and interrupting running tasks.\n     *   <li>awaits executor service termination for the other half of the specified timeout.\n     * </ol>\n     *\n     * <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link\n     * ExecutorService#shutdownNow()} and returns.\n     *\n     * @param service the {@code ExecutorService} to shut down\n     * @param timeout the maximum time to wait for the {@code ExecutorService} to terminate\n     * @param unit the time unit of the timeout argument\n     * @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n     *     if the call timed out or was interrupted\n     * @since 17.0\n     */\n\n    /**\n     * Returns an Executor that will propagate {@link RejectedExecutionException} from the delegate\n     * executor to the given {@code future}.\n     *\n     * <p>Note, the returned executor can only be used once.\n     */\n    static Executor rejectionPropagatingExecutor(\n        final Executor delegate, final AbstractFuture<?> future)\n    {\n        checkNotNull(delegate);\n        checkNotNull(future);\n        if (delegate == directExecutor())\n        {\n            // directExecutor() cannot throw RejectedExecutionException\n            return delegate;\n        }\n        return new Executor()\n        {\n            boolean thrownFromDelegate = true;\n\n            @Override\n            public void execute(final Runnable command)\n            {\n                try\n                {\n                    delegate.execute(\n                        new Runnable()\n                    {\n                        @Override\n                        public void run()\n                        {\n                            thrownFromDelegate = false;\n                            command.run();\n                        }\n                    });\n                }\n                catch (RejectedExecutionException e)\n                {\n                    if (thrownFromDelegate)\n                    {\n                        // wrap exception?\n                        future.setException(e);\n                    }\n                    // otherwise it must have been thrown from a transitive call and the delegate runnable\n                    // should have handled it.\n                }\n            }\n        };\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/io/CharSink.java", "func_name": "CharSink.write", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Writes the given character sequence to this sink.\n\n@throws IOException if an I/O error while writing to this sink", "docstring_tokens": ["Writes", "the", "given", "character", "sequence", "to", "this", "sink", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/io/CharSink.java#L92-L105", "partition": "valid", "up_fun_num": 4, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.io.BufferedWriter;", "import java.io.IOException;", "import java.io.Reader;", "import java.io.Writer;", "import java.nio.charset.Charset;", "import java.util.Iterator;", "import java.util.stream.Stream;"], "function": ["public abstract class CharSink\n", "    public abstract Writer openStream() throws IOException;\n", "    public Writer openBufferedStream() throws IOException\n", "    public void writeLines(Iterable<? extends CharSequence> lines) throws IOException\n", "    public void writeLines(Iterable<? extends CharSequence> lines, String lineSeparator)\n", "    public void writeLines(Stream<? extends CharSequence> lines) throws IOException\n", "    public void writeLines(Stream<? extends CharSequence> lines, String lineSeparator)\n", "    private void writeLines(Iterator<? extends CharSequence> lines, String lineSeparator)\n", "    public long writeFrom(Readable readable) throws IOException\n"], "context": "/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.stream.Stream;\n\n/**\n * A destination to which characters can be written, such as a text file. Unlike a {@link Writer}, a\n * {@code CharSink} is not an open, stateful stream that can be written to and closed. Instead, it\n * is an immutable <i>supplier</i> of {@code Writer} instances.\n *\n * <p>{@code CharSink} provides two kinds of methods:\n *\n * <ul>\n *   <li><b>Methods that return a writer:</b> These methods should return a <i>new</i>, independent\n *       instance each time they are called. The caller is responsible for ensuring that the\n *       returned writer is closed.\n *   <li><b>Convenience methods:</b> These are implementations of common operations that are\n *       typically implemented by opening a writer using one of the methods in the first category,\n *       doing something and finally closing the writer that was opened.\n * </ul>\n *\n * <p>Any {@link ByteSink} may be viewed as a {@code CharSink} with a specific {@linkplain Charset\n * character encoding} using {@link ByteSink#asCharSink(Charset)}. Characters written to the\n * resulting {@code CharSink} will written to the {@code ByteSink} as encoded bytes.\n *\n * @since 14.0\n * @author Colin Decker\n */\n@GwtIncompatible\npublic abstract class CharSink\n{\n\n    /** Constructor for use by subclasses. */\n    protected CharSink() {}\n\n    /**\n     * Opens a new {@link Writer} for writing to this sink. This method returns a new, independent\n     * writer each time it is called.\n     *\n     * <p>The caller is responsible for ensuring that the returned writer is closed.\n     *\n     * @throws IOException if an I/O error occurs while opening the writer\n     */\n    public abstract Writer openStream() throws IOException;\n\n    /**\n     * Opens a new buffered {@link Writer} for writing to this sink. The returned stream is not\n     * required to be a {@link BufferedWriter} in order to allow implementations to simply delegate to\n     * {@link #openStream()} when the stream returned by that method does not benefit from additional\n     * buffering. This method returns a new, independent writer each time it is called.\n     *\n     * <p>The caller is responsible for ensuring that the returned writer is closed.\n     *\n     * @throws IOException if an I/O error occurs while opening the writer\n     * @since 15.0 (in 14.0 with return type {@link BufferedWriter})\n     */\n    public Writer openBufferedStream() throws IOException\n    {\n        Writer writer = openStream();\n        return (writer instanceof BufferedWriter)\n               ? (BufferedWriter) writer\n               : new BufferedWriter(writer);\n    }\n\n    /**\n     * Writes the given character sequence to this sink.\n     *\n     * @throws IOException if an I/O error while writing to this sink\n     */\n\n    /**\n     * Writes the given lines of text to this sink with each line (including the last) terminated with\n     * the operating system's default line separator. This method is equivalent to {@code\n     * writeLines(lines, System.getProperty(\"line.separator\"))}.\n     *\n     * @throws IOException if an I/O error occurs while writing to this sink\n     */\n    public void writeLines(Iterable<? extends CharSequence> lines) throws IOException\n    {\n        writeLines(lines, System.getProperty(\"line.separator\"));\n    }\n\n    /**\n     * Writes the given lines of text to this sink with each line (including the last) terminated with\n     * the given line separator.\n     *\n     * @throws IOException if an I/O error occurs while writing to this sink\n     */\n    public void writeLines(Iterable<? extends CharSequence> lines, String lineSeparator)\n    throws IOException\n    {\n        writeLines(lines.iterator(), lineSeparator);\n    }\n\n    /**\n     * Writes the given lines of text to this sink with each line (including the last) terminated with\n     * the operating system's default line separator. This method is equivalent to {@code\n     * writeLines(lines, System.getProperty(\"line.separator\"))}.\n     *\n     * @throws IOException if an I/O error occurs while writing to this sink\n     * @since 22.0\n     */\n    @Beta\n    public void writeLines(Stream<? extends CharSequence> lines) throws IOException\n    {\n        writeLines(lines, System.getProperty(\"line.separator\"));\n    }\n\n    /**\n     * Writes the given lines of text to this sink with each line (including the last) terminated with\n     * the given line separator.\n     *\n     * @throws IOException if an I/O error occurs while writing to this sink\n     * @since 22.0\n     */\n    @Beta\n    public void writeLines(Stream<? extends CharSequence> lines, String lineSeparator)\n    throws IOException\n    {\n        writeLines(lines.iterator(), lineSeparator);\n    }\n\n    private void writeLines(Iterator<? extends CharSequence> lines, String lineSeparator)\n    throws IOException\n    {\n        checkNotNull(lineSeparator);\n\n        try (Writer out = openBufferedStream())\n        {\n            while (lines.hasNext())\n            {\n                out.append(lines.next()).append(lineSeparator);\n            }\n        }\n    }\n\n    /**\n     * Writes all the text from the given {@link Readable} (such as a {@link Reader}) to this sink.\n     * Does not close {@code readable} if it is {@code Closeable}.\n     *\n     * @return the number of characters written\n     * @throws IOException if an I/O error occurs while reading from {@code readable} or writing to\n     *     this sink\n     */\n    @CanIgnoreReturnValue\n    public long writeFrom(Readable readable) throws IOException\n    {\n        checkNotNull(readable);\n\n        Closer closer = Closer.create();\n        try\n        {\n            Writer out = closer.register(openStream());\n            long written = CharStreams.copy(readable, out);\n            out.flush(); // https://code.google.com/p/guava-libraries/issues/detail?id=1330\n            return written;\n        }\n        catch (Throwable e)\n        {\n            throw closer.rethrow(e);\n        }\n        finally\n        {\n            closer.close();\n        }\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/util/concurrent/ExecutionList.java", "func_name": "ExecutionList.execute", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Runs this execution list, executing all existing pairs in the order they were added. However,\nnote that listeners added after this point may be executed before those previously added, and\nnote that the execution order of all listeners is ultimately chosen by the implementations of\nthe supplied executors.\n\n<p>This method is idempotent. Calling it several times in parallel is semantically equivalent\nto calling it exactly once.\n\n@since 10.0 (present in 1.0 as {@code run})", "docstring_tokens": ["Runs", "this", "execution", "list", "executing", "all", "existing", "pairs", "in", "the", "order", "they", "were", "added", ".", "However", "note", "that", "listeners", "added", "after", "this", "point", "may", "be", "executed", "before", "those", "previously", "added", "and", "note", "that", "the", "execution", "order", "of", "all", "listeners", "is", "ultimately", "chosen", "by", "the", "implementations", "of", "the", "supplied", "executors", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/util/concurrent/ExecutionList.java#L101-L133", "partition": "valid", "up_fun_num": 3, "levels": [0, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.errorprone.annotations.concurrent.GuardedBy;", "import java.util.concurrent.Executor;", "import java.util.logging.Level;", "import java.util.logging.Logger;", "import org.checkerframework.checker.nullness.qual.Nullable;"], "function": ["public final class ExecutionList\n", "    public void add(Runnable runnable, Executor executor)\n", "    private static void executeListener(Runnable runnable, Executor executor)\n"], "context": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.concurrent.GuardedBy;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\n/**\n * A support class for {@code ListenableFuture} implementations to manage their listeners. An\n * instance contains a list of listeners, each with an associated {@code Executor}, and guarantees\n * that every {@code Runnable} that is {@linkplain #add added} will be executed after {@link\n * #execute()} is called. Any {@code Runnable} added after the call to {@code execute} is still\n * guaranteed to execute. There is no guarantee, however, that listeners will be executed in the\n * order that they are added.\n *\n * <p>Exceptions thrown by a listener will be propagated up to the executor. Any exception thrown\n * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException} or an exception\n * thrown by {@linkplain MoreExecutors#directExecutor direct execution}) will be caught and logged.\n *\n * @author Nishant Thakkar\n * @author Sven Mawson\n * @since 1.0\n */\n@GwtIncompatible\npublic final class ExecutionList\n{\n    /** Logger to log exceptions caught when running runnables. */\n    private static final Logger log = Logger.getLogger(ExecutionList.class.getName());\n\n    /**\n     * The runnable, executor pairs to execute. This acts as a stack threaded through the {@link\n     * RunnableExecutorPair#next} field.\n     */\n    @GuardedBy(\"this\")\n    private @Nullable RunnableExecutorPair runnables;\n\n    @GuardedBy(\"this\")\n    private boolean executed;\n\n    /** Creates a new, empty {@link ExecutionList}. */\n    public ExecutionList() {}\n\n    /**\n     * Adds the {@code Runnable} and accompanying {@code Executor} to the list of listeners to\n     * execute. If execution has already begun, the listener is executed immediately.\n     *\n     * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See\n     * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}\n     * documentation.\n     */\n    public void add(Runnable runnable, Executor executor)\n    {\n        // Fail fast on a null. We throw NPE here because the contract of Executor states that it throws\n        // NPE on null listener, so we propagate that contract up into the add method as well.\n        checkNotNull(runnable, \"Runnable was null.\");\n        checkNotNull(executor, \"Executor was null.\");\n\n        // Lock while we check state. We must maintain the lock while adding the new pair so that\n        // another thread can't run the list out from under us. We only add to the list if we have not\n        // yet started execution.\n        synchronized (this)\n        {\n            if (!executed)\n            {\n                runnables = new RunnableExecutorPair(runnable, executor, runnables);\n                return;\n            }\n        }\n        // Execute the runnable immediately. Because of scheduling this may end up getting called before\n        // some of the previously added runnables, but we're OK with that. If we want to change the\n        // contract to guarantee ordering among runnables we'd have to modify the logic here to allow\n        // it.\n        executeListener(runnable, executor);\n    }\n\n    /**\n     * Runs this execution list, executing all existing pairs in the order they were added. However,\n     * note that listeners added after this point may be executed before those previously added, and\n     * note that the execution order of all listeners is ultimately chosen by the implementations of\n     * the supplied executors.\n     *\n     * <p>This method is idempotent. Calling it several times in parallel is semantically equivalent\n     * to calling it exactly once.\n     *\n     * @since 10.0 (present in 1.0 as {@code run})\n     */\n\n    /**\n     * Submits the given runnable to the given {@link Executor} catching and logging all {@linkplain\n     * RuntimeException runtime exceptions} thrown by the executor.\n     */\n    private static void executeListener(Runnable runnable, Executor executor)\n    {\n        try\n        {\n            executor.execute(runnable);\n        }\n        catch (RuntimeException e)\n        {\n            // Log it and keep going -- bad runnable and/or executor. Don't punish the other runnables if\n            // we're given a bad one. We only catch RuntimeException because we want Errors to propagate\n            // up.\n            log.log(\n                Level.SEVERE,\n                \"RuntimeException while executing runnable \" + runnable + \" with executor \" + executor,\n                e);\n        }\n    }\n\n    private static final class RunnableExecutorPair\n    {\n        final Runnable runnable;\n        final Executor executor;\n        @Nullable RunnableExecutorPair next;\n\n        RunnableExecutorPair(Runnable runnable, Executor executor, RunnableExecutorPair next)\n        {\n            this.runnable = runnable;\n            this.executor = executor;\n            this.next = next;\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/hash/LittleEndianByteArray.java", "func_name": "LittleEndianByteArray.load64Safely", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Similar to load64, but allows offset + 8 > input.length, padding the result with zeroes. This\nhas to explicitly reverse the order of the bytes as it packs them into the result which makes\nit slower than the native version.\n\n@param input the input bytes\n@param offset the offset into the array at which to start reading\n@param length the number of bytes from the input to read\n@return a long of a concatenated 8 bytes", "docstring_tokens": ["Similar", "to", "load64", "but", "allows", "offset", "+", "8", ">", "input", ".", "length", "padding", "the", "result", "with", "zeroes", ".", "This", "has", "to", "explicitly", "reverse", "the", "order", "of", "the", "bytes", "as", "it", "packs", "them", "into", "the", "result", "which", "makes", "it", "slower", "than", "the", "native", "version", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/hash/LittleEndianByteArray.java#L57-L69", "partition": "valid", "up_fun_num": 3, "levels": [0, 1, 1, 1, 1], "package": ["import com.google.common.primitives.Longs;", "import java.nio.ByteOrder;", "import sun.misc.Unsafe;"], "function": ["final class LittleEndianByteArray\n", "    static long load64(byte[] input, int offset)\n", "    static void store64(byte[] sink, int offset, long value)\n", "    static int load32(byte[] source, int offset)\n", "    static boolean usingUnsafe()\n"], "context": "/*\n * Copyright (C) 2015 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.hash;\n\nimport com.google.common.primitives.Longs;\nimport java.nio.ByteOrder;\nimport sun.misc.Unsafe;\n\n/**\n * Utility functions for loading and storing values from a byte array.\n *\n * @author Kevin Damm\n * @author Kyle Maddison\n */\nfinal class LittleEndianByteArray\n{\n\n    /** The instance that actually does the work; delegates to Unsafe or a pure-Java fallback. */\n    private static final LittleEndianBytes byteArray;\n\n    /**\n     * Load 8 bytes into long in a little endian manner, from the substring between position and\n     * position + 8. The array must have at least 8 bytes from offset (inclusive).\n     *\n     * @param input the input bytes\n     * @param offset the offset into the array at which to start\n     * @return a long of a concatenated 8 bytes\n     */\n    static long load64(byte[] input, int offset)\n    {\n        // We don't want this in production code as this is the most critical part of the loop.\n        assert input.length >= offset + 8;\n        // Delegates to the fast (unsafe) version or the fallback.\n        return byteArray.getLongLittleEndian(input, offset);\n    }\n\n    /**\n     * Similar to load64, but allows offset + 8 > input.length, padding the result with zeroes. This\n     * has to explicitly reverse the order of the bytes as it packs them into the result which makes\n     * it slower than the native version.\n     *\n     * @param input the input bytes\n     * @param offset the offset into the array at which to start reading\n     * @param length the number of bytes from the input to read\n     * @return a long of a concatenated 8 bytes\n     */\n\n    /**\n     * Store 8 bytes into the provided array at the indicated offset, using the value provided.\n     *\n     * @param sink the output byte array\n     * @param offset the offset into the array at which to start writing\n     * @param value the value to write\n     */\n    static void store64(byte[] sink, int offset, long value)\n    {\n        // We don't want to assert in production code.\n        assert offset >= 0 && offset + 8 <= sink.length;\n        // Delegates to the fast (unsafe)version or the fallback.\n        byteArray.putLongLittleEndian(sink, offset, value);\n    }\n\n    /**\n     * Load 4 bytes from the provided array at the indicated offset.\n     *\n     * @param source the input bytes\n     * @param offset the offset into the array at which to start\n     * @return the value found in the array in the form of a long\n     */\n    static int load32(byte[] source, int offset)\n    {\n        // TODO(user): Measure the benefit of delegating this to LittleEndianBytes also.\n        return (source[offset] & 0xFF)\n               | ((source[offset + 1] & 0xFF) << 8)\n               | ((source[offset + 2] & 0xFF) << 16)\n               | ((source[offset + 3] & 0xFF) << 24);\n    }\n\n    /**\n     * Indicates that the loading of Unsafe was successful and the load and store operations will be\n     * very efficient. May be useful for calling code to fall back on an alternative implementation\n     * that is slower than Unsafe.get/store but faster than the pure-Java mask-and-shift.\n     */\n    static boolean usingUnsafe()\n    {\n        return (byteArray instanceof UnsafeByteArray);\n    }\n\n    /**\n     * Common interface for retrieving a 64-bit long from a little-endian byte array.\n     *\n     * <p>This abstraction allows us to use single-instruction load and put when available, or fall\n     * back on the slower approach of using Longs.fromBytes(byte...).\n     */\n    private interface LittleEndianBytes\n    {\n        long getLongLittleEndian(byte[] array, int offset);\n\n        void putLongLittleEndian(byte[] array, int offset, long value);\n    }\n\n    /**\n     * The only reference to Unsafe is in this nested class. We set things up so that if\n     * Unsafe.theUnsafe is inaccessible, the attempt to load the nested class fails, and the outer\n     * class's static initializer can fall back on a non-Unsafe version.\n     */\n    private enum UnsafeByteArray implements LittleEndianBytes\n    {\n        // Do *not* change the order of these constants!\n        UNSAFE_LITTLE_ENDIAN {\n            @Override\n            public long getLongLittleEndian(byte[] array, int offset)\n            {\n                return theUnsafe.getLong(array, (long) offset + BYTE_ARRAY_BASE_OFFSET);\n            }\n\n            @Override\n            public void putLongLittleEndian(byte[] array, int offset, long value)\n            {\n                theUnsafe.putLong(array, (long) offset + BYTE_ARRAY_BASE_OFFSET, value);\n            }\n        },\n        UNSAFE_BIG_ENDIAN {\n            @Override\n            public long getLongLittleEndian(byte[] array, int offset)\n            {\n                long bigEndian = theUnsafe.getLong(array, (long) offset + BYTE_ARRAY_BASE_OFFSET);\n                // The hardware is big-endian, so we need to reverse the order of the bytes.\n                return Long.reverseBytes(bigEndian);\n            }\n\n            @Override\n            public void putLongLittleEndian(byte[] array, int offset, long value)\n            {\n                // Reverse the order of the bytes before storing, since we're on big-endian hardware.\n                long littleEndianValue = Long.reverseBytes(value);\n                theUnsafe.putLong(array, (long) offset + BYTE_ARRAY_BASE_OFFSET, littleEndianValue);\n            }\n        };\n\n        // Provides load and store operations that use native instructions to get better performance.\n        private static final Unsafe theUnsafe;\n\n        // The offset to the first element in a byte array.\n        private static final int BYTE_ARRAY_BASE_OFFSET;\n\n        /**\n         * Returns a sun.misc.Unsafe. Suitable for use in a 3rd party package. Replace with a simple\n         * call to Unsafe.getUnsafe when integrating into a jdk.\n         *\n         * @return a sun.misc.Unsafe instance if successful\n         */\n        private static sun.misc.Unsafe getUnsafe()\n        {\n            try\n            {\n                return sun.misc.Unsafe.getUnsafe();\n            }\n            catch (SecurityException tryReflectionInstead)\n            {\n                // We'll try reflection instead.\n            }\n            try\n            {\n                return java.security.AccessController.doPrivileged(\n                           new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>()\n                {\n                    @Override\n                    public sun.misc.Unsafe run() throws Exception\n                    {\n                        Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\n                        for (java.lang.reflect.Field f : k.getDeclaredFields())\n                        {\n                            f.setAccessible(true);\n                            Object x = f.get(null);\n                            if (k.isInstance(x))\n                            {\n                                return k.cast(x);\n                            }\n                        }\n                        throw new NoSuchFieldError(\"the Unsafe\");\n                    }\n                });\n            }\n            catch (java.security.PrivilegedActionException e)\n            {\n                throw new RuntimeException(\"Could not initialize intrinsics\", e.getCause());\n            }\n        }\n\n        static {\n            theUnsafe = getUnsafe();\n            BYTE_ARRAY_BASE_OFFSET = theUnsafe.arrayBaseOffset(byte[].class);\n\n            // sanity check - this should never fail\n            if (theUnsafe.arrayIndexScale(byte[].class) != 1)\n            {\n                throw new AssertionError();\n            }\n        }\n    }\n\n    /** Fallback implementation for when Unsafe is not available in our current environment. */\n    private enum JavaLittleEndianBytes implements LittleEndianBytes\n    {\n        INSTANCE {\n            @Override\n            public long getLongLittleEndian(byte[] source, int offset)\n            {\n                return Longs.fromBytes(\n                    source[offset + 7],\n                    source[offset + 6],\n                    source[offset + 5],\n                    source[offset + 4],\n                    source[offset + 3],\n                    source[offset + 2],\n                    source[offset + 1],\n                    source[offset]);\n            }\n\n            @Override\n            public void putLongLittleEndian(byte[] sink, int offset, long value)\n            {\n                long mask = 0xFFL;\n                for (int i = 0; i < 8; mask <<= 8, i++)\n                {\n                    sink[offset + i] = (byte) ((value & mask) >> (i * 8));\n                }\n            }\n        };\n    }\n\n    static\n    {\n        LittleEndianBytes theGetter = JavaLittleEndianBytes.INSTANCE;\n        try\n        {\n            /*\n              UnsafeByteArray uses Unsafe.getLong() in an unsupported way, which is known to cause crashes\n              on Android when running in 32-bit mode. For maximum safety, we shouldn't use\n              Unsafe.getLong() at all, but the performance benefit on x86_64 is too great to ignore, so as\n              a compromise, we enable the optimization only on platforms that we specifically know to\n              work.\n\n              In the future, the use of Unsafe.getLong() should be replaced by ByteBuffer.getLong(), which\n              will have an efficient native implementation in JDK 9.\n\n            */\n            final String arch = System.getProperty(\"os.arch\");\n            if (\"amd64\".equals(arch))\n            {\n                theGetter =\n                    ByteOrder.nativeOrder().equals(ByteOrder.LITTLE_ENDIAN)\n                    ? UnsafeByteArray.UNSAFE_LITTLE_ENDIAN\n                    : UnsafeByteArray.UNSAFE_BIG_ENDIAN;\n            }\n        }\n        catch (Throwable t)\n        {\n            // ensure we really catch *everything*\n        }\n        byteArray = theGetter;\n    }\n\n    /** Deter instantiation of this class. */\n    private LittleEndianByteArray() {}\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/hash/LittleEndianByteArray.java", "func_name": "LittleEndianByteArray.store64", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Store 8 bytes into the provided array at the indicated offset, using the value provided.\n\n@param sink the output byte array\n@param offset the offset into the array at which to start writing\n@param value the value to write", "docstring_tokens": ["Store", "8", "bytes", "into", "the", "provided", "array", "at", "the", "indicated", "offset", "using", "the", "value", "provided", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/hash/LittleEndianByteArray.java#L78-L83", "partition": "valid", "up_fun_num": 4, "levels": [0, 1, 1, 1, 1], "package": ["import com.google.common.primitives.Longs;", "import java.nio.ByteOrder;", "import sun.misc.Unsafe;"], "function": ["final class LittleEndianByteArray\n", "    static long load64(byte[] input, int offset)\n", "    static long load64Safely(byte[] input, int offset, int length)\n", "    static int load32(byte[] source, int offset)\n", "    static boolean usingUnsafe()\n"], "context": "/*\n * Copyright (C) 2015 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.hash;\n\nimport com.google.common.primitives.Longs;\nimport java.nio.ByteOrder;\nimport sun.misc.Unsafe;\n\n/**\n * Utility functions for loading and storing values from a byte array.\n *\n * @author Kevin Damm\n * @author Kyle Maddison\n */\nfinal class LittleEndianByteArray\n{\n\n    /** The instance that actually does the work; delegates to Unsafe or a pure-Java fallback. */\n    private static final LittleEndianBytes byteArray;\n\n    /**\n     * Load 8 bytes into long in a little endian manner, from the substring between position and\n     * position + 8. The array must have at least 8 bytes from offset (inclusive).\n     *\n     * @param input the input bytes\n     * @param offset the offset into the array at which to start\n     * @return a long of a concatenated 8 bytes\n     */\n    static long load64(byte[] input, int offset)\n    {\n        // We don't want this in production code as this is the most critical part of the loop.\n        assert input.length >= offset + 8;\n        // Delegates to the fast (unsafe) version or the fallback.\n        return byteArray.getLongLittleEndian(input, offset);\n    }\n\n    /**\n     * Similar to load64, but allows offset + 8 > input.length, padding the result with zeroes. This\n     * has to explicitly reverse the order of the bytes as it packs them into the result which makes\n     * it slower than the native version.\n     *\n     * @param input the input bytes\n     * @param offset the offset into the array at which to start reading\n     * @param length the number of bytes from the input to read\n     * @return a long of a concatenated 8 bytes\n     */\n    static long load64Safely(byte[] input, int offset, int length)\n    {\n        long result = 0;\n        // Due to the way we shift, we can stop iterating once we've run out of data, the rest\n        // of the result already being filled with zeros.\n\n        // This loop is critical to performance, so please check HashBenchmark if altering it.\n        int limit = Math.min(length, 8);\n        for (int i = 0; i < limit; i++)\n        {\n            // Shift value left while iterating logically through the array.\n            result |= (input[offset + i] & 0xFFL) << (i * 8);\n        }\n        return result;\n    }\n\n    /**\n     * Store 8 bytes into the provided array at the indicated offset, using the value provided.\n     *\n     * @param sink the output byte array\n     * @param offset the offset into the array at which to start writing\n     * @param value the value to write\n     */\n\n    /**\n     * Load 4 bytes from the provided array at the indicated offset.\n     *\n     * @param source the input bytes\n     * @param offset the offset into the array at which to start\n     * @return the value found in the array in the form of a long\n     */\n    static int load32(byte[] source, int offset)\n    {\n        // TODO(user): Measure the benefit of delegating this to LittleEndianBytes also.\n        return (source[offset] & 0xFF)\n               | ((source[offset + 1] & 0xFF) << 8)\n               | ((source[offset + 2] & 0xFF) << 16)\n               | ((source[offset + 3] & 0xFF) << 24);\n    }\n\n    /**\n     * Indicates that the loading of Unsafe was successful and the load and store operations will be\n     * very efficient. May be useful for calling code to fall back on an alternative implementation\n     * that is slower than Unsafe.get/store but faster than the pure-Java mask-and-shift.\n     */\n    static boolean usingUnsafe()\n    {\n        return (byteArray instanceof UnsafeByteArray);\n    }\n\n    /**\n     * Common interface for retrieving a 64-bit long from a little-endian byte array.\n     *\n     * <p>This abstraction allows us to use single-instruction load and put when available, or fall\n     * back on the slower approach of using Longs.fromBytes(byte...).\n     */\n    private interface LittleEndianBytes\n    {\n        long getLongLittleEndian(byte[] array, int offset);\n\n        void putLongLittleEndian(byte[] array, int offset, long value);\n    }\n\n    /**\n     * The only reference to Unsafe is in this nested class. We set things up so that if\n     * Unsafe.theUnsafe is inaccessible, the attempt to load the nested class fails, and the outer\n     * class's static initializer can fall back on a non-Unsafe version.\n     */\n    private enum UnsafeByteArray implements LittleEndianBytes\n    {\n        // Do *not* change the order of these constants!\n        UNSAFE_LITTLE_ENDIAN {\n            @Override\n            public long getLongLittleEndian(byte[] array, int offset)\n            {\n                return theUnsafe.getLong(array, (long) offset + BYTE_ARRAY_BASE_OFFSET);\n            }\n\n            @Override\n            public void putLongLittleEndian(byte[] array, int offset, long value)\n            {\n                theUnsafe.putLong(array, (long) offset + BYTE_ARRAY_BASE_OFFSET, value);\n            }\n        },\n        UNSAFE_BIG_ENDIAN {\n            @Override\n            public long getLongLittleEndian(byte[] array, int offset)\n            {\n                long bigEndian = theUnsafe.getLong(array, (long) offset + BYTE_ARRAY_BASE_OFFSET);\n                // The hardware is big-endian, so we need to reverse the order of the bytes.\n                return Long.reverseBytes(bigEndian);\n            }\n\n            @Override\n            public void putLongLittleEndian(byte[] array, int offset, long value)\n            {\n                // Reverse the order of the bytes before storing, since we're on big-endian hardware.\n                long littleEndianValue = Long.reverseBytes(value);\n                theUnsafe.putLong(array, (long) offset + BYTE_ARRAY_BASE_OFFSET, littleEndianValue);\n            }\n        };\n\n        // Provides load and store operations that use native instructions to get better performance.\n        private static final Unsafe theUnsafe;\n\n        // The offset to the first element in a byte array.\n        private static final int BYTE_ARRAY_BASE_OFFSET;\n\n        /**\n         * Returns a sun.misc.Unsafe. Suitable for use in a 3rd party package. Replace with a simple\n         * call to Unsafe.getUnsafe when integrating into a jdk.\n         *\n         * @return a sun.misc.Unsafe instance if successful\n         */\n        private static sun.misc.Unsafe getUnsafe()\n        {\n            try\n            {\n                return sun.misc.Unsafe.getUnsafe();\n            }\n            catch (SecurityException tryReflectionInstead)\n            {\n                // We'll try reflection instead.\n            }\n            try\n            {\n                return java.security.AccessController.doPrivileged(\n                           new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>()\n                {\n                    @Override\n                    public sun.misc.Unsafe run() throws Exception\n                    {\n                        Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\n                        for (java.lang.reflect.Field f : k.getDeclaredFields())\n                        {\n                            f.setAccessible(true);\n                            Object x = f.get(null);\n                            if (k.isInstance(x))\n                            {\n                                return k.cast(x);\n                            }\n                        }\n                        throw new NoSuchFieldError(\"the Unsafe\");\n                    }\n                });\n            }\n            catch (java.security.PrivilegedActionException e)\n            {\n                throw new RuntimeException(\"Could not initialize intrinsics\", e.getCause());\n            }\n        }\n\n        static {\n            theUnsafe = getUnsafe();\n            BYTE_ARRAY_BASE_OFFSET = theUnsafe.arrayBaseOffset(byte[].class);\n\n            // sanity check - this should never fail\n            if (theUnsafe.arrayIndexScale(byte[].class) != 1)\n            {\n                throw new AssertionError();\n            }\n        }\n    }\n\n    /** Fallback implementation for when Unsafe is not available in our current environment. */\n    private enum JavaLittleEndianBytes implements LittleEndianBytes\n    {\n        INSTANCE {\n            @Override\n            public long getLongLittleEndian(byte[] source, int offset)\n            {\n                return Longs.fromBytes(\n                    source[offset + 7],\n                    source[offset + 6],\n                    source[offset + 5],\n                    source[offset + 4],\n                    source[offset + 3],\n                    source[offset + 2],\n                    source[offset + 1],\n                    source[offset]);\n            }\n\n            @Override\n            public void putLongLittleEndian(byte[] sink, int offset, long value)\n            {\n                long mask = 0xFFL;\n                for (int i = 0; i < 8; mask <<= 8, i++)\n                {\n                    sink[offset + i] = (byte) ((value & mask) >> (i * 8));\n                }\n            }\n        };\n    }\n\n    static\n    {\n        LittleEndianBytes theGetter = JavaLittleEndianBytes.INSTANCE;\n        try\n        {\n            /*\n              UnsafeByteArray uses Unsafe.getLong() in an unsupported way, which is known to cause crashes\n              on Android when running in 32-bit mode. For maximum safety, we shouldn't use\n              Unsafe.getLong() at all, but the performance benefit on x86_64 is too great to ignore, so as\n              a compromise, we enable the optimization only on platforms that we specifically know to\n              work.\n\n              In the future, the use of Unsafe.getLong() should be replaced by ByteBuffer.getLong(), which\n              will have an efficient native implementation in JDK 9.\n\n            */\n            final String arch = System.getProperty(\"os.arch\");\n            if (\"amd64\".equals(arch))\n            {\n                theGetter =\n                    ByteOrder.nativeOrder().equals(ByteOrder.LITTLE_ENDIAN)\n                    ? UnsafeByteArray.UNSAFE_LITTLE_ENDIAN\n                    : UnsafeByteArray.UNSAFE_BIG_ENDIAN;\n            }\n        }\n        catch (Throwable t)\n        {\n            // ensure we really catch *everything*\n        }\n        byteArray = theGetter;\n    }\n\n    /** Deter instantiation of this class. */\n    private LittleEndianByteArray() {}\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/hash/LittleEndianByteArray.java", "func_name": "LittleEndianByteArray.load32", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Load 4 bytes from the provided array at the indicated offset.\n\n@param source the input bytes\n@param offset the offset into the array at which to start\n@return the value found in the array in the form of a long", "docstring_tokens": ["Load", "4", "bytes", "from", "the", "provided", "array", "at", "the", "indicated", "offset", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/hash/LittleEndianByteArray.java#L92-L98", "partition": "valid", "up_fun_num": 5, "levels": [0, 1, 1, 1, 1], "package": ["import com.google.common.primitives.Longs;", "import java.nio.ByteOrder;", "import sun.misc.Unsafe;"], "function": ["final class LittleEndianByteArray\n", "    static long load64(byte[] input, int offset)\n", "    static long load64Safely(byte[] input, int offset, int length)\n", "    static void store64(byte[] sink, int offset, long value)\n", "    static boolean usingUnsafe()\n"], "context": "/*\n * Copyright (C) 2015 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.hash;\n\nimport com.google.common.primitives.Longs;\nimport java.nio.ByteOrder;\nimport sun.misc.Unsafe;\n\n/**\n * Utility functions for loading and storing values from a byte array.\n *\n * @author Kevin Damm\n * @author Kyle Maddison\n */\nfinal class LittleEndianByteArray\n{\n\n    /** The instance that actually does the work; delegates to Unsafe or a pure-Java fallback. */\n    private static final LittleEndianBytes byteArray;\n\n    /**\n     * Load 8 bytes into long in a little endian manner, from the substring between position and\n     * position + 8. The array must have at least 8 bytes from offset (inclusive).\n     *\n     * @param input the input bytes\n     * @param offset the offset into the array at which to start\n     * @return a long of a concatenated 8 bytes\n     */\n    static long load64(byte[] input, int offset)\n    {\n        // We don't want this in production code as this is the most critical part of the loop.\n        assert input.length >= offset + 8;\n        // Delegates to the fast (unsafe) version or the fallback.\n        return byteArray.getLongLittleEndian(input, offset);\n    }\n\n    /**\n     * Similar to load64, but allows offset + 8 > input.length, padding the result with zeroes. This\n     * has to explicitly reverse the order of the bytes as it packs them into the result which makes\n     * it slower than the native version.\n     *\n     * @param input the input bytes\n     * @param offset the offset into the array at which to start reading\n     * @param length the number of bytes from the input to read\n     * @return a long of a concatenated 8 bytes\n     */\n    static long load64Safely(byte[] input, int offset, int length)\n    {\n        long result = 0;\n        // Due to the way we shift, we can stop iterating once we've run out of data, the rest\n        // of the result already being filled with zeros.\n\n        // This loop is critical to performance, so please check HashBenchmark if altering it.\n        int limit = Math.min(length, 8);\n        for (int i = 0; i < limit; i++)\n        {\n            // Shift value left while iterating logically through the array.\n            result |= (input[offset + i] & 0xFFL) << (i * 8);\n        }\n        return result;\n    }\n\n    /**\n     * Store 8 bytes into the provided array at the indicated offset, using the value provided.\n     *\n     * @param sink the output byte array\n     * @param offset the offset into the array at which to start writing\n     * @param value the value to write\n     */\n    static void store64(byte[] sink, int offset, long value)\n    {\n        // We don't want to assert in production code.\n        assert offset >= 0 && offset + 8 <= sink.length;\n        // Delegates to the fast (unsafe)version or the fallback.\n        byteArray.putLongLittleEndian(sink, offset, value);\n    }\n\n    /**\n     * Load 4 bytes from the provided array at the indicated offset.\n     *\n     * @param source the input bytes\n     * @param offset the offset into the array at which to start\n     * @return the value found in the array in the form of a long\n     */\n\n    /**\n     * Indicates that the loading of Unsafe was successful and the load and store operations will be\n     * very efficient. May be useful for calling code to fall back on an alternative implementation\n     * that is slower than Unsafe.get/store but faster than the pure-Java mask-and-shift.\n     */\n    static boolean usingUnsafe()\n    {\n        return (byteArray instanceof UnsafeByteArray);\n    }\n\n    /**\n     * Common interface for retrieving a 64-bit long from a little-endian byte array.\n     *\n     * <p>This abstraction allows us to use single-instruction load and put when available, or fall\n     * back on the slower approach of using Longs.fromBytes(byte...).\n     */\n    private interface LittleEndianBytes\n    {\n        long getLongLittleEndian(byte[] array, int offset);\n\n        void putLongLittleEndian(byte[] array, int offset, long value);\n    }\n\n    /**\n     * The only reference to Unsafe is in this nested class. We set things up so that if\n     * Unsafe.theUnsafe is inaccessible, the attempt to load the nested class fails, and the outer\n     * class's static initializer can fall back on a non-Unsafe version.\n     */\n    private enum UnsafeByteArray implements LittleEndianBytes\n    {\n        // Do *not* change the order of these constants!\n        UNSAFE_LITTLE_ENDIAN {\n            @Override\n            public long getLongLittleEndian(byte[] array, int offset)\n            {\n                return theUnsafe.getLong(array, (long) offset + BYTE_ARRAY_BASE_OFFSET);\n            }\n\n            @Override\n            public void putLongLittleEndian(byte[] array, int offset, long value)\n            {\n                theUnsafe.putLong(array, (long) offset + BYTE_ARRAY_BASE_OFFSET, value);\n            }\n        },\n        UNSAFE_BIG_ENDIAN {\n            @Override\n            public long getLongLittleEndian(byte[] array, int offset)\n            {\n                long bigEndian = theUnsafe.getLong(array, (long) offset + BYTE_ARRAY_BASE_OFFSET);\n                // The hardware is big-endian, so we need to reverse the order of the bytes.\n                return Long.reverseBytes(bigEndian);\n            }\n\n            @Override\n            public void putLongLittleEndian(byte[] array, int offset, long value)\n            {\n                // Reverse the order of the bytes before storing, since we're on big-endian hardware.\n                long littleEndianValue = Long.reverseBytes(value);\n                theUnsafe.putLong(array, (long) offset + BYTE_ARRAY_BASE_OFFSET, littleEndianValue);\n            }\n        };\n\n        // Provides load and store operations that use native instructions to get better performance.\n        private static final Unsafe theUnsafe;\n\n        // The offset to the first element in a byte array.\n        private static final int BYTE_ARRAY_BASE_OFFSET;\n\n        /**\n         * Returns a sun.misc.Unsafe. Suitable for use in a 3rd party package. Replace with a simple\n         * call to Unsafe.getUnsafe when integrating into a jdk.\n         *\n         * @return a sun.misc.Unsafe instance if successful\n         */\n        private static sun.misc.Unsafe getUnsafe()\n        {\n            try\n            {\n                return sun.misc.Unsafe.getUnsafe();\n            }\n            catch (SecurityException tryReflectionInstead)\n            {\n                // We'll try reflection instead.\n            }\n            try\n            {\n                return java.security.AccessController.doPrivileged(\n                           new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>()\n                {\n                    @Override\n                    public sun.misc.Unsafe run() throws Exception\n                    {\n                        Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\n                        for (java.lang.reflect.Field f : k.getDeclaredFields())\n                        {\n                            f.setAccessible(true);\n                            Object x = f.get(null);\n                            if (k.isInstance(x))\n                            {\n                                return k.cast(x);\n                            }\n                        }\n                        throw new NoSuchFieldError(\"the Unsafe\");\n                    }\n                });\n            }\n            catch (java.security.PrivilegedActionException e)\n            {\n                throw new RuntimeException(\"Could not initialize intrinsics\", e.getCause());\n            }\n        }\n\n        static {\n            theUnsafe = getUnsafe();\n            BYTE_ARRAY_BASE_OFFSET = theUnsafe.arrayBaseOffset(byte[].class);\n\n            // sanity check - this should never fail\n            if (theUnsafe.arrayIndexScale(byte[].class) != 1)\n            {\n                throw new AssertionError();\n            }\n        }\n    }\n\n    /** Fallback implementation for when Unsafe is not available in our current environment. */\n    private enum JavaLittleEndianBytes implements LittleEndianBytes\n    {\n        INSTANCE {\n            @Override\n            public long getLongLittleEndian(byte[] source, int offset)\n            {\n                return Longs.fromBytes(\n                    source[offset + 7],\n                    source[offset + 6],\n                    source[offset + 5],\n                    source[offset + 4],\n                    source[offset + 3],\n                    source[offset + 2],\n                    source[offset + 1],\n                    source[offset]);\n            }\n\n            @Override\n            public void putLongLittleEndian(byte[] sink, int offset, long value)\n            {\n                long mask = 0xFFL;\n                for (int i = 0; i < 8; mask <<= 8, i++)\n                {\n                    sink[offset + i] = (byte) ((value & mask) >> (i * 8));\n                }\n            }\n        };\n    }\n\n    static\n    {\n        LittleEndianBytes theGetter = JavaLittleEndianBytes.INSTANCE;\n        try\n        {\n            /*\n              UnsafeByteArray uses Unsafe.getLong() in an unsupported way, which is known to cause crashes\n              on Android when running in 32-bit mode. For maximum safety, we shouldn't use\n              Unsafe.getLong() at all, but the performance benefit on x86_64 is too great to ignore, so as\n              a compromise, we enable the optimization only on platforms that we specifically know to\n              work.\n\n              In the future, the use of Unsafe.getLong() should be replaced by ByteBuffer.getLong(), which\n              will have an efficient native implementation in JDK 9.\n\n            */\n            final String arch = System.getProperty(\"os.arch\");\n            if (\"amd64\".equals(arch))\n            {\n                theGetter =\n                    ByteOrder.nativeOrder().equals(ByteOrder.LITTLE_ENDIAN)\n                    ? UnsafeByteArray.UNSAFE_LITTLE_ENDIAN\n                    : UnsafeByteArray.UNSAFE_BIG_ENDIAN;\n            }\n        }\n        catch (Throwable t)\n        {\n            // ensure we really catch *everything*\n        }\n        byteArray = theGetter;\n    }\n\n    /** Deter instantiation of this class. */\n    private LittleEndianByteArray() {}\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/net/MediaType.java", "func_name": "MediaType.create", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Creates a new media type with the given type and subtype.\n\n@throws IllegalArgumentException if type or subtype is invalid or if a wildcard is used for the\ntype, but not the subtype.", "docstring_tokens": ["Creates", "a", "new", "media", "type", "with", "the", "given", "type", "and", "subtype", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/net/MediaType.java#L845-L849", "partition": "valid", "up_fun_num": 17, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.CharMatcher.ascii;", "import static com.google.common.base.CharMatcher.javaIsoControl;", "import static com.google.common.base.Charsets.UTF_8;", "import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.base.Preconditions.checkState;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.base.Ascii;", "import com.google.common.base.CharMatcher;", "import com.google.common.base.Function;", "import com.google.common.base.Joiner;", "import com.google.common.base.Joiner.MapJoiner;", "import com.google.common.base.MoreObjects;", "import com.google.common.base.Objects;", "import com.google.common.base.Optional;", "import com.google.common.collect.ImmutableListMultimap;", "import com.google.common.collect.ImmutableMultiset;", "import com.google.common.collect.ImmutableSet;", "import com.google.common.collect.Maps;", "import com.google.common.collect.Multimap;", "import com.google.common.collect.Multimaps;", "import com.google.errorprone.annotations.Immutable;", "import com.google.errorprone.annotations.concurrent.LazyInit;", "import java.nio.charset.Charset;", "import java.nio.charset.IllegalCharsetNameException;", "import java.nio.charset.UnsupportedCharsetException;", "import java.util.Collection;", "import java.util.Map;", "import java.util.Map.Entry;", "import org.checkerframework.checker.nullness.qual.Nullable;"], "function": ["public final class MediaType\n", "    private static MediaType createConstant(String type, String subtype)\n", "    private static MediaType createConstantUtf8(String type, String subtype)\n", "    private static MediaType addKnownType(MediaType mediaType)\n", "    public String type()\n", "    public String subtype()\n", "    public ImmutableListMultimap<String, String> parameters()\n", "    private Map<String, ImmutableMultiset<String>> parametersAsMap()\n", "    public Optional<Charset> charset()\n", "    public MediaType withoutParameters()\n", "    public MediaType withParameters(Multimap<String, String> parameters)\n", "    public MediaType withParameters(String attribute, Iterable<String> values)\n", "    public MediaType withParameter(String attribute, String value)\n", "    public MediaType withCharset(Charset charset)\n", "    public boolean hasWildcard()\n", "    public boolean is(MediaType mediaTypeRange)\n", "    private static MediaType create(\n", "    static MediaType createApplicationType(String subtype)\n", "    static MediaType createAudioType(String subtype)\n", "    static MediaType createImageType(String subtype)\n", "    static MediaType createTextType(String subtype)\n", "    static MediaType createVideoType(String subtype)\n", "    private static String normalizeToken(String token)\n", "    private static String normalizeParameterValue(String attribute, String value)\n", "    public static MediaType parse(String input)\n", "    public boolean equals(@Nullable Object obj)\n", "    public int hashCode()\n", "    public String toString()\n", "    private String computeToString()\n", "    private static String escapeAndQuote(String value)\n"], "context": "/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.net;\n\nimport static com.google.common.base.CharMatcher.ascii;\nimport static com.google.common.base.CharMatcher.javaIsoControl;\nimport static com.google.common.base.Charsets.UTF_8;\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.base.Ascii;\nimport com.google.common.base.CharMatcher;\nimport com.google.common.base.Function;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Joiner.MapJoiner;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Objects;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.common.collect.ImmutableMultiset;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Multimap;\nimport com.google.common.collect.Multimaps;\nimport com.google.errorprone.annotations.Immutable;\nimport com.google.errorprone.annotations.concurrent.LazyInit;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\n/**\n * Represents an <a href=\"http://en.wikipedia.org/wiki/Internet_media_type\">Internet Media Type</a>\n * (also known as a MIME Type or Content Type). This class also supports the concept of media ranges\n * <a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1\">defined by HTTP/1.1</a>.\n * As such, the {@code *} character is treated as a wildcard and is used to represent any acceptable\n * type or subtype value. A media type may not have wildcard type with a declared subtype. The\n * {@code *} character has no special meaning as part of a parameter. All values for type, subtype,\n * parameter attributes or parameter values must be valid according to RFCs <a\n * href=\"http://www.ietf.org/rfc/rfc2045.txt\">2045</a> and <a\n * href=\"http://www.ietf.org/rfc/rfc2046.txt\">2046</a>.\n *\n * <p>All portions of the media type that are case-insensitive (type, subtype, parameter attributes)\n * are normalized to lowercase. The value of the {@code charset} parameter is normalized to\n * lowercase, but all others are left as-is.\n *\n * <p>Note that this specifically does <strong>not</strong> represent the value of the MIME {@code\n * Content-Type} header and as such has no support for header-specific considerations such as line\n * folding and comments.\n *\n * <p>For media types that take a charset the predefined constants default to UTF-8 and have a\n * \"_UTF_8\" suffix. To get a version without a character set, use {@link #withoutParameters}.\n *\n * @since 12.0\n * @author Gregory Kick\n */\n@Beta\n@GwtCompatible\n@Immutable\npublic final class MediaType\n{\n    private static final String CHARSET_ATTRIBUTE = \"charset\";\n    private static final ImmutableListMultimap<String, String> UTF_8_CONSTANT_PARAMETERS =\n        ImmutableListMultimap.of(CHARSET_ATTRIBUTE, Ascii.toLowerCase(UTF_8.name()));\n\n    /** Matcher for type, subtype and attributes. */\n    private static final CharMatcher TOKEN_MATCHER =\n        ascii()\n        .and(javaIsoControl().negate())\n        .and(CharMatcher.isNot(' '))\n        .and(CharMatcher.noneOf(\"()<>@,;:\\\\\\\"/[]?=\"));\n\n    private static final CharMatcher QUOTED_TEXT_MATCHER = ascii().and(CharMatcher.noneOf(\"\\\"\\\\\\r\"));\n\n    /*\n     * This matches the same characters as linear-white-space from RFC 822, but we make no effort to\n     * enforce any particular rules with regards to line folding as stated in the class docs.\n     */\n    private static final CharMatcher LINEAR_WHITE_SPACE = CharMatcher.anyOf(\" \\t\\r\\n\");\n\n    // TODO(gak): make these public?\n    private static final String APPLICATION_TYPE = \"application\";\n    private static final String AUDIO_TYPE = \"audio\";\n    private static final String IMAGE_TYPE = \"image\";\n    private static final String TEXT_TYPE = \"text\";\n    private static final String VIDEO_TYPE = \"video\";\n\n    private static final String WILDCARD = \"*\";\n\n    private static final Map<MediaType, MediaType> KNOWN_TYPES = Maps.newHashMap();\n\n    private static MediaType createConstant(String type, String subtype)\n    {\n        MediaType mediaType =\n            addKnownType(new MediaType(type, subtype, ImmutableListMultimap.<String, String>of()));\n        mediaType.parsedCharset = Optional.absent();\n        return mediaType;\n    }\n\n    private static MediaType createConstantUtf8(String type, String subtype)\n    {\n        MediaType mediaType = addKnownType(new MediaType(type, subtype, UTF_8_CONSTANT_PARAMETERS));\n        mediaType.parsedCharset = Optional.of(UTF_8);\n        return mediaType;\n    }\n\n    private static MediaType addKnownType(MediaType mediaType)\n    {\n        KNOWN_TYPES.put(mediaType, mediaType);\n        return mediaType;\n    }\n\n    /*\n     * The following constants are grouped by their type and ordered alphabetically by the constant\n     * name within that type. The constant name should be a sensible identifier that is closest to the\n     * \"common name\" of the media. This is often, but not necessarily the same as the subtype.\n     *\n     * Be sure to declare all constants with the type and subtype in all lowercase. For types that\n     * take a charset (e.g. all text/* types), default to UTF-8 and suffix the constant name with\n     * \"_UTF_8\".\n     */\n\n    public static final MediaType ANY_TYPE = createConstant(WILDCARD, WILDCARD);\n    public static final MediaType ANY_TEXT_TYPE = createConstant(TEXT_TYPE, WILDCARD);\n    public static final MediaType ANY_IMAGE_TYPE = createConstant(IMAGE_TYPE, WILDCARD);\n    public static final MediaType ANY_AUDIO_TYPE = createConstant(AUDIO_TYPE, WILDCARD);\n    public static final MediaType ANY_VIDEO_TYPE = createConstant(VIDEO_TYPE, WILDCARD);\n    public static final MediaType ANY_APPLICATION_TYPE = createConstant(APPLICATION_TYPE, WILDCARD);\n\n    /* text types */\n    public static final MediaType CACHE_MANIFEST_UTF_8 =\n        createConstantUtf8(TEXT_TYPE, \"cache-manifest\");\n    public static final MediaType CSS_UTF_8 = createConstantUtf8(TEXT_TYPE, \"css\");\n    public static final MediaType CSV_UTF_8 = createConstantUtf8(TEXT_TYPE, \"csv\");\n    public static final MediaType HTML_UTF_8 = createConstantUtf8(TEXT_TYPE, \"html\");\n    public static final MediaType I_CALENDAR_UTF_8 = createConstantUtf8(TEXT_TYPE, \"calendar\");\n    public static final MediaType PLAIN_TEXT_UTF_8 = createConstantUtf8(TEXT_TYPE, \"plain\");\n\n    /**\n     * <a href=\"http://www.rfc-editor.org/rfc/rfc4329.txt\">RFC 4329</a> declares {@link\n     * #JAVASCRIPT_UTF_8 application/javascript} to be the correct media type for JavaScript, but this\n     * may be necessary in certain situations for compatibility.\n     */\n    public static final MediaType TEXT_JAVASCRIPT_UTF_8 = createConstantUtf8(TEXT_TYPE, \"javascript\");\n    /**\n     * <a href=\"http://www.iana.org/assignments/media-types/text/tab-separated-values\">Tab separated\n     * values</a>.\n     *\n     * @since 15.0\n     */\n    public static final MediaType TSV_UTF_8 = createConstantUtf8(TEXT_TYPE, \"tab-separated-values\");\n\n    public static final MediaType VCARD_UTF_8 = createConstantUtf8(TEXT_TYPE, \"vcard\");\n\n    /**\n     * UTF-8 encoded <a href=\"https://en.wikipedia.org/wiki/Wireless_Markup_Language\">Wireless Markup\n     * Language</a>.\n     *\n     * @since 13.0\n     */\n    public static final MediaType WML_UTF_8 = createConstantUtf8(TEXT_TYPE, \"vnd.wap.wml\");\n\n    /**\n     * As described in <a href=\"http://www.ietf.org/rfc/rfc3023.txt\">RFC 3023</a>, this constant\n     * ({@code text/xml}) is used for XML documents that are \"readable by casual users.\" {@link\n     * #APPLICATION_XML_UTF_8} is provided for documents that are intended for applications.\n     */\n    public static final MediaType XML_UTF_8 = createConstantUtf8(TEXT_TYPE, \"xml\");\n\n    /**\n     * As described in <a href=\"https://w3c.github.io/webvtt/#iana-text-vtt\">the VTT spec</a>, this is\n     * used for Web Video Text Tracks (WebVTT) files, used with the HTML5 track element.\n     *\n     * @since 20.0\n     */\n    public static final MediaType VTT_UTF_8 = createConstantUtf8(TEXT_TYPE, \"vtt\");\n\n    /**\n     * <a href=\"https://en.wikipedia.org/wiki/BMP_file_format\">Bitmap file format</a> ({@code bmp}\n     * files).\n     *\n     * @since 13.0\n     */\n    public static final MediaType BMP = createConstant(IMAGE_TYPE, \"bmp\");\n\n    /**\n     * The <a href=\"https://en.wikipedia.org/wiki/Camera_Image_File_Format\">Canon Image File\n     * Format</a> ({@code crw} files), a widely-used \"raw image\" format for cameras. It is found in\n     * {@code /etc/mime.types}, e.g. in <a href=\n     * \"http://anonscm.debian.org/gitweb/?p=collab-maint/mime-support.git;a=blob;f=mime.types;hb=HEAD\"\n     * >Debian 3.48-1</a>.\n     *\n     * @since 15.0\n     */\n    public static final MediaType CRW = createConstant(IMAGE_TYPE, \"x-canon-crw\");\n\n    public static final MediaType GIF = createConstant(IMAGE_TYPE, \"gif\");\n    public static final MediaType ICO = createConstant(IMAGE_TYPE, \"vnd.microsoft.icon\");\n    public static final MediaType JPEG = createConstant(IMAGE_TYPE, \"jpeg\");\n    public static final MediaType PNG = createConstant(IMAGE_TYPE, \"png\");\n\n    /**\n     * The Photoshop File Format ({@code psd} files) as defined by <a\n     * href=\"http://www.iana.org/assignments/media-types/image/vnd.adobe.photoshop\">IANA</a>, and\n     * found in {@code /etc/mime.types}, e.g. <a\n     * href=\"http://svn.apache.org/repos/asf/httpd/httpd/branches/1.3.x/conf/mime.types\"></a> of the\n     * Apache <a href=\"http://httpd.apache.org/\">HTTPD project</a>; for the specification, see <a\n     * href=\"http://www.adobe.com/devnet-apps/photoshop/fileformatashtml/PhotoshopFileFormats.htm\">\n     * Adobe Photoshop Document Format</a> and <a\n     * href=\"http://en.wikipedia.org/wiki/Adobe_Photoshop#File_format\">Wikipedia</a>; this is the\n     * regular output/input of Photoshop (which can also export to various image formats; note that\n     * files with extension \"PSB\" are in a distinct but related format).\n     *\n     * <p>This is a more recent replacement for the older, experimental type {@code x-photoshop}: <a\n     * href=\"http://tools.ietf.org/html/rfc2046#section-6\">RFC-2046.6</a>.\n     *\n     * @since 15.0\n     */\n    public static final MediaType PSD = createConstant(IMAGE_TYPE, \"vnd.adobe.photoshop\");\n\n    public static final MediaType SVG_UTF_8 = createConstantUtf8(IMAGE_TYPE, \"svg+xml\");\n    public static final MediaType TIFF = createConstant(IMAGE_TYPE, \"tiff\");\n\n    /**\n     * <a href=\"https://en.wikipedia.org/wiki/WebP\">WebP image format</a>.\n     *\n     * @since 13.0\n     */\n    public static final MediaType WEBP = createConstant(IMAGE_TYPE, \"webp\");\n\n    /* audio types */\n    public static final MediaType MP4_AUDIO = createConstant(AUDIO_TYPE, \"mp4\");\n    public static final MediaType MPEG_AUDIO = createConstant(AUDIO_TYPE, \"mpeg\");\n    public static final MediaType OGG_AUDIO = createConstant(AUDIO_TYPE, \"ogg\");\n    public static final MediaType WEBM_AUDIO = createConstant(AUDIO_TYPE, \"webm\");\n\n    /**\n     * L16 audio, as defined by <a href=\"https://tools.ietf.org/html/rfc2586\">RFC 2586</a>.\n     *\n     * @since 24.1\n     */\n    public static final MediaType L16_AUDIO = createConstant(AUDIO_TYPE, \"l16\");\n\n    /**\n     * L24 audio, as defined by <a href=\"https://tools.ietf.org/html/rfc3190\">RFC 3190</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType L24_AUDIO = createConstant(AUDIO_TYPE, \"l24\");\n\n    /**\n     * Basic Audio, as defined by <a href=\"http://tools.ietf.org/html/rfc2046#section-4.3\">RFC\n     * 2046</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType BASIC_AUDIO = createConstant(AUDIO_TYPE, \"basic\");\n\n    /**\n     * Advanced Audio Coding. For more information, see <a\n     * href=\"https://en.wikipedia.org/wiki/Advanced_Audio_Coding\">Advanced Audio Coding</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType AAC_AUDIO = createConstant(AUDIO_TYPE, \"aac\");\n\n    /**\n     * Vorbis Audio, as defined by <a href=\"http://tools.ietf.org/html/rfc5215\">RFC 5215</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType VORBIS_AUDIO = createConstant(AUDIO_TYPE, \"vorbis\");\n\n    /**\n     * Windows Media Audio. For more information, see <a\n     * href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/dd562994(v=vs.85).aspx\">file\n     * name extensions for Windows Media metafiles</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType WMA_AUDIO = createConstant(AUDIO_TYPE, \"x-ms-wma\");\n\n    /**\n     * Windows Media metafiles. For more information, see <a\n     * href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/dd562994(v=vs.85).aspx\">file\n     * name extensions for Windows Media metafiles</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType WAX_AUDIO = createConstant(AUDIO_TYPE, \"x-ms-wax\");\n\n    /**\n     * Real Audio. For more information, see <a\n     * href=\"http://service.real.com/help/faq/rp8/configrp8win.html\">this link</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType VND_REAL_AUDIO = createConstant(AUDIO_TYPE, \"vnd.rn-realaudio\");\n\n    /**\n     * WAVE format, as defined by <a href=\"https://tools.ietf.org/html/rfc2361\">RFC 2361</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType VND_WAVE_AUDIO = createConstant(AUDIO_TYPE, \"vnd.wave\");\n\n    /* video types */\n    public static final MediaType MP4_VIDEO = createConstant(VIDEO_TYPE, \"mp4\");\n    public static final MediaType MPEG_VIDEO = createConstant(VIDEO_TYPE, \"mpeg\");\n    public static final MediaType OGG_VIDEO = createConstant(VIDEO_TYPE, \"ogg\");\n    public static final MediaType QUICKTIME = createConstant(VIDEO_TYPE, \"quicktime\");\n    public static final MediaType WEBM_VIDEO = createConstant(VIDEO_TYPE, \"webm\");\n    public static final MediaType WMV = createConstant(VIDEO_TYPE, \"x-ms-wmv\");\n\n    /**\n     * Flash video. For more information, see <a href=\n     * \"http://help.adobe.com/en_US/ActionScript/3.0_ProgrammingAS3/WS5b3ccc516d4fbf351e63e3d118a9b90204-7d48.html\"\n     * >this link</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType FLV_VIDEO = createConstant(VIDEO_TYPE, \"x-flv\");\n\n    /**\n     * The 3GP multimedia container format. For more information, see <a\n     * href=\"ftp://www.3gpp.org/tsg_sa/TSG_SA/TSGS_23/Docs/PDF/SP-040065.pdf#page=10\">3GPP TS\n     * 26.244</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType THREE_GPP_VIDEO = createConstant(VIDEO_TYPE, \"3gpp\");\n\n    /**\n     * The 3G2 multimedia container format. For more information, see <a\n     * href=\"http://www.3gpp2.org/Public_html/specs/C.S0050-B_v1.0_070521.pdf#page=16\">3GPP2\n     * C.S0050-B</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType THREE_GPP2_VIDEO = createConstant(VIDEO_TYPE, \"3gpp2\");\n\n    /* application types */\n    /**\n     * As described in <a href=\"http://www.ietf.org/rfc/rfc3023.txt\">RFC 3023</a>, this constant\n     * ({@code application/xml}) is used for XML documents that are \"unreadable by casual users.\"\n     * {@link #XML_UTF_8} is provided for documents that may be read by users.\n     *\n     * @since 14.0\n     */\n    public static final MediaType APPLICATION_XML_UTF_8 = createConstantUtf8(APPLICATION_TYPE, \"xml\");\n\n    public static final MediaType ATOM_UTF_8 = createConstantUtf8(APPLICATION_TYPE, \"atom+xml\");\n    public static final MediaType BZIP2 = createConstant(APPLICATION_TYPE, \"x-bzip2\");\n\n    /**\n     * Files in the <a href=\"https://www.dartlang.org/articles/embedding-in-html/\">dart</a>\n     * programming language.\n     *\n     * @since 19.0\n     */\n    public static final MediaType DART_UTF_8 = createConstantUtf8(APPLICATION_TYPE, \"dart\");\n\n    /**\n     * <a href=\"https://goo.gl/2QoMvg\">Apple Passbook</a>.\n     *\n     * @since 19.0\n     */\n    public static final MediaType APPLE_PASSBOOK =\n        createConstant(APPLICATION_TYPE, \"vnd.apple.pkpass\");\n\n    /**\n     * <a href=\"http://en.wikipedia.org/wiki/Embedded_OpenType\">Embedded OpenType</a> fonts. This is\n     * <a href=\"http://www.iana.org/assignments/media-types/application/vnd.ms-fontobject\">registered\n     * </a> with the IANA.\n     *\n     * @since 17.0\n     */\n    public static final MediaType EOT = createConstant(APPLICATION_TYPE, \"vnd.ms-fontobject\");\n\n    /**\n     * As described in the <a href=\"http://idpf.org/epub\">International Digital Publishing Forum</a>\n     * EPUB is the distribution and interchange format standard for digital publications and\n     * documents. This media type is defined in the <a\n     * href=\"http://www.idpf.org/epub/30/spec/epub30-ocf.html\">EPUB Open Container Format</a>\n     * specification.\n     *\n     * @since 15.0\n     */\n    public static final MediaType EPUB = createConstant(APPLICATION_TYPE, \"epub+zip\");\n\n    public static final MediaType FORM_DATA =\n        createConstant(APPLICATION_TYPE, \"x-www-form-urlencoded\");\n\n    /**\n     * As described in <a href=\"https://www.rsa.com/rsalabs/node.asp?id=2138\">PKCS #12: Personal\n     * Information Exchange Syntax Standard</a>, PKCS #12 defines an archive file format for storing\n     * many cryptography objects as a single file.\n     *\n     * @since 15.0\n     */\n    public static final MediaType KEY_ARCHIVE = createConstant(APPLICATION_TYPE, \"pkcs12\");\n\n    /**\n     * This is a non-standard media type, but is commonly used in serving hosted binary files as it is\n     * <a href=\"http://code.google.com/p/browsersec/wiki/Part2#Survey_of_content_sniffing_behaviors\">\n     * known not to trigger content sniffing in current browsers</a>. It <i>should not</i> be used in\n     * other situations as it is not specified by any RFC and does not appear in the <a\n     * href=\"http://www.iana.org/assignments/media-types\">/IANA MIME Media Types</a> list. Consider\n     * {@link #OCTET_STREAM} for binary data that is not being served to a browser.\n     *\n     * @since 14.0\n     */\n    public static final MediaType APPLICATION_BINARY = createConstant(APPLICATION_TYPE, \"binary\");\n\n    public static final MediaType GZIP = createConstant(APPLICATION_TYPE, \"x-gzip\");\n\n    /**\n     * <a href=\"https://tools.ietf.org/html/draft-kelly-json-hal-08#section-3\">JSON Hypertext\n     * Application Language (HAL) documents</a>.\n     *\n     * @since 26.0\n     */\n    public static final MediaType HAL_JSON = createConstant(APPLICATION_TYPE, \"hal+json\");\n\n    /**\n     * <a href=\"http://www.rfc-editor.org/rfc/rfc4329.txt\">RFC 4329</a> declares this to be the\n     * correct media type for JavaScript, but {@link #TEXT_JAVASCRIPT_UTF_8 text/javascript} may be\n     * necessary in certain situations for compatibility.\n     */\n    public static final MediaType JAVASCRIPT_UTF_8 =\n        createConstantUtf8(APPLICATION_TYPE, \"javascript\");\n\n    /**\n     * For <a href=\"https://tools.ietf.org/html/rfc7515\">JWS or JWE objects using the Compact\n     * Serialization</a>.\n     *\n     * @since 27.1\n     */\n    public static final MediaType JOSE = createConstant(APPLICATION_TYPE, \"jose\");\n\n    /**\n     * For <a href=\"https://tools.ietf.org/html/rfc7515\">JWS or JWE objects using the JSON\n     * Serialization</a>.\n     *\n     * @since 27.1\n     */\n    public static final MediaType JOSE_JSON = createConstant(APPLICATION_TYPE, \"jose+json\");\n\n    public static final MediaType JSON_UTF_8 = createConstantUtf8(APPLICATION_TYPE, \"json\");\n\n    /**\n     * The <a href=\"http://www.w3.org/TR/appmanifest/\">Manifest for a web application</a>.\n     *\n     * @since 19.0\n     */\n    public static final MediaType MANIFEST_JSON_UTF_8 =\n        createConstantUtf8(APPLICATION_TYPE, \"manifest+json\");\n\n    /**\n     * <a href=\"http://www.opengeospatial.org/standards/kml/\">OGC KML (Keyhole Markup Language)</a>.\n     */\n    public static final MediaType KML = createConstant(APPLICATION_TYPE, \"vnd.google-earth.kml+xml\");\n\n    /**\n     * <a href=\"http://www.opengeospatial.org/standards/kml/\">OGC KML (Keyhole Markup Language)</a>,\n     * compressed using the ZIP format into KMZ archives.\n     */\n    public static final MediaType KMZ = createConstant(APPLICATION_TYPE, \"vnd.google-earth.kmz\");\n\n    /**\n     * The <a href=\"https://tools.ietf.org/html/rfc4155\">mbox database format</a>.\n     *\n     * @since 13.0\n     */\n    public static final MediaType MBOX = createConstant(APPLICATION_TYPE, \"mbox\");\n\n    /**\n     * <a href=\"http://goo.gl/1pGBFm\">Apple over-the-air mobile configuration profiles</a>.\n     *\n     * @since 18.0\n     */\n    public static final MediaType APPLE_MOBILE_CONFIG =\n        createConstant(APPLICATION_TYPE, \"x-apple-aspen-config\");\n\n    /** <a href=\"http://goo.gl/XDQ1h2\">Microsoft Excel</a> spreadsheets. */\n    public static final MediaType MICROSOFT_EXCEL = createConstant(APPLICATION_TYPE, \"vnd.ms-excel\");\n\n    /**\n     * <a href=\"http://goo.gl/XrTEqG\">Microsoft Outlook</a> items.\n     *\n     * @since 27.1\n     */\n    public static final MediaType MICROSOFT_OUTLOOK =\n        createConstant(APPLICATION_TYPE, \"vnd.ms-outlook\");\n\n    /** <a href=\"http://goo.gl/XDQ1h2\">Microsoft Powerpoint</a> presentations. */\n    public static final MediaType MICROSOFT_POWERPOINT =\n        createConstant(APPLICATION_TYPE, \"vnd.ms-powerpoint\");\n\n    /** <a href=\"http://goo.gl/XDQ1h2\">Microsoft Word</a> documents. */\n    public static final MediaType MICROSOFT_WORD = createConstant(APPLICATION_TYPE, \"msword\");\n\n    /**\n     * WASM applications. For more information see <a href=\"https://webassembly.org/\">the Web Assembly\n     * overview</a>.\n     *\n     * @since 27.0\n     */\n    public static final MediaType WASM_APPLICATION = createConstant(APPLICATION_TYPE, \"wasm\");\n\n    /**\n     * NaCl applications. For more information see <a\n     * href=\"https://developer.chrome.com/native-client/devguide/coding/application-structure\">the\n     * Developer Guide for Native Client Application Structure</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType NACL_APPLICATION = createConstant(APPLICATION_TYPE, \"x-nacl\");\n\n    /**\n     * NaCl portable applications. For more information see <a\n     * href=\"https://developer.chrome.com/native-client/devguide/coding/application-structure\">the\n     * Developer Guide for Native Client Application Structure</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType NACL_PORTABLE_APPLICATION =\n        createConstant(APPLICATION_TYPE, \"x-pnacl\");\n\n    public static final MediaType OCTET_STREAM = createConstant(APPLICATION_TYPE, \"octet-stream\");\n\n    public static final MediaType OGG_CONTAINER = createConstant(APPLICATION_TYPE, \"ogg\");\n    public static final MediaType OOXML_DOCUMENT =\n        createConstant(\n            APPLICATION_TYPE, \"vnd.openxmlformats-officedocument.wordprocessingml.document\");\n    public static final MediaType OOXML_PRESENTATION =\n        createConstant(\n            APPLICATION_TYPE, \"vnd.openxmlformats-officedocument.presentationml.presentation\");\n    public static final MediaType OOXML_SHEET =\n        createConstant(APPLICATION_TYPE, \"vnd.openxmlformats-officedocument.spreadsheetml.sheet\");\n    public static final MediaType OPENDOCUMENT_GRAPHICS =\n        createConstant(APPLICATION_TYPE, \"vnd.oasis.opendocument.graphics\");\n    public static final MediaType OPENDOCUMENT_PRESENTATION =\n        createConstant(APPLICATION_TYPE, \"vnd.oasis.opendocument.presentation\");\n    public static final MediaType OPENDOCUMENT_SPREADSHEET =\n        createConstant(APPLICATION_TYPE, \"vnd.oasis.opendocument.spreadsheet\");\n    public static final MediaType OPENDOCUMENT_TEXT =\n        createConstant(APPLICATION_TYPE, \"vnd.oasis.opendocument.text\");\n    public static final MediaType PDF = createConstant(APPLICATION_TYPE, \"pdf\");\n    public static final MediaType POSTSCRIPT = createConstant(APPLICATION_TYPE, \"postscript\");\n\n    /**\n     * <a href=\"http://tools.ietf.org/html/draft-rfernando-protocol-buffers-00\">Protocol buffers</a>\n     *\n     * @since 15.0\n     */\n    public static final MediaType PROTOBUF = createConstant(APPLICATION_TYPE, \"protobuf\");\n\n    /**\n     * <a href=\"https://en.wikipedia.org/wiki/RDF/XML\">RDF/XML</a> documents, which are XML\n     * serializations of <a\n     * href=\"https://en.wikipedia.org/wiki/Resource_Description_Framework\">Resource Description\n     * Framework</a> graphs.\n     *\n     * @since 14.0\n     */\n    public static final MediaType RDF_XML_UTF_8 = createConstantUtf8(APPLICATION_TYPE, \"rdf+xml\");\n\n    public static final MediaType RTF_UTF_8 = createConstantUtf8(APPLICATION_TYPE, \"rtf\");\n\n    /**\n     * SFNT fonts (which includes <a href=\"http://en.wikipedia.org/wiki/TrueType/\">TrueType</a> and <a\n     * href=\"http://en.wikipedia.org/wiki/OpenType/\">OpenType</a> fonts). This is <a\n     * href=\"http://www.iana.org/assignments/media-types/application/font-sfnt\">registered</a> with\n     * the IANA.\n     *\n     * @since 17.0\n     */\n    public static final MediaType SFNT = createConstant(APPLICATION_TYPE, \"font-sfnt\");\n\n    public static final MediaType SHOCKWAVE_FLASH =\n        createConstant(APPLICATION_TYPE, \"x-shockwave-flash\");\n\n    /**\n     * {@code skp} files produced by the 3D Modeling software <a\n     * href=\"https://www.sketchup.com/\">SketchUp</a>\n     *\n     * @since 13.0\n     */\n    public static final MediaType SKETCHUP = createConstant(APPLICATION_TYPE, \"vnd.sketchup.skp\");\n\n    /**\n     * As described in <a href=\"http://www.ietf.org/rfc/rfc3902.txt\">RFC 3902</a>, this constant\n     * ({@code application/soap+xml}) is used to identify SOAP 1.2 message envelopes that have been\n     * serialized with XML 1.0.\n     *\n     * <p>For SOAP 1.1 messages, see {@code XML_UTF_8} per <a\n     * href=\"http://www.w3.org/TR/2000/NOTE-SOAP-20000508/\">W3C Note on Simple Object Access Protocol\n     * (SOAP) 1.1</a>\n     *\n     * @since 20.0\n     */\n    public static final MediaType SOAP_XML_UTF_8 = createConstantUtf8(APPLICATION_TYPE, \"soap+xml\");\n\n    public static final MediaType TAR = createConstant(APPLICATION_TYPE, \"x-tar\");\n\n    /**\n     * <a href=\"http://en.wikipedia.org/wiki/Web_Open_Font_Format\">Web Open Font Format</a> (WOFF) <a\n     * href=\"http://www.w3.org/TR/WOFF/\">defined</a> by the W3C. This is <a\n     * href=\"http://www.iana.org/assignments/media-types/application/font-woff\">registered</a> with\n     * the IANA.\n     *\n     * @since 17.0\n     */\n    public static final MediaType WOFF = createConstant(APPLICATION_TYPE, \"font-woff\");\n\n    /**\n     * <a href=\"http://en.wikipedia.org/wiki/Web_Open_Font_Format\">Web Open Font Format</a> (WOFF)\n     * version 2 <a href=\"https://www.w3.org/TR/WOFF2/\">defined</a> by the W3C.\n     *\n     * @since 20.0\n     */\n    public static final MediaType WOFF2 = createConstant(APPLICATION_TYPE, \"font-woff2\");\n\n    public static final MediaType XHTML_UTF_8 = createConstantUtf8(APPLICATION_TYPE, \"xhtml+xml\");\n\n    /**\n     * Extensible Resource Descriptors. This is not yet registered with the IANA, but it is specified\n     * by OASIS in the <a href=\"http://docs.oasis-open.org/xri/xrd/v1.0/cd02/xrd-1.0-cd02.html\">XRD\n     * definition</a> and implemented in projects such as <a\n     * href=\"http://code.google.com/p/webfinger/\">WebFinger</a>.\n     *\n     * @since 14.0\n     */\n    public static final MediaType XRD_UTF_8 = createConstantUtf8(APPLICATION_TYPE, \"xrd+xml\");\n\n    public static final MediaType ZIP = createConstant(APPLICATION_TYPE, \"zip\");\n\n    private final String type;\n    private final String subtype;\n    private final ImmutableListMultimap<String, String> parameters;\n\n    @LazyInit private String toString;\n\n    @LazyInit private int hashCode;\n\n    @LazyInit private Optional<Charset> parsedCharset;\n\n    private MediaType(String type, String subtype, ImmutableListMultimap<String, String> parameters)\n    {\n        this.type = type;\n        this.subtype = subtype;\n        this.parameters = parameters;\n    }\n\n    /** Returns the top-level media type. For example, {@code \"text\"} in {@code \"text/plain\"}. */\n    public String type()\n    {\n        return type;\n    }\n\n    /** Returns the media subtype. For example, {@code \"plain\"} in {@code \"text/plain\"}. */\n    public String subtype()\n    {\n        return subtype;\n    }\n\n    /** Returns a multimap containing the parameters of this media type. */\n    public ImmutableListMultimap<String, String> parameters()\n    {\n        return parameters;\n    }\n\n    private Map<String, ImmutableMultiset<String>> parametersAsMap()\n    {\n        return Maps.transformValues(\n                   parameters.asMap(),\n                   new Function<Collection<String>, ImmutableMultiset<String>>()\n        {\n            @Override\n            public ImmutableMultiset<String> apply(Collection<String> input)\n            {\n                return ImmutableMultiset.copyOf(input);\n            }\n        });\n    }\n\n    /**\n     * Returns an optional charset for the value of the charset parameter if it is specified.\n     *\n     * @throws IllegalStateException if multiple charset values have been set for this media type\n     * @throws IllegalCharsetNameException if a charset value is present, but illegal\n     * @throws UnsupportedCharsetException if a charset value is present, but no support is available\n     *     in this instance of the Java virtual machine\n     */\n    public Optional<Charset> charset()\n    {\n        // racy single-check idiom, this is safe because Optional is immutable.\n        Optional<Charset> local = parsedCharset;\n        if (local == null)\n        {\n            String value = null;\n            local = Optional.absent();\n            for (String currentValue : parameters.get(CHARSET_ATTRIBUTE))\n            {\n                if (value == null)\n                {\n                    value = currentValue;\n                    local = Optional.of(Charset.forName(value));\n                }\n                else if (!value.equals(currentValue))\n                {\n                    throw new IllegalStateException(\n                        \"Multiple charset values defined: \" + value + \", \" + currentValue);\n                }\n            }\n            parsedCharset = local;\n        }\n        return local;\n    }\n\n    /**\n     * Returns a new instance with the same type and subtype as this instance, but without any\n     * parameters.\n     */\n    public MediaType withoutParameters()\n    {\n        return parameters.isEmpty() ? this : create(type, subtype);\n    }\n\n    /**\n     * <em>Replaces</em> all parameters with the given parameters.\n     *\n     * @throws IllegalArgumentException if any parameter or value is invalid\n     */\n    public MediaType withParameters(Multimap<String, String> parameters)\n    {\n        return create(type, subtype, parameters);\n    }\n\n    /**\n     * <em>Replaces</em> all parameters with the given attribute with parameters using the given\n     * values. If there are no values, any existing parameters with the given attribute are removed.\n     *\n     * @throws IllegalArgumentException if either {@code attribute} or {@code values} is invalid\n     * @since 24.0\n     */\n    public MediaType withParameters(String attribute, Iterable<String> values)\n    {\n        checkNotNull(attribute);\n        checkNotNull(values);\n        String normalizedAttribute = normalizeToken(attribute);\n        ImmutableListMultimap.Builder<String, String> builder = ImmutableListMultimap.builder();\n        for (Entry<String, String> entry : parameters.entries())\n        {\n            String key = entry.getKey();\n            if (!normalizedAttribute.equals(key))\n            {\n                builder.put(key, entry.getValue());\n            }\n        }\n        for (String value : values)\n        {\n            builder.put(normalizedAttribute, normalizeParameterValue(normalizedAttribute, value));\n        }\n        MediaType mediaType = new MediaType(type, subtype, builder.build());\n        // if the attribute isn't charset, we can just inherit the current parsedCharset\n        if (!normalizedAttribute.equals(CHARSET_ATTRIBUTE))\n        {\n            mediaType.parsedCharset = this.parsedCharset;\n        }\n        // Return one of the constants if the media type is a known type.\n        return MoreObjects.firstNonNull(KNOWN_TYPES.get(mediaType), mediaType);\n    }\n\n    /**\n     * <em>Replaces</em> all parameters with the given attribute with a single parameter with the\n     * given value. If multiple parameters with the same attributes are necessary use {@link\n     * #withParameters(String, Iterable)}. Prefer {@link #withCharset} for setting the {@code charset}\n     * parameter when using a {@link Charset} object.\n     *\n     * @throws IllegalArgumentException if either {@code attribute} or {@code value} is invalid\n     */\n    public MediaType withParameter(String attribute, String value)\n    {\n        return withParameters(attribute, ImmutableSet.of(value));\n    }\n\n    /**\n     * Returns a new instance with the same type and subtype as this instance, with the {@code\n     * charset} parameter set to the {@link Charset#name name} of the given charset. Only one {@code\n     * charset} parameter will be present on the new instance regardless of the number set on this\n     * one.\n     *\n     * <p>If a charset must be specified that is not supported on this JVM (and thus is not\n     * representable as a {@link Charset} instance, use {@link #withParameter}.\n     */\n    public MediaType withCharset(Charset charset)\n    {\n        checkNotNull(charset);\n        MediaType withCharset = withParameter(CHARSET_ATTRIBUTE, charset.name());\n        // precache the charset so we don't need to parse it\n        withCharset.parsedCharset = Optional.of(charset);\n        return withCharset;\n    }\n\n    /** Returns true if either the type or subtype is the wildcard. */\n    public boolean hasWildcard()\n    {\n        return WILDCARD.equals(type) || WILDCARD.equals(subtype);\n    }\n\n    /**\n     * Returns {@code true} if this instance falls within the range (as defined by <a\n     * href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\">the HTTP Accept header</a>) given\n     * by the argument according to three criteria:\n     *\n     * <ol>\n     *   <li>The type of the argument is the wildcard or equal to the type of this instance.\n     *   <li>The subtype of the argument is the wildcard or equal to the subtype of this instance.\n     *   <li>All of the parameters present in the argument are present in this instance.\n     * </ol>\n     *\n     * <p>For example:\n     *\n     * <pre>{@code\n     * PLAIN_TEXT_UTF_8.is(PLAIN_TEXT_UTF_8) // true\n     * PLAIN_TEXT_UTF_8.is(HTML_UTF_8) // false\n     * PLAIN_TEXT_UTF_8.is(ANY_TYPE) // true\n     * PLAIN_TEXT_UTF_8.is(ANY_TEXT_TYPE) // true\n     * PLAIN_TEXT_UTF_8.is(ANY_IMAGE_TYPE) // false\n     * PLAIN_TEXT_UTF_8.is(ANY_TEXT_TYPE.withCharset(UTF_8)) // true\n     * PLAIN_TEXT_UTF_8.withoutParameters().is(ANY_TEXT_TYPE.withCharset(UTF_8)) // false\n     * PLAIN_TEXT_UTF_8.is(ANY_TEXT_TYPE.withCharset(UTF_16)) // false\n     * }</pre>\n     *\n     * <p>Note that while it is possible to have the same parameter declared multiple times within a\n     * media type this method does not consider the number of occurrences of a parameter. For example,\n     * {@code \"text/plain; charset=UTF-8\"} satisfies {@code \"text/plain; charset=UTF-8;\n     * charset=UTF-8\"}.\n     */\n    public boolean is(MediaType mediaTypeRange)\n    {\n        return (mediaTypeRange.type.equals(WILDCARD) || mediaTypeRange.type.equals(this.type))\n               && (mediaTypeRange.subtype.equals(WILDCARD) || mediaTypeRange.subtype.equals(this.subtype))\n               && this.parameters.entries().containsAll(mediaTypeRange.parameters.entries());\n    }\n\n    /**\n     * Creates a new media type with the given type and subtype.\n     *\n     * @throws IllegalArgumentException if type or subtype is invalid or if a wildcard is used for the\n     *     type, but not the subtype.\n     */\n\n    private static MediaType create(\n        String type, String subtype, Multimap<String, String> parameters)\n    {\n        checkNotNull(type);\n        checkNotNull(subtype);\n        checkNotNull(parameters);\n        String normalizedType = normalizeToken(type);\n        String normalizedSubtype = normalizeToken(subtype);\n        checkArgument(\n            !WILDCARD.equals(normalizedType) || WILDCARD.equals(normalizedSubtype),\n            \"A wildcard type cannot be used with a non-wildcard subtype\");\n        ImmutableListMultimap.Builder<String, String> builder = ImmutableListMultimap.builder();\n        for (Entry<String, String> entry : parameters.entries())\n        {\n            String attribute = normalizeToken(entry.getKey());\n            builder.put(attribute, normalizeParameterValue(attribute, entry.getValue()));\n        }\n        MediaType mediaType = new MediaType(normalizedType, normalizedSubtype, builder.build());\n        // Return one of the constants if the media type is a known type.\n        return MoreObjects.firstNonNull(KNOWN_TYPES.get(mediaType), mediaType);\n    }\n\n    /**\n     * Creates a media type with the \"application\" type and the given subtype.\n     *\n     * @throws IllegalArgumentException if subtype is invalid\n     */\n    static MediaType createApplicationType(String subtype)\n    {\n        return create(APPLICATION_TYPE, subtype);\n    }\n\n    /**\n     * Creates a media type with the \"audio\" type and the given subtype.\n     *\n     * @throws IllegalArgumentException if subtype is invalid\n     */\n    static MediaType createAudioType(String subtype)\n    {\n        return create(AUDIO_TYPE, subtype);\n    }\n\n    /**\n     * Creates a media type with the \"image\" type and the given subtype.\n     *\n     * @throws IllegalArgumentException if subtype is invalid\n     */\n    static MediaType createImageType(String subtype)\n    {\n        return create(IMAGE_TYPE, subtype);\n    }\n\n    /**\n     * Creates a media type with the \"text\" type and the given subtype.\n     *\n     * @throws IllegalArgumentException if subtype is invalid\n     */\n    static MediaType createTextType(String subtype)\n    {\n        return create(TEXT_TYPE, subtype);\n    }\n\n    /**\n     * Creates a media type with the \"video\" type and the given subtype.\n     *\n     * @throws IllegalArgumentException if subtype is invalid\n     */\n    static MediaType createVideoType(String subtype)\n    {\n        return create(VIDEO_TYPE, subtype);\n    }\n\n    private static String normalizeToken(String token)\n    {\n        checkArgument(TOKEN_MATCHER.matchesAllOf(token));\n        return Ascii.toLowerCase(token);\n    }\n\n    private static String normalizeParameterValue(String attribute, String value)\n    {\n        return CHARSET_ATTRIBUTE.equals(attribute) ? Ascii.toLowerCase(value) : value;\n    }\n\n    /**\n     * Parses a media type from its string representation.\n     *\n     * @throws IllegalArgumentException if the input is not parsable\n     */\n    public static MediaType parse(String input)\n    {\n        checkNotNull(input);\n        Tokenizer tokenizer = new Tokenizer(input);\n        try\n        {\n            String type = tokenizer.consumeToken(TOKEN_MATCHER);\n            tokenizer.consumeCharacter('/');\n            String subtype = tokenizer.consumeToken(TOKEN_MATCHER);\n            ImmutableListMultimap.Builder<String, String> parameters = ImmutableListMultimap.builder();\n            while (tokenizer.hasMore())\n            {\n                tokenizer.consumeTokenIfPresent(LINEAR_WHITE_SPACE);\n                tokenizer.consumeCharacter(';');\n                tokenizer.consumeTokenIfPresent(LINEAR_WHITE_SPACE);\n                String attribute = tokenizer.consumeToken(TOKEN_MATCHER);\n                tokenizer.consumeCharacter('=');\n                final String value;\n                if ('\"' == tokenizer.previewChar())\n                {\n                    tokenizer.consumeCharacter('\"');\n                    StringBuilder valueBuilder = new StringBuilder();\n                    while ('\"' != tokenizer.previewChar())\n                    {\n                        if ('\\\\' == tokenizer.previewChar())\n                        {\n                            tokenizer.consumeCharacter('\\\\');\n                            valueBuilder.append(tokenizer.consumeCharacter(ascii()));\n                        }\n                        else\n                        {\n                            valueBuilder.append(tokenizer.consumeToken(QUOTED_TEXT_MATCHER));\n                        }\n                    }\n                    value = valueBuilder.toString();\n                    tokenizer.consumeCharacter('\"');\n                }\n                else\n                {\n                    value = tokenizer.consumeToken(TOKEN_MATCHER);\n                }\n                parameters.put(attribute, value);\n            }\n            return create(type, subtype, parameters.build());\n        }\n        catch (IllegalStateException e)\n        {\n            throw new IllegalArgumentException(\"Could not parse '\" + input + \"'\", e);\n        }\n    }\n\n    private static final class Tokenizer\n    {\n        final String input;\n        int position = 0;\n\n        Tokenizer(String input)\n        {\n            this.input = input;\n        }\n\n        String consumeTokenIfPresent(CharMatcher matcher)\n        {\n            checkState(hasMore());\n            int startPosition = position;\n            position = matcher.negate().indexIn(input, startPosition);\n            return hasMore() ? input.substring(startPosition, position) : input.substring(startPosition);\n        }\n\n        String consumeToken(CharMatcher matcher)\n        {\n            int startPosition = position;\n            String token = consumeTokenIfPresent(matcher);\n            checkState(position != startPosition);\n            return token;\n        }\n\n        char consumeCharacter(CharMatcher matcher)\n        {\n            checkState(hasMore());\n            char c = previewChar();\n            checkState(matcher.matches(c));\n            position++;\n            return c;\n        }\n\n        char consumeCharacter(char c)\n        {\n            checkState(hasMore());\n            checkState(previewChar() == c);\n            position++;\n            return c;\n        }\n\n        char previewChar()\n        {\n            checkState(hasMore());\n            return input.charAt(position);\n        }\n\n        boolean hasMore()\n        {\n            return (position >= 0) && (position < input.length());\n        }\n    }\n\n    @Override\n    public boolean equals(@Nullable Object obj)\n    {\n        if (obj == this)\n        {\n            return true;\n        }\n        else if (obj instanceof MediaType)\n        {\n            MediaType that = (MediaType) obj;\n            return this.type.equals(that.type)\n                   && this.subtype.equals(that.subtype)\n                   // compare parameters regardless of order\n                   && this.parametersAsMap().equals(that.parametersAsMap());\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n    @Override\n    public int hashCode()\n    {\n        // racy single-check idiom\n        int h = hashCode;\n        if (h == 0)\n        {\n            h = Objects.hashCode(type, subtype, parametersAsMap());\n            hashCode = h;\n        }\n        return h;\n    }\n\n    private static final MapJoiner PARAMETER_JOINER = Joiner.on(\"; \").withKeyValueSeparator(\"=\");\n\n    /**\n     * Returns the string representation of this media type in the format described in <a\n     * href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>.\n     */\n    @Override\n    public String toString()\n    {\n        // racy single-check idiom, safe because String is immutable\n        String result = toString;\n        if (result == null)\n        {\n            result = computeToString();\n            toString = result;\n        }\n        return result;\n    }\n\n    private String computeToString()\n    {\n        StringBuilder builder = new StringBuilder().append(type).append('/').append(subtype);\n        if (!parameters.isEmpty())\n        {\n            builder.append(\"; \");\n            Multimap<String, String> quotedParameters =\n                Multimaps.transformValues(\n                    parameters,\n                    new Function<String, String>()\n            {\n                @Override\n                public String apply(String value)\n                {\n                    return TOKEN_MATCHER.matchesAllOf(value) ? value : escapeAndQuote(value);\n                }\n            });\n            PARAMETER_JOINER.appendTo(builder, quotedParameters.entries());\n        }\n        return builder.toString();\n    }\n\n    private static String escapeAndQuote(String value)\n    {\n        StringBuilder escaped = new StringBuilder(value.length() + 16).append('\"');\n        for (int i = 0; i < value.length(); i++)\n        {\n            char ch = value.charAt(i);\n            if (ch == '\\r' || ch == '\\\\' || ch == '\"')\n            {\n                escaped.append('\\\\');\n            }\n            escaped.append(ch);\n        }\n        return escaped.append('\"').toString();\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/net/MediaType.java", "func_name": "MediaType.parse", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Parses a media type from its string representation.\n\n@throws IllegalArgumentException if the input is not parsable", "docstring_tokens": ["Parses", "a", "media", "type", "from", "its", "string", "representation", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/net/MediaType.java#L930-L967", "partition": "valid", "up_fun_num": 26, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.CharMatcher.ascii;", "import static com.google.common.base.CharMatcher.javaIsoControl;", "import static com.google.common.base.Charsets.UTF_8;", "import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.base.Preconditions.checkState;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.base.Ascii;", "import com.google.common.base.CharMatcher;", "import com.google.common.base.Function;", "import com.google.common.base.Joiner;", "import com.google.common.base.Joiner.MapJoiner;", "import com.google.common.base.MoreObjects;", "import com.google.common.base.Objects;", "import com.google.common.base.Optional;", "import com.google.common.collect.ImmutableListMultimap;", "import com.google.common.collect.ImmutableMultiset;", "import com.google.common.collect.ImmutableSet;", "import com.google.common.collect.Maps;", "import com.google.common.collect.Multimap;", "import com.google.common.collect.Multimaps;", "import com.google.errorprone.annotations.Immutable;", "import com.google.errorprone.annotations.concurrent.LazyInit;", "import java.nio.charset.Charset;", "import java.nio.charset.IllegalCharsetNameException;", "import java.nio.charset.UnsupportedCharsetException;", "import java.util.Collection;", "import java.util.Map;", "import java.util.Map.Entry;", "import org.checkerframework.checker.nullness.qual.Nullable;"], "function": ["public final class MediaType\n", "    private static MediaType createConstant(String type, String subtype)\n", "    private static MediaType createConstantUtf8(String type, String subtype)\n", "    private static MediaType addKnownType(MediaType mediaType)\n", "    public String type()\n", "    public String subtype()\n", "    public ImmutableListMultimap<String, String> parameters()\n", "    private Map<String, ImmutableMultiset<String>> parametersAsMap()\n", "    public Optional<Charset> charset()\n", "    public MediaType withoutParameters()\n", "    public MediaType withParameters(Multimap<String, String> parameters)\n", "    public MediaType withParameters(String attribute, Iterable<String> values)\n", "    public MediaType withParameter(String attribute, String value)\n", "    public MediaType withCharset(Charset charset)\n", "    public boolean hasWildcard()\n", "    public boolean is(MediaType mediaTypeRange)\n", "    public static MediaType create(String type, String subtype)\n", "    private static MediaType create(\n", "    static MediaType createApplicationType(String subtype)\n", "    static MediaType createAudioType(String subtype)\n", "    static MediaType createImageType(String subtype)\n", "    static MediaType createTextType(String subtype)\n", "    static MediaType createVideoType(String subtype)\n", "    private static String normalizeToken(String token)\n", "    private static String normalizeParameterValue(String attribute, String value)\n", "    public boolean equals(@Nullable Object obj)\n", "    public int hashCode()\n", "    public String toString()\n", "    private String computeToString()\n", "    private static String escapeAndQuote(String value)\n"], "context": "/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.net;\n\nimport static com.google.common.base.CharMatcher.ascii;\nimport static com.google.common.base.CharMatcher.javaIsoControl;\nimport static com.google.common.base.Charsets.UTF_8;\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.base.Ascii;\nimport com.google.common.base.CharMatcher;\nimport com.google.common.base.Function;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Joiner.MapJoiner;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Objects;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.common.collect.ImmutableMultiset;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Multimap;\nimport com.google.common.collect.Multimaps;\nimport com.google.errorprone.annotations.Immutable;\nimport com.google.errorprone.annotations.concurrent.LazyInit;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\n/**\n * Represents an <a href=\"http://en.wikipedia.org/wiki/Internet_media_type\">Internet Media Type</a>\n * (also known as a MIME Type or Content Type). This class also supports the concept of media ranges\n * <a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1\">defined by HTTP/1.1</a>.\n * As such, the {@code *} character is treated as a wildcard and is used to represent any acceptable\n * type or subtype value. A media type may not have wildcard type with a declared subtype. The\n * {@code *} character has no special meaning as part of a parameter. All values for type, subtype,\n * parameter attributes or parameter values must be valid according to RFCs <a\n * href=\"http://www.ietf.org/rfc/rfc2045.txt\">2045</a> and <a\n * href=\"http://www.ietf.org/rfc/rfc2046.txt\">2046</a>.\n *\n * <p>All portions of the media type that are case-insensitive (type, subtype, parameter attributes)\n * are normalized to lowercase. The value of the {@code charset} parameter is normalized to\n * lowercase, but all others are left as-is.\n *\n * <p>Note that this specifically does <strong>not</strong> represent the value of the MIME {@code\n * Content-Type} header and as such has no support for header-specific considerations such as line\n * folding and comments.\n *\n * <p>For media types that take a charset the predefined constants default to UTF-8 and have a\n * \"_UTF_8\" suffix. To get a version without a character set, use {@link #withoutParameters}.\n *\n * @since 12.0\n * @author Gregory Kick\n */\n@Beta\n@GwtCompatible\n@Immutable\npublic final class MediaType\n{\n    private static final String CHARSET_ATTRIBUTE = \"charset\";\n    private static final ImmutableListMultimap<String, String> UTF_8_CONSTANT_PARAMETERS =\n        ImmutableListMultimap.of(CHARSET_ATTRIBUTE, Ascii.toLowerCase(UTF_8.name()));\n\n    /** Matcher for type, subtype and attributes. */\n    private static final CharMatcher TOKEN_MATCHER =\n        ascii()\n        .and(javaIsoControl().negate())\n        .and(CharMatcher.isNot(' '))\n        .and(CharMatcher.noneOf(\"()<>@,;:\\\\\\\"/[]?=\"));\n\n    private static final CharMatcher QUOTED_TEXT_MATCHER = ascii().and(CharMatcher.noneOf(\"\\\"\\\\\\r\"));\n\n    /*\n     * This matches the same characters as linear-white-space from RFC 822, but we make no effort to\n     * enforce any particular rules with regards to line folding as stated in the class docs.\n     */\n    private static final CharMatcher LINEAR_WHITE_SPACE = CharMatcher.anyOf(\" \\t\\r\\n\");\n\n    // TODO(gak): make these public?\n    private static final String APPLICATION_TYPE = \"application\";\n    private static final String AUDIO_TYPE = \"audio\";\n    private static final String IMAGE_TYPE = \"image\";\n    private static final String TEXT_TYPE = \"text\";\n    private static final String VIDEO_TYPE = \"video\";\n\n    private static final String WILDCARD = \"*\";\n\n    private static final Map<MediaType, MediaType> KNOWN_TYPES = Maps.newHashMap();\n\n    private static MediaType createConstant(String type, String subtype)\n    {\n        MediaType mediaType =\n            addKnownType(new MediaType(type, subtype, ImmutableListMultimap.<String, String>of()));\n        mediaType.parsedCharset = Optional.absent();\n        return mediaType;\n    }\n\n    private static MediaType createConstantUtf8(String type, String subtype)\n    {\n        MediaType mediaType = addKnownType(new MediaType(type, subtype, UTF_8_CONSTANT_PARAMETERS));\n        mediaType.parsedCharset = Optional.of(UTF_8);\n        return mediaType;\n    }\n\n    private static MediaType addKnownType(MediaType mediaType)\n    {\n        KNOWN_TYPES.put(mediaType, mediaType);\n        return mediaType;\n    }\n\n    /*\n     * The following constants are grouped by their type and ordered alphabetically by the constant\n     * name within that type. The constant name should be a sensible identifier that is closest to the\n     * \"common name\" of the media. This is often, but not necessarily the same as the subtype.\n     *\n     * Be sure to declare all constants with the type and subtype in all lowercase. For types that\n     * take a charset (e.g. all text/* types), default to UTF-8 and suffix the constant name with\n     * \"_UTF_8\".\n     */\n\n    public static final MediaType ANY_TYPE = createConstant(WILDCARD, WILDCARD);\n    public static final MediaType ANY_TEXT_TYPE = createConstant(TEXT_TYPE, WILDCARD);\n    public static final MediaType ANY_IMAGE_TYPE = createConstant(IMAGE_TYPE, WILDCARD);\n    public static final MediaType ANY_AUDIO_TYPE = createConstant(AUDIO_TYPE, WILDCARD);\n    public static final MediaType ANY_VIDEO_TYPE = createConstant(VIDEO_TYPE, WILDCARD);\n    public static final MediaType ANY_APPLICATION_TYPE = createConstant(APPLICATION_TYPE, WILDCARD);\n\n    /* text types */\n    public static final MediaType CACHE_MANIFEST_UTF_8 =\n        createConstantUtf8(TEXT_TYPE, \"cache-manifest\");\n    public static final MediaType CSS_UTF_8 = createConstantUtf8(TEXT_TYPE, \"css\");\n    public static final MediaType CSV_UTF_8 = createConstantUtf8(TEXT_TYPE, \"csv\");\n    public static final MediaType HTML_UTF_8 = createConstantUtf8(TEXT_TYPE, \"html\");\n    public static final MediaType I_CALENDAR_UTF_8 = createConstantUtf8(TEXT_TYPE, \"calendar\");\n    public static final MediaType PLAIN_TEXT_UTF_8 = createConstantUtf8(TEXT_TYPE, \"plain\");\n\n    /**\n     * <a href=\"http://www.rfc-editor.org/rfc/rfc4329.txt\">RFC 4329</a> declares {@link\n     * #JAVASCRIPT_UTF_8 application/javascript} to be the correct media type for JavaScript, but this\n     * may be necessary in certain situations for compatibility.\n     */\n    public static final MediaType TEXT_JAVASCRIPT_UTF_8 = createConstantUtf8(TEXT_TYPE, \"javascript\");\n    /**\n     * <a href=\"http://www.iana.org/assignments/media-types/text/tab-separated-values\">Tab separated\n     * values</a>.\n     *\n     * @since 15.0\n     */\n    public static final MediaType TSV_UTF_8 = createConstantUtf8(TEXT_TYPE, \"tab-separated-values\");\n\n    public static final MediaType VCARD_UTF_8 = createConstantUtf8(TEXT_TYPE, \"vcard\");\n\n    /**\n     * UTF-8 encoded <a href=\"https://en.wikipedia.org/wiki/Wireless_Markup_Language\">Wireless Markup\n     * Language</a>.\n     *\n     * @since 13.0\n     */\n    public static final MediaType WML_UTF_8 = createConstantUtf8(TEXT_TYPE, \"vnd.wap.wml\");\n\n    /**\n     * As described in <a href=\"http://www.ietf.org/rfc/rfc3023.txt\">RFC 3023</a>, this constant\n     * ({@code text/xml}) is used for XML documents that are \"readable by casual users.\" {@link\n     * #APPLICATION_XML_UTF_8} is provided for documents that are intended for applications.\n     */\n    public static final MediaType XML_UTF_8 = createConstantUtf8(TEXT_TYPE, \"xml\");\n\n    /**\n     * As described in <a href=\"https://w3c.github.io/webvtt/#iana-text-vtt\">the VTT spec</a>, this is\n     * used for Web Video Text Tracks (WebVTT) files, used with the HTML5 track element.\n     *\n     * @since 20.0\n     */\n    public static final MediaType VTT_UTF_8 = createConstantUtf8(TEXT_TYPE, \"vtt\");\n\n    /**\n     * <a href=\"https://en.wikipedia.org/wiki/BMP_file_format\">Bitmap file format</a> ({@code bmp}\n     * files).\n     *\n     * @since 13.0\n     */\n    public static final MediaType BMP = createConstant(IMAGE_TYPE, \"bmp\");\n\n    /**\n     * The <a href=\"https://en.wikipedia.org/wiki/Camera_Image_File_Format\">Canon Image File\n     * Format</a> ({@code crw} files), a widely-used \"raw image\" format for cameras. It is found in\n     * {@code /etc/mime.types}, e.g. in <a href=\n     * \"http://anonscm.debian.org/gitweb/?p=collab-maint/mime-support.git;a=blob;f=mime.types;hb=HEAD\"\n     * >Debian 3.48-1</a>.\n     *\n     * @since 15.0\n     */\n    public static final MediaType CRW = createConstant(IMAGE_TYPE, \"x-canon-crw\");\n\n    public static final MediaType GIF = createConstant(IMAGE_TYPE, \"gif\");\n    public static final MediaType ICO = createConstant(IMAGE_TYPE, \"vnd.microsoft.icon\");\n    public static final MediaType JPEG = createConstant(IMAGE_TYPE, \"jpeg\");\n    public static final MediaType PNG = createConstant(IMAGE_TYPE, \"png\");\n\n    /**\n     * The Photoshop File Format ({@code psd} files) as defined by <a\n     * href=\"http://www.iana.org/assignments/media-types/image/vnd.adobe.photoshop\">IANA</a>, and\n     * found in {@code /etc/mime.types}, e.g. <a\n     * href=\"http://svn.apache.org/repos/asf/httpd/httpd/branches/1.3.x/conf/mime.types\"></a> of the\n     * Apache <a href=\"http://httpd.apache.org/\">HTTPD project</a>; for the specification, see <a\n     * href=\"http://www.adobe.com/devnet-apps/photoshop/fileformatashtml/PhotoshopFileFormats.htm\">\n     * Adobe Photoshop Document Format</a> and <a\n     * href=\"http://en.wikipedia.org/wiki/Adobe_Photoshop#File_format\">Wikipedia</a>; this is the\n     * regular output/input of Photoshop (which can also export to various image formats; note that\n     * files with extension \"PSB\" are in a distinct but related format).\n     *\n     * <p>This is a more recent replacement for the older, experimental type {@code x-photoshop}: <a\n     * href=\"http://tools.ietf.org/html/rfc2046#section-6\">RFC-2046.6</a>.\n     *\n     * @since 15.0\n     */\n    public static final MediaType PSD = createConstant(IMAGE_TYPE, \"vnd.adobe.photoshop\");\n\n    public static final MediaType SVG_UTF_8 = createConstantUtf8(IMAGE_TYPE, \"svg+xml\");\n    public static final MediaType TIFF = createConstant(IMAGE_TYPE, \"tiff\");\n\n    /**\n     * <a href=\"https://en.wikipedia.org/wiki/WebP\">WebP image format</a>.\n     *\n     * @since 13.0\n     */\n    public static final MediaType WEBP = createConstant(IMAGE_TYPE, \"webp\");\n\n    /* audio types */\n    public static final MediaType MP4_AUDIO = createConstant(AUDIO_TYPE, \"mp4\");\n    public static final MediaType MPEG_AUDIO = createConstant(AUDIO_TYPE, \"mpeg\");\n    public static final MediaType OGG_AUDIO = createConstant(AUDIO_TYPE, \"ogg\");\n    public static final MediaType WEBM_AUDIO = createConstant(AUDIO_TYPE, \"webm\");\n\n    /**\n     * L16 audio, as defined by <a href=\"https://tools.ietf.org/html/rfc2586\">RFC 2586</a>.\n     *\n     * @since 24.1\n     */\n    public static final MediaType L16_AUDIO = createConstant(AUDIO_TYPE, \"l16\");\n\n    /**\n     * L24 audio, as defined by <a href=\"https://tools.ietf.org/html/rfc3190\">RFC 3190</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType L24_AUDIO = createConstant(AUDIO_TYPE, \"l24\");\n\n    /**\n     * Basic Audio, as defined by <a href=\"http://tools.ietf.org/html/rfc2046#section-4.3\">RFC\n     * 2046</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType BASIC_AUDIO = createConstant(AUDIO_TYPE, \"basic\");\n\n    /**\n     * Advanced Audio Coding. For more information, see <a\n     * href=\"https://en.wikipedia.org/wiki/Advanced_Audio_Coding\">Advanced Audio Coding</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType AAC_AUDIO = createConstant(AUDIO_TYPE, \"aac\");\n\n    /**\n     * Vorbis Audio, as defined by <a href=\"http://tools.ietf.org/html/rfc5215\">RFC 5215</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType VORBIS_AUDIO = createConstant(AUDIO_TYPE, \"vorbis\");\n\n    /**\n     * Windows Media Audio. For more information, see <a\n     * href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/dd562994(v=vs.85).aspx\">file\n     * name extensions for Windows Media metafiles</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType WMA_AUDIO = createConstant(AUDIO_TYPE, \"x-ms-wma\");\n\n    /**\n     * Windows Media metafiles. For more information, see <a\n     * href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/dd562994(v=vs.85).aspx\">file\n     * name extensions for Windows Media metafiles</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType WAX_AUDIO = createConstant(AUDIO_TYPE, \"x-ms-wax\");\n\n    /**\n     * Real Audio. For more information, see <a\n     * href=\"http://service.real.com/help/faq/rp8/configrp8win.html\">this link</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType VND_REAL_AUDIO = createConstant(AUDIO_TYPE, \"vnd.rn-realaudio\");\n\n    /**\n     * WAVE format, as defined by <a href=\"https://tools.ietf.org/html/rfc2361\">RFC 2361</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType VND_WAVE_AUDIO = createConstant(AUDIO_TYPE, \"vnd.wave\");\n\n    /* video types */\n    public static final MediaType MP4_VIDEO = createConstant(VIDEO_TYPE, \"mp4\");\n    public static final MediaType MPEG_VIDEO = createConstant(VIDEO_TYPE, \"mpeg\");\n    public static final MediaType OGG_VIDEO = createConstant(VIDEO_TYPE, \"ogg\");\n    public static final MediaType QUICKTIME = createConstant(VIDEO_TYPE, \"quicktime\");\n    public static final MediaType WEBM_VIDEO = createConstant(VIDEO_TYPE, \"webm\");\n    public static final MediaType WMV = createConstant(VIDEO_TYPE, \"x-ms-wmv\");\n\n    /**\n     * Flash video. For more information, see <a href=\n     * \"http://help.adobe.com/en_US/ActionScript/3.0_ProgrammingAS3/WS5b3ccc516d4fbf351e63e3d118a9b90204-7d48.html\"\n     * >this link</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType FLV_VIDEO = createConstant(VIDEO_TYPE, \"x-flv\");\n\n    /**\n     * The 3GP multimedia container format. For more information, see <a\n     * href=\"ftp://www.3gpp.org/tsg_sa/TSG_SA/TSGS_23/Docs/PDF/SP-040065.pdf#page=10\">3GPP TS\n     * 26.244</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType THREE_GPP_VIDEO = createConstant(VIDEO_TYPE, \"3gpp\");\n\n    /**\n     * The 3G2 multimedia container format. For more information, see <a\n     * href=\"http://www.3gpp2.org/Public_html/specs/C.S0050-B_v1.0_070521.pdf#page=16\">3GPP2\n     * C.S0050-B</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType THREE_GPP2_VIDEO = createConstant(VIDEO_TYPE, \"3gpp2\");\n\n    /* application types */\n    /**\n     * As described in <a href=\"http://www.ietf.org/rfc/rfc3023.txt\">RFC 3023</a>, this constant\n     * ({@code application/xml}) is used for XML documents that are \"unreadable by casual users.\"\n     * {@link #XML_UTF_8} is provided for documents that may be read by users.\n     *\n     * @since 14.0\n     */\n    public static final MediaType APPLICATION_XML_UTF_8 = createConstantUtf8(APPLICATION_TYPE, \"xml\");\n\n    public static final MediaType ATOM_UTF_8 = createConstantUtf8(APPLICATION_TYPE, \"atom+xml\");\n    public static final MediaType BZIP2 = createConstant(APPLICATION_TYPE, \"x-bzip2\");\n\n    /**\n     * Files in the <a href=\"https://www.dartlang.org/articles/embedding-in-html/\">dart</a>\n     * programming language.\n     *\n     * @since 19.0\n     */\n    public static final MediaType DART_UTF_8 = createConstantUtf8(APPLICATION_TYPE, \"dart\");\n\n    /**\n     * <a href=\"https://goo.gl/2QoMvg\">Apple Passbook</a>.\n     *\n     * @since 19.0\n     */\n    public static final MediaType APPLE_PASSBOOK =\n        createConstant(APPLICATION_TYPE, \"vnd.apple.pkpass\");\n\n    /**\n     * <a href=\"http://en.wikipedia.org/wiki/Embedded_OpenType\">Embedded OpenType</a> fonts. This is\n     * <a href=\"http://www.iana.org/assignments/media-types/application/vnd.ms-fontobject\">registered\n     * </a> with the IANA.\n     *\n     * @since 17.0\n     */\n    public static final MediaType EOT = createConstant(APPLICATION_TYPE, \"vnd.ms-fontobject\");\n\n    /**\n     * As described in the <a href=\"http://idpf.org/epub\">International Digital Publishing Forum</a>\n     * EPUB is the distribution and interchange format standard for digital publications and\n     * documents. This media type is defined in the <a\n     * href=\"http://www.idpf.org/epub/30/spec/epub30-ocf.html\">EPUB Open Container Format</a>\n     * specification.\n     *\n     * @since 15.0\n     */\n    public static final MediaType EPUB = createConstant(APPLICATION_TYPE, \"epub+zip\");\n\n    public static final MediaType FORM_DATA =\n        createConstant(APPLICATION_TYPE, \"x-www-form-urlencoded\");\n\n    /**\n     * As described in <a href=\"https://www.rsa.com/rsalabs/node.asp?id=2138\">PKCS #12: Personal\n     * Information Exchange Syntax Standard</a>, PKCS #12 defines an archive file format for storing\n     * many cryptography objects as a single file.\n     *\n     * @since 15.0\n     */\n    public static final MediaType KEY_ARCHIVE = createConstant(APPLICATION_TYPE, \"pkcs12\");\n\n    /**\n     * This is a non-standard media type, but is commonly used in serving hosted binary files as it is\n     * <a href=\"http://code.google.com/p/browsersec/wiki/Part2#Survey_of_content_sniffing_behaviors\">\n     * known not to trigger content sniffing in current browsers</a>. It <i>should not</i> be used in\n     * other situations as it is not specified by any RFC and does not appear in the <a\n     * href=\"http://www.iana.org/assignments/media-types\">/IANA MIME Media Types</a> list. Consider\n     * {@link #OCTET_STREAM} for binary data that is not being served to a browser.\n     *\n     * @since 14.0\n     */\n    public static final MediaType APPLICATION_BINARY = createConstant(APPLICATION_TYPE, \"binary\");\n\n    public static final MediaType GZIP = createConstant(APPLICATION_TYPE, \"x-gzip\");\n\n    /**\n     * <a href=\"https://tools.ietf.org/html/draft-kelly-json-hal-08#section-3\">JSON Hypertext\n     * Application Language (HAL) documents</a>.\n     *\n     * @since 26.0\n     */\n    public static final MediaType HAL_JSON = createConstant(APPLICATION_TYPE, \"hal+json\");\n\n    /**\n     * <a href=\"http://www.rfc-editor.org/rfc/rfc4329.txt\">RFC 4329</a> declares this to be the\n     * correct media type for JavaScript, but {@link #TEXT_JAVASCRIPT_UTF_8 text/javascript} may be\n     * necessary in certain situations for compatibility.\n     */\n    public static final MediaType JAVASCRIPT_UTF_8 =\n        createConstantUtf8(APPLICATION_TYPE, \"javascript\");\n\n    /**\n     * For <a href=\"https://tools.ietf.org/html/rfc7515\">JWS or JWE objects using the Compact\n     * Serialization</a>.\n     *\n     * @since 27.1\n     */\n    public static final MediaType JOSE = createConstant(APPLICATION_TYPE, \"jose\");\n\n    /**\n     * For <a href=\"https://tools.ietf.org/html/rfc7515\">JWS or JWE objects using the JSON\n     * Serialization</a>.\n     *\n     * @since 27.1\n     */\n    public static final MediaType JOSE_JSON = createConstant(APPLICATION_TYPE, \"jose+json\");\n\n    public static final MediaType JSON_UTF_8 = createConstantUtf8(APPLICATION_TYPE, \"json\");\n\n    /**\n     * The <a href=\"http://www.w3.org/TR/appmanifest/\">Manifest for a web application</a>.\n     *\n     * @since 19.0\n     */\n    public static final MediaType MANIFEST_JSON_UTF_8 =\n        createConstantUtf8(APPLICATION_TYPE, \"manifest+json\");\n\n    /**\n     * <a href=\"http://www.opengeospatial.org/standards/kml/\">OGC KML (Keyhole Markup Language)</a>.\n     */\n    public static final MediaType KML = createConstant(APPLICATION_TYPE, \"vnd.google-earth.kml+xml\");\n\n    /**\n     * <a href=\"http://www.opengeospatial.org/standards/kml/\">OGC KML (Keyhole Markup Language)</a>,\n     * compressed using the ZIP format into KMZ archives.\n     */\n    public static final MediaType KMZ = createConstant(APPLICATION_TYPE, \"vnd.google-earth.kmz\");\n\n    /**\n     * The <a href=\"https://tools.ietf.org/html/rfc4155\">mbox database format</a>.\n     *\n     * @since 13.0\n     */\n    public static final MediaType MBOX = createConstant(APPLICATION_TYPE, \"mbox\");\n\n    /**\n     * <a href=\"http://goo.gl/1pGBFm\">Apple over-the-air mobile configuration profiles</a>.\n     *\n     * @since 18.0\n     */\n    public static final MediaType APPLE_MOBILE_CONFIG =\n        createConstant(APPLICATION_TYPE, \"x-apple-aspen-config\");\n\n    /** <a href=\"http://goo.gl/XDQ1h2\">Microsoft Excel</a> spreadsheets. */\n    public static final MediaType MICROSOFT_EXCEL = createConstant(APPLICATION_TYPE, \"vnd.ms-excel\");\n\n    /**\n     * <a href=\"http://goo.gl/XrTEqG\">Microsoft Outlook</a> items.\n     *\n     * @since 27.1\n     */\n    public static final MediaType MICROSOFT_OUTLOOK =\n        createConstant(APPLICATION_TYPE, \"vnd.ms-outlook\");\n\n    /** <a href=\"http://goo.gl/XDQ1h2\">Microsoft Powerpoint</a> presentations. */\n    public static final MediaType MICROSOFT_POWERPOINT =\n        createConstant(APPLICATION_TYPE, \"vnd.ms-powerpoint\");\n\n    /** <a href=\"http://goo.gl/XDQ1h2\">Microsoft Word</a> documents. */\n    public static final MediaType MICROSOFT_WORD = createConstant(APPLICATION_TYPE, \"msword\");\n\n    /**\n     * WASM applications. For more information see <a href=\"https://webassembly.org/\">the Web Assembly\n     * overview</a>.\n     *\n     * @since 27.0\n     */\n    public static final MediaType WASM_APPLICATION = createConstant(APPLICATION_TYPE, \"wasm\");\n\n    /**\n     * NaCl applications. For more information see <a\n     * href=\"https://developer.chrome.com/native-client/devguide/coding/application-structure\">the\n     * Developer Guide for Native Client Application Structure</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType NACL_APPLICATION = createConstant(APPLICATION_TYPE, \"x-nacl\");\n\n    /**\n     * NaCl portable applications. For more information see <a\n     * href=\"https://developer.chrome.com/native-client/devguide/coding/application-structure\">the\n     * Developer Guide for Native Client Application Structure</a>.\n     *\n     * @since 20.0\n     */\n    public static final MediaType NACL_PORTABLE_APPLICATION =\n        createConstant(APPLICATION_TYPE, \"x-pnacl\");\n\n    public static final MediaType OCTET_STREAM = createConstant(APPLICATION_TYPE, \"octet-stream\");\n\n    public static final MediaType OGG_CONTAINER = createConstant(APPLICATION_TYPE, \"ogg\");\n    public static final MediaType OOXML_DOCUMENT =\n        createConstant(\n            APPLICATION_TYPE, \"vnd.openxmlformats-officedocument.wordprocessingml.document\");\n    public static final MediaType OOXML_PRESENTATION =\n        createConstant(\n            APPLICATION_TYPE, \"vnd.openxmlformats-officedocument.presentationml.presentation\");\n    public static final MediaType OOXML_SHEET =\n        createConstant(APPLICATION_TYPE, \"vnd.openxmlformats-officedocument.spreadsheetml.sheet\");\n    public static final MediaType OPENDOCUMENT_GRAPHICS =\n        createConstant(APPLICATION_TYPE, \"vnd.oasis.opendocument.graphics\");\n    public static final MediaType OPENDOCUMENT_PRESENTATION =\n        createConstant(APPLICATION_TYPE, \"vnd.oasis.opendocument.presentation\");\n    public static final MediaType OPENDOCUMENT_SPREADSHEET =\n        createConstant(APPLICATION_TYPE, \"vnd.oasis.opendocument.spreadsheet\");\n    public static final MediaType OPENDOCUMENT_TEXT =\n        createConstant(APPLICATION_TYPE, \"vnd.oasis.opendocument.text\");\n    public static final MediaType PDF = createConstant(APPLICATION_TYPE, \"pdf\");\n    public static final MediaType POSTSCRIPT = createConstant(APPLICATION_TYPE, \"postscript\");\n\n    /**\n     * <a href=\"http://tools.ietf.org/html/draft-rfernando-protocol-buffers-00\">Protocol buffers</a>\n     *\n     * @since 15.0\n     */\n    public static final MediaType PROTOBUF = createConstant(APPLICATION_TYPE, \"protobuf\");\n\n    /**\n     * <a href=\"https://en.wikipedia.org/wiki/RDF/XML\">RDF/XML</a> documents, which are XML\n     * serializations of <a\n     * href=\"https://en.wikipedia.org/wiki/Resource_Description_Framework\">Resource Description\n     * Framework</a> graphs.\n     *\n     * @since 14.0\n     */\n    public static final MediaType RDF_XML_UTF_8 = createConstantUtf8(APPLICATION_TYPE, \"rdf+xml\");\n\n    public static final MediaType RTF_UTF_8 = createConstantUtf8(APPLICATION_TYPE, \"rtf\");\n\n    /**\n     * SFNT fonts (which includes <a href=\"http://en.wikipedia.org/wiki/TrueType/\">TrueType</a> and <a\n     * href=\"http://en.wikipedia.org/wiki/OpenType/\">OpenType</a> fonts). This is <a\n     * href=\"http://www.iana.org/assignments/media-types/application/font-sfnt\">registered</a> with\n     * the IANA.\n     *\n     * @since 17.0\n     */\n    public static final MediaType SFNT = createConstant(APPLICATION_TYPE, \"font-sfnt\");\n\n    public static final MediaType SHOCKWAVE_FLASH =\n        createConstant(APPLICATION_TYPE, \"x-shockwave-flash\");\n\n    /**\n     * {@code skp} files produced by the 3D Modeling software <a\n     * href=\"https://www.sketchup.com/\">SketchUp</a>\n     *\n     * @since 13.0\n     */\n    public static final MediaType SKETCHUP = createConstant(APPLICATION_TYPE, \"vnd.sketchup.skp\");\n\n    /**\n     * As described in <a href=\"http://www.ietf.org/rfc/rfc3902.txt\">RFC 3902</a>, this constant\n     * ({@code application/soap+xml}) is used to identify SOAP 1.2 message envelopes that have been\n     * serialized with XML 1.0.\n     *\n     * <p>For SOAP 1.1 messages, see {@code XML_UTF_8} per <a\n     * href=\"http://www.w3.org/TR/2000/NOTE-SOAP-20000508/\">W3C Note on Simple Object Access Protocol\n     * (SOAP) 1.1</a>\n     *\n     * @since 20.0\n     */\n    public static final MediaType SOAP_XML_UTF_8 = createConstantUtf8(APPLICATION_TYPE, \"soap+xml\");\n\n    public static final MediaType TAR = createConstant(APPLICATION_TYPE, \"x-tar\");\n\n    /**\n     * <a href=\"http://en.wikipedia.org/wiki/Web_Open_Font_Format\">Web Open Font Format</a> (WOFF) <a\n     * href=\"http://www.w3.org/TR/WOFF/\">defined</a> by the W3C. This is <a\n     * href=\"http://www.iana.org/assignments/media-types/application/font-woff\">registered</a> with\n     * the IANA.\n     *\n     * @since 17.0\n     */\n    public static final MediaType WOFF = createConstant(APPLICATION_TYPE, \"font-woff\");\n\n    /**\n     * <a href=\"http://en.wikipedia.org/wiki/Web_Open_Font_Format\">Web Open Font Format</a> (WOFF)\n     * version 2 <a href=\"https://www.w3.org/TR/WOFF2/\">defined</a> by the W3C.\n     *\n     * @since 20.0\n     */\n    public static final MediaType WOFF2 = createConstant(APPLICATION_TYPE, \"font-woff2\");\n\n    public static final MediaType XHTML_UTF_8 = createConstantUtf8(APPLICATION_TYPE, \"xhtml+xml\");\n\n    /**\n     * Extensible Resource Descriptors. This is not yet registered with the IANA, but it is specified\n     * by OASIS in the <a href=\"http://docs.oasis-open.org/xri/xrd/v1.0/cd02/xrd-1.0-cd02.html\">XRD\n     * definition</a> and implemented in projects such as <a\n     * href=\"http://code.google.com/p/webfinger/\">WebFinger</a>.\n     *\n     * @since 14.0\n     */\n    public static final MediaType XRD_UTF_8 = createConstantUtf8(APPLICATION_TYPE, \"xrd+xml\");\n\n    public static final MediaType ZIP = createConstant(APPLICATION_TYPE, \"zip\");\n\n    private final String type;\n    private final String subtype;\n    private final ImmutableListMultimap<String, String> parameters;\n\n    @LazyInit private String toString;\n\n    @LazyInit private int hashCode;\n\n    @LazyInit private Optional<Charset> parsedCharset;\n\n    private MediaType(String type, String subtype, ImmutableListMultimap<String, String> parameters)\n    {\n        this.type = type;\n        this.subtype = subtype;\n        this.parameters = parameters;\n    }\n\n    /** Returns the top-level media type. For example, {@code \"text\"} in {@code \"text/plain\"}. */\n    public String type()\n    {\n        return type;\n    }\n\n    /** Returns the media subtype. For example, {@code \"plain\"} in {@code \"text/plain\"}. */\n    public String subtype()\n    {\n        return subtype;\n    }\n\n    /** Returns a multimap containing the parameters of this media type. */\n    public ImmutableListMultimap<String, String> parameters()\n    {\n        return parameters;\n    }\n\n    private Map<String, ImmutableMultiset<String>> parametersAsMap()\n    {\n        return Maps.transformValues(\n                   parameters.asMap(),\n                   new Function<Collection<String>, ImmutableMultiset<String>>()\n        {\n            @Override\n            public ImmutableMultiset<String> apply(Collection<String> input)\n            {\n                return ImmutableMultiset.copyOf(input);\n            }\n        });\n    }\n\n    /**\n     * Returns an optional charset for the value of the charset parameter if it is specified.\n     *\n     * @throws IllegalStateException if multiple charset values have been set for this media type\n     * @throws IllegalCharsetNameException if a charset value is present, but illegal\n     * @throws UnsupportedCharsetException if a charset value is present, but no support is available\n     *     in this instance of the Java virtual machine\n     */\n    public Optional<Charset> charset()\n    {\n        // racy single-check idiom, this is safe because Optional is immutable.\n        Optional<Charset> local = parsedCharset;\n        if (local == null)\n        {\n            String value = null;\n            local = Optional.absent();\n            for (String currentValue : parameters.get(CHARSET_ATTRIBUTE))\n            {\n                if (value == null)\n                {\n                    value = currentValue;\n                    local = Optional.of(Charset.forName(value));\n                }\n                else if (!value.equals(currentValue))\n                {\n                    throw new IllegalStateException(\n                        \"Multiple charset values defined: \" + value + \", \" + currentValue);\n                }\n            }\n            parsedCharset = local;\n        }\n        return local;\n    }\n\n    /**\n     * Returns a new instance with the same type and subtype as this instance, but without any\n     * parameters.\n     */\n    public MediaType withoutParameters()\n    {\n        return parameters.isEmpty() ? this : create(type, subtype);\n    }\n\n    /**\n     * <em>Replaces</em> all parameters with the given parameters.\n     *\n     * @throws IllegalArgumentException if any parameter or value is invalid\n     */\n    public MediaType withParameters(Multimap<String, String> parameters)\n    {\n        return create(type, subtype, parameters);\n    }\n\n    /**\n     * <em>Replaces</em> all parameters with the given attribute with parameters using the given\n     * values. If there are no values, any existing parameters with the given attribute are removed.\n     *\n     * @throws IllegalArgumentException if either {@code attribute} or {@code values} is invalid\n     * @since 24.0\n     */\n    public MediaType withParameters(String attribute, Iterable<String> values)\n    {\n        checkNotNull(attribute);\n        checkNotNull(values);\n        String normalizedAttribute = normalizeToken(attribute);\n        ImmutableListMultimap.Builder<String, String> builder = ImmutableListMultimap.builder();\n        for (Entry<String, String> entry : parameters.entries())\n        {\n            String key = entry.getKey();\n            if (!normalizedAttribute.equals(key))\n            {\n                builder.put(key, entry.getValue());\n            }\n        }\n        for (String value : values)\n        {\n            builder.put(normalizedAttribute, normalizeParameterValue(normalizedAttribute, value));\n        }\n        MediaType mediaType = new MediaType(type, subtype, builder.build());\n        // if the attribute isn't charset, we can just inherit the current parsedCharset\n        if (!normalizedAttribute.equals(CHARSET_ATTRIBUTE))\n        {\n            mediaType.parsedCharset = this.parsedCharset;\n        }\n        // Return one of the constants if the media type is a known type.\n        return MoreObjects.firstNonNull(KNOWN_TYPES.get(mediaType), mediaType);\n    }\n\n    /**\n     * <em>Replaces</em> all parameters with the given attribute with a single parameter with the\n     * given value. If multiple parameters with the same attributes are necessary use {@link\n     * #withParameters(String, Iterable)}. Prefer {@link #withCharset} for setting the {@code charset}\n     * parameter when using a {@link Charset} object.\n     *\n     * @throws IllegalArgumentException if either {@code attribute} or {@code value} is invalid\n     */\n    public MediaType withParameter(String attribute, String value)\n    {\n        return withParameters(attribute, ImmutableSet.of(value));\n    }\n\n    /**\n     * Returns a new instance with the same type and subtype as this instance, with the {@code\n     * charset} parameter set to the {@link Charset#name name} of the given charset. Only one {@code\n     * charset} parameter will be present on the new instance regardless of the number set on this\n     * one.\n     *\n     * <p>If a charset must be specified that is not supported on this JVM (and thus is not\n     * representable as a {@link Charset} instance, use {@link #withParameter}.\n     */\n    public MediaType withCharset(Charset charset)\n    {\n        checkNotNull(charset);\n        MediaType withCharset = withParameter(CHARSET_ATTRIBUTE, charset.name());\n        // precache the charset so we don't need to parse it\n        withCharset.parsedCharset = Optional.of(charset);\n        return withCharset;\n    }\n\n    /** Returns true if either the type or subtype is the wildcard. */\n    public boolean hasWildcard()\n    {\n        return WILDCARD.equals(type) || WILDCARD.equals(subtype);\n    }\n\n    /**\n     * Returns {@code true} if this instance falls within the range (as defined by <a\n     * href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\">the HTTP Accept header</a>) given\n     * by the argument according to three criteria:\n     *\n     * <ol>\n     *   <li>The type of the argument is the wildcard or equal to the type of this instance.\n     *   <li>The subtype of the argument is the wildcard or equal to the subtype of this instance.\n     *   <li>All of the parameters present in the argument are present in this instance.\n     * </ol>\n     *\n     * <p>For example:\n     *\n     * <pre>{@code\n     * PLAIN_TEXT_UTF_8.is(PLAIN_TEXT_UTF_8) // true\n     * PLAIN_TEXT_UTF_8.is(HTML_UTF_8) // false\n     * PLAIN_TEXT_UTF_8.is(ANY_TYPE) // true\n     * PLAIN_TEXT_UTF_8.is(ANY_TEXT_TYPE) // true\n     * PLAIN_TEXT_UTF_8.is(ANY_IMAGE_TYPE) // false\n     * PLAIN_TEXT_UTF_8.is(ANY_TEXT_TYPE.withCharset(UTF_8)) // true\n     * PLAIN_TEXT_UTF_8.withoutParameters().is(ANY_TEXT_TYPE.withCharset(UTF_8)) // false\n     * PLAIN_TEXT_UTF_8.is(ANY_TEXT_TYPE.withCharset(UTF_16)) // false\n     * }</pre>\n     *\n     * <p>Note that while it is possible to have the same parameter declared multiple times within a\n     * media type this method does not consider the number of occurrences of a parameter. For example,\n     * {@code \"text/plain; charset=UTF-8\"} satisfies {@code \"text/plain; charset=UTF-8;\n     * charset=UTF-8\"}.\n     */\n    public boolean is(MediaType mediaTypeRange)\n    {\n        return (mediaTypeRange.type.equals(WILDCARD) || mediaTypeRange.type.equals(this.type))\n               && (mediaTypeRange.subtype.equals(WILDCARD) || mediaTypeRange.subtype.equals(this.subtype))\n               && this.parameters.entries().containsAll(mediaTypeRange.parameters.entries());\n    }\n\n    /**\n     * Creates a new media type with the given type and subtype.\n     *\n     * @throws IllegalArgumentException if type or subtype is invalid or if a wildcard is used for the\n     *     type, but not the subtype.\n     */\n    public static MediaType create(String type, String subtype)\n    {\n        MediaType mediaType = create(type, subtype, ImmutableListMultimap.<String, String>of());\n        mediaType.parsedCharset = Optional.absent();\n        return mediaType;\n    }\n\n    private static MediaType create(\n        String type, String subtype, Multimap<String, String> parameters)\n    {\n        checkNotNull(type);\n        checkNotNull(subtype);\n        checkNotNull(parameters);\n        String normalizedType = normalizeToken(type);\n        String normalizedSubtype = normalizeToken(subtype);\n        checkArgument(\n            !WILDCARD.equals(normalizedType) || WILDCARD.equals(normalizedSubtype),\n            \"A wildcard type cannot be used with a non-wildcard subtype\");\n        ImmutableListMultimap.Builder<String, String> builder = ImmutableListMultimap.builder();\n        for (Entry<String, String> entry : parameters.entries())\n        {\n            String attribute = normalizeToken(entry.getKey());\n            builder.put(attribute, normalizeParameterValue(attribute, entry.getValue()));\n        }\n        MediaType mediaType = new MediaType(normalizedType, normalizedSubtype, builder.build());\n        // Return one of the constants if the media type is a known type.\n        return MoreObjects.firstNonNull(KNOWN_TYPES.get(mediaType), mediaType);\n    }\n\n    /**\n     * Creates a media type with the \"application\" type and the given subtype.\n     *\n     * @throws IllegalArgumentException if subtype is invalid\n     */\n    static MediaType createApplicationType(String subtype)\n    {\n        return create(APPLICATION_TYPE, subtype);\n    }\n\n    /**\n     * Creates a media type with the \"audio\" type and the given subtype.\n     *\n     * @throws IllegalArgumentException if subtype is invalid\n     */\n    static MediaType createAudioType(String subtype)\n    {\n        return create(AUDIO_TYPE, subtype);\n    }\n\n    /**\n     * Creates a media type with the \"image\" type and the given subtype.\n     *\n     * @throws IllegalArgumentException if subtype is invalid\n     */\n    static MediaType createImageType(String subtype)\n    {\n        return create(IMAGE_TYPE, subtype);\n    }\n\n    /**\n     * Creates a media type with the \"text\" type and the given subtype.\n     *\n     * @throws IllegalArgumentException if subtype is invalid\n     */\n    static MediaType createTextType(String subtype)\n    {\n        return create(TEXT_TYPE, subtype);\n    }\n\n    /**\n     * Creates a media type with the \"video\" type and the given subtype.\n     *\n     * @throws IllegalArgumentException if subtype is invalid\n     */\n    static MediaType createVideoType(String subtype)\n    {\n        return create(VIDEO_TYPE, subtype);\n    }\n\n    private static String normalizeToken(String token)\n    {\n        checkArgument(TOKEN_MATCHER.matchesAllOf(token));\n        return Ascii.toLowerCase(token);\n    }\n\n    private static String normalizeParameterValue(String attribute, String value)\n    {\n        return CHARSET_ATTRIBUTE.equals(attribute) ? Ascii.toLowerCase(value) : value;\n    }\n\n    /**\n     * Parses a media type from its string representation.\n     *\n     * @throws IllegalArgumentException if the input is not parsable\n     */\n\n    private static final class Tokenizer\n    {\n        final String input;\n        int position = 0;\n\n        Tokenizer(String input)\n        {\n            this.input = input;\n        }\n\n        String consumeTokenIfPresent(CharMatcher matcher)\n        {\n            checkState(hasMore());\n            int startPosition = position;\n            position = matcher.negate().indexIn(input, startPosition);\n            return hasMore() ? input.substring(startPosition, position) : input.substring(startPosition);\n        }\n\n        String consumeToken(CharMatcher matcher)\n        {\n            int startPosition = position;\n            String token = consumeTokenIfPresent(matcher);\n            checkState(position != startPosition);\n            return token;\n        }\n\n        char consumeCharacter(CharMatcher matcher)\n        {\n            checkState(hasMore());\n            char c = previewChar();\n            checkState(matcher.matches(c));\n            position++;\n            return c;\n        }\n\n        char consumeCharacter(char c)\n        {\n            checkState(hasMore());\n            checkState(previewChar() == c);\n            position++;\n            return c;\n        }\n\n        char previewChar()\n        {\n            checkState(hasMore());\n            return input.charAt(position);\n        }\n\n        boolean hasMore()\n        {\n            return (position >= 0) && (position < input.length());\n        }\n    }\n\n    @Override\n    public boolean equals(@Nullable Object obj)\n    {\n        if (obj == this)\n        {\n            return true;\n        }\n        else if (obj instanceof MediaType)\n        {\n            MediaType that = (MediaType) obj;\n            return this.type.equals(that.type)\n                   && this.subtype.equals(that.subtype)\n                   // compare parameters regardless of order\n                   && this.parametersAsMap().equals(that.parametersAsMap());\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n    @Override\n    public int hashCode()\n    {\n        // racy single-check idiom\n        int h = hashCode;\n        if (h == 0)\n        {\n            h = Objects.hashCode(type, subtype, parametersAsMap());\n            hashCode = h;\n        }\n        return h;\n    }\n\n    private static final MapJoiner PARAMETER_JOINER = Joiner.on(\"; \").withKeyValueSeparator(\"=\");\n\n    /**\n     * Returns the string representation of this media type in the format described in <a\n     * href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>.\n     */\n    @Override\n    public String toString()\n    {\n        // racy single-check idiom, safe because String is immutable\n        String result = toString;\n        if (result == null)\n        {\n            result = computeToString();\n            toString = result;\n        }\n        return result;\n    }\n\n    private String computeToString()\n    {\n        StringBuilder builder = new StringBuilder().append(type).append('/').append(subtype);\n        if (!parameters.isEmpty())\n        {\n            builder.append(\"; \");\n            Multimap<String, String> quotedParameters =\n                Multimaps.transformValues(\n                    parameters,\n                    new Function<String, String>()\n            {\n                @Override\n                public String apply(String value)\n                {\n                    return TOKEN_MATCHER.matchesAllOf(value) ? value : escapeAndQuote(value);\n                }\n            });\n            PARAMETER_JOINER.appendTo(builder, quotedParameters.entries());\n        }\n        return builder.toString();\n    }\n\n    private static String escapeAndQuote(String value)\n    {\n        StringBuilder escaped = new StringBuilder(value.length() + 16).append('\"');\n        for (int i = 0; i < value.length(); i++)\n        {\n            char ch = value.charAt(i);\n            if (ch == '\\r' || ch == '\\\\' || ch == '\"')\n            {\n                escaped.append('\\\\');\n            }\n            escaped.append(ch);\n        }\n        return escaped.append('\"').toString();\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/reflect/TypeCapture.java", "func_name": "TypeCapture.capture", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns the captured type.", "docstring_tokens": ["Returns", "the", "captured", "type", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/reflect/TypeCapture.java#L30-L34", "partition": "valid", "up_fun_num": 1, "levels": [0], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import java.lang.reflect.ParameterizedType;", "import java.lang.reflect.Type;"], "function": ["abstract class TypeCapture<T>\n"], "context": "/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.reflect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\n\n/**\n * Captures the actual type of {@code T}.\n *\n * @author Ben Yu\n */\nabstract class TypeCapture<T>\n{\n\n    /** Returns the captured type. */\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/Sets.java", "func_name": "Sets.removeAllImpl", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Remove each element in an iterable from a set.", "docstring_tokens": ["Remove", "each", "element", "in", "an", "iterable", "from", "a", "set", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/Sets.java#L1813-L1819", "partition": "valid", "up_fun_num": 40, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.collect.CollectPreconditions.checkNonnegative;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.Predicate;", "import com.google.common.base.Predicates;", "import com.google.common.collect.Collections2.FilteredCollection;", "import com.google.common.math.IntMath;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.io.Serializable;", "import java.util.AbstractSet;", "import java.util.Arrays;", "import java.util.BitSet;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.Comparator;", "import java.util.EnumSet;", "import java.util.HashSet;", "import java.util.Iterator;", "import java.util.LinkedHashSet;", "import java.util.List;", "import java.util.Map;", "import java.util.NavigableSet;", "import java.util.NoSuchElementException;", "import java.util.Set;", "import java.util.SortedSet;", "import java.util.TreeSet;", "import java.util.concurrent.ConcurrentHashMap;", "import java.util.concurrent.CopyOnWriteArraySet;", "import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Sets\n", "    public static <E extends Enum<E>> ImmutableSet<E> immutableEnumSet(\n", "    public static <E extends Enum<E>> ImmutableSet<E> immutableEnumSet(Iterable<E> elements)\n", "    public static <E extends Enum<E>> EnumSet<E> newEnumSet(\n", "    public static <E> HashSet<E> newHashSet()\n", "    public static <E> HashSet<E> newHashSet(E... elements)\n", "    public static <E> HashSet<E> newHashSet(Iterable<? extends E> elements)\n", "    public static <E> HashSet<E> newHashSet(Iterator<? extends E> elements)\n", "    public static <E> HashSet<E> newHashSetWithExpectedSize(int expectedSize)\n", "    public static <E> Set<E> newConcurrentHashSet()\n", "    public static <E> Set<E> newConcurrentHashSet(Iterable<? extends E> elements)\n", "    public static <E> LinkedHashSet<E> newLinkedHashSet()\n", "    public static <E> LinkedHashSet<E> newLinkedHashSet(Iterable<? extends E> elements)\n", "    public static <E> LinkedHashSet<E> newLinkedHashSetWithExpectedSize(int expectedSize)\n", "    public static <E extends Comparable> TreeSet<E> newTreeSet()\n", "    public static <E extends Comparable> TreeSet<E> newTreeSet(Iterable<? extends E> elements)\n", "    public static <E> TreeSet<E> newTreeSet(Comparator<? super E> comparator)\n", "    public static <E> Set<E> newIdentityHashSet()\n", "    public static <E> CopyOnWriteArraySet<E> newCopyOnWriteArraySet()\n", "    public static <E> CopyOnWriteArraySet<E> newCopyOnWriteArraySet(Iterable<? extends E> elements)\n", "    public static <E extends Enum<E>> EnumSet<E> complementOf(Collection<E> collection)\n", "    public static <E extends Enum<E>> EnumSet<E> complementOf(\n", "    private static <E extends Enum<E>> EnumSet<E> makeComplementByHand(\n", "    public static <E> Set<E> newSetFromMap(Map<E, Boolean> map)\n", "    public static <E> SetView<E> union(final Set<? extends E> set1, final Set<? extends E> set2)\n", "    public static <E> SetView<E> intersection(final Set<E> set1, final Set<?> set2)\n", "    public static <E> SetView<E> difference(final Set<E> set1, final Set<?> set2)\n", "    public static <E> SetView<E> symmetricDifference(\n", "    public static <E> Set<E> filter(Set<E> unfiltered, Predicate<? super E> predicate)\n", "    public static <E> SortedSet<E> filter(SortedSet<E> unfiltered, Predicate<? super E> predicate)\n", "    public static <E> NavigableSet<E> filter(\n", "    public static <B> Set<List<B>> cartesianProduct(List<? extends Set<? extends B>> sets)\n", "    public static <B> Set<List<B>> cartesianProduct(Set<? extends B>... sets)\n", "    public static <E> Set<Set<E>> powerSet(Set<E> set)\n", "    public static <E> Set<Set<E>> combinations(Set<E> set, final int size)\n", "    static int hashCodeImpl(Set<?> s)\n", "    static boolean equalsImpl(Set<?> s, @NullableDecl Object object)\n", "    public static <E> NavigableSet<E> unmodifiableNavigableSet(NavigableSet<E> set)\n", "    public static <E> NavigableSet<E> synchronizedNavigableSet(NavigableSet<E> navigableSet)\n", "    static boolean removeAllImpl(Set<?> set, Collection<?> collection)\n", "    public static <K extends Comparable<? super K>> NavigableSet<K> subSet(\n"], "context": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.collect.CollectPreconditions.checkNonnegative;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport com.google.common.collect.Collections2.FilteredCollection;\nimport com.google.common.math.IntMath;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.Serializable;\nimport java.util.AbstractSet;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.EnumSet;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NavigableSet;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CopyOnWriteArraySet;\nimport org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * Static utility methods pertaining to {@link Set} instances. Also see this class's counterparts\n * {@link Lists}, {@link Maps} and {@link Queues}.\n *\n * <p>See the Guava User Guide article on <a href=\n * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#sets\"> {@code Sets}</a>.\n *\n * @author Kevin Bourrillion\n * @author Jared Levy\n * @author Chris Povirk\n * @since 2.0\n */\n@GwtCompatible(emulated = true)\npublic final class Sets\n{\n    private Sets() {}\n\n    /**\n     * {@link AbstractSet} substitute without the potentially-quadratic {@code removeAll}\n     * implementation.\n     */\n    abstract static class ImprovedAbstractSet<E> extends AbstractSet<E>\n    {\n        @Override\n        public boolean removeAll(Collection<?> c)\n        {\n            return removeAllImpl(this, c);\n        }\n\n        @Override\n        public boolean retainAll(Collection<?> c)\n        {\n            return super.retainAll(checkNotNull(c)); // GWT compatibility\n        }\n    }\n\n    /**\n     * Returns an immutable set instance containing the given enum elements. Internally, the returned\n     * set will be backed by an {@link EnumSet}.\n     *\n     * <p>The iteration order of the returned set follows the enum's iteration order, not the order in\n     * which the elements are provided to the method.\n     *\n     * @param anElement one of the elements the set should contain\n     * @param otherElements the rest of the elements the set should contain\n     * @return an immutable set containing those elements, minus duplicates\n     */\n    // http://code.google.com/p/google-web-toolkit/issues/detail?id=3028\n    @GwtCompatible(serializable = true)\n    public static <E extends Enum<E>> ImmutableSet<E> immutableEnumSet(\n        E anElement, E... otherElements)\n    {\n        return ImmutableEnumSet.asImmutable(EnumSet.of(anElement, otherElements));\n    }\n\n    /**\n     * Returns an immutable set instance containing the given enum elements. Internally, the returned\n     * set will be backed by an {@link EnumSet}.\n     *\n     * <p>The iteration order of the returned set follows the enum's iteration order, not the order in\n     * which the elements appear in the given collection.\n     *\n     * @param elements the elements, all of the same {@code enum} type, that the set should contain\n     * @return an immutable set containing those elements, minus duplicates\n     */\n    // http://code.google.com/p/google-web-toolkit/issues/detail?id=3028\n    @GwtCompatible(serializable = true)\n    public static <E extends Enum<E>> ImmutableSet<E> immutableEnumSet(Iterable<E> elements)\n    {\n        if (elements instanceof ImmutableEnumSet)\n        {\n            return (ImmutableEnumSet<E>) elements;\n        }\n        else if (elements instanceof Collection)\n        {\n            Collection<E> collection = (Collection<E>) elements;\n            if (collection.isEmpty())\n            {\n                return ImmutableSet.of();\n            }\n            else\n            {\n                return ImmutableEnumSet.asImmutable(EnumSet.copyOf(collection));\n            }\n        }\n        else\n        {\n            Iterator<E> itr = elements.iterator();\n            if (itr.hasNext())\n            {\n                EnumSet<E> enumSet = EnumSet.of(itr.next());\n                Iterators.addAll(enumSet, itr);\n                return ImmutableEnumSet.asImmutable(enumSet);\n            }\n            else\n            {\n                return ImmutableSet.of();\n            }\n        }\n    }\n\n    /**\n     * Returns a new, <i>mutable</i> {@code EnumSet} instance containing the given elements in their\n     * natural order. This method behaves identically to {@link EnumSet#copyOf(Collection)}, but also\n     * accepts non-{@code Collection} iterables and empty iterables.\n     */\n    public static <E extends Enum<E>> EnumSet<E> newEnumSet(\n        Iterable<E> iterable, Class<E> elementType)\n    {\n        EnumSet<E> set = EnumSet.noneOf(elementType);\n        Iterables.addAll(set, iterable);\n        return set;\n    }\n\n    // HashSet\n\n    /**\n     * Creates a <i>mutable</i>, initially empty {@code HashSet} instance.\n     *\n     * <p><b>Note:</b> if mutability is not required, use {@link ImmutableSet#of()} instead. If {@code\n     * E} is an {@link Enum} type, use {@link EnumSet#noneOf} instead. Otherwise, strongly consider\n     * using a {@code LinkedHashSet} instead, at the cost of increased memory footprint, to get\n     * deterministic iteration behavior.\n     *\n     * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n     * deprecated. Instead, use the {@code HashSet} constructor directly, taking advantage of the new\n     * <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n     */\n    public static <E> HashSet<E> newHashSet()\n    {\n        return new HashSet<E>();\n    }\n\n    /**\n     * Creates a <i>mutable</i> {@code HashSet} instance initially containing the given elements.\n     *\n     * <p><b>Note:</b> if elements are non-null and won't be added or removed after this point, use\n     * {@link ImmutableSet#of()} or {@link ImmutableSet#copyOf(Object[])} instead. If {@code E} is an\n     * {@link Enum} type, use {@link EnumSet#of(Enum, Enum[])} instead. Otherwise, strongly consider\n     * using a {@code LinkedHashSet} instead, at the cost of increased memory footprint, to get\n     * deterministic iteration behavior.\n     *\n     * <p>This method is just a small convenience, either for {@code newHashSet(}{@link Arrays#asList\n     * asList}{@code (...))}, or for creating an empty set then calling {@link Collections#addAll}.\n     * This method is not actually very useful and will likely be deprecated in the future.\n     */\n    public static <E> HashSet<E> newHashSet(E... elements)\n    {\n        HashSet<E> set = newHashSetWithExpectedSize(elements.length);\n        Collections.addAll(set, elements);\n        return set;\n    }\n\n    /**\n     * Creates a <i>mutable</i> {@code HashSet} instance containing the given elements. A very thin\n     * convenience for creating an empty set then calling {@link Collection#addAll} or {@link\n     * Iterables#addAll}.\n     *\n     * <p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link\n     * ImmutableSet#copyOf(Iterable)} instead. (Or, change {@code elements} to be a {@link\n     * FluentIterable} and call {@code elements.toSet()}.)\n     *\n     * <p><b>Note:</b> if {@code E} is an {@link Enum} type, use {@link #newEnumSet(Iterable, Class)}\n     * instead.\n     *\n     * <p><b>Note for Java 7 and later:</b> if {@code elements} is a {@link Collection}, you don't\n     * need this method. Instead, use the {@code HashSet} constructor directly, taking advantage of\n     * the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n     *\n     * <p>Overall, this method is not very useful and will likely be deprecated in the future.\n     */\n    public static <E> HashSet<E> newHashSet(Iterable<? extends E> elements)\n    {\n        return (elements instanceof Collection)\n               ? new HashSet<E>(Collections2.cast(elements))\n               : newHashSet(elements.iterator());\n    }\n\n    /**\n     * Creates a <i>mutable</i> {@code HashSet} instance containing the given elements. A very thin\n     * convenience for creating an empty set and then calling {@link Iterators#addAll}.\n     *\n     * <p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link\n     * ImmutableSet#copyOf(Iterator)} instead.\n     *\n     * <p><b>Note:</b> if {@code E} is an {@link Enum} type, you should create an {@link EnumSet}\n     * instead.\n     *\n     * <p>Overall, this method is not very useful and will likely be deprecated in the future.\n     */\n    public static <E> HashSet<E> newHashSet(Iterator<? extends E> elements)\n    {\n        HashSet<E> set = newHashSet();\n        Iterators.addAll(set, elements);\n        return set;\n    }\n\n    /**\n     * Returns a new hash set using the smallest initial table size that can hold {@code expectedSize}\n     * elements without resizing. Note that this is not what {@link HashSet#HashSet(int)} does, but it\n     * is what most users want and expect it to do.\n     *\n     * <p>This behavior can't be broadly guaranteed, but has been tested with OpenJDK 1.7 and 1.8.\n     *\n     * @param expectedSize the number of elements you expect to add to the returned set\n     * @return a new, empty hash set with enough capacity to hold {@code expectedSize} elements\n     *     without resizing\n     * @throws IllegalArgumentException if {@code expectedSize} is negative\n     */\n    public static <E> HashSet<E> newHashSetWithExpectedSize(int expectedSize)\n    {\n        return new HashSet<E>(Maps.capacity(expectedSize));\n    }\n\n    /**\n     * Creates a thread-safe set backed by a hash map. The set is backed by a {@link\n     * ConcurrentHashMap} instance, and thus carries the same concurrency guarantees.\n     *\n     * <p>Unlike {@code HashSet}, this class does NOT allow {@code null} to be used as an element. The\n     * set is serializable.\n     *\n     * @return a new, empty thread-safe {@code Set}\n     * @since 15.0\n     */\n    public static <E> Set<E> newConcurrentHashSet()\n    {\n        return Collections.newSetFromMap(new ConcurrentHashMap<E, Boolean>());\n    }\n\n    /**\n     * Creates a thread-safe set backed by a hash map and containing the given elements. The set is\n     * backed by a {@link ConcurrentHashMap} instance, and thus carries the same concurrency\n     * guarantees.\n     *\n     * <p>Unlike {@code HashSet}, this class does NOT allow {@code null} to be used as an element. The\n     * set is serializable.\n     *\n     * @param elements the elements that the set should contain\n     * @return a new thread-safe set containing those elements (minus duplicates)\n     * @throws NullPointerException if {@code elements} or any of its contents is null\n     * @since 15.0\n     */\n    public static <E> Set<E> newConcurrentHashSet(Iterable<? extends E> elements)\n    {\n        Set<E> set = newConcurrentHashSet();\n        Iterables.addAll(set, elements);\n        return set;\n    }\n\n    // LinkedHashSet\n\n    /**\n     * Creates a <i>mutable</i>, empty {@code LinkedHashSet} instance.\n     *\n     * <p><b>Note:</b> if mutability is not required, use {@link ImmutableSet#of()} instead.\n     *\n     * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n     * deprecated. Instead, use the {@code LinkedHashSet} constructor directly, taking advantage of\n     * the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n     *\n     * @return a new, empty {@code LinkedHashSet}\n     */\n    public static <E> LinkedHashSet<E> newLinkedHashSet()\n    {\n        return new LinkedHashSet<E>();\n    }\n\n    /**\n     * Creates a <i>mutable</i> {@code LinkedHashSet} instance containing the given elements in order.\n     *\n     * <p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link\n     * ImmutableSet#copyOf(Iterable)} instead.\n     *\n     * <p><b>Note for Java 7 and later:</b> if {@code elements} is a {@link Collection}, you don't\n     * need this method. Instead, use the {@code LinkedHashSet} constructor directly, taking advantage\n     * of the new <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n     *\n     * <p>Overall, this method is not very useful and will likely be deprecated in the future.\n     *\n     * @param elements the elements that the set should contain, in order\n     * @return a new {@code LinkedHashSet} containing those elements (minus duplicates)\n     */\n    public static <E> LinkedHashSet<E> newLinkedHashSet(Iterable<? extends E> elements)\n    {\n        if (elements instanceof Collection)\n        {\n            return new LinkedHashSet<E>(Collections2.cast(elements));\n        }\n        LinkedHashSet<E> set = newLinkedHashSet();\n        Iterables.addAll(set, elements);\n        return set;\n    }\n\n    /**\n     * Creates a {@code LinkedHashSet} instance, with a high enough \"initial capacity\" that it\n     * <i>should</i> hold {@code expectedSize} elements without growth. This behavior cannot be\n     * broadly guaranteed, but it is observed to be true for OpenJDK 1.7. It also can't be guaranteed\n     * that the method isn't inadvertently <i>oversizing</i> the returned set.\n     *\n     * @param expectedSize the number of elements you expect to add to the returned set\n     * @return a new, empty {@code LinkedHashSet} with enough capacity to hold {@code expectedSize}\n     *     elements without resizing\n     * @throws IllegalArgumentException if {@code expectedSize} is negative\n     * @since 11.0\n     */\n    public static <E> LinkedHashSet<E> newLinkedHashSetWithExpectedSize(int expectedSize)\n    {\n        return new LinkedHashSet<E>(Maps.capacity(expectedSize));\n    }\n\n    // TreeSet\n\n    /**\n     * Creates a <i>mutable</i>, empty {@code TreeSet} instance sorted by the natural sort ordering of\n     * its elements.\n     *\n     * <p><b>Note:</b> if mutability is not required, use {@link ImmutableSortedSet#of()} instead.\n     *\n     * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n     * deprecated. Instead, use the {@code TreeSet} constructor directly, taking advantage of the new\n     * <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n     *\n     * @return a new, empty {@code TreeSet}\n     */\n    public static <E extends Comparable> TreeSet<E> newTreeSet()\n    {\n        return new TreeSet<E>();\n    }\n\n    /**\n     * Creates a <i>mutable</i> {@code TreeSet} instance containing the given elements sorted by their\n     * natural ordering.\n     *\n     * <p><b>Note:</b> if mutability is not required, use {@link ImmutableSortedSet#copyOf(Iterable)}\n     * instead.\n     *\n     * <p><b>Note:</b> If {@code elements} is a {@code SortedSet} with an explicit comparator, this\n     * method has different behavior than {@link TreeSet#TreeSet(SortedSet)}, which returns a {@code\n     * TreeSet} with that comparator.\n     *\n     * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n     * deprecated. Instead, use the {@code TreeSet} constructor directly, taking advantage of the new\n     * <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>.\n     *\n     * <p>This method is just a small convenience for creating an empty set and then calling {@link\n     * Iterables#addAll}. This method is not very useful and will likely be deprecated in the future.\n     *\n     * @param elements the elements that the set should contain\n     * @return a new {@code TreeSet} containing those elements (minus duplicates)\n     */\n    public static <E extends Comparable> TreeSet<E> newTreeSet(Iterable<? extends E> elements)\n    {\n        TreeSet<E> set = newTreeSet();\n        Iterables.addAll(set, elements);\n        return set;\n    }\n\n    /**\n     * Creates a <i>mutable</i>, empty {@code TreeSet} instance with the given comparator.\n     *\n     * <p><b>Note:</b> if mutability is not required, use {@code\n     * ImmutableSortedSet.orderedBy(comparator).build()} instead.\n     *\n     * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as\n     * deprecated. Instead, use the {@code TreeSet} constructor directly, taking advantage of the new\n     * <a href=\"http://goo.gl/iz2Wi\">\"diamond\" syntax</a>. One caveat to this is that the {@code\n     * TreeSet} constructor uses a null {@code Comparator} to mean \"natural ordering,\" whereas this\n     * factory rejects null. Clean your code accordingly.\n     *\n     * @param comparator the comparator to use to sort the set\n     * @return a new, empty {@code TreeSet}\n     * @throws NullPointerException if {@code comparator} is null\n     */\n    public static <E> TreeSet<E> newTreeSet(Comparator<? super E> comparator)\n    {\n        return new TreeSet<E>(checkNotNull(comparator));\n    }\n\n    /**\n     * Creates an empty {@code Set} that uses identity to determine equality. It compares object\n     * references, instead of calling {@code equals}, to determine whether a provided object matches\n     * an element in the set. For example, {@code contains} returns {@code false} when passed an\n     * object that equals a set member, but isn't the same instance. This behavior is similar to the\n     * way {@code IdentityHashMap} handles key lookups.\n     *\n     * @since 8.0\n     */\n    public static <E> Set<E> newIdentityHashSet()\n    {\n        return Collections.newSetFromMap(Maps.<E, Boolean>newIdentityHashMap());\n    }\n\n    /**\n     * Creates an empty {@code CopyOnWriteArraySet} instance.\n     *\n     * <p><b>Note:</b> if you need an immutable empty {@link Set}, use {@link Collections#emptySet}\n     * instead.\n     *\n     * @return a new, empty {@code CopyOnWriteArraySet}\n     * @since 12.0\n     */\n    @GwtIncompatible // CopyOnWriteArraySet\n    public static <E> CopyOnWriteArraySet<E> newCopyOnWriteArraySet()\n    {\n        return new CopyOnWriteArraySet<E>();\n    }\n\n    /**\n     * Creates a {@code CopyOnWriteArraySet} instance containing the given elements.\n     *\n     * @param elements the elements that the set should contain, in order\n     * @return a new {@code CopyOnWriteArraySet} containing those elements\n     * @since 12.0\n     */\n    @GwtIncompatible // CopyOnWriteArraySet\n    public static <E> CopyOnWriteArraySet<E> newCopyOnWriteArraySet(Iterable<? extends E> elements)\n    {\n        // We copy elements to an ArrayList first, rather than incurring the\n        // quadratic cost of adding them to the COWAS directly.\n        Collection<? extends E> elementsCollection =\n            (elements instanceof Collection)\n            ? Collections2.cast(elements)\n            : Lists.newArrayList(elements);\n        return new CopyOnWriteArraySet<E>(elementsCollection);\n    }\n\n    /**\n     * Creates an {@code EnumSet} consisting of all enum values that are not in the specified\n     * collection. If the collection is an {@link EnumSet}, this method has the same behavior as\n     * {@link EnumSet#complementOf}. Otherwise, the specified collection must contain at least one\n     * element, in order to determine the element type. If the collection could be empty, use {@link\n     * #complementOf(Collection, Class)} instead of this method.\n     *\n     * @param collection the collection whose complement should be stored in the enum set\n     * @return a new, modifiable {@code EnumSet} containing all values of the enum that aren't present\n     *     in the given collection\n     * @throws IllegalArgumentException if {@code collection} is not an {@code EnumSet} instance and\n     *     contains no elements\n     */\n    public static <E extends Enum<E>> EnumSet<E> complementOf(Collection<E> collection)\n    {\n        if (collection instanceof EnumSet)\n        {\n            return EnumSet.complementOf((EnumSet<E>) collection);\n        }\n        checkArgument(\n            !collection.isEmpty(), \"collection is empty; use the other version of this method\");\n        Class<E> type = collection.iterator().next().getDeclaringClass();\n        return makeComplementByHand(collection, type);\n    }\n\n    /**\n     * Creates an {@code EnumSet} consisting of all enum values that are not in the specified\n     * collection. This is equivalent to {@link EnumSet#complementOf}, but can act on any input\n     * collection, as long as the elements are of enum type.\n     *\n     * @param collection the collection whose complement should be stored in the {@code EnumSet}\n     * @param type the type of the elements in the set\n     * @return a new, modifiable {@code EnumSet} initially containing all the values of the enum not\n     *     present in the given collection\n     */\n    public static <E extends Enum<E>> EnumSet<E> complementOf(\n        Collection<E> collection, Class<E> type)\n    {\n        checkNotNull(collection);\n        return (collection instanceof EnumSet)\n               ? EnumSet.complementOf((EnumSet<E>) collection)\n               : makeComplementByHand(collection, type);\n    }\n\n    private static <E extends Enum<E>> EnumSet<E> makeComplementByHand(\n        Collection<E> collection, Class<E> type)\n    {\n        EnumSet<E> result = EnumSet.allOf(type);\n        result.removeAll(collection);\n        return result;\n    }\n\n    /**\n     * Returns a set backed by the specified map. The resulting set displays the same ordering,\n     * concurrency, and performance characteristics as the backing map. In essence, this factory\n     * method provides a {@link Set} implementation corresponding to any {@link Map} implementation.\n     * There is no need to use this method on a {@link Map} implementation that already has a\n     * corresponding {@link Set} implementation (such as {@link java.util.HashMap} or {@link\n     * java.util.TreeMap}).\n     *\n     * <p>Each method invocation on the set returned by this method results in exactly one method\n     * invocation on the backing map or its {@code keySet} view, with one exception. The {@code\n     * addAll} method is implemented as a sequence of {@code put} invocations on the backing map.\n     *\n     * <p>The specified map must be empty at the time this method is invoked, and should not be\n     * accessed directly after this method returns. These conditions are ensured if the map is created\n     * empty, passed directly to this method, and no reference to the map is retained, as illustrated\n     * in the following code fragment:\n     *\n     * <pre>{@code\n     * Set<Object> identityHashSet = Sets.newSetFromMap(\n     *     new IdentityHashMap<Object, Boolean>());\n     * }</pre>\n     *\n     * <p>The returned set is serializable if the backing map is.\n     *\n     * @param map the backing map\n     * @return the set backed by the map\n     * @throws IllegalArgumentException if {@code map} is not empty\n     * @deprecated Use {@link Collections#newSetFromMap} instead.\n     */\n    @Deprecated\n    public static <E> Set<E> newSetFromMap(Map<E, Boolean> map)\n    {\n        return Collections.newSetFromMap(map);\n    }\n\n    /**\n     * An unmodifiable view of a set which may be backed by other sets; this view will change as the\n     * backing sets do. Contains methods to copy the data into a new set which will then remain\n     * stable. There is usually no reason to retain a reference of type {@code SetView}; typically,\n     * you either use it as a plain {@link Set}, or immediately invoke {@link #immutableCopy} or\n     * {@link #copyInto} and forget the {@code SetView} itself.\n     *\n     * @since 2.0\n     */\n    public abstract static class SetView<E> extends AbstractSet<E>\n    {\n        private SetView() {} // no subclasses but our own\n\n        /**\n         * Returns an immutable copy of the current contents of this set view. Does not support null\n         * elements.\n         *\n         * <p><b>Warning:</b> this may have unexpected results if a backing set of this view uses a\n         * nonstandard notion of equivalence, for example if it is a {@link TreeSet} using a comparator\n         * that is inconsistent with {@link Object#equals(Object)}.\n         */\n        public ImmutableSet<E> immutableCopy()\n        {\n            return ImmutableSet.copyOf(this);\n        }\n\n        /**\n         * Copies the current contents of this set view into an existing set. This method has equivalent\n         * behavior to {@code set.addAll(this)}, assuming that all the sets involved are based on the\n         * same notion of equivalence.\n         *\n         * @return a reference to {@code set}, for convenience\n         */\n        // Note: S should logically extend Set<? super E> but can't due to either\n        // some javac bug or some weirdness in the spec, not sure which.\n        @CanIgnoreReturnValue\n        public <S extends Set<E>> S copyInto(S set)\n        {\n            set.addAll(this);\n            return set;\n        }\n\n        /**\n         * Guaranteed to throw an exception and leave the collection unmodified.\n         *\n         * @throws UnsupportedOperationException always\n         * @deprecated Unsupported operation.\n         */\n        @CanIgnoreReturnValue\n        @Deprecated\n        @Override\n        public final boolean add(E e)\n        {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * Guaranteed to throw an exception and leave the collection unmodified.\n         *\n         * @throws UnsupportedOperationException always\n         * @deprecated Unsupported operation.\n         */\n        @CanIgnoreReturnValue\n        @Deprecated\n        @Override\n        public final boolean remove(Object object)\n        {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * Guaranteed to throw an exception and leave the collection unmodified.\n         *\n         * @throws UnsupportedOperationException always\n         * @deprecated Unsupported operation.\n         */\n        @CanIgnoreReturnValue\n        @Deprecated\n        @Override\n        public final boolean addAll(Collection<? extends E> newElements)\n        {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * Guaranteed to throw an exception and leave the collection unmodified.\n         *\n         * @throws UnsupportedOperationException always\n         * @deprecated Unsupported operation.\n         */\n        @CanIgnoreReturnValue\n        @Deprecated\n        @Override\n        public final boolean removeAll(Collection<?> oldElements)\n        {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * Guaranteed to throw an exception and leave the collection unmodified.\n         *\n         * @throws UnsupportedOperationException always\n         * @deprecated Unsupported operation.\n         */\n        @CanIgnoreReturnValue\n        @Deprecated\n        @Override\n        public final boolean retainAll(Collection<?> elementsToKeep)\n        {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * Guaranteed to throw an exception and leave the collection unmodified.\n         *\n         * @throws UnsupportedOperationException always\n         * @deprecated Unsupported operation.\n         */\n        @Deprecated\n        @Override\n        public final void clear()\n        {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * Scope the return type to {@link UnmodifiableIterator} to ensure this is an unmodifiable view.\n         *\n         * @since 20.0 (present with return type {@link Iterator} since 2.0)\n         */\n        @Override\n        public abstract UnmodifiableIterator<E> iterator();\n    }\n\n    /**\n     * Returns an unmodifiable <b>view</b> of the union of two sets. The returned set contains all\n     * elements that are contained in either backing set. Iterating over the returned set iterates\n     * first over all the elements of {@code set1}, then over each element of {@code set2}, in order,\n     * that is not contained in {@code set1}.\n     *\n     * <p>Results are undefined if {@code set1} and {@code set2} are sets based on different\n     * equivalence relations (as {@link HashSet}, {@link TreeSet}, and the {@link Map#keySet} of an\n     * {@code IdentityHashMap} all are).\n     */\n    public static <E> SetView<E> union(final Set<? extends E> set1, final Set<? extends E> set2)\n    {\n        checkNotNull(set1, \"set1\");\n        checkNotNull(set2, \"set2\");\n\n        return new SetView<E>()\n        {\n            @Override\n            public int size()\n            {\n                int size = set1.size();\n                for (E e : set2)\n                {\n                    if (!set1.contains(e))\n                    {\n                        size++;\n                    }\n                }\n                return size;\n            }\n\n            @Override\n            public boolean isEmpty()\n            {\n                return set1.isEmpty() && set2.isEmpty();\n            }\n\n            @Override\n            public UnmodifiableIterator<E> iterator()\n            {\n                return new AbstractIterator<E>()\n                {\n                    final Iterator<? extends E> itr1 = set1.iterator();\n                    final Iterator<? extends E> itr2 = set2.iterator();\n\n                    @Override\n                    protected E computeNext()\n                    {\n                        if (itr1.hasNext())\n                        {\n                            return itr1.next();\n                        }\n                        while (itr2.hasNext())\n                        {\n                            E e = itr2.next();\n                            if (!set1.contains(e))\n                            {\n                                return e;\n                            }\n                        }\n                        return endOfData();\n                    }\n                };\n            }\n\n            @Override\n            public boolean contains(Object object)\n            {\n                return set1.contains(object) || set2.contains(object);\n            }\n\n            @Override\n            public <S extends Set<E>> S copyInto(S set)\n            {\n                set.addAll(set1);\n                set.addAll(set2);\n                return set;\n            }\n\n            @Override\n            public ImmutableSet<E> immutableCopy()\n            {\n                return new ImmutableSet.Builder<E>().addAll(set1).addAll(set2).build();\n            }\n        };\n    }\n\n    /**\n     * Returns an unmodifiable <b>view</b> of the intersection of two sets. The returned set contains\n     * all elements that are contained by both backing sets. The iteration order of the returned set\n     * matches that of {@code set1}.\n     *\n     * <p>Results are undefined if {@code set1} and {@code set2} are sets based on different\n     * equivalence relations (as {@code HashSet}, {@code TreeSet}, and the keySet of an {@code\n     * IdentityHashMap} all are).\n     *\n     * <p><b>Note:</b> The returned view performs slightly better when {@code set1} is the smaller of\n     * the two sets. If you have reason to believe one of your sets will generally be smaller than the\n     * other, pass it first. Unfortunately, since this method sets the generic type of the returned\n     * set based on the type of the first set passed, this could in rare cases force you to make a\n     * cast, for example:\n     *\n     * <pre>{@code\n     * Set<Object> aFewBadObjects = ...\n     * Set<String> manyBadStrings = ...\n     *\n     * // impossible for a non-String to be in the intersection\n     * SuppressWarnings(\"unchecked\")\n     * Set<String> badStrings = (Set) Sets.intersection(\n     *     aFewBadObjects, manyBadStrings);\n     * }</pre>\n     *\n     * <p>This is unfortunate, but should come up only very rarely.\n     */\n    public static <E> SetView<E> intersection(final Set<E> set1, final Set<?> set2)\n    {\n        checkNotNull(set1, \"set1\");\n        checkNotNull(set2, \"set2\");\n\n        return new SetView<E>()\n        {\n            @Override\n            public UnmodifiableIterator<E> iterator()\n            {\n                return new AbstractIterator<E>()\n                {\n                    final Iterator<E> itr = set1.iterator();\n\n                    @Override\n                    protected E computeNext()\n                    {\n                        while (itr.hasNext())\n                        {\n                            E e = itr.next();\n                            if (set2.contains(e))\n                            {\n                                return e;\n                            }\n                        }\n                        return endOfData();\n                    }\n                };\n            }\n\n            @Override\n            public int size()\n            {\n                int size = 0;\n                for (E e : set1)\n                {\n                    if (set2.contains(e))\n                    {\n                        size++;\n                    }\n                }\n                return size;\n            }\n\n            @Override\n            public boolean isEmpty()\n            {\n                return Collections.disjoint(set2, set1);\n            }\n\n            @Override\n            public boolean contains(Object object)\n            {\n                return set1.contains(object) && set2.contains(object);\n            }\n\n            @Override\n            public boolean containsAll(Collection<?> collection)\n            {\n                return set1.containsAll(collection) && set2.containsAll(collection);\n            }\n        };\n    }\n\n    /**\n     * Returns an unmodifiable <b>view</b> of the difference of two sets. The returned set contains\n     * all elements that are contained by {@code set1} and not contained by {@code set2}. {@code set2}\n     * may also contain elements not present in {@code set1}; these are simply ignored. The iteration\n     * order of the returned set matches that of {@code set1}.\n     *\n     * <p>Results are undefined if {@code set1} and {@code set2} are sets based on different\n     * equivalence relations (as {@code HashSet}, {@code TreeSet}, and the keySet of an {@code\n     * IdentityHashMap} all are).\n     */\n    public static <E> SetView<E> difference(final Set<E> set1, final Set<?> set2)\n    {\n        checkNotNull(set1, \"set1\");\n        checkNotNull(set2, \"set2\");\n\n        return new SetView<E>()\n        {\n            @Override\n            public UnmodifiableIterator<E> iterator()\n            {\n                return new AbstractIterator<E>()\n                {\n                    final Iterator<E> itr = set1.iterator();\n\n                    @Override\n                    protected E computeNext()\n                    {\n                        while (itr.hasNext())\n                        {\n                            E e = itr.next();\n                            if (!set2.contains(e))\n                            {\n                                return e;\n                            }\n                        }\n                        return endOfData();\n                    }\n                };\n            }\n\n            @Override\n            public int size()\n            {\n                int size = 0;\n                for (E e : set1)\n                {\n                    if (!set2.contains(e))\n                    {\n                        size++;\n                    }\n                }\n                return size;\n            }\n\n            @Override\n            public boolean isEmpty()\n            {\n                return set2.containsAll(set1);\n            }\n\n            @Override\n            public boolean contains(Object element)\n            {\n                return set1.contains(element) && !set2.contains(element);\n            }\n        };\n    }\n\n    /**\n     * Returns an unmodifiable <b>view</b> of the symmetric difference of two sets. The returned set\n     * contains all elements that are contained in either {@code set1} or {@code set2} but not in\n     * both. The iteration order of the returned set is undefined.\n     *\n     * <p>Results are undefined if {@code set1} and {@code set2} are sets based on different\n     * equivalence relations (as {@code HashSet}, {@code TreeSet}, and the keySet of an {@code\n     * IdentityHashMap} all are).\n     *\n     * @since 3.0\n     */\n    public static <E> SetView<E> symmetricDifference(\n        final Set<? extends E> set1, final Set<? extends E> set2)\n    {\n        checkNotNull(set1, \"set1\");\n        checkNotNull(set2, \"set2\");\n\n        return new SetView<E>()\n        {\n            @Override\n            public UnmodifiableIterator<E> iterator()\n            {\n                final Iterator<? extends E> itr1 = set1.iterator();\n                final Iterator<? extends E> itr2 = set2.iterator();\n                return new AbstractIterator<E>()\n                {\n                    @Override\n                    public E computeNext()\n                    {\n                        while (itr1.hasNext())\n                        {\n                            E elem1 = itr1.next();\n                            if (!set2.contains(elem1))\n                            {\n                                return elem1;\n                            }\n                        }\n                        while (itr2.hasNext())\n                        {\n                            E elem2 = itr2.next();\n                            if (!set1.contains(elem2))\n                            {\n                                return elem2;\n                            }\n                        }\n                        return endOfData();\n                    }\n                };\n            }\n\n            @Override\n            public int size()\n            {\n                int size = 0;\n                for (E e : set1)\n                {\n                    if (!set2.contains(e))\n                    {\n                        size++;\n                    }\n                }\n                for (E e : set2)\n                {\n                    if (!set1.contains(e))\n                    {\n                        size++;\n                    }\n                }\n                return size;\n            }\n\n            @Override\n            public boolean isEmpty()\n            {\n                return set1.equals(set2);\n            }\n\n            @Override\n            public boolean contains(Object element)\n            {\n                return set1.contains(element) ^ set2.contains(element);\n            }\n        };\n    }\n\n    /**\n     * Returns the elements of {@code unfiltered} that satisfy a predicate. The returned set is a live\n     * view of {@code unfiltered}; changes to one affect the other.\n     *\n     * <p>The resulting set's iterator does not support {@code remove()}, but all other set methods\n     * are supported. When given an element that doesn't satisfy the predicate, the set's {@code\n     * add()} and {@code addAll()} methods throw an {@link IllegalArgumentException}. When methods\n     * such as {@code removeAll()} and {@code clear()} are called on the filtered set, only elements\n     * that satisfy the filter will be removed from the underlying set.\n     *\n     * <p>The returned set isn't threadsafe or serializable, even if {@code unfiltered} is.\n     *\n     * <p>Many of the filtered set's methods, such as {@code size()}, iterate across every element in\n     * the underlying set and determine which elements satisfy the filter. When a live view is\n     * <i>not</i> needed, it may be faster to copy {@code Iterables.filter(unfiltered, predicate)} and\n     * use the copy.\n     *\n     * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>, as documented at\n     * {@link Predicate#apply}. Do not provide a predicate such as {@code\n     * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link\n     * Iterables#filter(Iterable, Class)} for related functionality.)\n     *\n     * <p><b>Java 8 users:</b> many use cases for this method are better addressed by {@link\n     * java.util.stream.Stream#filter}. This method is not being deprecated, but we gently encourage\n     * you to migrate to streams.\n     */\n    // TODO(kevinb): how to omit that last sentence when building GWT javadoc?\n    public static <E> Set<E> filter(Set<E> unfiltered, Predicate<? super E> predicate)\n    {\n        if (unfiltered instanceof SortedSet)\n        {\n            return filter((SortedSet<E>) unfiltered, predicate);\n        }\n        if (unfiltered instanceof FilteredSet)\n        {\n            // Support clear(), removeAll(), and retainAll() when filtering a filtered\n            // collection.\n            FilteredSet<E> filtered = (FilteredSet<E>) unfiltered;\n            Predicate<E> combinedPredicate = Predicates.<E> and (filtered.predicate, predicate);\n            return new FilteredSet<E>((Set<E>) filtered.unfiltered, combinedPredicate);\n        }\n\n        return new FilteredSet<E>(checkNotNull(unfiltered), checkNotNull(predicate));\n    }\n\n    /**\n     * Returns the elements of a {@code SortedSet}, {@code unfiltered}, that satisfy a predicate. The\n     * returned set is a live view of {@code unfiltered}; changes to one affect the other.\n     *\n     * <p>The resulting set's iterator does not support {@code remove()}, but all other set methods\n     * are supported. When given an element that doesn't satisfy the predicate, the set's {@code\n     * add()} and {@code addAll()} methods throw an {@link IllegalArgumentException}. When methods\n     * such as {@code removeAll()} and {@code clear()} are called on the filtered set, only elements\n     * that satisfy the filter will be removed from the underlying set.\n     *\n     * <p>The returned set isn't threadsafe or serializable, even if {@code unfiltered} is.\n     *\n     * <p>Many of the filtered set's methods, such as {@code size()}, iterate across every element in\n     * the underlying set and determine which elements satisfy the filter. When a live view is\n     * <i>not</i> needed, it may be faster to copy {@code Iterables.filter(unfiltered, predicate)} and\n     * use the copy.\n     *\n     * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>, as documented at\n     * {@link Predicate#apply}. Do not provide a predicate such as {@code\n     * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link\n     * Iterables#filter(Iterable, Class)} for related functionality.)\n     *\n     * @since 11.0\n     */\n    public static <E> SortedSet<E> filter(SortedSet<E> unfiltered, Predicate<? super E> predicate)\n    {\n        if (unfiltered instanceof FilteredSet)\n        {\n            // Support clear(), removeAll(), and retainAll() when filtering a filtered\n            // collection.\n            FilteredSet<E> filtered = (FilteredSet<E>) unfiltered;\n            Predicate<E> combinedPredicate = Predicates.<E> and (filtered.predicate, predicate);\n            return new FilteredSortedSet<E>((SortedSet<E>) filtered.unfiltered, combinedPredicate);\n        }\n\n        return new FilteredSortedSet<E>(checkNotNull(unfiltered), checkNotNull(predicate));\n    }\n\n    /**\n     * Returns the elements of a {@code NavigableSet}, {@code unfiltered}, that satisfy a predicate.\n     * The returned set is a live view of {@code unfiltered}; changes to one affect the other.\n     *\n     * <p>The resulting set's iterator does not support {@code remove()}, but all other set methods\n     * are supported. When given an element that doesn't satisfy the predicate, the set's {@code\n     * add()} and {@code addAll()} methods throw an {@link IllegalArgumentException}. When methods\n     * such as {@code removeAll()} and {@code clear()} are called on the filtered set, only elements\n     * that satisfy the filter will be removed from the underlying set.\n     *\n     * <p>The returned set isn't threadsafe or serializable, even if {@code unfiltered} is.\n     *\n     * <p>Many of the filtered set's methods, such as {@code size()}, iterate across every element in\n     * the underlying set and determine which elements satisfy the filter. When a live view is\n     * <i>not</i> needed, it may be faster to copy {@code Iterables.filter(unfiltered, predicate)} and\n     * use the copy.\n     *\n     * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>, as documented at\n     * {@link Predicate#apply}. Do not provide a predicate such as {@code\n     * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link\n     * Iterables#filter(Iterable, Class)} for related functionality.)\n     *\n     * @since 14.0\n     */\n    @GwtIncompatible // NavigableSet\n    @SuppressWarnings(\"unchecked\")\n    public static <E> NavigableSet<E> filter(\n        NavigableSet<E> unfiltered, Predicate<? super E> predicate)\n    {\n        if (unfiltered instanceof FilteredSet)\n        {\n            // Support clear(), removeAll(), and retainAll() when filtering a filtered\n            // collection.\n            FilteredSet<E> filtered = (FilteredSet<E>) unfiltered;\n            Predicate<E> combinedPredicate = Predicates.<E> and (filtered.predicate, predicate);\n            return new FilteredNavigableSet<E>((NavigableSet<E>) filtered.unfiltered, combinedPredicate);\n        }\n\n        return new FilteredNavigableSet<E>(checkNotNull(unfiltered), checkNotNull(predicate));\n    }\n\n    private static class FilteredSet<E> extends FilteredCollection<E> implements Set<E>\n    {\n        FilteredSet(Set<E> unfiltered, Predicate<? super E> predicate)\n        {\n            super(unfiltered, predicate);\n        }\n\n        @Override\n        public boolean equals(@NullableDecl Object object)\n        {\n            return equalsImpl(this, object);\n        }\n\n        @Override\n        public int hashCode()\n        {\n            return hashCodeImpl(this);\n        }\n    }\n\n    private static class FilteredSortedSet<E> extends FilteredSet<E> implements SortedSet<E>\n    {\n\n        FilteredSortedSet(SortedSet<E> unfiltered, Predicate<? super E> predicate)\n        {\n            super(unfiltered, predicate);\n        }\n\n        @Override\n        public Comparator<? super E> comparator()\n        {\n            return ((SortedSet<E>) unfiltered).comparator();\n        }\n\n        @Override\n        public SortedSet<E> subSet(E fromElement, E toElement)\n        {\n            return new FilteredSortedSet<E>(\n                       ((SortedSet<E>) unfiltered).subSet(fromElement, toElement), predicate);\n        }\n\n        @Override\n        public SortedSet<E> headSet(E toElement)\n        {\n            return new FilteredSortedSet<E>(((SortedSet<E>) unfiltered).headSet(toElement), predicate);\n        }\n\n        @Override\n        public SortedSet<E> tailSet(E fromElement)\n        {\n            return new FilteredSortedSet<E>(((SortedSet<E>) unfiltered).tailSet(fromElement), predicate);\n        }\n\n        @Override\n        public E first()\n        {\n            return Iterators.find(unfiltered.iterator(), predicate);\n        }\n\n        @Override\n        public E last()\n        {\n            SortedSet<E> sortedUnfiltered = (SortedSet<E>) unfiltered;\n            while (true)\n            {\n                E element = sortedUnfiltered.last();\n                if (predicate.apply(element))\n                {\n                    return element;\n                }\n                sortedUnfiltered = sortedUnfiltered.headSet(element);\n            }\n        }\n    }\n\n    @GwtIncompatible // NavigableSet\n    private static class FilteredNavigableSet<E> extends FilteredSortedSet<E>\n        implements NavigableSet<E>\n    {\n        FilteredNavigableSet(NavigableSet<E> unfiltered, Predicate<? super E> predicate)\n        {\n            super(unfiltered, predicate);\n        }\n\n        NavigableSet<E> unfiltered()\n        {\n            return (NavigableSet<E>) unfiltered;\n        }\n\n        @Override\n        @NullableDecl\n        public E lower(E e)\n        {\n            return Iterators.find(unfiltered().headSet(e, false).descendingIterator(), predicate, null);\n        }\n\n        @Override\n        @NullableDecl\n        public E floor(E e)\n        {\n            return Iterators.find(unfiltered().headSet(e, true).descendingIterator(), predicate, null);\n        }\n\n        @Override\n        public E ceiling(E e)\n        {\n            return Iterables.find(unfiltered().tailSet(e, true), predicate, null);\n        }\n\n        @Override\n        public E higher(E e)\n        {\n            return Iterables.find(unfiltered().tailSet(e, false), predicate, null);\n        }\n\n        @Override\n        public E pollFirst()\n        {\n            return Iterables.removeFirstMatching(unfiltered(), predicate);\n        }\n\n        @Override\n        public E pollLast()\n        {\n            return Iterables.removeFirstMatching(unfiltered().descendingSet(), predicate);\n        }\n\n        @Override\n        public NavigableSet<E> descendingSet()\n        {\n            return Sets.filter(unfiltered().descendingSet(), predicate);\n        }\n\n        @Override\n        public Iterator<E> descendingIterator()\n        {\n            return Iterators.filter(unfiltered().descendingIterator(), predicate);\n        }\n\n        @Override\n        public E last()\n        {\n            return Iterators.find(unfiltered().descendingIterator(), predicate);\n        }\n\n        @Override\n        public NavigableSet<E> subSet(\n            E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)\n        {\n            return filter(\n                       unfiltered().subSet(fromElement, fromInclusive, toElement, toInclusive), predicate);\n        }\n\n        @Override\n        public NavigableSet<E> headSet(E toElement, boolean inclusive)\n        {\n            return filter(unfiltered().headSet(toElement, inclusive), predicate);\n        }\n\n        @Override\n        public NavigableSet<E> tailSet(E fromElement, boolean inclusive)\n        {\n            return filter(unfiltered().tailSet(fromElement, inclusive), predicate);\n        }\n    }\n\n    /**\n     * Returns every possible list that can be formed by choosing one element from each of the given\n     * sets in order; the \"n-ary <a href=\"http://en.wikipedia.org/wiki/Cartesian_product\">Cartesian\n     * product</a>\" of the sets. For example:\n     *\n     * <pre>{@code\n     * Sets.cartesianProduct(ImmutableList.of(\n     *     ImmutableSet.of(1, 2),\n     *     ImmutableSet.of(\"A\", \"B\", \"C\")))\n     * }</pre>\n     *\n     * <p>returns a set containing six lists:\n     *\n     * <ul>\n     *   <li>{@code ImmutableList.of(1, \"A\")}\n     *   <li>{@code ImmutableList.of(1, \"B\")}\n     *   <li>{@code ImmutableList.of(1, \"C\")}\n     *   <li>{@code ImmutableList.of(2, \"A\")}\n     *   <li>{@code ImmutableList.of(2, \"B\")}\n     *   <li>{@code ImmutableList.of(2, \"C\")}\n     * </ul>\n     *\n     * <p>The result is guaranteed to be in the \"traditional\", lexicographical order for Cartesian\n     * products that you would get from nesting for loops:\n     *\n     * <pre>{@code\n     * for (B b0 : sets.get(0)) {\n     *   for (B b1 : sets.get(1)) {\n     *     ...\n     *     ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);\n     *     // operate on tuple\n     *   }\n     * }\n     * }</pre>\n     *\n     * <p>Note that if any input set is empty, the Cartesian product will also be empty. If no sets at\n     * all are provided (an empty list), the resulting Cartesian product has one element, an empty\n     * list (counter-intuitive, but mathematically consistent).\n     *\n     * <p><i>Performance notes:</i> while the cartesian product of sets of size {@code m, n, p} is a\n     * set of size {@code m x n x p}, its actual memory consumption is much smaller. When the\n     * cartesian set is constructed, the input sets are merely copied. Only as the resulting set is\n     * iterated are the individual lists created, and these are not retained after iteration.\n     *\n     * @param sets the sets to choose elements from, in the order that the elements chosen from those\n     *     sets should appear in the resulting lists\n     * @param <B> any common base class shared by all axes (often just {@link Object})\n     * @return the Cartesian product, as an immutable set containing immutable lists\n     * @throws NullPointerException if {@code sets}, any one of the {@code sets}, or any element of a\n     *     provided set is null\n     * @since 2.0\n     */\n    public static <B> Set<List<B>> cartesianProduct(List<? extends Set<? extends B>> sets)\n    {\n        return CartesianSet.create(sets);\n    }\n\n    /**\n     * Returns every possible list that can be formed by choosing one element from each of the given\n     * sets in order; the \"n-ary <a href=\"http://en.wikipedia.org/wiki/Cartesian_product\">Cartesian\n     * product</a>\" of the sets. For example:\n     *\n     * <pre>{@code\n     * Sets.cartesianProduct(\n     *     ImmutableSet.of(1, 2),\n     *     ImmutableSet.of(\"A\", \"B\", \"C\"))\n     * }</pre>\n     *\n     * <p>returns a set containing six lists:\n     *\n     * <ul>\n     *   <li>{@code ImmutableList.of(1, \"A\")}\n     *   <li>{@code ImmutableList.of(1, \"B\")}\n     *   <li>{@code ImmutableList.of(1, \"C\")}\n     *   <li>{@code ImmutableList.of(2, \"A\")}\n     *   <li>{@code ImmutableList.of(2, \"B\")}\n     *   <li>{@code ImmutableList.of(2, \"C\")}\n     * </ul>\n     *\n     * <p>The result is guaranteed to be in the \"traditional\", lexicographical order for Cartesian\n     * products that you would get from nesting for loops:\n     *\n     * <pre>{@code\n     * for (B b0 : sets.get(0)) {\n     *   for (B b1 : sets.get(1)) {\n     *     ...\n     *     ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);\n     *     // operate on tuple\n     *   }\n     * }\n     * }</pre>\n     *\n     * <p>Note that if any input set is empty, the Cartesian product will also be empty. If no sets at\n     * all are provided (an empty list), the resulting Cartesian product has one element, an empty\n     * list (counter-intuitive, but mathematically consistent).\n     *\n     * <p><i>Performance notes:</i> while the cartesian product of sets of size {@code m, n, p} is a\n     * set of size {@code m x n x p}, its actual memory consumption is much smaller. When the\n     * cartesian set is constructed, the input sets are merely copied. Only as the resulting set is\n     * iterated are the individual lists created, and these are not retained after iteration.\n     *\n     * @param sets the sets to choose elements from, in the order that the elements chosen from those\n     *     sets should appear in the resulting lists\n     * @param <B> any common base class shared by all axes (often just {@link Object})\n     * @return the Cartesian product, as an immutable set containing immutable lists\n     * @throws NullPointerException if {@code sets}, any one of the {@code sets}, or any element of a\n     *     provided set is null\n     * @since 2.0\n     */\n    @SafeVarargs\n    public static <B> Set<List<B>> cartesianProduct(Set<? extends B>... sets)\n    {\n        return cartesianProduct(Arrays.asList(sets));\n    }\n\n    private static final class CartesianSet<E> extends ForwardingCollection<List<E>>\n        implements Set<List<E>>\n    {\n        private final transient ImmutableList<ImmutableSet<E>> axes;\n        private final transient CartesianList<E> delegate;\n\n        static <E> Set<List<E>> create(List<? extends Set<? extends E>> sets)\n        {\n            ImmutableList.Builder<ImmutableSet<E>> axesBuilder = new ImmutableList.Builder<>(sets.size());\n            for (Set<? extends E> set : sets)\n            {\n                ImmutableSet<E> copy = ImmutableSet.copyOf(set);\n                if (copy.isEmpty())\n                {\n                    return ImmutableSet.of();\n                }\n                axesBuilder.add(copy);\n            }\n            final ImmutableList<ImmutableSet<E>> axes = axesBuilder.build();\n            ImmutableList<List<E>> listAxes =\n                new ImmutableList<List<E>>()\n            {\n                @Override\n                public int size()\n                {\n                    return axes.size();\n                }\n\n                @Override\n                public List<E> get(int index)\n                {\n                    return axes.get(index).asList();\n                }\n\n                @Override\n                boolean isPartialView()\n                {\n                    return true;\n                }\n            };\n            return new CartesianSet<E>(axes, new CartesianList<E>(listAxes));\n        }\n\n        private CartesianSet(ImmutableList<ImmutableSet<E>> axes, CartesianList<E> delegate)\n        {\n            this.axes = axes;\n            this.delegate = delegate;\n        }\n\n        @Override\n        protected Collection<List<E>> delegate()\n        {\n            return delegate;\n        }\n\n        @Override\n        public boolean equals(@NullableDecl Object object)\n        {\n            // Warning: this is broken if size() == 0, so it is critical that we\n            // substitute an empty ImmutableSet to the user in place of this\n            if (object instanceof CartesianSet)\n            {\n                CartesianSet<?> that = (CartesianSet<?>) object;\n                return this.axes.equals(that.axes);\n            }\n            return super.equals(object);\n        }\n\n        @Override\n        public int hashCode()\n        {\n            // Warning: this is broken if size() == 0, so it is critical that we\n            // substitute an empty ImmutableSet to the user in place of this\n\n            // It's a weird formula, but tests prove it works.\n            int adjust = size() - 1;\n            for (int i = 0; i < axes.size(); i++)\n            {\n                adjust *= 31;\n                adjust = ~~adjust;\n                // in GWT, we have to deal with integer overflow carefully\n            }\n            int hash = 1;\n            for (Set<E> axis : axes)\n            {\n                hash = 31 * hash + (size() / axis.size() * axis.hashCode());\n\n                hash = ~~hash;\n            }\n            hash += adjust;\n            return ~~hash;\n        }\n    }\n\n    /**\n     * Returns the set of all possible subsets of {@code set}. For example, {@code\n     * powerSet(ImmutableSet.of(1, 2))} returns the set {@code {{}, {1}, {2}, {1, 2}}}.\n     *\n     * <p>Elements appear in these subsets in the same iteration order as they appeared in the input\n     * set. The order in which these subsets appear in the outer set is undefined. Note that the power\n     * set of the empty set is not the empty set, but a one-element set containing the empty set.\n     *\n     * <p>The returned set and its constituent sets use {@code equals} to decide whether two elements\n     * are identical, even if the input set uses a different concept of equivalence.\n     *\n     * <p><i>Performance notes:</i> while the power set of a set with size {@code n} is of size {@code\n     * 2^n}, its memory usage is only {@code O(n)}. When the power set is constructed, the input set\n     * is merely copied. Only as the power set is iterated are the individual subsets created, and\n     * these subsets themselves occupy only a small constant amount of memory.\n     *\n     * @param set the set of elements to construct a power set from\n     * @return the power set, as an immutable set of immutable sets\n     * @throws IllegalArgumentException if {@code set} has more than 30 unique elements (causing the\n     *     power set size to exceed the {@code int} range)\n     * @throws NullPointerException if {@code set} is or contains {@code null}\n     * @see <a href=\"http://en.wikipedia.org/wiki/Power_set\">Power set article at Wikipedia</a>\n     * @since 4.0\n     */\n    @GwtCompatible(serializable = false)\n    public static <E> Set<Set<E>> powerSet(Set<E> set)\n    {\n        return new PowerSet<E>(set);\n    }\n\n    private static final class SubSet<E> extends AbstractSet<E>\n    {\n        private final ImmutableMap<E, Integer> inputSet;\n        private final int mask;\n\n        SubSet(ImmutableMap<E, Integer> inputSet, int mask)\n        {\n            this.inputSet = inputSet;\n            this.mask = mask;\n        }\n\n        @Override\n        public Iterator<E> iterator()\n        {\n            return new UnmodifiableIterator<E>()\n            {\n                final ImmutableList<E> elements = inputSet.keySet().asList();\n                int remainingSetBits = mask;\n\n                @Override\n                public boolean hasNext()\n                {\n                    return remainingSetBits != 0;\n                }\n\n                @Override\n                public E next()\n                {\n                    int index = Integer.numberOfTrailingZeros(remainingSetBits);\n                    if (index == 32)\n                    {\n                        throw new NoSuchElementException();\n                    }\n                    remainingSetBits &= ~(1 << index);\n                    return elements.get(index);\n                }\n            };\n        }\n\n        @Override\n        public int size()\n        {\n            return Integer.bitCount(mask);\n        }\n\n        @Override\n        public boolean contains(@NullableDecl Object o)\n        {\n            Integer index = inputSet.get(o);\n            return index != null && (mask & (1 << index)) != 0;\n        }\n    }\n\n    private static final class PowerSet<E> extends AbstractSet<Set<E>>\n    {\n        final ImmutableMap<E, Integer> inputSet;\n\n        PowerSet(Set<E> input)\n        {\n            checkArgument(\n                input.size() <= 30, \"Too many elements to create power set: %s > 30\", input.size());\n            this.inputSet = Maps.indexMap(input);\n        }\n\n        @Override\n        public int size()\n        {\n            return 1 << inputSet.size();\n        }\n\n        @Override\n        public boolean isEmpty()\n        {\n            return false;\n        }\n\n        @Override\n        public Iterator<Set<E>> iterator()\n        {\n            return new AbstractIndexedListIterator<Set<E>>(size())\n            {\n                @Override\n                protected Set<E> get(final int setBits)\n                {\n                    return new SubSet<E>(inputSet, setBits);\n                }\n            };\n        }\n\n        @Override\n        public boolean contains(@NullableDecl Object obj)\n        {\n            if (obj instanceof Set)\n            {\n                Set<?> set = (Set<?>) obj;\n                return inputSet.keySet().containsAll(set);\n            }\n            return false;\n        }\n\n        @Override\n        public boolean equals(@NullableDecl Object obj)\n        {\n            if (obj instanceof PowerSet)\n            {\n                PowerSet<?> that = (PowerSet<?>) obj;\n                return inputSet.equals(that.inputSet);\n            }\n            return super.equals(obj);\n        }\n\n        @Override\n        public int hashCode()\n        {\n            /*\n             * The sum of the sums of the hash codes in each subset is just the sum of\n             * each input element's hash code times the number of sets that element\n             * appears in. Each element appears in exactly half of the 2^n sets, so:\n             */\n            return inputSet.keySet().hashCode() << (inputSet.size() - 1);\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"powerSet(\" + inputSet + \")\";\n        }\n    }\n\n    /**\n     * Returns the set of all subsets of {@code set} of size {@code size}. For example, {@code\n     * combinations(ImmutableSet.of(1, 2, 3), 2)} returns the set {@code {{1, 2}, {1, 3}, {2, 3}}}.\n     *\n     * <p>Elements appear in these subsets in the same iteration order as they appeared in the input\n     * set. The order in which these subsets appear in the outer set is undefined.\n     *\n     * <p>The returned set and its constituent sets use {@code equals} to decide whether two elements\n     * are identical, even if the input set uses a different concept of equivalence.\n     *\n     * <p><i>Performance notes:</i> the memory usage of the returned set is only {@code O(n)}. When\n     * the result set is constructed, the input set is merely copied. Only as the result set is\n     * iterated are the individual subsets created. Each of these subsets occupies an additional O(n)\n     * memory but only for as long as the user retains a reference to it. That is, the set returned by\n     * {@code combinations} does not retain the individual subsets.\n     *\n     * @param set the set of elements to take combinations of\n     * @param size the number of elements per combination\n     * @return the set of all combinations of {@code size} elements from {@code set}\n     * @throws IllegalArgumentException if {@code size} is not between 0 and {@code set.size()}\n     *     inclusive\n     * @throws NullPointerException if {@code set} is or contains {@code null}\n     * @since 23.0\n     */\n    @Beta\n    public static <E> Set<Set<E>> combinations(Set<E> set, final int size)\n    {\n        final ImmutableMap<E, Integer> index = Maps.indexMap(set);\n        checkNonnegative(size, \"size\");\n        checkArgument(size <= index.size(), \"size (%s) must be <= set.size() (%s)\", size, index.size());\n        if (size == 0)\n        {\n            return ImmutableSet.<Set<E>>of(ImmutableSet.<E>of());\n        }\n        else if (size == index.size())\n        {\n            return ImmutableSet.<Set<E>>of(index.keySet());\n        }\n        return new AbstractSet<Set<E>>()\n        {\n            @Override\n            public boolean contains(@NullableDecl Object o)\n            {\n                if (o instanceof Set)\n                {\n                    Set<?> s = (Set<?>) o;\n                    return s.size() == size && index.keySet().containsAll(s);\n                }\n                return false;\n            }\n\n            @Override\n            public Iterator<Set<E>> iterator()\n            {\n                return new AbstractIterator<Set<E>>()\n                {\n                    final BitSet bits = new BitSet(index.size());\n\n                    @Override\n                    protected Set<E> computeNext()\n                    {\n                        if (bits.isEmpty())\n                        {\n                            bits.set(0, size);\n                        }\n                        else\n                        {\n                            int firstSetBit = bits.nextSetBit(0);\n                            int bitToFlip = bits.nextClearBit(firstSetBit);\n\n                            if (bitToFlip == index.size())\n                            {\n                                return endOfData();\n                            }\n                            /*\n                             * The current set in sorted order looks like\n                             * {firstSetBit, firstSetBit + 1, ..., bitToFlip - 1, ...}\n                             * where it does *not* contain bitToFlip.\n                             *\n                             * The next combination is\n                             *\n                             * {0, 1, ..., bitToFlip - firstSetBit - 2, bitToFlip, ...}\n                             *\n                             * This is lexicographically next if you look at the combinations in descending order\n                             * e.g. {2, 1, 0}, {3, 1, 0}, {3, 2, 0}, {3, 2, 1}, {4, 1, 0}...\n                             */\n\n                            bits.set(0, bitToFlip - firstSetBit - 1);\n                            bits.clear(bitToFlip - firstSetBit - 1, bitToFlip);\n                            bits.set(bitToFlip);\n                        }\n                        final BitSet copy = (BitSet) bits.clone();\n                        return new AbstractSet<E>()\n                        {\n                            @Override\n                            public boolean contains(@NullableDecl Object o)\n                            {\n                                Integer i = index.get(o);\n                                return i != null && copy.get(i);\n                            }\n\n                            @Override\n                            public Iterator<E> iterator()\n                            {\n                                return new AbstractIterator<E>()\n                                {\n                                    int i = -1;\n\n                                    @Override\n                                    protected E computeNext()\n                                    {\n                                        i = copy.nextSetBit(i + 1);\n                                        if (i == -1)\n                                        {\n                                            return endOfData();\n                                        }\n                                        return index.keySet().asList().get(i);\n                                    }\n                                };\n                            }\n\n                            @Override\n                            public int size()\n                            {\n                                return size;\n                            }\n                        };\n                    }\n                };\n            }\n\n            @Override\n            public int size()\n            {\n                return IntMath.binomial(index.size(), size);\n            }\n\n            @Override\n            public String toString()\n            {\n                return \"Sets.combinations(\" + index.keySet() + \", \" + size + \")\";\n            }\n        };\n    }\n\n    /** An implementation for {@link Set#hashCode()}. */\n    static int hashCodeImpl(Set<?> s)\n    {\n        int hashCode = 0;\n        for (Object o : s)\n        {\n            hashCode += o != null ? o.hashCode() : 0;\n\n            hashCode = ~~hashCode;\n            // Needed to deal with unusual integer overflow in GWT.\n        }\n        return hashCode;\n    }\n\n    /** An implementation for {@link Set#equals(Object)}. */\n    static boolean equalsImpl(Set<?> s, @NullableDecl Object object)\n    {\n        if (s == object)\n        {\n            return true;\n        }\n        if (object instanceof Set)\n        {\n            Set<?> o = (Set<?>) object;\n\n            try\n            {\n                return s.size() == o.size() && s.containsAll(o);\n            }\n            catch (NullPointerException | ClassCastException ignored)\n            {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns an unmodifiable view of the specified navigable set. This method allows modules to\n     * provide users with \"read-only\" access to internal navigable sets. Query operations on the\n     * returned set \"read through\" to the specified set, and attempts to modify the returned set,\n     * whether direct or via its collection views, result in an {@code UnsupportedOperationException}.\n     *\n     * <p>The returned navigable set will be serializable if the specified navigable set is\n     * serializable.\n     *\n     * @param set the navigable set for which an unmodifiable view is to be returned\n     * @return an unmodifiable view of the specified navigable set\n     * @since 12.0\n     */\n    public static <E> NavigableSet<E> unmodifiableNavigableSet(NavigableSet<E> set)\n    {\n        if (set instanceof ImmutableCollection || set instanceof UnmodifiableNavigableSet)\n        {\n            return set;\n        }\n        return new UnmodifiableNavigableSet<E>(set);\n    }\n\n    static final class UnmodifiableNavigableSet<E> extends ForwardingSortedSet<E>\n        implements NavigableSet<E>, Serializable\n    {\n        private final NavigableSet<E> delegate;\n        private final SortedSet<E> unmodifiableDelegate;\n\n        UnmodifiableNavigableSet(NavigableSet<E> delegate)\n        {\n            this.delegate = checkNotNull(delegate);\n            this.unmodifiableDelegate = Collections.unmodifiableSortedSet(delegate);\n        }\n\n        @Override\n        protected SortedSet<E> delegate()\n        {\n            return unmodifiableDelegate;\n        }\n\n        @Override\n        public E lower(E e)\n        {\n            return delegate.lower(e);\n        }\n\n        @Override\n        public E floor(E e)\n        {\n            return delegate.floor(e);\n        }\n\n        @Override\n        public E ceiling(E e)\n        {\n            return delegate.ceiling(e);\n        }\n\n        @Override\n        public E higher(E e)\n        {\n            return delegate.higher(e);\n        }\n\n        @Override\n        public E pollFirst()\n        {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public E pollLast()\n        {\n            throw new UnsupportedOperationException();\n        }\n\n        @MonotonicNonNullDecl private transient UnmodifiableNavigableSet<E> descendingSet;\n\n        @Override\n        public NavigableSet<E> descendingSet()\n        {\n            UnmodifiableNavigableSet<E> result = descendingSet;\n            if (result == null)\n            {\n                result = descendingSet = new UnmodifiableNavigableSet<E>(delegate.descendingSet());\n                result.descendingSet = this;\n            }\n            return result;\n        }\n\n        @Override\n        public Iterator<E> descendingIterator()\n        {\n            return Iterators.unmodifiableIterator(delegate.descendingIterator());\n        }\n\n        @Override\n        public NavigableSet<E> subSet(\n            E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)\n        {\n            return unmodifiableNavigableSet(\n                       delegate.subSet(fromElement, fromInclusive, toElement, toInclusive));\n        }\n\n        @Override\n        public NavigableSet<E> headSet(E toElement, boolean inclusive)\n        {\n            return unmodifiableNavigableSet(delegate.headSet(toElement, inclusive));\n        }\n\n        @Override\n        public NavigableSet<E> tailSet(E fromElement, boolean inclusive)\n        {\n            return unmodifiableNavigableSet(delegate.tailSet(fromElement, inclusive));\n        }\n\n        private static final long serialVersionUID = 0;\n    }\n\n    /**\n     * Returns a synchronized (thread-safe) navigable set backed by the specified navigable set. In\n     * order to guarantee serial access, it is critical that <b>all</b> access to the backing\n     * navigable set is accomplished through the returned navigable set (or its views).\n     *\n     * <p>It is imperative that the user manually synchronize on the returned sorted set when\n     * iterating over it or any of its {@code descendingSet}, {@code subSet}, {@code headSet}, or\n     * {@code tailSet} views.\n     *\n     * <pre>{@code\n     * NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>());\n     *  ...\n     * synchronized (set) {\n     *   // Must be in the synchronized block\n     *   Iterator<E> it = set.iterator();\n     *   while (it.hasNext()) {\n     *     foo(it.next());\n     *   }\n     * }\n     * }</pre>\n     *\n     * <p>or:\n     *\n     * <pre>{@code\n     * NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>());\n     * NavigableSet<E> set2 = set.descendingSet().headSet(foo);\n     *  ...\n     * synchronized (set) { // Note: set, not set2!!!\n     *   // Must be in the synchronized block\n     *   Iterator<E> it = set2.descendingIterator();\n     *   while (it.hasNext())\n     *     foo(it.next());\n     *   }\n     * }\n     * }</pre>\n     *\n     * <p>Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * <p>The returned navigable set will be serializable if the specified navigable set is\n     * serializable.\n     *\n     * @param navigableSet the navigable set to be \"wrapped\" in a synchronized navigable set.\n     * @return a synchronized view of the specified navigable set.\n     * @since 13.0\n     */\n    @GwtIncompatible // NavigableSet\n    public static <E> NavigableSet<E> synchronizedNavigableSet(NavigableSet<E> navigableSet)\n    {\n        return Synchronized.navigableSet(navigableSet);\n    }\n\n    /** Remove each element in an iterable from a set. */\n\n    static boolean removeAllImpl(Set<?> set, Collection<?> collection)\n    {\n        checkNotNull(collection); // for GWT\n        if (collection instanceof Multiset)\n        {\n            collection = ((Multiset<?>) collection).elementSet();\n        }\n        /*\n         * AbstractSet.removeAll(List) has quadratic behavior if the list size\n         * is just more than the set's size.  We augment the test by\n         * assuming that sets have fast contains() performance, and other\n         * collections don't.  See\n         * http://code.google.com/p/guava-libraries/issues/detail?id=1013\n         */\n        if (collection instanceof Set && collection.size() > set.size())\n        {\n            return Iterators.removeAll(set.iterator(), collection);\n        }\n        else\n        {\n            return removeAllImpl(set, collection.iterator());\n        }\n    }\n\n    @GwtIncompatible // NavigableSet\n    static class DescendingSet<E> extends ForwardingNavigableSet<E>\n    {\n        private final NavigableSet<E> forward;\n\n        DescendingSet(NavigableSet<E> forward)\n        {\n            this.forward = forward;\n        }\n\n        @Override\n        protected NavigableSet<E> delegate()\n        {\n            return forward;\n        }\n\n        @Override\n        public E lower(E e)\n        {\n            return forward.higher(e);\n        }\n\n        @Override\n        public E floor(E e)\n        {\n            return forward.ceiling(e);\n        }\n\n        @Override\n        public E ceiling(E e)\n        {\n            return forward.floor(e);\n        }\n\n        @Override\n        public E higher(E e)\n        {\n            return forward.lower(e);\n        }\n\n        @Override\n        public E pollFirst()\n        {\n            return forward.pollLast();\n        }\n\n        @Override\n        public E pollLast()\n        {\n            return forward.pollFirst();\n        }\n\n        @Override\n        public NavigableSet<E> descendingSet()\n        {\n            return forward;\n        }\n\n        @Override\n        public Iterator<E> descendingIterator()\n        {\n            return forward.iterator();\n        }\n\n        @Override\n        public NavigableSet<E> subSet(\n            E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)\n        {\n            return forward.subSet(toElement, toInclusive, fromElement, fromInclusive).descendingSet();\n        }\n\n        @Override\n        public SortedSet<E> subSet(E fromElement, E toElement)\n        {\n            return standardSubSet(fromElement, toElement);\n        }\n\n        @Override\n        public NavigableSet<E> headSet(E toElement, boolean inclusive)\n        {\n            return forward.tailSet(toElement, inclusive).descendingSet();\n        }\n\n        @Override\n        public SortedSet<E> headSet(E toElement)\n        {\n            return standardHeadSet(toElement);\n        }\n\n        @Override\n        public NavigableSet<E> tailSet(E fromElement, boolean inclusive)\n        {\n            return forward.headSet(fromElement, inclusive).descendingSet();\n        }\n\n        @Override\n        public SortedSet<E> tailSet(E fromElement)\n        {\n            return standardTailSet(fromElement);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public Comparator<? super E> comparator()\n        {\n            Comparator<? super E> forwardComparator = forward.comparator();\n            if (forwardComparator == null)\n            {\n                return (Comparator) Ordering.natural().reverse();\n            }\n            else\n            {\n                return reverse(forwardComparator);\n            }\n        }\n\n        // If we inline this, we get a javac error.\n        private static <T> Ordering<T> reverse(Comparator<T> forward)\n        {\n            return Ordering.from(forward).reverse();\n        }\n\n        @Override\n        public E first()\n        {\n            return forward.last();\n        }\n\n        @Override\n        public E last()\n        {\n            return forward.first();\n        }\n\n        @Override\n        public Iterator<E> iterator()\n        {\n            return forward.descendingIterator();\n        }\n\n        @Override\n        public Object[] toArray()\n        {\n            return standardToArray();\n        }\n\n        @Override\n        public <T> T[] toArray(T[] array)\n        {\n            return standardToArray(array);\n        }\n\n        @Override\n        public String toString()\n        {\n            return standardToString();\n        }\n    }\n\n    /**\n     * Returns a view of the portion of {@code set} whose elements are contained by {@code range}.\n     *\n     * <p>This method delegates to the appropriate methods of {@link NavigableSet} (namely {@link\n     * NavigableSet#subSet(Object, boolean, Object, boolean) subSet()}, {@link\n     * NavigableSet#tailSet(Object, boolean) tailSet()}, and {@link NavigableSet#headSet(Object,\n     * boolean) headSet()}) to actually construct the view. Consult these methods for a full\n     * description of the returned view's behavior.\n     *\n     * <p><b>Warning:</b> {@code Range}s always represent a range of values using the values' natural\n     * ordering. {@code NavigableSet} on the other hand can specify a custom ordering via a {@link\n     * Comparator}, which can violate the natural ordering. Using this method (or in general using\n     * {@code Range}) with unnaturally-ordered sets can lead to unexpected and undefined behavior.\n     *\n     * @since 20.0\n     */\n    @Beta\n    @GwtIncompatible // NavigableSet\n    public static <K extends Comparable<? super K>> NavigableSet<K> subSet(\n        NavigableSet<K> set, Range<K> range)\n    {\n        if (set.comparator() != null\n                && set.comparator() != Ordering.natural()\n                && range.hasLowerBound()\n                && range.hasUpperBound())\n        {\n            checkArgument(\n                set.comparator().compare(range.lowerEndpoint(), range.upperEndpoint()) <= 0,\n                \"set is using a custom comparator which is inconsistent with the natural ordering.\");\n        }\n        if (range.hasLowerBound() && range.hasUpperBound())\n        {\n            return set.subSet(\n                       range.lowerEndpoint(),\n                       range.lowerBoundType() == BoundType.CLOSED,\n                       range.upperEndpoint(),\n                       range.upperBoundType() == BoundType.CLOSED);\n        }\n        else if (range.hasLowerBound())\n        {\n            return set.tailSet(range.lowerEndpoint(), range.lowerBoundType() == BoundType.CLOSED);\n        }\n        else if (range.hasUpperBound())\n        {\n            return set.headSet(range.upperEndpoint(), range.upperBoundType() == BoundType.CLOSED);\n        }\n        return checkNotNull(set);\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/escape/CharEscaper.java", "func_name": "CharEscaper.escape", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns the escaped form of a given literal string.\n\n@param string the literal string to be escaped\n@return the escaped form of {@code string}\n@throws NullPointerException if {@code string} is null", "docstring_tokens": ["Returns", "the", "escaped", "form", "of", "a", "given", "literal", "string", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/escape/CharEscaper.java#L55-L66", "partition": "valid", "up_fun_num": 1, "levels": [0, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;"], "function": ["public abstract class CharEscaper extends Escaper\n", "    protected abstract char[] escape(char c);\n", "    protected final String escapeSlow(String s, int index)\n", "    private static char[] growBuffer(char[] dest, int index, int size)\n"], "context": "/*\n * Copyright (C) 2006 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.escape;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\n\n/**\n * An object that converts literal text into a format safe for inclusion in a particular context\n * (such as an XML document). Typically (but not always), the inverse process of \"unescaping\" the\n * text is performed automatically by the relevant parser.\n *\n * <p>For example, an XML escaper would convert the literal string {@code \"Foo<Bar>\"} into {@code\n * \"Foo&lt;Bar&gt;\"} to prevent {@code \"<Bar>\"} from being confused with an XML tag. When the\n * resulting XML document is parsed, the parser API will return this text as the original literal\n * string {@code \"Foo<Bar>\"}.\n *\n * <p>A {@code CharEscaper} instance is required to be stateless, and safe when used concurrently by\n * multiple threads.\n *\n * <p>Popular escapers are defined as constants in classes like {@link\n * com.google.common.html.HtmlEscapers} and {@link com.google.common.xml.XmlEscapers}. To create\n * your own escapers extend this class and implement the {@link #escape(char)} method.\n *\n * @author Sven Mawson\n * @since 15.0\n */\n@Beta\n@GwtCompatible\npublic abstract class CharEscaper extends Escaper\n{\n    /** Constructor for use by subclasses. */\n    protected CharEscaper() {}\n\n    /**\n     * Returns the escaped form of a given literal string.\n     *\n     * @param string the literal string to be escaped\n     * @return the escaped form of {@code string}\n     * @throws NullPointerException if {@code string} is null\n     */\n\n    /**\n     * Returns the escaped form of the given character, or {@code null} if this character does not\n     * need to be escaped. If an empty array is returned, this effectively strips the input character\n     * from the resulting text.\n     *\n     * <p>If the character does not need to be escaped, this method should return {@code null}, rather\n     * than a one-character array containing the character itself. This enables the escaping algorithm\n     * to perform more efficiently.\n     *\n     * <p>An escaper is expected to be able to deal with any {@code char} value, so this method should\n     * not throw any exceptions.\n     *\n     * @param c the character to escape if necessary\n     * @return the replacement characters, or {@code null} if no escaping was needed\n     */\n    protected abstract char[] escape(char c);\n\n    /**\n     * Returns the escaped form of a given literal string, starting at the given index. This method is\n     * called by the {@link #escape(String)} method when it discovers that escaping is required. It is\n     * protected to allow subclasses to override the fastpath escaping function to inline their\n     * escaping test. See {@link CharEscaperBuilder} for an example usage.\n     *\n     * @param s the literal string to be escaped\n     * @param index the index to start escaping from\n     * @return the escaped form of {@code string}\n     * @throws NullPointerException if {@code string} is null\n     */\n    protected final String escapeSlow(String s, int index)\n    {\n        int slen = s.length();\n\n        // Get a destination buffer and setup some loop variables.\n        char[] dest = Platform.charBufferFromThreadLocal();\n        int destSize = dest.length;\n        int destIndex = 0;\n        int lastEscape = 0;\n\n        // Loop through the rest of the string, replacing when needed into the\n        // destination buffer, which gets grown as needed as well.\n        for (; index < slen; index++)\n        {\n\n            // Get a replacement for the current character.\n            char[] r = escape(s.charAt(index));\n\n            // If no replacement is needed, just continue.\n            if (r == null)\n            {\n                continue;\n            }\n\n            int rlen = r.length;\n            int charsSkipped = index - lastEscape;\n\n            // This is the size needed to add the replacement, not the full size\n            // needed by the string. We only regrow when we absolutely must, and\n            // when we do grow, grow enough to avoid excessive growing. Grow.\n            int sizeNeeded = destIndex + charsSkipped + rlen;\n            if (destSize < sizeNeeded)\n            {\n                destSize = sizeNeeded + DEST_PAD_MULTIPLIER * (slen - index);\n                dest = growBuffer(dest, destIndex, destSize);\n            }\n\n            // If we have skipped any characters, we need to copy them now.\n            if (charsSkipped > 0)\n            {\n                s.getChars(lastEscape, index, dest, destIndex);\n                destIndex += charsSkipped;\n            }\n\n            // Copy the replacement string into the dest buffer as needed.\n            if (rlen > 0)\n            {\n                System.arraycopy(r, 0, dest, destIndex, rlen);\n                destIndex += rlen;\n            }\n            lastEscape = index + 1;\n        }\n\n        // Copy leftover characters if there are any.\n        int charsLeft = slen - lastEscape;\n        if (charsLeft > 0)\n        {\n            int sizeNeeded = destIndex + charsLeft;\n            if (destSize < sizeNeeded)\n            {\n\n                // Regrow and copy, expensive! No padding as this is the final copy.\n                dest = growBuffer(dest, destIndex, sizeNeeded);\n            }\n            s.getChars(lastEscape, slen, dest, destIndex);\n            destIndex = sizeNeeded;\n        }\n        return new String(dest, 0, destIndex);\n    }\n\n    /**\n     * Helper method to grow the character buffer as needed, this only happens once in a while so it's\n     * ok if it's in a method call. If the index passed in is 0 then no copying will be done.\n     */\n    private static char[] growBuffer(char[] dest, int index, int size)\n    {\n        if (size < 0)   // overflow - should be OutOfMemoryError but GWT/j2cl don't support it\n        {\n            throw new AssertionError(\"Cannot increase internal buffer any further\");\n        }\n        char[] copy = new char[size];\n        if (index > 0)\n        {\n            System.arraycopy(dest, 0, copy, 0, index);\n        }\n        return copy;\n    }\n\n    /** The multiplier for padding to use when growing the escape buffer. */\n    private static final int DEST_PAD_MULTIPLIER = 2;\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/escape/CharEscaper.java", "func_name": "CharEscaper.growBuffer", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Helper method to grow the character buffer as needed, this only happens once in a while so it's\nok if it's in a method call. If the index passed in is 0 then no copying will be done.", "docstring_tokens": ["Helper", "method", "to", "grow", "the", "character", "buffer", "as", "needed", "this", "only", "happens", "once", "in", "a", "while", "so", "it", "s", "ok", "if", "it", "s", "in", "a", "method", "call", ".", "If", "the", "index", "passed", "in", "is", "0", "then", "no", "copying", "will", "be", "done", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/escape/CharEscaper.java#L162-L171", "partition": "valid", "up_fun_num": 4, "levels": [0, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;"], "function": ["public abstract class CharEscaper extends Escaper\n", "    public String escape(String string)\n", "    protected abstract char[] escape(char c);\n", "    protected final String escapeSlow(String s, int index)\n"], "context": "/*\n * Copyright (C) 2006 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.escape;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\n\n/**\n * An object that converts literal text into a format safe for inclusion in a particular context\n * (such as an XML document). Typically (but not always), the inverse process of \"unescaping\" the\n * text is performed automatically by the relevant parser.\n *\n * <p>For example, an XML escaper would convert the literal string {@code \"Foo<Bar>\"} into {@code\n * \"Foo&lt;Bar&gt;\"} to prevent {@code \"<Bar>\"} from being confused with an XML tag. When the\n * resulting XML document is parsed, the parser API will return this text as the original literal\n * string {@code \"Foo<Bar>\"}.\n *\n * <p>A {@code CharEscaper} instance is required to be stateless, and safe when used concurrently by\n * multiple threads.\n *\n * <p>Popular escapers are defined as constants in classes like {@link\n * com.google.common.html.HtmlEscapers} and {@link com.google.common.xml.XmlEscapers}. To create\n * your own escapers extend this class and implement the {@link #escape(char)} method.\n *\n * @author Sven Mawson\n * @since 15.0\n */\n@Beta\n@GwtCompatible\npublic abstract class CharEscaper extends Escaper\n{\n    /** Constructor for use by subclasses. */\n    protected CharEscaper() {}\n\n    /**\n     * Returns the escaped form of a given literal string.\n     *\n     * @param string the literal string to be escaped\n     * @return the escaped form of {@code string}\n     * @throws NullPointerException if {@code string} is null\n     */\n    @Override\n    public String escape(String string)\n    {\n        checkNotNull(string); // GWT specific check (do not optimize)\n        // Inlineable fast-path loop which hands off to escapeSlow() only if needed\n        int length = string.length();\n        for (int index = 0; index < length; index++)\n        {\n            if (escape(string.charAt(index)) != null)\n            {\n                return escapeSlow(string, index);\n            }\n        }\n        return string;\n    }\n\n    /**\n     * Returns the escaped form of the given character, or {@code null} if this character does not\n     * need to be escaped. If an empty array is returned, this effectively strips the input character\n     * from the resulting text.\n     *\n     * <p>If the character does not need to be escaped, this method should return {@code null}, rather\n     * than a one-character array containing the character itself. This enables the escaping algorithm\n     * to perform more efficiently.\n     *\n     * <p>An escaper is expected to be able to deal with any {@code char} value, so this method should\n     * not throw any exceptions.\n     *\n     * @param c the character to escape if necessary\n     * @return the replacement characters, or {@code null} if no escaping was needed\n     */\n    protected abstract char[] escape(char c);\n\n    /**\n     * Returns the escaped form of a given literal string, starting at the given index. This method is\n     * called by the {@link #escape(String)} method when it discovers that escaping is required. It is\n     * protected to allow subclasses to override the fastpath escaping function to inline their\n     * escaping test. See {@link CharEscaperBuilder} for an example usage.\n     *\n     * @param s the literal string to be escaped\n     * @param index the index to start escaping from\n     * @return the escaped form of {@code string}\n     * @throws NullPointerException if {@code string} is null\n     */\n    protected final String escapeSlow(String s, int index)\n    {\n        int slen = s.length();\n\n        // Get a destination buffer and setup some loop variables.\n        char[] dest = Platform.charBufferFromThreadLocal();\n        int destSize = dest.length;\n        int destIndex = 0;\n        int lastEscape = 0;\n\n        // Loop through the rest of the string, replacing when needed into the\n        // destination buffer, which gets grown as needed as well.\n        for (; index < slen; index++)\n        {\n\n            // Get a replacement for the current character.\n            char[] r = escape(s.charAt(index));\n\n            // If no replacement is needed, just continue.\n            if (r == null)\n            {\n                continue;\n            }\n\n            int rlen = r.length;\n            int charsSkipped = index - lastEscape;\n\n            // This is the size needed to add the replacement, not the full size\n            // needed by the string. We only regrow when we absolutely must, and\n            // when we do grow, grow enough to avoid excessive growing. Grow.\n            int sizeNeeded = destIndex + charsSkipped + rlen;\n            if (destSize < sizeNeeded)\n            {\n                destSize = sizeNeeded + DEST_PAD_MULTIPLIER * (slen - index);\n                dest = growBuffer(dest, destIndex, destSize);\n            }\n\n            // If we have skipped any characters, we need to copy them now.\n            if (charsSkipped > 0)\n            {\n                s.getChars(lastEscape, index, dest, destIndex);\n                destIndex += charsSkipped;\n            }\n\n            // Copy the replacement string into the dest buffer as needed.\n            if (rlen > 0)\n            {\n                System.arraycopy(r, 0, dest, destIndex, rlen);\n                destIndex += rlen;\n            }\n            lastEscape = index + 1;\n        }\n\n        // Copy leftover characters if there are any.\n        int charsLeft = slen - lastEscape;\n        if (charsLeft > 0)\n        {\n            int sizeNeeded = destIndex + charsLeft;\n            if (destSize < sizeNeeded)\n            {\n\n                // Regrow and copy, expensive! No padding as this is the final copy.\n                dest = growBuffer(dest, destIndex, sizeNeeded);\n            }\n            s.getChars(lastEscape, slen, dest, destIndex);\n            destIndex = sizeNeeded;\n        }\n        return new String(dest, 0, destIndex);\n    }\n\n    /**\n     * Helper method to grow the character buffer as needed, this only happens once in a while so it's\n     * ok if it's in a method call. If the index passed in is 0 then no copying will be done.\n     */\n\n    /** The multiplier for padding to use when growing the escape buffer. */\n    private static final int DEST_PAD_MULTIPLIER = 2;\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/cache/CacheBuilder.java", "func_name": "CacheBuilder.concurrencyLevel", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Guides the allowed concurrency among update operations. Used as a hint for internal sizing. The\ntable is internally partitioned to try to permit the indicated number of concurrent updates\nwithout contention. Because assignment of entries to these partitions is not necessarily\nuniform, the actual concurrency observed may vary. Ideally, you should choose a value to\naccommodate as many threads as will ever concurrently modify the table. Using a significantly\nhigher value than you need can waste space and time, and a significantly lower value can lead\nto thread contention. But overestimates and underestimates within an order of magnitude do not\nusually have much noticeable impact. A value of one permits only one thread to modify the cache\nat a time, but since read operations and cache loading computations can proceed concurrently,\nthis still yields higher concurrency than full synchronization.\n\n<p>Defaults to 4. <b>Note:</b>The default may change in the future. If you care about this\nvalue, you should always choose it explicitly.\n\n<p>The current implementation uses the concurrency level to create a fixed number of hashtable\nsegments, each governed by its own write lock. The segment lock is taken once for each explicit\nwrite, and twice for each cache loading computation (once prior to loading the new value, and\nonce after loading completes). Much internal cache management is performed at the segment\ngranularity. For example, access queues and write queues are kept per segment when they are\nrequired by the selected eviction algorithm. As such, when writing unit tests it is not\nuncommon to specify {@code concurrencyLevel(1)} in order to achieve more deterministic eviction\nbehavior.\n\n<p>Note that future implementations may abandon segment locking in favor of more advanced\nconcurrency controls.\n\n@return this {@code CacheBuilder} instance (for chaining)\n@throws IllegalArgumentException if {@code concurrencyLevel} is nonpositive\n@throws IllegalStateException if a concurrency level was already set", "docstring_tokens": ["Guides", "the", "allowed", "concurrency", "among", "update", "operations", ".", "Used", "as", "a", "hint", "for", "internal", "sizing", ".", "The", "table", "is", "internally", "partitioned", "to", "try", "to", "permit", "the", "indicated", "number", "of", "concurrent", "updates", "without", "contention", ".", "Because", "assignment", "of", "entries", "to", "these", "partitions", "is", "not", "necessarily", "uniform", "the", "actual", "concurrency", "observed", "may", "vary", ".", "Ideally", "you", "should", "choose", "a", "value", "to", "accommodate", "as", "many", "threads", "as", "will", "ever", "concurrently", "modify", "the", "table", ".", "Using", "a", "significantly", "higher", "value", "than", "you", "need", "can", "waste", "space", "and", "time", "and", "a", "significantly", "lower", "value", "can", "lead", "to", "thread", "contention", ".", "But", "overestimates", "and", "underestimates", "within", "an", "order", "of", "magnitude", "do", "not", "usually", "have", "much", "noticeable", "impact", ".", "A", "value", "of", "one", "permits", "only", "one", "thread", "to", "modify", "the", "cache", "at", "a", "time", "but", "since", "read", "operations", "and", "cache", "loading", "computations", "can", "proceed", "concurrently", "this", "still", "yields", "higher", "concurrency", "than", "full", "synchronization", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/cache/CacheBuilder.java#L399-L407", "partition": "valid", "up_fun_num": 12, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.base.Preconditions.checkState;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.Ascii;", "import com.google.common.base.Equivalence;", "import com.google.common.base.MoreObjects;", "import com.google.common.base.Supplier;", "import com.google.common.base.Suppliers;", "import com.google.common.base.Ticker;", "import com.google.common.cache.AbstractCache.SimpleStatsCounter;", "import com.google.common.cache.AbstractCache.StatsCounter;", "import com.google.common.cache.LocalCache.Strength;", "import com.google.errorprone.annotations.CheckReturnValue;", "import java.lang.ref.SoftReference;", "import java.lang.ref.WeakReference;", "import java.util.ConcurrentModificationException;", "import java.util.IdentityHashMap;", "import java.util.Map;", "import java.util.concurrent.ConcurrentHashMap;", "import java.util.concurrent.TimeUnit;", "import java.util.logging.Level;", "import java.util.logging.Logger;", "import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;"], "function": ["public final class CacheBuilder<K, V>\n", "    public static CacheBuilder<Object, Object> newBuilder()\n", "    public static CacheBuilder<Object, Object> from(CacheBuilderSpec spec)\n", "    public static CacheBuilder<Object, Object> from(String spec)\n", "    CacheBuilder<K, V> lenientParsing()\n", "    CacheBuilder<K, V> keyEquivalence(Equivalence<Object> equivalence)\n", "    Equivalence<Object> getKeyEquivalence()\n", "    CacheBuilder<K, V> valueEquivalence(Equivalence<Object> equivalence)\n", "    Equivalence<Object> getValueEquivalence()\n", "    public CacheBuilder<K, V> initialCapacity(int initialCapacity)\n", "    int getInitialCapacity()\n", "    int getConcurrencyLevel()\n", "    public CacheBuilder<K, V> maximumSize(long maximumSize)\n", "    public CacheBuilder<K, V> maximumWeight(long maximumWeight)\n", "    public <K1 extends K, V1 extends V> CacheBuilder<K1, V1> weigher(\n", "    long getMaximumWeight()\n", "    <K1 extends K, V1 extends V> Weigher<K1, V1> getWeigher()\n", "    public CacheBuilder<K, V> weakKeys()\n", "    CacheBuilder<K, V> setKeyStrength(Strength strength)\n", "    Strength getKeyStrength()\n", "    public CacheBuilder<K, V> weakValues()\n", "    public CacheBuilder<K, V> softValues()\n", "    CacheBuilder<K, V> setValueStrength(Strength strength)\n", "    Strength getValueStrength()\n", "    public CacheBuilder<K, V> expireAfterWrite(long duration, TimeUnit unit)\n", "    long getExpireAfterWriteNanos()\n", "    public CacheBuilder<K, V> expireAfterAccess(long duration, TimeUnit unit)\n", "    long getExpireAfterAccessNanos()\n", "    public CacheBuilder<K, V> refreshAfterWrite(long duration, TimeUnit unit)\n", "    long getRefreshNanos()\n", "    public CacheBuilder<K, V> ticker(Ticker ticker)\n", "    Ticker getTicker(boolean recordsTime)\n", "    public <K1 extends K, V1 extends V> CacheBuilder<K1, V1> removalListener(\n", "    <K1 extends K, V1 extends V> RemovalListener<K1, V1> getRemovalListener()\n", "    public CacheBuilder<K, V> recordStats()\n", "    boolean isRecordingStats()\n", "    Supplier<? extends StatsCounter> getStatsCounterSupplier()\n", "    public <K1 extends K, V1 extends V> LoadingCache<K1, V1> build(\n", "    public <K1 extends K, V1 extends V> Cache<K1, V1> build()\n", "    private void checkNonLoadingCache()\n", "    private void checkWeightWithWeigher()\n", "    public String toString()\n"], "context": "/*\n * Copyright (C) 2009 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.cache;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\n\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Ascii;\nimport com.google.common.base.Equivalence;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Suppliers;\nimport com.google.common.base.Ticker;\nimport com.google.common.cache.AbstractCache.SimpleStatsCounter;\nimport com.google.common.cache.AbstractCache.StatsCounter;\nimport com.google.common.cache.LocalCache.Strength;\nimport com.google.errorprone.annotations.CheckReturnValue;\nimport java.lang.ref.SoftReference;\nimport java.lang.ref.WeakReference;\nimport java.util.ConcurrentModificationException;\nimport java.util.IdentityHashMap;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;\n\n/**\n * A builder of {@link LoadingCache} and {@link Cache} instances having any combination of the\n * following features:\n *\n * <ul>\n *   <li>automatic loading of entries into the cache\n *   <li>least-recently-used eviction when a maximum size is exceeded\n *   <li>time-based expiration of entries, measured since last access or last write\n *   <li>keys automatically wrapped in {@linkplain WeakReference weak} references\n *   <li>values automatically wrapped in {@linkplain WeakReference weak} or {@linkplain\n *       SoftReference soft} references\n *   <li>notification of evicted (or otherwise removed) entries\n *   <li>accumulation of cache access statistics\n * </ul>\n *\n *\n * <p>These features are all optional; caches can be created using all or none of them. By default\n * cache instances created by {@code CacheBuilder} will not perform any type of eviction.\n *\n * <p>Usage example:\n *\n * <pre>{@code\n * LoadingCache<Key, Graph> graphs = CacheBuilder.newBuilder()\n *     .maximumSize(10000)\n *     .expireAfterWrite(10, TimeUnit.MINUTES)\n *     .removalListener(MY_LISTENER)\n *     .build(\n *         new CacheLoader<Key, Graph>() {\n *           public Graph load(Key key) throws AnyException {\n *             return createExpensiveGraph(key);\n *           }\n *         });\n * }</pre>\n *\n * <p>Or equivalently,\n *\n * <pre>{@code\n * // In real life this would come from a command-line flag or config file\n * String spec = \"maximumSize=10000,expireAfterWrite=10m\";\n *\n * LoadingCache<Key, Graph> graphs = CacheBuilder.from(spec)\n *     .removalListener(MY_LISTENER)\n *     .build(\n *         new CacheLoader<Key, Graph>() {\n *           public Graph load(Key key) throws AnyException {\n *             return createExpensiveGraph(key);\n *           }\n *         });\n * }</pre>\n *\n * <p>The returned cache is implemented as a hash table with similar performance characteristics to\n * {@link ConcurrentHashMap}. It implements all optional operations of the {@link LoadingCache} and\n * {@link Cache} interfaces. The {@code asMap} view (and its collection views) have <i>weakly\n * consistent iterators</i>. This means that they are safe for concurrent use, but if other threads\n * modify the cache after the iterator is created, it is undefined which of these changes, if any,\n * are reflected in that iterator. These iterators never throw {@link\n * ConcurrentModificationException}.\n *\n * <p><b>Note:</b> by default, the returned cache uses equality comparisons (the {@link\n * Object#equals equals} method) to determine equality for keys or values. However, if {@link\n * #weakKeys} was specified, the cache uses identity ({@code ==}) comparisons instead for keys.\n * Likewise, if {@link #weakValues} or {@link #softValues} was specified, the cache uses identity\n * comparisons for values.\n *\n * <p>Entries are automatically evicted from the cache when any of {@linkplain #maximumSize(long)\n * maximumSize}, {@linkplain #maximumWeight(long) maximumWeight}, {@linkplain #expireAfterWrite\n * expireAfterWrite}, {@linkplain #expireAfterAccess expireAfterAccess}, {@linkplain #weakKeys\n * weakKeys}, {@linkplain #weakValues weakValues}, or {@linkplain #softValues softValues} are\n * requested.\n *\n * <p>If {@linkplain #maximumSize(long) maximumSize} or {@linkplain #maximumWeight(long)\n * maximumWeight} is requested entries may be evicted on each cache modification.\n *\n * <p>If {@linkplain #expireAfterWrite expireAfterWrite} or {@linkplain #expireAfterAccess\n * expireAfterAccess} is requested entries may be evicted on each cache modification, on occasional\n * cache accesses, or on calls to {@link Cache#cleanUp}. Expired entries may be counted by {@link\n * Cache#size}, but will never be visible to read or write operations.\n *\n * <p>If {@linkplain #weakKeys weakKeys}, {@linkplain #weakValues weakValues}, or {@linkplain\n * #softValues softValues} are requested, it is possible for a key or value present in the cache to\n * be reclaimed by the garbage collector. Entries with reclaimed keys or values may be removed from\n * the cache on each cache modification, on occasional cache accesses, or on calls to {@link\n * Cache#cleanUp}; such entries may be counted in {@link Cache#size}, but will never be visible to\n * read or write operations.\n *\n * <p>Certain cache configurations will result in the accrual of periodic maintenance tasks which\n * will be performed during write operations, or during occasional read operations in the absence of\n * writes. The {@link Cache#cleanUp} method of the returned cache will also perform maintenance, but\n * calling it should not be necessary with a high throughput cache. Only caches built with\n * {@linkplain #removalListener removalListener}, {@linkplain #expireAfterWrite expireAfterWrite},\n * {@linkplain #expireAfterAccess expireAfterAccess}, {@linkplain #weakKeys weakKeys}, {@linkplain\n * #weakValues weakValues}, or {@linkplain #softValues softValues} perform periodic maintenance.\n *\n * <p>The caches produced by {@code CacheBuilder} are serializable, and the deserialized caches\n * retain all the configuration properties of the original cache. Note that the serialized form does\n * <i>not</i> include cache contents, but only configuration.\n *\n * <p>See the Guava User Guide article on <a\n * href=\"https://github.com/google/guava/wiki/CachesExplained\">caching</a> for a higher-level\n * explanation.\n *\n * @param <K> the most general key type this builder will be able to create caches for. This is\n *     normally {@code Object} unless it is constrained by using a method like {@code\n *     #removalListener}\n * @param <V> the most general value type this builder will be able to create caches for. This is\n *     normally {@code Object} unless it is constrained by using a method like {@code\n *     #removalListener}\n * @author Charles Fry\n * @author Kevin Bourrillion\n * @since 10.0\n */\n@GwtCompatible(emulated = true)\npublic final class CacheBuilder<K, V>\n{\n    private static final int DEFAULT_INITIAL_CAPACITY = 16;\n    private static final int DEFAULT_CONCURRENCY_LEVEL = 4;\n\n    @SuppressWarnings(\"GoodTime\") // should be a java.time.Duration\n    private static final int DEFAULT_EXPIRATION_NANOS = 0;\n\n    @SuppressWarnings(\"GoodTime\") // should be a java.time.Duration\n    private static final int DEFAULT_REFRESH_NANOS = 0;\n\n    static final Supplier<? extends StatsCounter> NULL_STATS_COUNTER =\n        Suppliers.ofInstance(\n            new StatsCounter()\n    {\n        @Override\n        public void recordHits(int count) {}\n\n        @Override\n        public void recordMisses(int count) {}\n\n        @SuppressWarnings(\"GoodTime\") // b/122668874\n        @Override\n        public void recordLoadSuccess(long loadTime) {}\n\n        @SuppressWarnings(\"GoodTime\") // b/122668874\n        @Override\n        public void recordLoadException(long loadTime) {}\n\n        @Override\n        public void recordEviction() {}\n\n        @Override\n        public CacheStats snapshot()\n        {\n            return EMPTY_STATS;\n        }\n    });\n    static final CacheStats EMPTY_STATS = new CacheStats(0, 0, 0, 0, 0, 0);\n\n    static final Supplier<StatsCounter> CACHE_STATS_COUNTER =\n        new Supplier<StatsCounter>()\n    {\n        @Override\n        public StatsCounter get()\n        {\n            return new SimpleStatsCounter();\n        }\n    };\n\n    enum NullListener implements RemovalListener<Object, Object>\n    {\n        INSTANCE;\n\n        @Override\n        public void onRemoval(RemovalNotification<Object, Object> notification) {}\n    }\n\n    enum OneWeigher implements Weigher<Object, Object>\n    {\n        INSTANCE;\n\n        @Override\n        public int weigh(Object key, Object value)\n        {\n            return 1;\n        }\n    }\n\n    static final Ticker NULL_TICKER =\n        new Ticker()\n    {\n        @Override\n        public long read()\n        {\n            return 0;\n        }\n    };\n\n    private static final Logger logger = Logger.getLogger(CacheBuilder.class.getName());\n\n    static final int UNSET_INT = -1;\n\n    boolean strictParsing = true;\n\n    int initialCapacity = UNSET_INT;\n    int concurrencyLevel = UNSET_INT;\n    long maximumSize = UNSET_INT;\n    long maximumWeight = UNSET_INT;\n    @MonotonicNonNullDecl Weigher<? super K, ? super V> weigher;\n\n    @MonotonicNonNullDecl Strength keyStrength;\n    @MonotonicNonNullDecl Strength valueStrength;\n\n    @SuppressWarnings(\"GoodTime\") // should be a java.time.Duration\n    long expireAfterWriteNanos = UNSET_INT;\n\n    @SuppressWarnings(\"GoodTime\") // should be a java.time.Duration\n    long expireAfterAccessNanos = UNSET_INT;\n\n    @SuppressWarnings(\"GoodTime\") // should be a java.time.Duration\n    long refreshNanos = UNSET_INT;\n\n    @MonotonicNonNullDecl Equivalence<Object> keyEquivalence;\n    @MonotonicNonNullDecl Equivalence<Object> valueEquivalence;\n\n    @MonotonicNonNullDecl RemovalListener<? super K, ? super V> removalListener;\n    @MonotonicNonNullDecl Ticker ticker;\n\n    Supplier<? extends StatsCounter> statsCounterSupplier = NULL_STATS_COUNTER;\n\n    private CacheBuilder() {}\n\n    /**\n     * Constructs a new {@code CacheBuilder} instance with default settings, including strong keys,\n     * strong values, and no automatic eviction of any kind.\n     *\n     * <p>Note that while this return type is {@code CacheBuilder<Object, Object>}, type parameters on\n     * the {@link #build} methods allow you to create a cache of any key and value type desired.\n     */\n    public static CacheBuilder<Object, Object> newBuilder()\n    {\n        return new CacheBuilder<>();\n    }\n\n    /**\n     * Constructs a new {@code CacheBuilder} instance with the settings specified in {@code spec}.\n     *\n     * @since 12.0\n     */\n    @GwtIncompatible // To be supported\n    public static CacheBuilder<Object, Object> from(CacheBuilderSpec spec)\n    {\n        return spec.toCacheBuilder().lenientParsing();\n    }\n\n    /**\n     * Constructs a new {@code CacheBuilder} instance with the settings specified in {@code spec}.\n     * This is especially useful for command-line configuration of a {@code CacheBuilder}.\n     *\n     * @param spec a String in the format specified by {@link CacheBuilderSpec}\n     * @since 12.0\n     */\n    @GwtIncompatible // To be supported\n    public static CacheBuilder<Object, Object> from(String spec)\n    {\n        return from(CacheBuilderSpec.parse(spec));\n    }\n\n    /**\n     * Enables lenient parsing. Useful for tests and spec parsing.\n     *\n     * @return this {@code CacheBuilder} instance (for chaining)\n     */\n    @GwtIncompatible // To be supported\n    CacheBuilder<K, V> lenientParsing()\n    {\n        strictParsing = false;\n        return this;\n    }\n\n    /**\n     * Sets a custom {@code Equivalence} strategy for comparing keys.\n     *\n     * <p>By default, the cache uses {@link Equivalence#identity} to determine key equality when\n     * {@link #weakKeys} is specified, and {@link Equivalence#equals()} otherwise.\n     *\n     * @return this {@code CacheBuilder} instance (for chaining)\n     */\n    @GwtIncompatible // To be supported\n    CacheBuilder<K, V> keyEquivalence(Equivalence<Object> equivalence)\n    {\n        checkState(keyEquivalence == null, \"key equivalence was already set to %s\", keyEquivalence);\n        keyEquivalence = checkNotNull(equivalence);\n        return this;\n    }\n\n    Equivalence<Object> getKeyEquivalence()\n    {\n        return MoreObjects.firstNonNull(keyEquivalence, getKeyStrength().defaultEquivalence());\n    }\n\n    /**\n     * Sets a custom {@code Equivalence} strategy for comparing values.\n     *\n     * <p>By default, the cache uses {@link Equivalence#identity} to determine value equality when\n     * {@link #weakValues} or {@link #softValues} is specified, and {@link Equivalence#equals()}\n     * otherwise.\n     *\n     * @return this {@code CacheBuilder} instance (for chaining)\n     */\n    @GwtIncompatible // To be supported\n    CacheBuilder<K, V> valueEquivalence(Equivalence<Object> equivalence)\n    {\n        checkState(\n            valueEquivalence == null, \"value equivalence was already set to %s\", valueEquivalence);\n        this.valueEquivalence = checkNotNull(equivalence);\n        return this;\n    }\n\n    Equivalence<Object> getValueEquivalence()\n    {\n        return MoreObjects.firstNonNull(valueEquivalence, getValueStrength().defaultEquivalence());\n    }\n\n    /**\n     * Sets the minimum total size for the internal hash tables. For example, if the initial capacity\n     * is {@code 60}, and the concurrency level is {@code 8}, then eight segments are created, each\n     * having a hash table of size eight. Providing a large enough estimate at construction time\n     * avoids the need for expensive resizing operations later, but setting this value unnecessarily\n     * high wastes memory.\n     *\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalArgumentException if {@code initialCapacity} is negative\n     * @throws IllegalStateException if an initial capacity was already set\n     */\n    public CacheBuilder<K, V> initialCapacity(int initialCapacity)\n    {\n        checkState(\n            this.initialCapacity == UNSET_INT,\n            \"initial capacity was already set to %s\",\n            this.initialCapacity);\n        checkArgument(initialCapacity >= 0);\n        this.initialCapacity = initialCapacity;\n        return this;\n    }\n\n    int getInitialCapacity()\n    {\n        return (initialCapacity == UNSET_INT) ? DEFAULT_INITIAL_CAPACITY : initialCapacity;\n    }\n\n    /**\n     * Guides the allowed concurrency among update operations. Used as a hint for internal sizing. The\n     * table is internally partitioned to try to permit the indicated number of concurrent updates\n     * without contention. Because assignment of entries to these partitions is not necessarily\n     * uniform, the actual concurrency observed may vary. Ideally, you should choose a value to\n     * accommodate as many threads as will ever concurrently modify the table. Using a significantly\n     * higher value than you need can waste space and time, and a significantly lower value can lead\n     * to thread contention. But overestimates and underestimates within an order of magnitude do not\n     * usually have much noticeable impact. A value of one permits only one thread to modify the cache\n     * at a time, but since read operations and cache loading computations can proceed concurrently,\n     * this still yields higher concurrency than full synchronization.\n     *\n     * <p>Defaults to 4. <b>Note:</b>The default may change in the future. If you care about this\n     * value, you should always choose it explicitly.\n     *\n     * <p>The current implementation uses the concurrency level to create a fixed number of hashtable\n     * segments, each governed by its own write lock. The segment lock is taken once for each explicit\n     * write, and twice for each cache loading computation (once prior to loading the new value, and\n     * once after loading completes). Much internal cache management is performed at the segment\n     * granularity. For example, access queues and write queues are kept per segment when they are\n     * required by the selected eviction algorithm. As such, when writing unit tests it is not\n     * uncommon to specify {@code concurrencyLevel(1)} in order to achieve more deterministic eviction\n     * behavior.\n     *\n     * <p>Note that future implementations may abandon segment locking in favor of more advanced\n     * concurrency controls.\n     *\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalArgumentException if {@code concurrencyLevel} is nonpositive\n     * @throws IllegalStateException if a concurrency level was already set\n     */\n\n    int getConcurrencyLevel()\n    {\n        return (concurrencyLevel == UNSET_INT) ? DEFAULT_CONCURRENCY_LEVEL : concurrencyLevel;\n    }\n\n    /**\n     * Specifies the maximum number of entries the cache may contain.\n     *\n     * <p>Note that the cache <b>may evict an entry before this limit is exceeded</b>. For example, in\n     * the current implementation, when {@code concurrencyLevel} is greater than {@code 1}, each\n     * resulting segment inside the cache <i>independently</i> limits its own size to approximately\n     * {@code maximumSize / concurrencyLevel}.\n     *\n     * <p>When eviction is necessary, the cache evicts entries that are less likely to be used again.\n     * For example, the cache may evict an entry because it hasn't been used recently or very often.\n     *\n     * <p>If {@code maximumSize} is zero, elements will be evicted immediately after being loaded into\n     * cache. This can be useful in testing, or to disable caching temporarily.\n     *\n     * <p>This feature cannot be used in conjunction with {@link #maximumWeight}.\n     *\n     * @param maximumSize the maximum size of the cache\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalArgumentException if {@code maximumSize} is negative\n     * @throws IllegalStateException if a maximum size or weight was already set\n     */\n    public CacheBuilder<K, V> maximumSize(long maximumSize)\n    {\n        checkState(\n            this.maximumSize == UNSET_INT, \"maximum size was already set to %s\", this.maximumSize);\n        checkState(\n            this.maximumWeight == UNSET_INT,\n            \"maximum weight was already set to %s\",\n            this.maximumWeight);\n        checkState(this.weigher == null, \"maximum size can not be combined with weigher\");\n        checkArgument(maximumSize >= 0, \"maximum size must not be negative\");\n        this.maximumSize = maximumSize;\n        return this;\n    }\n\n    /**\n     * Specifies the maximum weight of entries the cache may contain. Weight is determined using the\n     * {@link Weigher} specified with {@link #weigher}, and use of this method requires a\n     * corresponding call to {@link #weigher} prior to calling {@link #build}.\n     *\n     * <p>Note that the cache <b>may evict an entry before this limit is exceeded</b>. For example, in\n     * the current implementation, when {@code concurrencyLevel} is greater than {@code 1}, each\n     * resulting segment inside the cache <i>independently</i> limits its own weight to approximately\n     * {@code maximumWeight / concurrencyLevel}.\n     *\n     * <p>When eviction is necessary, the cache evicts entries that are less likely to be used again.\n     * For example, the cache may evict an entry because it hasn't been used recently or very often.\n     *\n     * <p>If {@code maximumWeight} is zero, elements will be evicted immediately after being loaded\n     * into cache. This can be useful in testing, or to disable caching temporarily.\n     *\n     * <p>Note that weight is only used to determine whether the cache is over capacity; it has no\n     * effect on selecting which entry should be evicted next.\n     *\n     * <p>This feature cannot be used in conjunction with {@link #maximumSize}.\n     *\n     * @param maximumWeight the maximum total weight of entries the cache may contain\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalArgumentException if {@code maximumWeight} is negative\n     * @throws IllegalStateException if a maximum weight or size was already set\n     * @since 11.0\n     */\n    @GwtIncompatible // To be supported\n    public CacheBuilder<K, V> maximumWeight(long maximumWeight)\n    {\n        checkState(\n            this.maximumWeight == UNSET_INT,\n            \"maximum weight was already set to %s\",\n            this.maximumWeight);\n        checkState(\n            this.maximumSize == UNSET_INT, \"maximum size was already set to %s\", this.maximumSize);\n        this.maximumWeight = maximumWeight;\n        checkArgument(maximumWeight >= 0, \"maximum weight must not be negative\");\n        return this;\n    }\n\n    /**\n     * Specifies the weigher to use in determining the weight of entries. Entry weight is taken into\n     * consideration by {@link #maximumWeight(long)} when determining which entries to evict, and use\n     * of this method requires a corresponding call to {@link #maximumWeight(long)} prior to calling\n     * {@link #build}. Weights are measured and recorded when entries are inserted into the cache, and\n     * are thus effectively static during the lifetime of a cache entry.\n     *\n     * <p>When the weight of an entry is zero it will not be considered for size-based eviction\n     * (though it still may be evicted by other means).\n     *\n     * <p><b>Important note:</b> Instead of returning <em>this</em> as a {@code CacheBuilder}\n     * instance, this method returns {@code CacheBuilder<K1, V1>}. From this point on, either the\n     * original reference or the returned reference may be used to complete configuration and build\n     * the cache, but only the \"generic\" one is type-safe. That is, it will properly prevent you from\n     * building caches whose key or value types are incompatible with the types accepted by the\n     * weigher already provided; the {@code CacheBuilder} type cannot do this. For best results,\n     * simply use the standard method-chaining idiom, as illustrated in the documentation at top,\n     * configuring a {@code CacheBuilder} and building your {@link Cache} all in a single statement.\n     *\n     * <p><b>Warning:</b> if you ignore the above advice, and use this {@code CacheBuilder} to build a\n     * cache whose key or value type is incompatible with the weigher, you will likely experience a\n     * {@link ClassCastException} at some <i>undefined</i> point in the future.\n     *\n     * @param weigher the weigher to use in calculating the weight of cache entries\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalArgumentException if {@code size} is negative\n     * @throws IllegalStateException if a maximum size was already set\n     * @since 11.0\n     */\n    @GwtIncompatible // To be supported\n    public <K1 extends K, V1 extends V> CacheBuilder<K1, V1> weigher(\n        Weigher<? super K1, ? super V1> weigher)\n    {\n        checkState(this.weigher == null);\n        if (strictParsing)\n        {\n            checkState(\n                this.maximumSize == UNSET_INT,\n                \"weigher can not be combined with maximum size\",\n                this.maximumSize);\n        }\n\n        // safely limiting the kinds of caches this can produce\n        @SuppressWarnings(\"unchecked\")\n        CacheBuilder<K1, V1> me = (CacheBuilder<K1, V1>) this;\n        me.weigher = checkNotNull(weigher);\n        return me;\n    }\n\n    long getMaximumWeight()\n    {\n        if (expireAfterWriteNanos == 0 || expireAfterAccessNanos == 0)\n        {\n            return 0;\n        }\n        return (weigher == null) ? maximumSize : maximumWeight;\n    }\n\n    // Make a safe contravariant cast now so we don't have to do it over and over.\n    @SuppressWarnings(\"unchecked\")\n    <K1 extends K, V1 extends V> Weigher<K1, V1> getWeigher()\n    {\n        return (Weigher<K1, V1>) MoreObjects.firstNonNull(weigher, OneWeigher.INSTANCE);\n    }\n\n    /**\n     * Specifies that each key (not value) stored in the cache should be wrapped in a {@link\n     * WeakReference} (by default, strong references are used).\n     *\n     * <p><b>Warning:</b> when this method is used, the resulting cache will use identity ({@code ==})\n     * comparison to determine equality of keys. Its {@link Cache#asMap} view will therefore\n     * technically violate the {@link Map} specification (in the same way that {@link IdentityHashMap}\n     * does).\n     *\n     * <p>Entries with keys that have been garbage collected may be counted in {@link Cache#size}, but\n     * will never be visible to read or write operations; such entries are cleaned up as part of the\n     * routine maintenance described in the class javadoc.\n     *\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalStateException if the key strength was already set\n     */\n    @GwtIncompatible // java.lang.ref.WeakReference\n    public CacheBuilder<K, V> weakKeys()\n    {\n        return setKeyStrength(Strength.WEAK);\n    }\n\n    CacheBuilder<K, V> setKeyStrength(Strength strength)\n    {\n        checkState(keyStrength == null, \"Key strength was already set to %s\", keyStrength);\n        keyStrength = checkNotNull(strength);\n        return this;\n    }\n\n    Strength getKeyStrength()\n    {\n        return MoreObjects.firstNonNull(keyStrength, Strength.STRONG);\n    }\n\n    /**\n     * Specifies that each value (not key) stored in the cache should be wrapped in a {@link\n     * WeakReference} (by default, strong references are used).\n     *\n     * <p>Weak values will be garbage collected once they are weakly reachable. This makes them a poor\n     * candidate for caching; consider {@link #softValues} instead.\n     *\n     * <p><b>Note:</b> when this method is used, the resulting cache will use identity ({@code ==})\n     * comparison to determine equality of values.\n     *\n     * <p>Entries with values that have been garbage collected may be counted in {@link Cache#size},\n     * but will never be visible to read or write operations; such entries are cleaned up as part of\n     * the routine maintenance described in the class javadoc.\n     *\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalStateException if the value strength was already set\n     */\n    @GwtIncompatible // java.lang.ref.WeakReference\n    public CacheBuilder<K, V> weakValues()\n    {\n        return setValueStrength(Strength.WEAK);\n    }\n\n    /**\n     * Specifies that each value (not key) stored in the cache should be wrapped in a {@link\n     * SoftReference} (by default, strong references are used). Softly-referenced objects will be\n     * garbage-collected in a <i>globally</i> least-recently-used manner, in response to memory\n     * demand.\n     *\n     * <p><b>Warning:</b> in most circumstances it is better to set a per-cache {@linkplain\n     * #maximumSize(long) maximum size} instead of using soft references. You should only use this\n     * method if you are well familiar with the practical consequences of soft references.\n     *\n     * <p><b>Note:</b> when this method is used, the resulting cache will use identity ({@code ==})\n     * comparison to determine equality of values.\n     *\n     * <p>Entries with values that have been garbage collected may be counted in {@link Cache#size},\n     * but will never be visible to read or write operations; such entries are cleaned up as part of\n     * the routine maintenance described in the class javadoc.\n     *\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalStateException if the value strength was already set\n     */\n    @GwtIncompatible // java.lang.ref.SoftReference\n    public CacheBuilder<K, V> softValues()\n    {\n        return setValueStrength(Strength.SOFT);\n    }\n\n    CacheBuilder<K, V> setValueStrength(Strength strength)\n    {\n        checkState(valueStrength == null, \"Value strength was already set to %s\", valueStrength);\n        valueStrength = checkNotNull(strength);\n        return this;\n    }\n\n    Strength getValueStrength()\n    {\n        return MoreObjects.firstNonNull(valueStrength, Strength.STRONG);\n    }\n\n    /**\n     * Specifies that each entry should be automatically removed from the cache once a fixed duration\n     * has elapsed after the entry's creation, or the most recent replacement of its value.\n     *\n     * <p>When {@code duration} is zero, this method hands off to {@link #maximumSize(long)\n     * maximumSize}{@code (0)}, ignoring any otherwise-specified maximum size or weight. This can be\n     * useful in testing, or to disable caching temporarily without a code change.\n     *\n     * <p>Expired entries may be counted in {@link Cache#size}, but will never be visible to read or\n     * write operations. Expired entries are cleaned up as part of the routine maintenance described\n     * in the class javadoc.\n     *\n     * @param duration the length of time after an entry is created that it should be automatically\n     *     removed\n     * @param unit the unit that {@code duration} is expressed in\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalArgumentException if {@code duration} is negative\n     * @throws IllegalStateException if the time to live or time to idle was already set\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public CacheBuilder<K, V> expireAfterWrite(long duration, TimeUnit unit)\n    {\n        checkState(\n            expireAfterWriteNanos == UNSET_INT,\n            \"expireAfterWrite was already set to %s ns\",\n            expireAfterWriteNanos);\n        checkArgument(duration >= 0, \"duration cannot be negative: %s %s\", duration, unit);\n        this.expireAfterWriteNanos = unit.toNanos(duration);\n        return this;\n    }\n\n    long getExpireAfterWriteNanos()\n    {\n        return (expireAfterWriteNanos == UNSET_INT) ? DEFAULT_EXPIRATION_NANOS : expireAfterWriteNanos;\n    }\n\n    /**\n     * Specifies that each entry should be automatically removed from the cache once a fixed duration\n     * has elapsed after the entry's creation, the most recent replacement of its value, or its last\n     * access. Access time is reset by all cache read and write operations (including {@code\n     * Cache.asMap().get(Object)} and {@code Cache.asMap().put(K, V)}), but not by operations on the\n     * collection-views of {@link Cache#asMap}.\n     *\n     * <p>When {@code duration} is zero, this method hands off to {@link #maximumSize(long)\n     * maximumSize}{@code (0)}, ignoring any otherwise-specified maximum size or weight. This can be\n     * useful in testing, or to disable caching temporarily without a code change.\n     *\n     * <p>Expired entries may be counted in {@link Cache#size}, but will never be visible to read or\n     * write operations. Expired entries are cleaned up as part of the routine maintenance described\n     * in the class javadoc.\n     *\n     * @param duration the length of time after an entry is last accessed that it should be\n     *     automatically removed\n     * @param unit the unit that {@code duration} is expressed in\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalArgumentException if {@code duration} is negative\n     * @throws IllegalStateException if the time to idle or time to live was already set\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public CacheBuilder<K, V> expireAfterAccess(long duration, TimeUnit unit)\n    {\n        checkState(\n            expireAfterAccessNanos == UNSET_INT,\n            \"expireAfterAccess was already set to %s ns\",\n            expireAfterAccessNanos);\n        checkArgument(duration >= 0, \"duration cannot be negative: %s %s\", duration, unit);\n        this.expireAfterAccessNanos = unit.toNanos(duration);\n        return this;\n    }\n\n    long getExpireAfterAccessNanos()\n    {\n        return (expireAfterAccessNanos == UNSET_INT)\n               ? DEFAULT_EXPIRATION_NANOS\n               : expireAfterAccessNanos;\n    }\n\n    /**\n     * Specifies that active entries are eligible for automatic refresh once a fixed duration has\n     * elapsed after the entry's creation, or the most recent replacement of its value. The semantics\n     * of refreshes are specified in {@link LoadingCache#refresh}, and are performed by calling {@link\n     * CacheLoader#reload}.\n     *\n     * <p>As the default implementation of {@link CacheLoader#reload} is synchronous, it is\n     * recommended that users of this method override {@link CacheLoader#reload} with an asynchronous\n     * implementation; otherwise refreshes will be performed during unrelated cache read and write\n     * operations.\n     *\n     * <p>Currently automatic refreshes are performed when the first stale request for an entry\n     * occurs. The request triggering refresh will make a blocking call to {@link CacheLoader#reload}\n     * and immediately return the new value if the returned future is complete, and the old value\n     * otherwise.\n     *\n     * <p><b>Note:</b> <i>all exceptions thrown during refresh will be logged and then swallowed</i>.\n     *\n     * @param duration the length of time after an entry is created that it should be considered\n     *     stale, and thus eligible for refresh\n     * @param unit the unit that {@code duration} is expressed in\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalArgumentException if {@code duration} is negative\n     * @throws IllegalStateException if the refresh interval was already set\n     * @since 11.0\n     */\n    @GwtIncompatible // To be supported (synchronously).\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public CacheBuilder<K, V> refreshAfterWrite(long duration, TimeUnit unit)\n    {\n        checkNotNull(unit);\n        checkState(refreshNanos == UNSET_INT, \"refresh was already set to %s ns\", refreshNanos);\n        checkArgument(duration > 0, \"duration must be positive: %s %s\", duration, unit);\n        this.refreshNanos = unit.toNanos(duration);\n        return this;\n    }\n\n    long getRefreshNanos()\n    {\n        return (refreshNanos == UNSET_INT) ? DEFAULT_REFRESH_NANOS : refreshNanos;\n    }\n\n    /**\n     * Specifies a nanosecond-precision time source for this cache. By default, {@link\n     * System#nanoTime} is used.\n     *\n     * <p>The primary intent of this method is to facilitate testing of caches with a fake or mock\n     * time source.\n     *\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalStateException if a ticker was already set\n     */\n    public CacheBuilder<K, V> ticker(Ticker ticker)\n    {\n        checkState(this.ticker == null);\n        this.ticker = checkNotNull(ticker);\n        return this;\n    }\n\n    Ticker getTicker(boolean recordsTime)\n    {\n        if (ticker != null)\n        {\n            return ticker;\n        }\n        return recordsTime ? Ticker.systemTicker() : NULL_TICKER;\n    }\n\n    /**\n     * Specifies a listener instance that caches should notify each time an entry is removed for any\n     * {@linkplain RemovalCause reason}. Each cache created by this builder will invoke this listener\n     * as part of the routine maintenance described in the class documentation above.\n     *\n     * <p><b>Warning:</b> after invoking this method, do not continue to use <i>this</i> cache builder\n     * reference; instead use the reference this method <i>returns</i>. At runtime, these point to the\n     * same instance, but only the returned reference has the correct generic type information so as\n     * to ensure type safety. For best results, use the standard method-chaining idiom illustrated in\n     * the class documentation above, configuring a builder and building your cache in a single\n     * statement. Failure to heed this advice can result in a {@link ClassCastException} being thrown\n     * by a cache operation at some <i>undefined</i> point in the future.\n     *\n     * <p><b>Warning:</b> any exception thrown by {@code listener} will <i>not</i> be propagated to\n     * the {@code Cache} user, only logged via a {@link Logger}.\n     *\n     * @return the cache builder reference that should be used instead of {@code this} for any\n     *     remaining configuration and cache building\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalStateException if a removal listener was already set\n     */\n    @CheckReturnValue\n    public <K1 extends K, V1 extends V> CacheBuilder<K1, V1> removalListener(\n        RemovalListener<? super K1, ? super V1> listener)\n    {\n        checkState(this.removalListener == null);\n\n        // safely limiting the kinds of caches this can produce\n        @SuppressWarnings(\"unchecked\")\n        CacheBuilder<K1, V1> me = (CacheBuilder<K1, V1>) this;\n        me.removalListener = checkNotNull(listener);\n        return me;\n    }\n\n    // Make a safe contravariant cast now so we don't have to do it over and over.\n    @SuppressWarnings(\"unchecked\")\n    <K1 extends K, V1 extends V> RemovalListener<K1, V1> getRemovalListener()\n    {\n        return (RemovalListener<K1, V1>)\n               MoreObjects.firstNonNull(removalListener, NullListener.INSTANCE);\n    }\n\n    /**\n     * Enable the accumulation of {@link CacheStats} during the operation of the cache. Without this\n     * {@link Cache#stats} will return zero for all statistics. Note that recording stats requires\n     * bookkeeping to be performed with each operation, and thus imposes a performance penalty on\n     * cache operation.\n     *\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @since 12.0 (previously, stats collection was automatic)\n     */\n    public CacheBuilder<K, V> recordStats()\n    {\n        statsCounterSupplier = CACHE_STATS_COUNTER;\n        return this;\n    }\n\n    boolean isRecordingStats()\n    {\n        return statsCounterSupplier == CACHE_STATS_COUNTER;\n    }\n\n    Supplier<? extends StatsCounter> getStatsCounterSupplier()\n    {\n        return statsCounterSupplier;\n    }\n\n    /**\n     * Builds a cache, which either returns an already-loaded value for a given key or atomically\n     * computes or retrieves it using the supplied {@code CacheLoader}. If another thread is currently\n     * loading the value for this key, simply waits for that thread to finish and returns its loaded\n     * value. Note that multiple threads can concurrently load values for distinct keys.\n     *\n     * <p>This method does not alter the state of this {@code CacheBuilder} instance, so it can be\n     * invoked again to create multiple independent caches.\n     *\n     * @param loader the cache loader used to obtain new values\n     * @return a cache having the requested features\n     */\n    public <K1 extends K, V1 extends V> LoadingCache<K1, V1> build(\n        CacheLoader<? super K1, V1> loader)\n    {\n        checkWeightWithWeigher();\n        return new LocalCache.LocalLoadingCache<>(this, loader);\n    }\n\n    /**\n     * Builds a cache which does not automatically load values when keys are requested.\n     *\n     * <p>Consider {@link #build(CacheLoader)} instead, if it is feasible to implement a {@code\n     * CacheLoader}.\n     *\n     * <p>This method does not alter the state of this {@code CacheBuilder} instance, so it can be\n     * invoked again to create multiple independent caches.\n     *\n     * @return a cache having the requested features\n     * @since 11.0\n     */\n    public <K1 extends K, V1 extends V> Cache<K1, V1> build()\n    {\n        checkWeightWithWeigher();\n        checkNonLoadingCache();\n        return new LocalCache.LocalManualCache<>(this);\n    }\n\n    private void checkNonLoadingCache()\n    {\n        checkState(refreshNanos == UNSET_INT, \"refreshAfterWrite requires a LoadingCache\");\n    }\n\n    private void checkWeightWithWeigher()\n    {\n        if (weigher == null)\n        {\n            checkState(maximumWeight == UNSET_INT, \"maximumWeight requires weigher\");\n        }\n        else\n        {\n            if (strictParsing)\n            {\n                checkState(maximumWeight != UNSET_INT, \"weigher requires maximumWeight\");\n            }\n            else\n            {\n                if (maximumWeight == UNSET_INT)\n                {\n                    logger.log(Level.WARNING, \"ignoring weigher specified without maximumWeight\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a string representation for this CacheBuilder instance. The exact form of the returned\n     * string is not specified.\n     */\n    @Override\n    public String toString()\n    {\n        MoreObjects.ToStringHelper s = MoreObjects.toStringHelper(this);\n        if (initialCapacity != UNSET_INT)\n        {\n            s.add(\"initialCapacity\", initialCapacity);\n        }\n        if (concurrencyLevel != UNSET_INT)\n        {\n            s.add(\"concurrencyLevel\", concurrencyLevel);\n        }\n        if (maximumSize != UNSET_INT)\n        {\n            s.add(\"maximumSize\", maximumSize);\n        }\n        if (maximumWeight != UNSET_INT)\n        {\n            s.add(\"maximumWeight\", maximumWeight);\n        }\n        if (expireAfterWriteNanos != UNSET_INT)\n        {\n            s.add(\"expireAfterWrite\", expireAfterWriteNanos + \"ns\");\n        }\n        if (expireAfterAccessNanos != UNSET_INT)\n        {\n            s.add(\"expireAfterAccess\", expireAfterAccessNanos + \"ns\");\n        }\n        if (keyStrength != null)\n        {\n            s.add(\"keyStrength\", Ascii.toLowerCase(keyStrength.toString()));\n        }\n        if (valueStrength != null)\n        {\n            s.add(\"valueStrength\", Ascii.toLowerCase(valueStrength.toString()));\n        }\n        if (keyEquivalence != null)\n        {\n            s.addValue(\"keyEquivalence\");\n        }\n        if (valueEquivalence != null)\n        {\n            s.addValue(\"valueEquivalence\");\n        }\n        if (removalListener != null)\n        {\n            s.addValue(\"removalListener\");\n        }\n        return s.toString();\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/cache/CacheBuilder.java", "func_name": "CacheBuilder.build", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Builds a cache which does not automatically load values when keys are requested.\n\n<p>Consider {@link #build(CacheLoader)} instead, if it is feasible to implement a {@code\nCacheLoader}.\n\n<p>This method does not alter the state of this {@code CacheBuilder} instance, so it can be\ninvoked again to create multiple independent caches.\n\n@return a cache having the requested features\n@since 11.0", "docstring_tokens": ["Builds", "a", "cache", "which", "does", "not", "automatically", "load", "values", "when", "keys", "are", "requested", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/cache/CacheBuilder.java#L863-L867", "partition": "valid", "up_fun_num": 40, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.base.Preconditions.checkState;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.base.Ascii;", "import com.google.common.base.Equivalence;", "import com.google.common.base.MoreObjects;", "import com.google.common.base.Supplier;", "import com.google.common.base.Suppliers;", "import com.google.common.base.Ticker;", "import com.google.common.cache.AbstractCache.SimpleStatsCounter;", "import com.google.common.cache.AbstractCache.StatsCounter;", "import com.google.common.cache.LocalCache.Strength;", "import com.google.errorprone.annotations.CheckReturnValue;", "import java.lang.ref.SoftReference;", "import java.lang.ref.WeakReference;", "import java.util.ConcurrentModificationException;", "import java.util.IdentityHashMap;", "import java.util.Map;", "import java.util.concurrent.ConcurrentHashMap;", "import java.util.concurrent.TimeUnit;", "import java.util.logging.Level;", "import java.util.logging.Logger;", "import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;"], "function": ["public final class CacheBuilder<K, V>\n", "    public static CacheBuilder<Object, Object> newBuilder()\n", "    public static CacheBuilder<Object, Object> from(CacheBuilderSpec spec)\n", "    public static CacheBuilder<Object, Object> from(String spec)\n", "    CacheBuilder<K, V> lenientParsing()\n", "    CacheBuilder<K, V> keyEquivalence(Equivalence<Object> equivalence)\n", "    Equivalence<Object> getKeyEquivalence()\n", "    CacheBuilder<K, V> valueEquivalence(Equivalence<Object> equivalence)\n", "    Equivalence<Object> getValueEquivalence()\n", "    public CacheBuilder<K, V> initialCapacity(int initialCapacity)\n", "    int getInitialCapacity()\n", "    public CacheBuilder<K, V> concurrencyLevel(int concurrencyLevel)\n", "    int getConcurrencyLevel()\n", "    public CacheBuilder<K, V> maximumSize(long maximumSize)\n", "    public CacheBuilder<K, V> maximumWeight(long maximumWeight)\n", "    public <K1 extends K, V1 extends V> CacheBuilder<K1, V1> weigher(\n", "    long getMaximumWeight()\n", "    <K1 extends K, V1 extends V> Weigher<K1, V1> getWeigher()\n", "    public CacheBuilder<K, V> weakKeys()\n", "    CacheBuilder<K, V> setKeyStrength(Strength strength)\n", "    Strength getKeyStrength()\n", "    public CacheBuilder<K, V> weakValues()\n", "    public CacheBuilder<K, V> softValues()\n", "    CacheBuilder<K, V> setValueStrength(Strength strength)\n", "    Strength getValueStrength()\n", "    public CacheBuilder<K, V> expireAfterWrite(long duration, TimeUnit unit)\n", "    long getExpireAfterWriteNanos()\n", "    public CacheBuilder<K, V> expireAfterAccess(long duration, TimeUnit unit)\n", "    long getExpireAfterAccessNanos()\n", "    public CacheBuilder<K, V> refreshAfterWrite(long duration, TimeUnit unit)\n", "    long getRefreshNanos()\n", "    public CacheBuilder<K, V> ticker(Ticker ticker)\n", "    Ticker getTicker(boolean recordsTime)\n", "    public <K1 extends K, V1 extends V> CacheBuilder<K1, V1> removalListener(\n", "    <K1 extends K, V1 extends V> RemovalListener<K1, V1> getRemovalListener()\n", "    public CacheBuilder<K, V> recordStats()\n", "    boolean isRecordingStats()\n", "    Supplier<? extends StatsCounter> getStatsCounterSupplier()\n", "    public <K1 extends K, V1 extends V> LoadingCache<K1, V1> build(\n", "    private void checkNonLoadingCache()\n", "    private void checkWeightWithWeigher()\n", "    public String toString()\n"], "context": "/*\n * Copyright (C) 2009 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.cache;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\n\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Ascii;\nimport com.google.common.base.Equivalence;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Suppliers;\nimport com.google.common.base.Ticker;\nimport com.google.common.cache.AbstractCache.SimpleStatsCounter;\nimport com.google.common.cache.AbstractCache.StatsCounter;\nimport com.google.common.cache.LocalCache.Strength;\nimport com.google.errorprone.annotations.CheckReturnValue;\nimport java.lang.ref.SoftReference;\nimport java.lang.ref.WeakReference;\nimport java.util.ConcurrentModificationException;\nimport java.util.IdentityHashMap;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;\n\n/**\n * A builder of {@link LoadingCache} and {@link Cache} instances having any combination of the\n * following features:\n *\n * <ul>\n *   <li>automatic loading of entries into the cache\n *   <li>least-recently-used eviction when a maximum size is exceeded\n *   <li>time-based expiration of entries, measured since last access or last write\n *   <li>keys automatically wrapped in {@linkplain WeakReference weak} references\n *   <li>values automatically wrapped in {@linkplain WeakReference weak} or {@linkplain\n *       SoftReference soft} references\n *   <li>notification of evicted (or otherwise removed) entries\n *   <li>accumulation of cache access statistics\n * </ul>\n *\n *\n * <p>These features are all optional; caches can be created using all or none of them. By default\n * cache instances created by {@code CacheBuilder} will not perform any type of eviction.\n *\n * <p>Usage example:\n *\n * <pre>{@code\n * LoadingCache<Key, Graph> graphs = CacheBuilder.newBuilder()\n *     .maximumSize(10000)\n *     .expireAfterWrite(10, TimeUnit.MINUTES)\n *     .removalListener(MY_LISTENER)\n *     .build(\n *         new CacheLoader<Key, Graph>() {\n *           public Graph load(Key key) throws AnyException {\n *             return createExpensiveGraph(key);\n *           }\n *         });\n * }</pre>\n *\n * <p>Or equivalently,\n *\n * <pre>{@code\n * // In real life this would come from a command-line flag or config file\n * String spec = \"maximumSize=10000,expireAfterWrite=10m\";\n *\n * LoadingCache<Key, Graph> graphs = CacheBuilder.from(spec)\n *     .removalListener(MY_LISTENER)\n *     .build(\n *         new CacheLoader<Key, Graph>() {\n *           public Graph load(Key key) throws AnyException {\n *             return createExpensiveGraph(key);\n *           }\n *         });\n * }</pre>\n *\n * <p>The returned cache is implemented as a hash table with similar performance characteristics to\n * {@link ConcurrentHashMap}. It implements all optional operations of the {@link LoadingCache} and\n * {@link Cache} interfaces. The {@code asMap} view (and its collection views) have <i>weakly\n * consistent iterators</i>. This means that they are safe for concurrent use, but if other threads\n * modify the cache after the iterator is created, it is undefined which of these changes, if any,\n * are reflected in that iterator. These iterators never throw {@link\n * ConcurrentModificationException}.\n *\n * <p><b>Note:</b> by default, the returned cache uses equality comparisons (the {@link\n * Object#equals equals} method) to determine equality for keys or values. However, if {@link\n * #weakKeys} was specified, the cache uses identity ({@code ==}) comparisons instead for keys.\n * Likewise, if {@link #weakValues} or {@link #softValues} was specified, the cache uses identity\n * comparisons for values.\n *\n * <p>Entries are automatically evicted from the cache when any of {@linkplain #maximumSize(long)\n * maximumSize}, {@linkplain #maximumWeight(long) maximumWeight}, {@linkplain #expireAfterWrite\n * expireAfterWrite}, {@linkplain #expireAfterAccess expireAfterAccess}, {@linkplain #weakKeys\n * weakKeys}, {@linkplain #weakValues weakValues}, or {@linkplain #softValues softValues} are\n * requested.\n *\n * <p>If {@linkplain #maximumSize(long) maximumSize} or {@linkplain #maximumWeight(long)\n * maximumWeight} is requested entries may be evicted on each cache modification.\n *\n * <p>If {@linkplain #expireAfterWrite expireAfterWrite} or {@linkplain #expireAfterAccess\n * expireAfterAccess} is requested entries may be evicted on each cache modification, on occasional\n * cache accesses, or on calls to {@link Cache#cleanUp}. Expired entries may be counted by {@link\n * Cache#size}, but will never be visible to read or write operations.\n *\n * <p>If {@linkplain #weakKeys weakKeys}, {@linkplain #weakValues weakValues}, or {@linkplain\n * #softValues softValues} are requested, it is possible for a key or value present in the cache to\n * be reclaimed by the garbage collector. Entries with reclaimed keys or values may be removed from\n * the cache on each cache modification, on occasional cache accesses, or on calls to {@link\n * Cache#cleanUp}; such entries may be counted in {@link Cache#size}, but will never be visible to\n * read or write operations.\n *\n * <p>Certain cache configurations will result in the accrual of periodic maintenance tasks which\n * will be performed during write operations, or during occasional read operations in the absence of\n * writes. The {@link Cache#cleanUp} method of the returned cache will also perform maintenance, but\n * calling it should not be necessary with a high throughput cache. Only caches built with\n * {@linkplain #removalListener removalListener}, {@linkplain #expireAfterWrite expireAfterWrite},\n * {@linkplain #expireAfterAccess expireAfterAccess}, {@linkplain #weakKeys weakKeys}, {@linkplain\n * #weakValues weakValues}, or {@linkplain #softValues softValues} perform periodic maintenance.\n *\n * <p>The caches produced by {@code CacheBuilder} are serializable, and the deserialized caches\n * retain all the configuration properties of the original cache. Note that the serialized form does\n * <i>not</i> include cache contents, but only configuration.\n *\n * <p>See the Guava User Guide article on <a\n * href=\"https://github.com/google/guava/wiki/CachesExplained\">caching</a> for a higher-level\n * explanation.\n *\n * @param <K> the most general key type this builder will be able to create caches for. This is\n *     normally {@code Object} unless it is constrained by using a method like {@code\n *     #removalListener}\n * @param <V> the most general value type this builder will be able to create caches for. This is\n *     normally {@code Object} unless it is constrained by using a method like {@code\n *     #removalListener}\n * @author Charles Fry\n * @author Kevin Bourrillion\n * @since 10.0\n */\n@GwtCompatible(emulated = true)\npublic final class CacheBuilder<K, V>\n{\n    private static final int DEFAULT_INITIAL_CAPACITY = 16;\n    private static final int DEFAULT_CONCURRENCY_LEVEL = 4;\n\n    @SuppressWarnings(\"GoodTime\") // should be a java.time.Duration\n    private static final int DEFAULT_EXPIRATION_NANOS = 0;\n\n    @SuppressWarnings(\"GoodTime\") // should be a java.time.Duration\n    private static final int DEFAULT_REFRESH_NANOS = 0;\n\n    static final Supplier<? extends StatsCounter> NULL_STATS_COUNTER =\n        Suppliers.ofInstance(\n            new StatsCounter()\n    {\n        @Override\n        public void recordHits(int count) {}\n\n        @Override\n        public void recordMisses(int count) {}\n\n        @SuppressWarnings(\"GoodTime\") // b/122668874\n        @Override\n        public void recordLoadSuccess(long loadTime) {}\n\n        @SuppressWarnings(\"GoodTime\") // b/122668874\n        @Override\n        public void recordLoadException(long loadTime) {}\n\n        @Override\n        public void recordEviction() {}\n\n        @Override\n        public CacheStats snapshot()\n        {\n            return EMPTY_STATS;\n        }\n    });\n    static final CacheStats EMPTY_STATS = new CacheStats(0, 0, 0, 0, 0, 0);\n\n    static final Supplier<StatsCounter> CACHE_STATS_COUNTER =\n        new Supplier<StatsCounter>()\n    {\n        @Override\n        public StatsCounter get()\n        {\n            return new SimpleStatsCounter();\n        }\n    };\n\n    enum NullListener implements RemovalListener<Object, Object>\n    {\n        INSTANCE;\n\n        @Override\n        public void onRemoval(RemovalNotification<Object, Object> notification) {}\n    }\n\n    enum OneWeigher implements Weigher<Object, Object>\n    {\n        INSTANCE;\n\n        @Override\n        public int weigh(Object key, Object value)\n        {\n            return 1;\n        }\n    }\n\n    static final Ticker NULL_TICKER =\n        new Ticker()\n    {\n        @Override\n        public long read()\n        {\n            return 0;\n        }\n    };\n\n    private static final Logger logger = Logger.getLogger(CacheBuilder.class.getName());\n\n    static final int UNSET_INT = -1;\n\n    boolean strictParsing = true;\n\n    int initialCapacity = UNSET_INT;\n    int concurrencyLevel = UNSET_INT;\n    long maximumSize = UNSET_INT;\n    long maximumWeight = UNSET_INT;\n    @MonotonicNonNullDecl Weigher<? super K, ? super V> weigher;\n\n    @MonotonicNonNullDecl Strength keyStrength;\n    @MonotonicNonNullDecl Strength valueStrength;\n\n    @SuppressWarnings(\"GoodTime\") // should be a java.time.Duration\n    long expireAfterWriteNanos = UNSET_INT;\n\n    @SuppressWarnings(\"GoodTime\") // should be a java.time.Duration\n    long expireAfterAccessNanos = UNSET_INT;\n\n    @SuppressWarnings(\"GoodTime\") // should be a java.time.Duration\n    long refreshNanos = UNSET_INT;\n\n    @MonotonicNonNullDecl Equivalence<Object> keyEquivalence;\n    @MonotonicNonNullDecl Equivalence<Object> valueEquivalence;\n\n    @MonotonicNonNullDecl RemovalListener<? super K, ? super V> removalListener;\n    @MonotonicNonNullDecl Ticker ticker;\n\n    Supplier<? extends StatsCounter> statsCounterSupplier = NULL_STATS_COUNTER;\n\n    private CacheBuilder() {}\n\n    /**\n     * Constructs a new {@code CacheBuilder} instance with default settings, including strong keys,\n     * strong values, and no automatic eviction of any kind.\n     *\n     * <p>Note that while this return type is {@code CacheBuilder<Object, Object>}, type parameters on\n     * the {@link #build} methods allow you to create a cache of any key and value type desired.\n     */\n    public static CacheBuilder<Object, Object> newBuilder()\n    {\n        return new CacheBuilder<>();\n    }\n\n    /**\n     * Constructs a new {@code CacheBuilder} instance with the settings specified in {@code spec}.\n     *\n     * @since 12.0\n     */\n    @GwtIncompatible // To be supported\n    public static CacheBuilder<Object, Object> from(CacheBuilderSpec spec)\n    {\n        return spec.toCacheBuilder().lenientParsing();\n    }\n\n    /**\n     * Constructs a new {@code CacheBuilder} instance with the settings specified in {@code spec}.\n     * This is especially useful for command-line configuration of a {@code CacheBuilder}.\n     *\n     * @param spec a String in the format specified by {@link CacheBuilderSpec}\n     * @since 12.0\n     */\n    @GwtIncompatible // To be supported\n    public static CacheBuilder<Object, Object> from(String spec)\n    {\n        return from(CacheBuilderSpec.parse(spec));\n    }\n\n    /**\n     * Enables lenient parsing. Useful for tests and spec parsing.\n     *\n     * @return this {@code CacheBuilder} instance (for chaining)\n     */\n    @GwtIncompatible // To be supported\n    CacheBuilder<K, V> lenientParsing()\n    {\n        strictParsing = false;\n        return this;\n    }\n\n    /**\n     * Sets a custom {@code Equivalence} strategy for comparing keys.\n     *\n     * <p>By default, the cache uses {@link Equivalence#identity} to determine key equality when\n     * {@link #weakKeys} is specified, and {@link Equivalence#equals()} otherwise.\n     *\n     * @return this {@code CacheBuilder} instance (for chaining)\n     */\n    @GwtIncompatible // To be supported\n    CacheBuilder<K, V> keyEquivalence(Equivalence<Object> equivalence)\n    {\n        checkState(keyEquivalence == null, \"key equivalence was already set to %s\", keyEquivalence);\n        keyEquivalence = checkNotNull(equivalence);\n        return this;\n    }\n\n    Equivalence<Object> getKeyEquivalence()\n    {\n        return MoreObjects.firstNonNull(keyEquivalence, getKeyStrength().defaultEquivalence());\n    }\n\n    /**\n     * Sets a custom {@code Equivalence} strategy for comparing values.\n     *\n     * <p>By default, the cache uses {@link Equivalence#identity} to determine value equality when\n     * {@link #weakValues} or {@link #softValues} is specified, and {@link Equivalence#equals()}\n     * otherwise.\n     *\n     * @return this {@code CacheBuilder} instance (for chaining)\n     */\n    @GwtIncompatible // To be supported\n    CacheBuilder<K, V> valueEquivalence(Equivalence<Object> equivalence)\n    {\n        checkState(\n            valueEquivalence == null, \"value equivalence was already set to %s\", valueEquivalence);\n        this.valueEquivalence = checkNotNull(equivalence);\n        return this;\n    }\n\n    Equivalence<Object> getValueEquivalence()\n    {\n        return MoreObjects.firstNonNull(valueEquivalence, getValueStrength().defaultEquivalence());\n    }\n\n    /**\n     * Sets the minimum total size for the internal hash tables. For example, if the initial capacity\n     * is {@code 60}, and the concurrency level is {@code 8}, then eight segments are created, each\n     * having a hash table of size eight. Providing a large enough estimate at construction time\n     * avoids the need for expensive resizing operations later, but setting this value unnecessarily\n     * high wastes memory.\n     *\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalArgumentException if {@code initialCapacity} is negative\n     * @throws IllegalStateException if an initial capacity was already set\n     */\n    public CacheBuilder<K, V> initialCapacity(int initialCapacity)\n    {\n        checkState(\n            this.initialCapacity == UNSET_INT,\n            \"initial capacity was already set to %s\",\n            this.initialCapacity);\n        checkArgument(initialCapacity >= 0);\n        this.initialCapacity = initialCapacity;\n        return this;\n    }\n\n    int getInitialCapacity()\n    {\n        return (initialCapacity == UNSET_INT) ? DEFAULT_INITIAL_CAPACITY : initialCapacity;\n    }\n\n    /**\n     * Guides the allowed concurrency among update operations. Used as a hint for internal sizing. The\n     * table is internally partitioned to try to permit the indicated number of concurrent updates\n     * without contention. Because assignment of entries to these partitions is not necessarily\n     * uniform, the actual concurrency observed may vary. Ideally, you should choose a value to\n     * accommodate as many threads as will ever concurrently modify the table. Using a significantly\n     * higher value than you need can waste space and time, and a significantly lower value can lead\n     * to thread contention. But overestimates and underestimates within an order of magnitude do not\n     * usually have much noticeable impact. A value of one permits only one thread to modify the cache\n     * at a time, but since read operations and cache loading computations can proceed concurrently,\n     * this still yields higher concurrency than full synchronization.\n     *\n     * <p>Defaults to 4. <b>Note:</b>The default may change in the future. If you care about this\n     * value, you should always choose it explicitly.\n     *\n     * <p>The current implementation uses the concurrency level to create a fixed number of hashtable\n     * segments, each governed by its own write lock. The segment lock is taken once for each explicit\n     * write, and twice for each cache loading computation (once prior to loading the new value, and\n     * once after loading completes). Much internal cache management is performed at the segment\n     * granularity. For example, access queues and write queues are kept per segment when they are\n     * required by the selected eviction algorithm. As such, when writing unit tests it is not\n     * uncommon to specify {@code concurrencyLevel(1)} in order to achieve more deterministic eviction\n     * behavior.\n     *\n     * <p>Note that future implementations may abandon segment locking in favor of more advanced\n     * concurrency controls.\n     *\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalArgumentException if {@code concurrencyLevel} is nonpositive\n     * @throws IllegalStateException if a concurrency level was already set\n     */\n    public CacheBuilder<K, V> concurrencyLevel(int concurrencyLevel)\n    {\n        checkState(\n            this.concurrencyLevel == UNSET_INT,\n            \"concurrency level was already set to %s\",\n            this.concurrencyLevel);\n        checkArgument(concurrencyLevel > 0);\n        this.concurrencyLevel = concurrencyLevel;\n        return this;\n    }\n\n    int getConcurrencyLevel()\n    {\n        return (concurrencyLevel == UNSET_INT) ? DEFAULT_CONCURRENCY_LEVEL : concurrencyLevel;\n    }\n\n    /**\n     * Specifies the maximum number of entries the cache may contain.\n     *\n     * <p>Note that the cache <b>may evict an entry before this limit is exceeded</b>. For example, in\n     * the current implementation, when {@code concurrencyLevel} is greater than {@code 1}, each\n     * resulting segment inside the cache <i>independently</i> limits its own size to approximately\n     * {@code maximumSize / concurrencyLevel}.\n     *\n     * <p>When eviction is necessary, the cache evicts entries that are less likely to be used again.\n     * For example, the cache may evict an entry because it hasn't been used recently or very often.\n     *\n     * <p>If {@code maximumSize} is zero, elements will be evicted immediately after being loaded into\n     * cache. This can be useful in testing, or to disable caching temporarily.\n     *\n     * <p>This feature cannot be used in conjunction with {@link #maximumWeight}.\n     *\n     * @param maximumSize the maximum size of the cache\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalArgumentException if {@code maximumSize} is negative\n     * @throws IllegalStateException if a maximum size or weight was already set\n     */\n    public CacheBuilder<K, V> maximumSize(long maximumSize)\n    {\n        checkState(\n            this.maximumSize == UNSET_INT, \"maximum size was already set to %s\", this.maximumSize);\n        checkState(\n            this.maximumWeight == UNSET_INT,\n            \"maximum weight was already set to %s\",\n            this.maximumWeight);\n        checkState(this.weigher == null, \"maximum size can not be combined with weigher\");\n        checkArgument(maximumSize >= 0, \"maximum size must not be negative\");\n        this.maximumSize = maximumSize;\n        return this;\n    }\n\n    /**\n     * Specifies the maximum weight of entries the cache may contain. Weight is determined using the\n     * {@link Weigher} specified with {@link #weigher}, and use of this method requires a\n     * corresponding call to {@link #weigher} prior to calling {@link #build}.\n     *\n     * <p>Note that the cache <b>may evict an entry before this limit is exceeded</b>. For example, in\n     * the current implementation, when {@code concurrencyLevel} is greater than {@code 1}, each\n     * resulting segment inside the cache <i>independently</i> limits its own weight to approximately\n     * {@code maximumWeight / concurrencyLevel}.\n     *\n     * <p>When eviction is necessary, the cache evicts entries that are less likely to be used again.\n     * For example, the cache may evict an entry because it hasn't been used recently or very often.\n     *\n     * <p>If {@code maximumWeight} is zero, elements will be evicted immediately after being loaded\n     * into cache. This can be useful in testing, or to disable caching temporarily.\n     *\n     * <p>Note that weight is only used to determine whether the cache is over capacity; it has no\n     * effect on selecting which entry should be evicted next.\n     *\n     * <p>This feature cannot be used in conjunction with {@link #maximumSize}.\n     *\n     * @param maximumWeight the maximum total weight of entries the cache may contain\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalArgumentException if {@code maximumWeight} is negative\n     * @throws IllegalStateException if a maximum weight or size was already set\n     * @since 11.0\n     */\n    @GwtIncompatible // To be supported\n    public CacheBuilder<K, V> maximumWeight(long maximumWeight)\n    {\n        checkState(\n            this.maximumWeight == UNSET_INT,\n            \"maximum weight was already set to %s\",\n            this.maximumWeight);\n        checkState(\n            this.maximumSize == UNSET_INT, \"maximum size was already set to %s\", this.maximumSize);\n        this.maximumWeight = maximumWeight;\n        checkArgument(maximumWeight >= 0, \"maximum weight must not be negative\");\n        return this;\n    }\n\n    /**\n     * Specifies the weigher to use in determining the weight of entries. Entry weight is taken into\n     * consideration by {@link #maximumWeight(long)} when determining which entries to evict, and use\n     * of this method requires a corresponding call to {@link #maximumWeight(long)} prior to calling\n     * {@link #build}. Weights are measured and recorded when entries are inserted into the cache, and\n     * are thus effectively static during the lifetime of a cache entry.\n     *\n     * <p>When the weight of an entry is zero it will not be considered for size-based eviction\n     * (though it still may be evicted by other means).\n     *\n     * <p><b>Important note:</b> Instead of returning <em>this</em> as a {@code CacheBuilder}\n     * instance, this method returns {@code CacheBuilder<K1, V1>}. From this point on, either the\n     * original reference or the returned reference may be used to complete configuration and build\n     * the cache, but only the \"generic\" one is type-safe. That is, it will properly prevent you from\n     * building caches whose key or value types are incompatible with the types accepted by the\n     * weigher already provided; the {@code CacheBuilder} type cannot do this. For best results,\n     * simply use the standard method-chaining idiom, as illustrated in the documentation at top,\n     * configuring a {@code CacheBuilder} and building your {@link Cache} all in a single statement.\n     *\n     * <p><b>Warning:</b> if you ignore the above advice, and use this {@code CacheBuilder} to build a\n     * cache whose key or value type is incompatible with the weigher, you will likely experience a\n     * {@link ClassCastException} at some <i>undefined</i> point in the future.\n     *\n     * @param weigher the weigher to use in calculating the weight of cache entries\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalArgumentException if {@code size} is negative\n     * @throws IllegalStateException if a maximum size was already set\n     * @since 11.0\n     */\n    @GwtIncompatible // To be supported\n    public <K1 extends K, V1 extends V> CacheBuilder<K1, V1> weigher(\n        Weigher<? super K1, ? super V1> weigher)\n    {\n        checkState(this.weigher == null);\n        if (strictParsing)\n        {\n            checkState(\n                this.maximumSize == UNSET_INT,\n                \"weigher can not be combined with maximum size\",\n                this.maximumSize);\n        }\n\n        // safely limiting the kinds of caches this can produce\n        @SuppressWarnings(\"unchecked\")\n        CacheBuilder<K1, V1> me = (CacheBuilder<K1, V1>) this;\n        me.weigher = checkNotNull(weigher);\n        return me;\n    }\n\n    long getMaximumWeight()\n    {\n        if (expireAfterWriteNanos == 0 || expireAfterAccessNanos == 0)\n        {\n            return 0;\n        }\n        return (weigher == null) ? maximumSize : maximumWeight;\n    }\n\n    // Make a safe contravariant cast now so we don't have to do it over and over.\n    @SuppressWarnings(\"unchecked\")\n    <K1 extends K, V1 extends V> Weigher<K1, V1> getWeigher()\n    {\n        return (Weigher<K1, V1>) MoreObjects.firstNonNull(weigher, OneWeigher.INSTANCE);\n    }\n\n    /**\n     * Specifies that each key (not value) stored in the cache should be wrapped in a {@link\n     * WeakReference} (by default, strong references are used).\n     *\n     * <p><b>Warning:</b> when this method is used, the resulting cache will use identity ({@code ==})\n     * comparison to determine equality of keys. Its {@link Cache#asMap} view will therefore\n     * technically violate the {@link Map} specification (in the same way that {@link IdentityHashMap}\n     * does).\n     *\n     * <p>Entries with keys that have been garbage collected may be counted in {@link Cache#size}, but\n     * will never be visible to read or write operations; such entries are cleaned up as part of the\n     * routine maintenance described in the class javadoc.\n     *\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalStateException if the key strength was already set\n     */\n    @GwtIncompatible // java.lang.ref.WeakReference\n    public CacheBuilder<K, V> weakKeys()\n    {\n        return setKeyStrength(Strength.WEAK);\n    }\n\n    CacheBuilder<K, V> setKeyStrength(Strength strength)\n    {\n        checkState(keyStrength == null, \"Key strength was already set to %s\", keyStrength);\n        keyStrength = checkNotNull(strength);\n        return this;\n    }\n\n    Strength getKeyStrength()\n    {\n        return MoreObjects.firstNonNull(keyStrength, Strength.STRONG);\n    }\n\n    /**\n     * Specifies that each value (not key) stored in the cache should be wrapped in a {@link\n     * WeakReference} (by default, strong references are used).\n     *\n     * <p>Weak values will be garbage collected once they are weakly reachable. This makes them a poor\n     * candidate for caching; consider {@link #softValues} instead.\n     *\n     * <p><b>Note:</b> when this method is used, the resulting cache will use identity ({@code ==})\n     * comparison to determine equality of values.\n     *\n     * <p>Entries with values that have been garbage collected may be counted in {@link Cache#size},\n     * but will never be visible to read or write operations; such entries are cleaned up as part of\n     * the routine maintenance described in the class javadoc.\n     *\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalStateException if the value strength was already set\n     */\n    @GwtIncompatible // java.lang.ref.WeakReference\n    public CacheBuilder<K, V> weakValues()\n    {\n        return setValueStrength(Strength.WEAK);\n    }\n\n    /**\n     * Specifies that each value (not key) stored in the cache should be wrapped in a {@link\n     * SoftReference} (by default, strong references are used). Softly-referenced objects will be\n     * garbage-collected in a <i>globally</i> least-recently-used manner, in response to memory\n     * demand.\n     *\n     * <p><b>Warning:</b> in most circumstances it is better to set a per-cache {@linkplain\n     * #maximumSize(long) maximum size} instead of using soft references. You should only use this\n     * method if you are well familiar with the practical consequences of soft references.\n     *\n     * <p><b>Note:</b> when this method is used, the resulting cache will use identity ({@code ==})\n     * comparison to determine equality of values.\n     *\n     * <p>Entries with values that have been garbage collected may be counted in {@link Cache#size},\n     * but will never be visible to read or write operations; such entries are cleaned up as part of\n     * the routine maintenance described in the class javadoc.\n     *\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalStateException if the value strength was already set\n     */\n    @GwtIncompatible // java.lang.ref.SoftReference\n    public CacheBuilder<K, V> softValues()\n    {\n        return setValueStrength(Strength.SOFT);\n    }\n\n    CacheBuilder<K, V> setValueStrength(Strength strength)\n    {\n        checkState(valueStrength == null, \"Value strength was already set to %s\", valueStrength);\n        valueStrength = checkNotNull(strength);\n        return this;\n    }\n\n    Strength getValueStrength()\n    {\n        return MoreObjects.firstNonNull(valueStrength, Strength.STRONG);\n    }\n\n    /**\n     * Specifies that each entry should be automatically removed from the cache once a fixed duration\n     * has elapsed after the entry's creation, or the most recent replacement of its value.\n     *\n     * <p>When {@code duration} is zero, this method hands off to {@link #maximumSize(long)\n     * maximumSize}{@code (0)}, ignoring any otherwise-specified maximum size or weight. This can be\n     * useful in testing, or to disable caching temporarily without a code change.\n     *\n     * <p>Expired entries may be counted in {@link Cache#size}, but will never be visible to read or\n     * write operations. Expired entries are cleaned up as part of the routine maintenance described\n     * in the class javadoc.\n     *\n     * @param duration the length of time after an entry is created that it should be automatically\n     *     removed\n     * @param unit the unit that {@code duration} is expressed in\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalArgumentException if {@code duration} is negative\n     * @throws IllegalStateException if the time to live or time to idle was already set\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public CacheBuilder<K, V> expireAfterWrite(long duration, TimeUnit unit)\n    {\n        checkState(\n            expireAfterWriteNanos == UNSET_INT,\n            \"expireAfterWrite was already set to %s ns\",\n            expireAfterWriteNanos);\n        checkArgument(duration >= 0, \"duration cannot be negative: %s %s\", duration, unit);\n        this.expireAfterWriteNanos = unit.toNanos(duration);\n        return this;\n    }\n\n    long getExpireAfterWriteNanos()\n    {\n        return (expireAfterWriteNanos == UNSET_INT) ? DEFAULT_EXPIRATION_NANOS : expireAfterWriteNanos;\n    }\n\n    /**\n     * Specifies that each entry should be automatically removed from the cache once a fixed duration\n     * has elapsed after the entry's creation, the most recent replacement of its value, or its last\n     * access. Access time is reset by all cache read and write operations (including {@code\n     * Cache.asMap().get(Object)} and {@code Cache.asMap().put(K, V)}), but not by operations on the\n     * collection-views of {@link Cache#asMap}.\n     *\n     * <p>When {@code duration} is zero, this method hands off to {@link #maximumSize(long)\n     * maximumSize}{@code (0)}, ignoring any otherwise-specified maximum size or weight. This can be\n     * useful in testing, or to disable caching temporarily without a code change.\n     *\n     * <p>Expired entries may be counted in {@link Cache#size}, but will never be visible to read or\n     * write operations. Expired entries are cleaned up as part of the routine maintenance described\n     * in the class javadoc.\n     *\n     * @param duration the length of time after an entry is last accessed that it should be\n     *     automatically removed\n     * @param unit the unit that {@code duration} is expressed in\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalArgumentException if {@code duration} is negative\n     * @throws IllegalStateException if the time to idle or time to live was already set\n     */\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public CacheBuilder<K, V> expireAfterAccess(long duration, TimeUnit unit)\n    {\n        checkState(\n            expireAfterAccessNanos == UNSET_INT,\n            \"expireAfterAccess was already set to %s ns\",\n            expireAfterAccessNanos);\n        checkArgument(duration >= 0, \"duration cannot be negative: %s %s\", duration, unit);\n        this.expireAfterAccessNanos = unit.toNanos(duration);\n        return this;\n    }\n\n    long getExpireAfterAccessNanos()\n    {\n        return (expireAfterAccessNanos == UNSET_INT)\n               ? DEFAULT_EXPIRATION_NANOS\n               : expireAfterAccessNanos;\n    }\n\n    /**\n     * Specifies that active entries are eligible for automatic refresh once a fixed duration has\n     * elapsed after the entry's creation, or the most recent replacement of its value. The semantics\n     * of refreshes are specified in {@link LoadingCache#refresh}, and are performed by calling {@link\n     * CacheLoader#reload}.\n     *\n     * <p>As the default implementation of {@link CacheLoader#reload} is synchronous, it is\n     * recommended that users of this method override {@link CacheLoader#reload} with an asynchronous\n     * implementation; otherwise refreshes will be performed during unrelated cache read and write\n     * operations.\n     *\n     * <p>Currently automatic refreshes are performed when the first stale request for an entry\n     * occurs. The request triggering refresh will make a blocking call to {@link CacheLoader#reload}\n     * and immediately return the new value if the returned future is complete, and the old value\n     * otherwise.\n     *\n     * <p><b>Note:</b> <i>all exceptions thrown during refresh will be logged and then swallowed</i>.\n     *\n     * @param duration the length of time after an entry is created that it should be considered\n     *     stale, and thus eligible for refresh\n     * @param unit the unit that {@code duration} is expressed in\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalArgumentException if {@code duration} is negative\n     * @throws IllegalStateException if the refresh interval was already set\n     * @since 11.0\n     */\n    @GwtIncompatible // To be supported (synchronously).\n    @SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n    public CacheBuilder<K, V> refreshAfterWrite(long duration, TimeUnit unit)\n    {\n        checkNotNull(unit);\n        checkState(refreshNanos == UNSET_INT, \"refresh was already set to %s ns\", refreshNanos);\n        checkArgument(duration > 0, \"duration must be positive: %s %s\", duration, unit);\n        this.refreshNanos = unit.toNanos(duration);\n        return this;\n    }\n\n    long getRefreshNanos()\n    {\n        return (refreshNanos == UNSET_INT) ? DEFAULT_REFRESH_NANOS : refreshNanos;\n    }\n\n    /**\n     * Specifies a nanosecond-precision time source for this cache. By default, {@link\n     * System#nanoTime} is used.\n     *\n     * <p>The primary intent of this method is to facilitate testing of caches with a fake or mock\n     * time source.\n     *\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalStateException if a ticker was already set\n     */\n    public CacheBuilder<K, V> ticker(Ticker ticker)\n    {\n        checkState(this.ticker == null);\n        this.ticker = checkNotNull(ticker);\n        return this;\n    }\n\n    Ticker getTicker(boolean recordsTime)\n    {\n        if (ticker != null)\n        {\n            return ticker;\n        }\n        return recordsTime ? Ticker.systemTicker() : NULL_TICKER;\n    }\n\n    /**\n     * Specifies a listener instance that caches should notify each time an entry is removed for any\n     * {@linkplain RemovalCause reason}. Each cache created by this builder will invoke this listener\n     * as part of the routine maintenance described in the class documentation above.\n     *\n     * <p><b>Warning:</b> after invoking this method, do not continue to use <i>this</i> cache builder\n     * reference; instead use the reference this method <i>returns</i>. At runtime, these point to the\n     * same instance, but only the returned reference has the correct generic type information so as\n     * to ensure type safety. For best results, use the standard method-chaining idiom illustrated in\n     * the class documentation above, configuring a builder and building your cache in a single\n     * statement. Failure to heed this advice can result in a {@link ClassCastException} being thrown\n     * by a cache operation at some <i>undefined</i> point in the future.\n     *\n     * <p><b>Warning:</b> any exception thrown by {@code listener} will <i>not</i> be propagated to\n     * the {@code Cache} user, only logged via a {@link Logger}.\n     *\n     * @return the cache builder reference that should be used instead of {@code this} for any\n     *     remaining configuration and cache building\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @throws IllegalStateException if a removal listener was already set\n     */\n    @CheckReturnValue\n    public <K1 extends K, V1 extends V> CacheBuilder<K1, V1> removalListener(\n        RemovalListener<? super K1, ? super V1> listener)\n    {\n        checkState(this.removalListener == null);\n\n        // safely limiting the kinds of caches this can produce\n        @SuppressWarnings(\"unchecked\")\n        CacheBuilder<K1, V1> me = (CacheBuilder<K1, V1>) this;\n        me.removalListener = checkNotNull(listener);\n        return me;\n    }\n\n    // Make a safe contravariant cast now so we don't have to do it over and over.\n    @SuppressWarnings(\"unchecked\")\n    <K1 extends K, V1 extends V> RemovalListener<K1, V1> getRemovalListener()\n    {\n        return (RemovalListener<K1, V1>)\n               MoreObjects.firstNonNull(removalListener, NullListener.INSTANCE);\n    }\n\n    /**\n     * Enable the accumulation of {@link CacheStats} during the operation of the cache. Without this\n     * {@link Cache#stats} will return zero for all statistics. Note that recording stats requires\n     * bookkeeping to be performed with each operation, and thus imposes a performance penalty on\n     * cache operation.\n     *\n     * @return this {@code CacheBuilder} instance (for chaining)\n     * @since 12.0 (previously, stats collection was automatic)\n     */\n    public CacheBuilder<K, V> recordStats()\n    {\n        statsCounterSupplier = CACHE_STATS_COUNTER;\n        return this;\n    }\n\n    boolean isRecordingStats()\n    {\n        return statsCounterSupplier == CACHE_STATS_COUNTER;\n    }\n\n    Supplier<? extends StatsCounter> getStatsCounterSupplier()\n    {\n        return statsCounterSupplier;\n    }\n\n    /**\n     * Builds a cache, which either returns an already-loaded value for a given key or atomically\n     * computes or retrieves it using the supplied {@code CacheLoader}. If another thread is currently\n     * loading the value for this key, simply waits for that thread to finish and returns its loaded\n     * value. Note that multiple threads can concurrently load values for distinct keys.\n     *\n     * <p>This method does not alter the state of this {@code CacheBuilder} instance, so it can be\n     * invoked again to create multiple independent caches.\n     *\n     * @param loader the cache loader used to obtain new values\n     * @return a cache having the requested features\n     */\n    public <K1 extends K, V1 extends V> LoadingCache<K1, V1> build(\n        CacheLoader<? super K1, V1> loader)\n    {\n        checkWeightWithWeigher();\n        return new LocalCache.LocalLoadingCache<>(this, loader);\n    }\n\n    /**\n     * Builds a cache which does not automatically load values when keys are requested.\n     *\n     * <p>Consider {@link #build(CacheLoader)} instead, if it is feasible to implement a {@code\n     * CacheLoader}.\n     *\n     * <p>This method does not alter the state of this {@code CacheBuilder} instance, so it can be\n     * invoked again to create multiple independent caches.\n     *\n     * @return a cache having the requested features\n     * @since 11.0\n     */\n\n    private void checkNonLoadingCache()\n    {\n        checkState(refreshNanos == UNSET_INT, \"refreshAfterWrite requires a LoadingCache\");\n    }\n\n    private void checkWeightWithWeigher()\n    {\n        if (weigher == null)\n        {\n            checkState(maximumWeight == UNSET_INT, \"maximumWeight requires weigher\");\n        }\n        else\n        {\n            if (strictParsing)\n            {\n                checkState(maximumWeight != UNSET_INT, \"weigher requires maximumWeight\");\n            }\n            else\n            {\n                if (maximumWeight == UNSET_INT)\n                {\n                    logger.log(Level.WARNING, \"ignoring weigher specified without maximumWeight\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a string representation for this CacheBuilder instance. The exact form of the returned\n     * string is not specified.\n     */\n    @Override\n    public String toString()\n    {\n        MoreObjects.ToStringHelper s = MoreObjects.toStringHelper(this);\n        if (initialCapacity != UNSET_INT)\n        {\n            s.add(\"initialCapacity\", initialCapacity);\n        }\n        if (concurrencyLevel != UNSET_INT)\n        {\n            s.add(\"concurrencyLevel\", concurrencyLevel);\n        }\n        if (maximumSize != UNSET_INT)\n        {\n            s.add(\"maximumSize\", maximumSize);\n        }\n        if (maximumWeight != UNSET_INT)\n        {\n            s.add(\"maximumWeight\", maximumWeight);\n        }\n        if (expireAfterWriteNanos != UNSET_INT)\n        {\n            s.add(\"expireAfterWrite\", expireAfterWriteNanos + \"ns\");\n        }\n        if (expireAfterAccessNanos != UNSET_INT)\n        {\n            s.add(\"expireAfterAccess\", expireAfterAccessNanos + \"ns\");\n        }\n        if (keyStrength != null)\n        {\n            s.add(\"keyStrength\", Ascii.toLowerCase(keyStrength.toString()));\n        }\n        if (valueStrength != null)\n        {\n            s.add(\"valueStrength\", Ascii.toLowerCase(valueStrength.toString()));\n        }\n        if (keyEquivalence != null)\n        {\n            s.addValue(\"keyEquivalence\");\n        }\n        if (valueEquivalence != null)\n        {\n            s.addValue(\"valueEquivalence\");\n        }\n        if (removalListener != null)\n        {\n            s.addValue(\"removalListener\");\n        }\n        return s.toString();\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/CompactHashMap.java", "func_name": "CompactHashMap.allocArrays", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Handle lazy allocation of arrays.", "docstring_tokens": ["Handle", "lazy", "allocation", "of", "arrays", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/CompactHashMap.java#L179-L189", "partition": "valid", "up_fun_num": 6, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.collect.CollectPreconditions.checkRemove;", "import static com.google.common.collect.Hashing.smearedHash;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.annotations.VisibleForTesting;", "import com.google.common.base.Objects;", "import com.google.common.base.Preconditions;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import com.google.j2objc.annotations.WeakOuter;", "import java.io.IOException;", "import java.io.InvalidObjectException;", "import java.io.ObjectInputStream;", "import java.io.ObjectOutputStream;", "import java.io.Serializable;", "import java.util.AbstractCollection;", "import java.util.AbstractMap;", "import java.util.AbstractSet;", "import java.util.Arrays;", "import java.util.Collection;", "import java.util.ConcurrentModificationException;", "import java.util.Iterator;", "import java.util.NoSuchElementException;", "import java.util.Set;", "import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["class CompactHashMap<K, V> extends AbstractMap<K, V> implements Serializable\n", "    public static <K, V> CompactHashMap<K, V> create()\n", "    public static <K, V> CompactHashMap<K, V> createWithExpectedSize(int expectedSize)\n", "    void init(int expectedSize)\n", "    boolean needsAllocArrays()\n", "    private static int[] newTable(int size)\n", "    private static long[] newEntries(int size)\n", "    private int hashTableMask()\n", "    private static int getHash(long entry)\n", "    private static int getNext(long entry)\n", "    private static long swapNext(long entry, int newNext)\n", "    void accessEntry(int index)\n", "    public V put(@NullableDecl K key, @NullableDecl V value)\n", "    void insertEntry(int entryIndex, @NullableDecl K key, @NullableDecl V value, int hash)\n", "    private void resizeMeMaybe(int newSize)\n", "    void resizeEntries(int newCapacity)\n", "    private void resizeTable(int newCapacity)   // newCapacity always a power of two\n", "    private int indexOf(@NullableDecl Object key)\n", "    public boolean containsKey(@NullableDecl Object key)\n", "    public V get(@NullableDecl Object key)\n", "    public V remove(@NullableDecl Object key)\n", "    private V remove(@NullableDecl Object key, int hash)\n", "    private V removeEntry(int entryIndex)\n", "    void moveLastEntry(int dstIndex)\n", "    int firstEntryIndex()\n", "    int getSuccessor(int entryIndex)\n", "    int adjustAfterRemove(int indexBeforeRemove, @SuppressWarnings(\"unused\") int indexRemoved)\n", "    public Set<K> keySet()\n", "    Set<K> createKeySet()\n", "    Iterator<K> keySetIterator()\n", "    public Set<Entry<K, V>> entrySet()\n", "    Set<Entry<K, V>> createEntrySet()\n", "    Iterator<Entry<K, V>> entrySetIterator()\n", "    public int size()\n", "    public boolean isEmpty()\n", "    public boolean containsValue(@NullableDecl Object value)\n", "    public Collection<V> values()\n", "    Collection<V> createValues()\n", "    Iterator<V> valuesIterator()\n", "    public void trimToSize()\n", "    public void clear()\n", "    private void writeObject(ObjectOutputStream stream) throws IOException\n", "    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException\n"], "context": "/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.collect.CollectPreconditions.checkRemove;\nimport static com.google.common.collect.Hashing.smearedHash;\n\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Objects;\nimport com.google.common.base.Preconditions;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.google.j2objc.annotations.WeakOuter;\nimport java.io.IOException;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.AbstractCollection;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.ConcurrentModificationException;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\nimport org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * CompactHashMap is an implementation of a Map. All optional operations (put and remove) are\n * supported. Null keys and values are supported.\n *\n * <p>{@code containsKey(k)}, {@code put(k, v)} and {@code remove(k)} are all (expected and\n * amortized) constant time operations. Expected in the hashtable sense (depends on the hash\n * function doing a good job of distributing the elements to the buckets to a distribution not far\n * from uniform), and amortized since some operations can trigger a hash table resize.\n *\n * <p>Unlike {@code java.util.HashMap}, iteration is only proportional to the actual {@code size()},\n * which is optimal, and <i>not</i> the size of the internal hashtable, which could be much larger\n * than {@code size()}. Furthermore, this structure places significantly reduced load on the garbage\n * collector by only using a constant number of internal objects.\n *\n * <p>If there are no removals, then iteration order for the {@link #entrySet}, {@link #keySet}, and\n * {@link #values} views is the same as insertion order. Any removal invalidates any ordering\n * guarantees.\n *\n * <p>This class should not be assumed to be universally superior to {@code java.util.HashMap}.\n * Generally speaking, this class reduces object allocation and memory consumption at the price of\n * moderately increased constant factors of CPU. Only use this class when there is a specific reason\n * to prioritize memory over CPU.\n *\n * @author Louis Wasserman\n */\n@GwtIncompatible // not worth using in GWT for now\nclass CompactHashMap<K, V> extends AbstractMap<K, V> implements Serializable\n{\n    /*\n     * TODO: Make this a drop-in replacement for j.u. versions, actually drop them in, and test the\n     * world. Figure out what sort of space-time tradeoff we're actually going to get here with the\n     * *Map variants. Followon optimizations, such as using 16-bit indices for small collections, will\n     * take more work to implement. This class is particularly hard to benchmark, because the benefit\n     * is not only in less allocation, but also having the GC do less work to scan the heap because of\n     * fewer references, which is particularly hard to quantify.\n     */\n\n    /** Creates an empty {@code CompactHashMap} instance. */\n    public static <K, V> CompactHashMap<K, V> create()\n    {\n        return new CompactHashMap<>();\n    }\n\n    /**\n     * Creates a {@code CompactHashMap} instance, with a high enough \"initial capacity\" that it\n     * <i>should</i> hold {@code expectedSize} elements without growth.\n     *\n     * @param expectedSize the number of elements you expect to add to the returned set\n     * @return a new, empty {@code CompactHashMap} with enough capacity to hold {@code expectedSize}\n     *     elements without resizing\n     * @throws IllegalArgumentException if {@code expectedSize} is negative\n     */\n    public static <K, V> CompactHashMap<K, V> createWithExpectedSize(int expectedSize)\n    {\n        return new CompactHashMap<>(expectedSize);\n    }\n\n    private static final float LOAD_FACTOR = 1.0f;\n\n    /** Bitmask that selects the low 32 bits. */\n    private static final long NEXT_MASK = (1L << 32) - 1;\n\n    /** Bitmask that selects the high 32 bits. */\n    private static final long HASH_MASK = ~NEXT_MASK;\n\n    // TODO(user): decide default size\n    static final int DEFAULT_SIZE = 3;\n\n    // used to indicate blank table entries\n    static final int UNSET = -1;\n\n    /**\n     * The hashtable. Its values are indexes to the keys, values, and entries arrays.\n     *\n     * <p>Currently, the UNSET value means \"null pointer\", and any non negative value x is the actual\n     * index.\n     *\n     * <p>Its size must be a power of two.\n     */\n    @MonotonicNonNullDecl private transient int[] table;\n\n    /**\n     * Contains the logical entries, in the range of [0, size()). The high 32 bits of each long is the\n     * smeared hash of the element, whereas the low 32 bits is the \"next\" pointer (pointing to the\n     * next entry in the bucket chain). The pointers in [size(), entries.length) are all \"null\"\n     * (UNSET).\n     */\n    @VisibleForTesting @MonotonicNonNullDecl transient long[] entries;\n\n    /**\n     * The keys of the entries in the map, in the range of [0, size()). The keys in [size(),\n     * keys.length) are all {@code null}.\n     */\n    @VisibleForTesting @MonotonicNonNullDecl transient Object[] keys;\n\n    /**\n     * The values of the entries in the map, in the range of [0, size()). The values in [size(),\n     * values.length) are all {@code null}.\n     */\n    @VisibleForTesting @MonotonicNonNullDecl transient Object[] values;\n\n    /**\n     * Keeps track of modifications of this set, to make it possible to throw\n     * ConcurrentModificationException in the iterator. Note that we choose not to make this volatile,\n     * so we do less of a \"best effort\" to track such errors, for better performance.\n     */\n    transient int modCount;\n\n    /** The number of elements contained in the set. */\n    private transient int size;\n\n    /** Constructs a new empty instance of {@code CompactHashMap}. */\n    CompactHashMap()\n    {\n        init(DEFAULT_SIZE);\n    }\n\n    /**\n     * Constructs a new instance of {@code CompactHashMap} with the specified capacity.\n     *\n     * @param expectedSize the initial capacity of this {@code CompactHashMap}.\n     */\n    CompactHashMap(int expectedSize)\n    {\n        init(expectedSize);\n    }\n\n    /** Pseudoconstructor for serialization support. */\n    void init(int expectedSize)\n    {\n        Preconditions.checkArgument(expectedSize >= 0, \"Expected size must be non-negative\");\n        this.modCount = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()\n    }\n\n    /** Returns whether arrays need to be allocated. */\n    boolean needsAllocArrays()\n    {\n        return table == null;\n    }\n\n    /** Handle lazy allocation of arrays. */\n\n    private static int[] newTable(int size)\n    {\n        int[] array = new int[size];\n        Arrays.fill(array, UNSET);\n        return array;\n    }\n\n    private static long[] newEntries(int size)\n    {\n        long[] array = new long[size];\n        Arrays.fill(array, UNSET);\n        return array;\n    }\n\n    private int hashTableMask()\n    {\n        return table.length - 1;\n    }\n\n    private static int getHash(long entry)\n    {\n        return (int) (entry >>> 32);\n    }\n\n    /** Returns the index, or UNSET if the pointer is \"null\" */\n    private static int getNext(long entry)\n    {\n        return (int) entry;\n    }\n\n    /** Returns a new entry value by changing the \"next\" index of an existing entry */\n    private static long swapNext(long entry, int newNext)\n    {\n        return (HASH_MASK & entry) | (NEXT_MASK & newNext);\n    }\n\n    /**\n     * Mark an access of the specified entry. Used only in {@code CompactLinkedHashMap} for LRU\n     * ordering.\n     */\n    void accessEntry(int index)\n    {\n        // no-op by default\n    }\n\n    @CanIgnoreReturnValue\n    @Override\n    @NullableDecl\n    public V put(@NullableDecl K key, @NullableDecl V value)\n    {\n        if (needsAllocArrays())\n        {\n            allocArrays();\n        }\n        long[] entries = this.entries;\n        Object[] keys = this.keys;\n        Object[] values = this.values;\n\n        int hash = smearedHash(key);\n        int tableIndex = hash & hashTableMask();\n        int newEntryIndex = this.size; // current size, and pointer to the entry to be appended\n        int next = table[tableIndex];\n        if (next == UNSET)   // uninitialized bucket\n        {\n            table[tableIndex] = newEntryIndex;\n        }\n        else\n        {\n            int last;\n            long entry;\n            do\n            {\n                last = next;\n                entry = entries[next];\n                if (getHash(entry) == hash && Objects.equal(key, keys[next]))\n                {\n                    @SuppressWarnings(\"unchecked\") // known to be a V\n                    @NullableDecl\n                    V oldValue = (V) values[next];\n\n                    values[next] = value;\n                    accessEntry(next);\n                    return oldValue;\n                }\n                next = getNext(entry);\n            }\n            while (next != UNSET);\n            entries[last] = swapNext(entry, newEntryIndex);\n        }\n        if (newEntryIndex == Integer.MAX_VALUE)\n        {\n            throw new IllegalStateException(\"Cannot contain more than Integer.MAX_VALUE elements!\");\n        }\n        int newSize = newEntryIndex + 1;\n        resizeMeMaybe(newSize);\n        insertEntry(newEntryIndex, key, value, hash);\n        this.size = newSize;\n        int oldCapacity = table.length;\n        if (Hashing.needsResizing(newEntryIndex, oldCapacity, LOAD_FACTOR))\n        {\n            resizeTable(2 * oldCapacity);\n        }\n        modCount++;\n        return null;\n    }\n\n    /**\n     * Creates a fresh entry with the specified object at the specified position in the entry arrays.\n     */\n    void insertEntry(int entryIndex, @NullableDecl K key, @NullableDecl V value, int hash)\n    {\n        this.entries[entryIndex] = ((long) hash << 32) | (NEXT_MASK & UNSET);\n        this.keys[entryIndex] = key;\n        this.values[entryIndex] = value;\n    }\n\n    /** Resizes the entries storage if necessary. */\n    private void resizeMeMaybe(int newSize)\n    {\n        int entriesSize = entries.length;\n        if (newSize > entriesSize)\n        {\n            int newCapacity = entriesSize + Math.max(1, entriesSize >>> 1);\n            if (newCapacity < 0)\n            {\n                newCapacity = Integer.MAX_VALUE;\n            }\n            if (newCapacity != entriesSize)\n            {\n                resizeEntries(newCapacity);\n            }\n        }\n    }\n\n    /**\n     * Resizes the internal entries array to the specified capacity, which may be greater or less than\n     * the current capacity.\n     */\n    void resizeEntries(int newCapacity)\n    {\n        this.keys = Arrays.copyOf(keys, newCapacity);\n        this.values = Arrays.copyOf(values, newCapacity);\n        long[] entries = this.entries;\n        int oldCapacity = entries.length;\n        entries = Arrays.copyOf(entries, newCapacity);\n        if (newCapacity > oldCapacity)\n        {\n            Arrays.fill(entries, oldCapacity, newCapacity, UNSET);\n        }\n        this.entries = entries;\n    }\n\n    private void resizeTable(int newCapacity)   // newCapacity always a power of two\n    {\n        int[] newTable = newTable(newCapacity);\n        long[] entries = this.entries;\n\n        int mask = newTable.length - 1;\n        for (int i = 0; i < size; i++)\n        {\n            long oldEntry = entries[i];\n            int hash = getHash(oldEntry);\n            int tableIndex = hash & mask;\n            int next = newTable[tableIndex];\n            newTable[tableIndex] = i;\n            entries[i] = ((long) hash << 32) | (NEXT_MASK & next);\n        }\n\n        this.table = newTable;\n    }\n\n    private int indexOf(@NullableDecl Object key)\n    {\n        if (needsAllocArrays())\n        {\n            return -1;\n        }\n        int hash = smearedHash(key);\n        int next = table[hash & hashTableMask()];\n        while (next != UNSET)\n        {\n            long entry = entries[next];\n            if (getHash(entry) == hash && Objects.equal(key, keys[next]))\n            {\n                return next;\n            }\n            next = getNext(entry);\n        }\n        return -1;\n    }\n\n    @Override\n    public boolean containsKey(@NullableDecl Object key)\n    {\n        return indexOf(key) != -1;\n    }\n\n    @SuppressWarnings(\"unchecked\") // values only contains Vs\n    @Override\n    public V get(@NullableDecl Object key)\n    {\n        int index = indexOf(key);\n        accessEntry(index);\n        return (index == -1) ? null : (V) values[index];\n    }\n\n    @CanIgnoreReturnValue\n    @Override\n    @NullableDecl\n    public V remove(@NullableDecl Object key)\n    {\n        if (needsAllocArrays())\n        {\n            return null;\n        }\n        return remove(key, smearedHash(key));\n    }\n\n    @NullableDecl\n    private V remove(@NullableDecl Object key, int hash)\n    {\n        int tableIndex = hash & hashTableMask();\n        int next = table[tableIndex];\n        if (next == UNSET)   // empty bucket\n        {\n            return null;\n        }\n        int last = UNSET;\n        do\n        {\n            if (getHash(entries[next]) == hash && Objects.equal(key, keys[next]))\n            {\n                @SuppressWarnings(\"unchecked\") // values only contains Vs\n                @NullableDecl\n                V oldValue = (V) values[next];\n\n                if (last == UNSET)\n                {\n                    // we need to update the root link from table[]\n                    table[tableIndex] = getNext(entries[next]);\n                }\n                else\n                {\n                    // we need to update the link from the chain\n                    entries[last] = swapNext(entries[last], getNext(entries[next]));\n                }\n\n                moveLastEntry(next);\n                size--;\n                modCount++;\n                return oldValue;\n            }\n            last = next;\n            next = getNext(entries[next]);\n        }\n        while (next != UNSET);\n        return null;\n    }\n\n    @CanIgnoreReturnValue\n    private V removeEntry(int entryIndex)\n    {\n        return remove(keys[entryIndex], getHash(entries[entryIndex]));\n    }\n\n    /**\n     * Moves the last entry in the entry array into {@code dstIndex}, and nulls out its old position.\n     */\n    void moveLastEntry(int dstIndex)\n    {\n        int srcIndex = size() - 1;\n        if (dstIndex < srcIndex)\n        {\n            // move last entry to deleted spot\n            keys[dstIndex] = keys[srcIndex];\n            values[dstIndex] = values[srcIndex];\n            keys[srcIndex] = null;\n            values[srcIndex] = null;\n\n            // move the last entry to the removed spot, just like we moved the element\n            long lastEntry = entries[srcIndex];\n            entries[dstIndex] = lastEntry;\n            entries[srcIndex] = UNSET;\n\n            // also need to update whoever's \"next\" pointer was pointing to the last entry place\n            // reusing \"tableIndex\" and \"next\"; these variables were no longer needed\n            int tableIndex = getHash(lastEntry) & hashTableMask();\n            int lastNext = table[tableIndex];\n            if (lastNext == srcIndex)\n            {\n                // we need to update the root pointer\n                table[tableIndex] = dstIndex;\n            }\n            else\n            {\n                // we need to update a pointer in an entry\n                int previous;\n                long entry;\n                do\n                {\n                    previous = lastNext;\n                    lastNext = getNext(entry = entries[lastNext]);\n                }\n                while (lastNext != srcIndex);\n                // here, entries[previous] points to the old entry location; update it\n                entries[previous] = swapNext(entry, dstIndex);\n            }\n        }\n        else\n        {\n            keys[dstIndex] = null;\n            values[dstIndex] = null;\n            entries[dstIndex] = UNSET;\n        }\n    }\n\n    int firstEntryIndex()\n    {\n        return isEmpty() ? -1 : 0;\n    }\n\n    int getSuccessor(int entryIndex)\n    {\n        return (entryIndex + 1 < size) ? entryIndex + 1 : -1;\n    }\n\n    /**\n     * Updates the index an iterator is pointing to after a call to remove: returns the index of the\n     * entry that should be looked at after a removal on indexRemoved, with indexBeforeRemove as the\n     * index that *was* the next entry that would be looked at.\n     */\n    int adjustAfterRemove(int indexBeforeRemove, @SuppressWarnings(\"unused\") int indexRemoved)\n    {\n        return indexBeforeRemove - 1;\n    }\n\n    private abstract class Itr<T> implements Iterator<T>\n    {\n        int expectedModCount = modCount;\n        int currentIndex = firstEntryIndex();\n        int indexToRemove = -1;\n\n        @Override\n        public boolean hasNext()\n        {\n            return currentIndex >= 0;\n        }\n\n        abstract T getOutput(int entry);\n\n        @Override\n        public T next()\n        {\n            checkForConcurrentModification();\n            if (!hasNext())\n            {\n                throw new NoSuchElementException();\n            }\n            indexToRemove = currentIndex;\n            T result = getOutput(currentIndex);\n            currentIndex = getSuccessor(currentIndex);\n            return result;\n        }\n\n        @Override\n        public void remove()\n        {\n            checkForConcurrentModification();\n            checkRemove(indexToRemove >= 0);\n            expectedModCount++;\n            removeEntry(indexToRemove);\n            currentIndex = adjustAfterRemove(currentIndex, indexToRemove);\n            indexToRemove = -1;\n        }\n\n        private void checkForConcurrentModification()\n        {\n            if (modCount != expectedModCount)\n            {\n                throw new ConcurrentModificationException();\n            }\n        }\n    }\n\n    @MonotonicNonNullDecl private transient Set<K> keySetView;\n\n    @Override\n    public Set<K> keySet()\n    {\n        return (keySetView == null) ? keySetView = createKeySet() : keySetView;\n    }\n\n    Set<K> createKeySet()\n    {\n        return new KeySetView();\n    }\n\n    @WeakOuter\n    class KeySetView extends AbstractSet<K>\n    {\n        @Override\n        public int size()\n        {\n            return size;\n        }\n\n        @Override\n        public boolean contains(Object o)\n        {\n            return CompactHashMap.this.containsKey(o);\n        }\n\n        @Override\n        public boolean remove(@NullableDecl Object o)\n        {\n            int index = indexOf(o);\n            if (index == -1)\n            {\n                return false;\n            }\n            else\n            {\n                removeEntry(index);\n                return true;\n            }\n        }\n\n        @Override\n        public Iterator<K> iterator()\n        {\n            return keySetIterator();\n        }\n\n        @Override\n        public void clear()\n        {\n            CompactHashMap.this.clear();\n        }\n    }\n\n    Iterator<K> keySetIterator()\n    {\n        return new Itr<K>()\n        {\n            @SuppressWarnings(\"unchecked\") // keys only contains Ks\n            @Override\n            K getOutput(int entry)\n            {\n                return (K) keys[entry];\n            }\n        };\n    }\n\n    @MonotonicNonNullDecl private transient Set<Entry<K, V>> entrySetView;\n\n    @Override\n    public Set<Entry<K, V>> entrySet()\n    {\n        return (entrySetView == null) ? entrySetView = createEntrySet() : entrySetView;\n    }\n\n    Set<Entry<K, V>> createEntrySet()\n    {\n        return new EntrySetView();\n    }\n\n    @WeakOuter\n    class EntrySetView extends AbstractSet<Entry<K, V>>\n    {\n\n        @Override\n        public int size()\n        {\n            return size;\n        }\n\n        @Override\n        public void clear()\n        {\n            CompactHashMap.this.clear();\n        }\n\n        @Override\n        public Iterator<Entry<K, V>> iterator()\n        {\n            return entrySetIterator();\n        }\n\n        @Override\n        public boolean contains(@NullableDecl Object o)\n        {\n            if (o instanceof Entry)\n            {\n                Entry<?, ?> entry = (Entry<?, ?>) o;\n                int index = indexOf(entry.getKey());\n                return index != -1 && Objects.equal(values[index], entry.getValue());\n            }\n            return false;\n        }\n\n        @Override\n        public boolean remove(@NullableDecl Object o)\n        {\n            if (o instanceof Entry)\n            {\n                Entry<?, ?> entry = (Entry<?, ?>) o;\n                int index = indexOf(entry.getKey());\n                if (index != -1 && Objects.equal(values[index], entry.getValue()))\n                {\n                    removeEntry(index);\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    Iterator<Entry<K, V>> entrySetIterator()\n    {\n        return new Itr<Entry<K, V>>()\n        {\n            @Override\n            Entry<K, V> getOutput(int entry)\n            {\n                return new MapEntry(entry);\n            }\n        };\n    }\n\n    final class MapEntry extends AbstractMapEntry<K, V>\n    {\n        @NullableDecl private final K key;\n\n        private int lastKnownIndex;\n\n        @SuppressWarnings(\"unchecked\") // keys only contains Ks\n        MapEntry(int index)\n        {\n            this.key = (K) keys[index];\n            this.lastKnownIndex = index;\n        }\n\n        @Override\n        public K getKey()\n        {\n            return key;\n        }\n\n        private void updateLastKnownIndex()\n        {\n            if (lastKnownIndex == -1\n                    || lastKnownIndex >= size()\n                    || !Objects.equal(key, keys[lastKnownIndex]))\n            {\n                lastKnownIndex = indexOf(key);\n            }\n        }\n\n        @SuppressWarnings(\"unchecked\") // values only contains Vs\n        @Override\n        public V getValue()\n        {\n            updateLastKnownIndex();\n            return (lastKnownIndex == -1) ? null : (V) values[lastKnownIndex];\n        }\n\n        @SuppressWarnings(\"unchecked\") // values only contains Vs\n        @Override\n        public V setValue(V value)\n        {\n            updateLastKnownIndex();\n            if (lastKnownIndex == -1)\n            {\n                put(key, value);\n                return null;\n            }\n            else\n            {\n                V old = (V) values[lastKnownIndex];\n                values[lastKnownIndex] = value;\n                return old;\n            }\n        }\n    }\n\n    @Override\n    public int size()\n    {\n        return size;\n    }\n\n    @Override\n    public boolean isEmpty()\n    {\n        return size == 0;\n    }\n\n    @Override\n    public boolean containsValue(@NullableDecl Object value)\n    {\n        for (int i = 0; i < size; i++)\n        {\n            if (Objects.equal(value, values[i]))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @MonotonicNonNullDecl private transient Collection<V> valuesView;\n\n    @Override\n    public Collection<V> values()\n    {\n        return (valuesView == null) ? valuesView = createValues() : valuesView;\n    }\n\n    Collection<V> createValues()\n    {\n        return new ValuesView();\n    }\n\n    @WeakOuter\n    class ValuesView extends AbstractCollection<V>\n    {\n        @Override\n        public int size()\n        {\n            return size;\n        }\n\n        @Override\n        public void clear()\n        {\n            CompactHashMap.this.clear();\n        }\n\n        @Override\n        public Iterator<V> iterator()\n        {\n            return valuesIterator();\n        }\n    }\n\n    Iterator<V> valuesIterator()\n    {\n        return new Itr<V>()\n        {\n            @SuppressWarnings(\"unchecked\") // values only contains Vs\n            @Override\n            V getOutput(int entry)\n            {\n                return (V) values[entry];\n            }\n        };\n    }\n\n    /**\n     * Ensures that this {@code CompactHashMap} has the smallest representation in memory, given its\n     * current size.\n     */\n    public void trimToSize()\n    {\n        if (needsAllocArrays())\n        {\n            return;\n        }\n        int size = this.size;\n        if (size < entries.length)\n        {\n            resizeEntries(size);\n        }\n        int minimumTableSize = Hashing.closedTableSize(size, LOAD_FACTOR);\n        if (minimumTableSize < table.length)\n        {\n            resizeTable(minimumTableSize);\n        }\n    }\n\n    @Override\n    public void clear()\n    {\n        if (needsAllocArrays())\n        {\n            return;\n        }\n        modCount++;\n        Arrays.fill(keys, 0, size, null);\n        Arrays.fill(values, 0, size, null);\n        Arrays.fill(table, UNSET);\n        Arrays.fill(entries, 0, size, UNSET);\n        this.size = 0;\n    }\n\n    /**\n     * The serial form currently mimics Android's java.util.HashMap version, e.g. see\n     * http://omapzoom.org/?p=platform/libcore.git;a=blob;f=luni/src/main/java/java/util/HashMap.java\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException\n    {\n        stream.defaultWriteObject();\n        stream.writeInt(size);\n        for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i))\n        {\n            stream.writeObject(keys[i]);\n            stream.writeObject(values[i]);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException\n    {\n        stream.defaultReadObject();\n        int elementCount = stream.readInt();\n        if (elementCount < 0)\n        {\n            throw new InvalidObjectException(\"Invalid size: \" + elementCount);\n        }\n        init(elementCount);\n        for (int i = 0; i < elementCount; i++)\n        {\n            K key = (K) stream.readObject();\n            V value = (V) stream.readObject();\n            put(key, value);\n        }\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/math/StatsAccumulator.java", "func_name": "StatsAccumulator.add", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Adds the given value to the dataset.", "docstring_tokens": ["Adds", "the", "given", "value", "to", "the", "dataset", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/math/StatsAccumulator.java#L48-L71", "partition": "valid", "up_fun_num": 2, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkState;", "import static com.google.common.math.DoubleUtils.ensureNonNegative;", "import static com.google.common.primitives.Doubles.isFinite;", "import static java.lang.Double.NaN;", "import static java.lang.Double.isNaN;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import java.util.Iterator;"], "function": ["public final class StatsAccumulator\n", "    public void addAll(Iterable<? extends Number> values)\n", "    public void addAll(Iterator<? extends Number> values)\n", "    public void addAll(double... values)\n", "    public void addAll(int... values)\n", "    public void addAll(long... values)\n", "    public void addAll(Stats values)\n", "    public Stats snapshot()\n", "    public long count()\n", "    public double mean()\n", "    public final double sum()\n", "    public final double populationVariance()\n", "    public final double populationStandardDeviation()\n", "    public final double sampleVariance()\n", "    public final double sampleStandardDeviation()\n", "    public double min()\n", "    public double max()\n", "    double sumOfSquaresOfDeltas()\n", "    static double calculateNewMeanNonFinite(double previousMean, double value)\n"], "context": "/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.math;\n\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.math.DoubleUtils.ensureNonNegative;\nimport static com.google.common.primitives.Doubles.isFinite;\nimport static java.lang.Double.NaN;\nimport static java.lang.Double.isNaN;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport java.util.Iterator;\n\n/**\n * A mutable object which accumulates double values and tracks some basic statistics over all the\n * values added so far. The values may be added singly or in groups. This class is not thread safe.\n *\n * @author Pete Gillin\n * @author Kevin Bourrillion\n * @since 20.0\n */\n@Beta\n@GwtIncompatible\npublic final class StatsAccumulator\n{\n\n    // These fields must satisfy the requirements of Stats' constructor as well as those of the stat\n    // methods of this class.\n    private long count = 0;\n    private double mean = 0.0; // any finite value will do, we only use it to multiply by zero for sum\n    private double sumOfSquaresOfDeltas = 0.0;\n    private double min = NaN; // any value will do\n    private double max = NaN; // any value will do\n\n    /** Adds the given value to the dataset. */\n\n    /**\n     * Adds the given values to the dataset.\n     *\n     * @param values a series of values, which will be converted to {@code double} values (this may\n     *     cause loss of precision)\n     */\n    public void addAll(Iterable<? extends Number> values)\n    {\n        for (Number value : values)\n        {\n            add(value.doubleValue());\n        }\n    }\n\n    /**\n     * Adds the given values to the dataset.\n     *\n     * @param values a series of values, which will be converted to {@code double} values (this may\n     *     cause loss of precision)\n     */\n    public void addAll(Iterator<? extends Number> values)\n    {\n        while (values.hasNext())\n        {\n            add(values.next().doubleValue());\n        }\n    }\n\n    /**\n     * Adds the given values to the dataset.\n     *\n     * @param values a series of values\n     */\n    public void addAll(double... values)\n    {\n        for (double value : values)\n        {\n            add(value);\n        }\n    }\n\n    /**\n     * Adds the given values to the dataset.\n     *\n     * @param values a series of values\n     */\n    public void addAll(int... values)\n    {\n        for (int value : values)\n        {\n            add(value);\n        }\n    }\n\n    /**\n     * Adds the given values to the dataset.\n     *\n     * @param values a series of values, which will be converted to {@code double} values (this may\n     *     cause loss of precision for longs of magnitude over 2^53 (slightly over 9e15))\n     */\n    public void addAll(long... values)\n    {\n        for (long value : values)\n        {\n            add(value);\n        }\n    }\n\n    /**\n     * Adds the given statistics to the dataset, as if the individual values used to compute the\n     * statistics had been added directly.\n     */\n    public void addAll(Stats values)\n    {\n        if (values.count() == 0)\n        {\n            return;\n        }\n\n        if (count == 0)\n        {\n            count = values.count();\n            mean = values.mean();\n            sumOfSquaresOfDeltas = values.sumOfSquaresOfDeltas();\n            min = values.min();\n            max = values.max();\n        }\n        else\n        {\n            count += values.count();\n            if (isFinite(mean) && isFinite(values.mean()))\n            {\n                // This is a generalized version of the calculation in add(double) above.\n                double delta = values.mean() - mean;\n                mean += delta * values.count() / count;\n                sumOfSquaresOfDeltas +=\n                    values.sumOfSquaresOfDeltas() + delta * (values.mean() - mean) * values.count();\n            }\n            else\n            {\n                mean = calculateNewMeanNonFinite(mean, values.mean());\n                sumOfSquaresOfDeltas = NaN;\n            }\n            min = Math.min(min, values.min());\n            max = Math.max(max, values.max());\n        }\n    }\n\n    /** Returns an immutable snapshot of the current statistics. */\n    public Stats snapshot()\n    {\n        return new Stats(count, mean, sumOfSquaresOfDeltas, min, max);\n    }\n\n    /** Returns the number of values. */\n    public long count()\n    {\n        return count;\n    }\n\n    /**\n     * Returns the <a href=\"http://en.wikipedia.org/wiki/Arithmetic_mean\">arithmetic mean</a> of the\n     * values. The count must be non-zero.\n     *\n     * <p>If these values are a sample drawn from a population, this is also an unbiased estimator of\n     * the arithmetic mean of the population.\n     *\n     * <h3>Non-finite values</h3>\n     *\n     * <p>If the dataset contains {@link Double#NaN} then the result is {@link Double#NaN}. If it\n     * contains both {@link Double#POSITIVE_INFINITY} and {@link Double#NEGATIVE_INFINITY} then the\n     * result is {@link Double#NaN}. If it contains {@link Double#POSITIVE_INFINITY} and finite values\n     * only or {@link Double#POSITIVE_INFINITY} only, the result is {@link Double#POSITIVE_INFINITY}.\n     * If it contains {@link Double#NEGATIVE_INFINITY} and finite values only or {@link\n     * Double#NEGATIVE_INFINITY} only, the result is {@link Double#NEGATIVE_INFINITY}.\n     *\n     * @throws IllegalStateException if the dataset is empty\n     */\n    public double mean()\n    {\n        checkState(count != 0);\n        return mean;\n    }\n\n    /**\n     * Returns the sum of the values.\n     *\n     * <h3>Non-finite values</h3>\n     *\n     * <p>If the dataset contains {@link Double#NaN} then the result is {@link Double#NaN}. If it\n     * contains both {@link Double#POSITIVE_INFINITY} and {@link Double#NEGATIVE_INFINITY} then the\n     * result is {@link Double#NaN}. If it contains {@link Double#POSITIVE_INFINITY} and finite values\n     * only or {@link Double#POSITIVE_INFINITY} only, the result is {@link Double#POSITIVE_INFINITY}.\n     * If it contains {@link Double#NEGATIVE_INFINITY} and finite values only or {@link\n     * Double#NEGATIVE_INFINITY} only, the result is {@link Double#NEGATIVE_INFINITY}.\n     */\n    public final double sum()\n    {\n        return mean * count;\n    }\n\n    /**\n     * Returns the <a href=\"http://en.wikipedia.org/wiki/Variance#Population_variance\">population\n     * variance</a> of the values. The count must be non-zero.\n     *\n     * <p>This is guaranteed to return zero if the dataset contains only exactly one finite value. It\n     * is not guaranteed to return zero when the dataset consists of the same value multiple times,\n     * due to numerical errors. However, it is guaranteed never to return a negative result.\n     *\n     * <h3>Non-finite values</h3>\n     *\n     * <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link\n     * Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.\n     *\n     * @throws IllegalStateException if the dataset is empty\n     */\n    public final double populationVariance()\n    {\n        checkState(count != 0);\n        if (isNaN(sumOfSquaresOfDeltas))\n        {\n            return NaN;\n        }\n        if (count == 1)\n        {\n            return 0.0;\n        }\n        return ensureNonNegative(sumOfSquaresOfDeltas) / count;\n    }\n\n    /**\n     * Returns the <a\n     * href=\"http://en.wikipedia.org/wiki/Standard_deviation#Definition_of_population_values\">\n     * population standard deviation</a> of the values. The count must be non-zero.\n     *\n     * <p>This is guaranteed to return zero if the dataset contains only exactly one finite value. It\n     * is not guaranteed to return zero when the dataset consists of the same value multiple times,\n     * due to numerical errors. However, it is guaranteed never to return a negative result.\n     *\n     * <h3>Non-finite values</h3>\n     *\n     * <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link\n     * Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.\n     *\n     * @throws IllegalStateException if the dataset is empty\n     */\n    public final double populationStandardDeviation()\n    {\n        return Math.sqrt(populationVariance());\n    }\n\n    /**\n     * Returns the <a href=\"http://en.wikipedia.org/wiki/Variance#Sample_variance\">unbiased sample\n     * variance</a> of the values. If this dataset is a sample drawn from a population, this is an\n     * unbiased estimator of the population variance of the population. The count must be greater than\n     * one.\n     *\n     * <p>This is not guaranteed to return zero when the dataset consists of the same value multiple\n     * times, due to numerical errors. However, it is guaranteed never to return a negative result.\n     *\n     * <h3>Non-finite values</h3>\n     *\n     * <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link\n     * Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.\n     *\n     * @throws IllegalStateException if the dataset is empty or contains a single value\n     */\n    public final double sampleVariance()\n    {\n        checkState(count > 1);\n        if (isNaN(sumOfSquaresOfDeltas))\n        {\n            return NaN;\n        }\n        return ensureNonNegative(sumOfSquaresOfDeltas) / (count - 1);\n    }\n\n    /**\n     * Returns the <a\n     * href=\"http://en.wikipedia.org/wiki/Standard_deviation#Corrected_sample_standard_deviation\">\n     * corrected sample standard deviation</a> of the values. If this dataset is a sample drawn from a\n     * population, this is an estimator of the population standard deviation of the population which\n     * is less biased than {@link #populationStandardDeviation()} (the unbiased estimator depends on\n     * the distribution). The count must be greater than one.\n     *\n     * <p>This is not guaranteed to return zero when the dataset consists of the same value multiple\n     * times, due to numerical errors. However, it is guaranteed never to return a negative result.\n     *\n     * <h3>Non-finite values</h3>\n     *\n     * <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link\n     * Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.\n     *\n     * @throws IllegalStateException if the dataset is empty or contains a single value\n     */\n    public final double sampleStandardDeviation()\n    {\n        return Math.sqrt(sampleVariance());\n    }\n\n    /**\n     * Returns the lowest value in the dataset. The count must be non-zero.\n     *\n     * <h3>Non-finite values</h3>\n     *\n     * <p>If the dataset contains {@link Double#NaN} then the result is {@link Double#NaN}. If it\n     * contains {@link Double#NEGATIVE_INFINITY} and not {@link Double#NaN} then the result is {@link\n     * Double#NEGATIVE_INFINITY}. If it contains {@link Double#POSITIVE_INFINITY} and finite values\n     * only then the result is the lowest finite value. If it contains {@link\n     * Double#POSITIVE_INFINITY} only then the result is {@link Double#POSITIVE_INFINITY}.\n     *\n     * @throws IllegalStateException if the dataset is empty\n     */\n    public double min()\n    {\n        checkState(count != 0);\n        return min;\n    }\n\n    /**\n     * Returns the highest value in the dataset. The count must be non-zero.\n     *\n     * <h3>Non-finite values</h3>\n     *\n     * <p>If the dataset contains {@link Double#NaN} then the result is {@link Double#NaN}. If it\n     * contains {@link Double#POSITIVE_INFINITY} and not {@link Double#NaN} then the result is {@link\n     * Double#POSITIVE_INFINITY}. If it contains {@link Double#NEGATIVE_INFINITY} and finite values\n     * only then the result is the highest finite value. If it contains {@link\n     * Double#NEGATIVE_INFINITY} only then the result is {@link Double#NEGATIVE_INFINITY}.\n     *\n     * @throws IllegalStateException if the dataset is empty\n     */\n    public double max()\n    {\n        checkState(count != 0);\n        return max;\n    }\n\n    double sumOfSquaresOfDeltas()\n    {\n        return sumOfSquaresOfDeltas;\n    }\n\n    /**\n     * Calculates the new value for the accumulated mean when a value is added, in the case where at\n     * least one of the previous mean and the value is non-finite.\n     */\n    static double calculateNewMeanNonFinite(double previousMean, double value)\n    {\n        /*\n         * Desired behaviour is to match the results of applying the naive mean formula. In particular,\n         * the update formula can subtract infinities in cases where the naive formula would add them.\n         *\n         * Consequently:\n         * 1. If the previous mean is finite and the new value is non-finite then the new mean is that\n         *    value (whether it is NaN or infinity).\n         * 2. If the new value is finite and the previous mean is non-finite then the mean is unchanged\n         *    (whether it is NaN or infinity).\n         * 3. If both the previous mean and the new value are non-finite and...\n         * 3a. ...either or both is NaN (so mean != value) then the new mean is NaN.\n         * 3b. ...they are both the same infinities (so mean == value) then the mean is unchanged.\n         * 3c. ...they are different infinities (so mean != value) then the new mean is NaN.\n         */\n        if (isFinite(previousMean))\n        {\n            // This is case 1.\n            return value;\n        }\n        else if (isFinite(value) || previousMean == value)\n        {\n            // This is case 2. or 3b.\n            return previousMean;\n        }\n        else\n        {\n            // This is case 3a. or 3c.\n            return NaN;\n        }\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/math/StatsAccumulator.java", "func_name": "StatsAccumulator.calculateNewMeanNonFinite", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Calculates the new value for the accumulated mean when a value is added, in the case where at\nleast one of the previous mean and the value is non-finite.", "docstring_tokens": ["Calculates", "the", "new", "value", "for", "the", "accumulated", "mean", "when", "a", "value", "is", "added", "in", "the", "case", "where", "at", "least", "one", "of", "the", "previous", "mean", "and", "the", "value", "is", "non", "-", "finite", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/math/StatsAccumulator.java#L348-L373", "partition": "valid", "up_fun_num": 19, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkState;", "import static com.google.common.math.DoubleUtils.ensureNonNegative;", "import static com.google.common.primitives.Doubles.isFinite;", "import static java.lang.Double.NaN;", "import static java.lang.Double.isNaN;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtIncompatible;", "import java.util.Iterator;"], "function": ["public final class StatsAccumulator\n", "    public void add(double value)\n", "    public void addAll(Iterable<? extends Number> values)\n", "    public void addAll(Iterator<? extends Number> values)\n", "    public void addAll(double... values)\n", "    public void addAll(int... values)\n", "    public void addAll(long... values)\n", "    public void addAll(Stats values)\n", "    public Stats snapshot()\n", "    public long count()\n", "    public double mean()\n", "    public final double sum()\n", "    public final double populationVariance()\n", "    public final double populationStandardDeviation()\n", "    public final double sampleVariance()\n", "    public final double sampleStandardDeviation()\n", "    public double min()\n", "    public double max()\n", "    double sumOfSquaresOfDeltas()\n"], "context": "/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.math;\n\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.math.DoubleUtils.ensureNonNegative;\nimport static com.google.common.primitives.Doubles.isFinite;\nimport static java.lang.Double.NaN;\nimport static java.lang.Double.isNaN;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport java.util.Iterator;\n\n/**\n * A mutable object which accumulates double values and tracks some basic statistics over all the\n * values added so far. The values may be added singly or in groups. This class is not thread safe.\n *\n * @author Pete Gillin\n * @author Kevin Bourrillion\n * @since 20.0\n */\n@Beta\n@GwtIncompatible\npublic final class StatsAccumulator\n{\n\n    // These fields must satisfy the requirements of Stats' constructor as well as those of the stat\n    // methods of this class.\n    private long count = 0;\n    private double mean = 0.0; // any finite value will do, we only use it to multiply by zero for sum\n    private double sumOfSquaresOfDeltas = 0.0;\n    private double min = NaN; // any value will do\n    private double max = NaN; // any value will do\n\n    /** Adds the given value to the dataset. */\n    public void add(double value)\n    {\n        if (count == 0)\n        {\n            count = 1;\n            mean = value;\n            min = value;\n            max = value;\n            if (!isFinite(value))\n            {\n                sumOfSquaresOfDeltas = NaN;\n            }\n        }\n        else\n        {\n            count++;\n            if (isFinite(value) && isFinite(mean))\n            {\n                // Art of Computer Programming vol. 2, Knuth, 4.2.2, (15) and (16)\n                double delta = value - mean;\n                mean += delta / count;\n                sumOfSquaresOfDeltas += delta * (value - mean);\n            }\n            else\n            {\n                mean = calculateNewMeanNonFinite(mean, value);\n                sumOfSquaresOfDeltas = NaN;\n            }\n            min = Math.min(min, value);\n            max = Math.max(max, value);\n        }\n    }\n\n    /**\n     * Adds the given values to the dataset.\n     *\n     * @param values a series of values, which will be converted to {@code double} values (this may\n     *     cause loss of precision)\n     */\n    public void addAll(Iterable<? extends Number> values)\n    {\n        for (Number value : values)\n        {\n            add(value.doubleValue());\n        }\n    }\n\n    /**\n     * Adds the given values to the dataset.\n     *\n     * @param values a series of values, which will be converted to {@code double} values (this may\n     *     cause loss of precision)\n     */\n    public void addAll(Iterator<? extends Number> values)\n    {\n        while (values.hasNext())\n        {\n            add(values.next().doubleValue());\n        }\n    }\n\n    /**\n     * Adds the given values to the dataset.\n     *\n     * @param values a series of values\n     */\n    public void addAll(double... values)\n    {\n        for (double value : values)\n        {\n            add(value);\n        }\n    }\n\n    /**\n     * Adds the given values to the dataset.\n     *\n     * @param values a series of values\n     */\n    public void addAll(int... values)\n    {\n        for (int value : values)\n        {\n            add(value);\n        }\n    }\n\n    /**\n     * Adds the given values to the dataset.\n     *\n     * @param values a series of values, which will be converted to {@code double} values (this may\n     *     cause loss of precision for longs of magnitude over 2^53 (slightly over 9e15))\n     */\n    public void addAll(long... values)\n    {\n        for (long value : values)\n        {\n            add(value);\n        }\n    }\n\n    /**\n     * Adds the given statistics to the dataset, as if the individual values used to compute the\n     * statistics had been added directly.\n     */\n    public void addAll(Stats values)\n    {\n        if (values.count() == 0)\n        {\n            return;\n        }\n\n        if (count == 0)\n        {\n            count = values.count();\n            mean = values.mean();\n            sumOfSquaresOfDeltas = values.sumOfSquaresOfDeltas();\n            min = values.min();\n            max = values.max();\n        }\n        else\n        {\n            count += values.count();\n            if (isFinite(mean) && isFinite(values.mean()))\n            {\n                // This is a generalized version of the calculation in add(double) above.\n                double delta = values.mean() - mean;\n                mean += delta * values.count() / count;\n                sumOfSquaresOfDeltas +=\n                    values.sumOfSquaresOfDeltas() + delta * (values.mean() - mean) * values.count();\n            }\n            else\n            {\n                mean = calculateNewMeanNonFinite(mean, values.mean());\n                sumOfSquaresOfDeltas = NaN;\n            }\n            min = Math.min(min, values.min());\n            max = Math.max(max, values.max());\n        }\n    }\n\n    /** Returns an immutable snapshot of the current statistics. */\n    public Stats snapshot()\n    {\n        return new Stats(count, mean, sumOfSquaresOfDeltas, min, max);\n    }\n\n    /** Returns the number of values. */\n    public long count()\n    {\n        return count;\n    }\n\n    /**\n     * Returns the <a href=\"http://en.wikipedia.org/wiki/Arithmetic_mean\">arithmetic mean</a> of the\n     * values. The count must be non-zero.\n     *\n     * <p>If these values are a sample drawn from a population, this is also an unbiased estimator of\n     * the arithmetic mean of the population.\n     *\n     * <h3>Non-finite values</h3>\n     *\n     * <p>If the dataset contains {@link Double#NaN} then the result is {@link Double#NaN}. If it\n     * contains both {@link Double#POSITIVE_INFINITY} and {@link Double#NEGATIVE_INFINITY} then the\n     * result is {@link Double#NaN}. If it contains {@link Double#POSITIVE_INFINITY} and finite values\n     * only or {@link Double#POSITIVE_INFINITY} only, the result is {@link Double#POSITIVE_INFINITY}.\n     * If it contains {@link Double#NEGATIVE_INFINITY} and finite values only or {@link\n     * Double#NEGATIVE_INFINITY} only, the result is {@link Double#NEGATIVE_INFINITY}.\n     *\n     * @throws IllegalStateException if the dataset is empty\n     */\n    public double mean()\n    {\n        checkState(count != 0);\n        return mean;\n    }\n\n    /**\n     * Returns the sum of the values.\n     *\n     * <h3>Non-finite values</h3>\n     *\n     * <p>If the dataset contains {@link Double#NaN} then the result is {@link Double#NaN}. If it\n     * contains both {@link Double#POSITIVE_INFINITY} and {@link Double#NEGATIVE_INFINITY} then the\n     * result is {@link Double#NaN}. If it contains {@link Double#POSITIVE_INFINITY} and finite values\n     * only or {@link Double#POSITIVE_INFINITY} only, the result is {@link Double#POSITIVE_INFINITY}.\n     * If it contains {@link Double#NEGATIVE_INFINITY} and finite values only or {@link\n     * Double#NEGATIVE_INFINITY} only, the result is {@link Double#NEGATIVE_INFINITY}.\n     */\n    public final double sum()\n    {\n        return mean * count;\n    }\n\n    /**\n     * Returns the <a href=\"http://en.wikipedia.org/wiki/Variance#Population_variance\">population\n     * variance</a> of the values. The count must be non-zero.\n     *\n     * <p>This is guaranteed to return zero if the dataset contains only exactly one finite value. It\n     * is not guaranteed to return zero when the dataset consists of the same value multiple times,\n     * due to numerical errors. However, it is guaranteed never to return a negative result.\n     *\n     * <h3>Non-finite values</h3>\n     *\n     * <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link\n     * Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.\n     *\n     * @throws IllegalStateException if the dataset is empty\n     */\n    public final double populationVariance()\n    {\n        checkState(count != 0);\n        if (isNaN(sumOfSquaresOfDeltas))\n        {\n            return NaN;\n        }\n        if (count == 1)\n        {\n            return 0.0;\n        }\n        return ensureNonNegative(sumOfSquaresOfDeltas) / count;\n    }\n\n    /**\n     * Returns the <a\n     * href=\"http://en.wikipedia.org/wiki/Standard_deviation#Definition_of_population_values\">\n     * population standard deviation</a> of the values. The count must be non-zero.\n     *\n     * <p>This is guaranteed to return zero if the dataset contains only exactly one finite value. It\n     * is not guaranteed to return zero when the dataset consists of the same value multiple times,\n     * due to numerical errors. However, it is guaranteed never to return a negative result.\n     *\n     * <h3>Non-finite values</h3>\n     *\n     * <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link\n     * Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.\n     *\n     * @throws IllegalStateException if the dataset is empty\n     */\n    public final double populationStandardDeviation()\n    {\n        return Math.sqrt(populationVariance());\n    }\n\n    /**\n     * Returns the <a href=\"http://en.wikipedia.org/wiki/Variance#Sample_variance\">unbiased sample\n     * variance</a> of the values. If this dataset is a sample drawn from a population, this is an\n     * unbiased estimator of the population variance of the population. The count must be greater than\n     * one.\n     *\n     * <p>This is not guaranteed to return zero when the dataset consists of the same value multiple\n     * times, due to numerical errors. However, it is guaranteed never to return a negative result.\n     *\n     * <h3>Non-finite values</h3>\n     *\n     * <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link\n     * Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.\n     *\n     * @throws IllegalStateException if the dataset is empty or contains a single value\n     */\n    public final double sampleVariance()\n    {\n        checkState(count > 1);\n        if (isNaN(sumOfSquaresOfDeltas))\n        {\n            return NaN;\n        }\n        return ensureNonNegative(sumOfSquaresOfDeltas) / (count - 1);\n    }\n\n    /**\n     * Returns the <a\n     * href=\"http://en.wikipedia.org/wiki/Standard_deviation#Corrected_sample_standard_deviation\">\n     * corrected sample standard deviation</a> of the values. If this dataset is a sample drawn from a\n     * population, this is an estimator of the population standard deviation of the population which\n     * is less biased than {@link #populationStandardDeviation()} (the unbiased estimator depends on\n     * the distribution). The count must be greater than one.\n     *\n     * <p>This is not guaranteed to return zero when the dataset consists of the same value multiple\n     * times, due to numerical errors. However, it is guaranteed never to return a negative result.\n     *\n     * <h3>Non-finite values</h3>\n     *\n     * <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link\n     * Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.\n     *\n     * @throws IllegalStateException if the dataset is empty or contains a single value\n     */\n    public final double sampleStandardDeviation()\n    {\n        return Math.sqrt(sampleVariance());\n    }\n\n    /**\n     * Returns the lowest value in the dataset. The count must be non-zero.\n     *\n     * <h3>Non-finite values</h3>\n     *\n     * <p>If the dataset contains {@link Double#NaN} then the result is {@link Double#NaN}. If it\n     * contains {@link Double#NEGATIVE_INFINITY} and not {@link Double#NaN} then the result is {@link\n     * Double#NEGATIVE_INFINITY}. If it contains {@link Double#POSITIVE_INFINITY} and finite values\n     * only then the result is the lowest finite value. If it contains {@link\n     * Double#POSITIVE_INFINITY} only then the result is {@link Double#POSITIVE_INFINITY}.\n     *\n     * @throws IllegalStateException if the dataset is empty\n     */\n    public double min()\n    {\n        checkState(count != 0);\n        return min;\n    }\n\n    /**\n     * Returns the highest value in the dataset. The count must be non-zero.\n     *\n     * <h3>Non-finite values</h3>\n     *\n     * <p>If the dataset contains {@link Double#NaN} then the result is {@link Double#NaN}. If it\n     * contains {@link Double#POSITIVE_INFINITY} and not {@link Double#NaN} then the result is {@link\n     * Double#POSITIVE_INFINITY}. If it contains {@link Double#NEGATIVE_INFINITY} and finite values\n     * only then the result is the highest finite value. If it contains {@link\n     * Double#NEGATIVE_INFINITY} only then the result is {@link Double#NEGATIVE_INFINITY}.\n     *\n     * @throws IllegalStateException if the dataset is empty\n     */\n    public double max()\n    {\n        checkState(count != 0);\n        return max;\n    }\n\n    double sumOfSquaresOfDeltas()\n    {\n        return sumOfSquaresOfDeltas;\n    }\n\n    /**\n     * Calculates the new value for the accumulated mean when a value is added, in the case where at\n     * least one of the previous mean and the value is non-finite.\n     */\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/collect/ImmutableSet.java", "func_name": "ImmutableSet.rebuildHashTable", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Builds a new open-addressed hash table from the first n objects in elements.", "docstring_tokens": ["Builds", "a", "new", "open", "-", "addressed", "hash", "table", "from", "the", "first", "n", "objects", "in", "elements", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/collect/ImmutableSet.java#L440-L455", "partition": "valid", "up_fun_num": 26, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.collect.CollectPreconditions.checkNonnegative;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.annotations.VisibleForTesting;", "import com.google.common.math.IntMath;", "import com.google.common.primitives.Ints;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import com.google.errorprone.annotations.concurrent.LazyInit;", "import com.google.j2objc.annotations.RetainedWith;", "import java.io.Serializable;", "import java.math.RoundingMode;", "import java.util.Arrays;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.EnumSet;", "import java.util.Iterator;", "import java.util.Set;", "import java.util.SortedSet;", "import java.util.Spliterator;", "import java.util.function.Consumer;", "import java.util.stream.Collector;", "import org.checkerframework.checker.nullness.qual.Nullable;"], "function": ["public abstract class ImmutableSet<E> extends ImmutableCollection<E> implements Set<E>\n", "    public static <E> Collector<E, ?, ImmutableSet<E>> toImmutableSet()\n", "    public static <E> ImmutableSet<E> of()\n", "    public static <E> ImmutableSet<E> of(E element)\n", "    public static <E> ImmutableSet<E> of(E e1, E e2)\n", "    public static <E> ImmutableSet<E> of(E e1, E e2, E e3)\n", "    public static <E> ImmutableSet<E> of(E e1, E e2, E e3, E e4)\n", "    public static <E> ImmutableSet<E> of(E e1, E e2, E e3, E e4, E e5)\n", "    public static <E> ImmutableSet<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E... others)\n", "    private static <E> ImmutableSet<E> constructUnknownDuplication(int n, Object... elements)\n", "    private static <E> ImmutableSet<E> construct(int n, int expectedSize, Object... elements)\n", "    public static <E> ImmutableSet<E> copyOf(Collection<? extends E> elements)\n", "    public static <E> ImmutableSet<E> copyOf(Iterable<? extends E> elements)\n", "    public static <E> ImmutableSet<E> copyOf(Iterator<? extends E> elements)\n", "    public static <E> ImmutableSet<E> copyOf(E[] elements)\n", "    private static ImmutableSet copyOfEnumSet(EnumSet enumSet)\n", "    boolean isHashCodeFast()\n", "    public boolean equals(@Nullable Object object)\n", "    public int hashCode()\n", "    public abstract UnmodifiableIterator<E> iterator();\n", "    public ImmutableList<E> asList()\n", "    ImmutableList<E> createAsList()\n", "    Object writeReplace()\n", "    public static <E> Builder<E> builder()\n", "    public static <E> Builder<E> builderWithExpectedSize(int expectedSize)\n", "    static int chooseTableSize(int setSize)\n", "    static boolean hashFloodingDetected(Object[] hashTable)\n", "    private static int maxRunBeforeFallback(int tableSize)\n"], "context": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.collect.CollectPreconditions.checkNonnegative;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.math.IntMath;\nimport com.google.common.primitives.Ints;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.google.errorprone.annotations.concurrent.LazyInit;\nimport com.google.j2objc.annotations.RetainedWith;\nimport java.io.Serializable;\nimport java.math.RoundingMode;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.Spliterator;\nimport java.util.function.Consumer;\nimport java.util.stream.Collector;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\n/**\n * A {@link Set} whose contents will never change, with many other important properties detailed at\n * {@link ImmutableCollection}.\n *\n * @since 2.0\n */\n@GwtCompatible(serializable = true, emulated = true)\n@SuppressWarnings(\"serial\") // we're overriding default serialization\npublic abstract class ImmutableSet<E> extends ImmutableCollection<E> implements Set<E>\n{\n    static final int SPLITERATOR_CHARACTERISTICS =\n        ImmutableCollection.SPLITERATOR_CHARACTERISTICS | Spliterator.DISTINCT;\n\n    /**\n     * Returns a {@code Collector} that accumulates the input elements into a new {@code\n     * ImmutableSet}. Elements appear in the resulting set in the encounter order of the stream; if\n     * the stream contains duplicates (according to {@link Object#equals(Object)}), only the first\n     * duplicate in encounter order will appear in the result.\n     *\n     * @since 21.0\n     */\n    public static <E> Collector<E, ?, ImmutableSet<E>> toImmutableSet()\n    {\n        return CollectCollectors.toImmutableSet();\n    }\n\n    /**\n     * Returns the empty immutable set. Preferred over {@link Collections#emptySet} for code\n     * consistency, and because the return type conveys the immutability guarantee.\n     */\n    @SuppressWarnings({\"unchecked\"}) // fully variant implementation (never actually produces any Es)\n    public static <E> ImmutableSet<E> of()\n    {\n        return (ImmutableSet<E>) RegularImmutableSet.EMPTY;\n    }\n\n    /**\n     * Returns an immutable set containing {@code element}. Preferred over {@link\n     * Collections#singleton} for code consistency, {@code null} rejection, and because the return\n     * type conveys the immutability guarantee.\n     */\n    public static <E> ImmutableSet<E> of(E element)\n    {\n        return new SingletonImmutableSet<E>(element);\n    }\n\n    /**\n     * Returns an immutable set containing the given elements, minus duplicates, in the order each was\n     * first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except\n     * the first are ignored.\n     */\n    public static <E> ImmutableSet<E> of(E e1, E e2)\n    {\n        return construct(2, 2, e1, e2);\n    }\n\n    /**\n     * Returns an immutable set containing the given elements, minus duplicates, in the order each was\n     * first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except\n     * the first are ignored.\n     */\n    public static <E> ImmutableSet<E> of(E e1, E e2, E e3)\n    {\n        return construct(3, 3, e1, e2, e3);\n    }\n\n    /**\n     * Returns an immutable set containing the given elements, minus duplicates, in the order each was\n     * first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except\n     * the first are ignored.\n     */\n    public static <E> ImmutableSet<E> of(E e1, E e2, E e3, E e4)\n    {\n        return construct(4, 4, e1, e2, e3, e4);\n    }\n\n    /**\n     * Returns an immutable set containing the given elements, minus duplicates, in the order each was\n     * first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except\n     * the first are ignored.\n     */\n    public static <E> ImmutableSet<E> of(E e1, E e2, E e3, E e4, E e5)\n    {\n        return construct(5, 5, e1, e2, e3, e4, e5);\n    }\n\n    /**\n     * Returns an immutable set containing the given elements, minus duplicates, in the order each was\n     * first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except\n     * the first are ignored.\n     *\n     * <p>The array {@code others} must not be longer than {@code Integer.MAX_VALUE - 6}.\n     *\n     * @since 3.0 (source-compatible since 2.0)\n     */\n    @SafeVarargs // For Eclipse. For internal javac we have disabled this pointless type of warning.\n    public static <E> ImmutableSet<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E... others)\n    {\n        checkArgument(\n            others.length <= Integer.MAX_VALUE - 6, \"the total number of elements must fit in an int\");\n        final int paramCount = 6;\n        Object[] elements = new Object[paramCount + others.length];\n        elements[0] = e1;\n        elements[1] = e2;\n        elements[2] = e3;\n        elements[3] = e4;\n        elements[4] = e5;\n        elements[5] = e6;\n        System.arraycopy(others, 0, elements, paramCount, others.length);\n        return construct(elements.length, elements.length, elements);\n    }\n\n    /**\n     * Constructs an {@code ImmutableSet} from the first {@code n} elements of the specified array,\n     * which we have no particular reason to believe does or does not contain duplicates. If {@code k}\n     * is the size of the returned {@code ImmutableSet}, then the unique elements of {@code elements}\n     * will be in the first {@code k} positions, and {@code elements[i] == null} for {@code k <= i <\n     * n}.\n     *\n     * <p>This may modify {@code elements}. Additionally, if {@code n == elements.length} and {@code\n     * elements} contains no duplicates, {@code elements} may be used without copying in the returned\n     * {@code ImmutableSet}, in which case the caller must not modify it.\n     *\n     * <p>{@code elements} may contain only values of type {@code E}.\n     *\n     * @throws NullPointerException if any of the first {@code n} elements of {@code elements} is null\n     */\n    private static <E> ImmutableSet<E> constructUnknownDuplication(int n, Object... elements)\n    {\n        // Guess the size is \"halfway between\" all duplicates and no duplicates, on a log scale.\n        return construct(\n                   n,\n                   Math.max(\n                       ImmutableCollection.Builder.DEFAULT_INITIAL_CAPACITY,\n                       IntMath.sqrt(n, RoundingMode.CEILING)),\n                   elements);\n    }\n\n    /**\n     * Constructs an {@code ImmutableSet} from the first {@code n} elements of the specified array. If\n     * {@code k} is the size of the returned {@code ImmutableSet}, then the unique elements of {@code\n     * elements} will be in the first {@code k} positions, and {@code elements[i] == null} for {@code\n     * k <= i < n}.\n     *\n     * <p>This may modify {@code elements}. Additionally, if {@code n == elements.length} and {@code\n     * elements} contains no duplicates, {@code elements} may be used without copying in the returned\n     * {@code ImmutableSet}, in which case it may no longer be modified.\n     *\n     * <p>{@code elements} may contain only values of type {@code E}.\n     *\n     * @throws NullPointerException if any of the first {@code n} elements of {@code elements} is null\n     */\n    private static <E> ImmutableSet<E> construct(int n, int expectedSize, Object... elements)\n    {\n        switch (n)\n        {\n        case 0:\n            return of();\n        case 1:\n            @SuppressWarnings(\"unchecked\") // safe; elements contains only E's\n            E elem = (E) elements[0];\n            return of(elem);\n        default:\n            SetBuilderImpl<E> builder = new RegularSetBuilderImpl<E>(expectedSize);\n            for (int i = 0; i < n; i++)\n            {\n                @SuppressWarnings(\"unchecked\")\n                E e = (E) checkNotNull(elements[i]);\n                builder = builder.add(e);\n            }\n            return builder.review().build();\n        }\n    }\n\n    /**\n     * Returns an immutable set containing each of {@code elements}, minus duplicates, in the order\n     * each appears first in the source collection.\n     *\n     * <p><b>Performance note:</b> This method will sometimes recognize that the actual copy operation\n     * is unnecessary; for example, {@code copyOf(copyOf(anArrayList))} will copy the data only once.\n     * This reduces the expense of habitually making defensive copies at API boundaries. However, the\n     * precise conditions for skipping the copy operation are undefined.\n     *\n     * @throws NullPointerException if any of {@code elements} is null\n     * @since 7.0 (source-compatible since 2.0)\n     */\n    public static <E> ImmutableSet<E> copyOf(Collection<? extends E> elements)\n    {\n        /*\n         * TODO(lowasser): consider checking for ImmutableAsList here\n         * TODO(lowasser): consider checking for Multiset here\n         */\n        // Don't refer to ImmutableSortedSet by name so it won't pull in all that code\n        if (elements instanceof ImmutableSet && !(elements instanceof SortedSet))\n        {\n            @SuppressWarnings(\"unchecked\") // all supported methods are covariant\n            ImmutableSet<E> set = (ImmutableSet<E>) elements;\n            if (!set.isPartialView())\n            {\n                return set;\n            }\n        }\n        else if (elements instanceof EnumSet)\n        {\n            return copyOfEnumSet((EnumSet) elements);\n        }\n        Object[] array = elements.toArray();\n        if (elements instanceof Set)\n        {\n            // assume probably no duplicates (though it might be using different equality semantics)\n            return construct(array.length, array.length, array);\n        }\n        else\n        {\n            return constructUnknownDuplication(array.length, array);\n        }\n    }\n\n    /**\n     * Returns an immutable set containing each of {@code elements}, minus duplicates, in the order\n     * each appears first in the source iterable. This method iterates over {@code elements} only\n     * once.\n     *\n     * <p><b>Performance note:</b> This method will sometimes recognize that the actual copy operation\n     * is unnecessary; for example, {@code copyOf(copyOf(anArrayList))} should copy the data only\n     * once. This reduces the expense of habitually making defensive copies at API boundaries.\n     * However, the precise conditions for skipping the copy operation are undefined.\n     *\n     * @throws NullPointerException if any of {@code elements} is null\n     */\n    public static <E> ImmutableSet<E> copyOf(Iterable<? extends E> elements)\n    {\n        return (elements instanceof Collection)\n               ? copyOf((Collection<? extends E>) elements)\n               : copyOf(elements.iterator());\n    }\n\n    /**\n     * Returns an immutable set containing each of {@code elements}, minus duplicates, in the order\n     * each appears first in the source iterator.\n     *\n     * @throws NullPointerException if any of {@code elements} is null\n     */\n    public static <E> ImmutableSet<E> copyOf(Iterator<? extends E> elements)\n    {\n        // We special-case for 0 or 1 elements, but anything further is madness.\n        if (!elements.hasNext())\n        {\n            return of();\n        }\n        E first = elements.next();\n        if (!elements.hasNext())\n        {\n            return of(first);\n        }\n        else\n        {\n            return new ImmutableSet.Builder<E>().add(first).addAll(elements).build();\n        }\n    }\n\n    /**\n     * Returns an immutable set containing each of {@code elements}, minus duplicates, in the order\n     * each appears first in the source array.\n     *\n     * @throws NullPointerException if any of {@code elements} is null\n     * @since 3.0\n     */\n    public static <E> ImmutableSet<E> copyOf(E[] elements)\n    {\n        switch (elements.length)\n        {\n        case 0:\n            return of();\n        case 1:\n            return of(elements[0]);\n        default:\n            return constructUnknownDuplication(elements.length, elements.clone());\n        }\n    }\n\n    @SuppressWarnings(\"rawtypes\") // necessary to compile against Java 8\n    private static ImmutableSet copyOfEnumSet(EnumSet enumSet)\n    {\n        return ImmutableEnumSet.asImmutable(EnumSet.copyOf(enumSet));\n    }\n\n    ImmutableSet() {}\n\n    /** Returns {@code true} if the {@code hashCode()} method runs quickly. */\n    boolean isHashCodeFast()\n    {\n        return false;\n    }\n\n    @Override\n    public boolean equals(@Nullable Object object)\n    {\n        if (object == this)\n        {\n            return true;\n        }\n        else if (object instanceof ImmutableSet\n                 && isHashCodeFast()\n                 && ((ImmutableSet<?>) object).isHashCodeFast()\n                 && hashCode() != object.hashCode())\n        {\n            return false;\n        }\n        return Sets.equalsImpl(this, object);\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return Sets.hashCodeImpl(this);\n    }\n\n    // This declaration is needed to make Set.iterator() and\n    // ImmutableCollection.iterator() consistent.\n    @Override\n    public abstract UnmodifiableIterator<E> iterator();\n\n    @LazyInit @RetainedWith private transient @Nullable ImmutableList<E> asList;\n\n    @Override\n    public ImmutableList<E> asList()\n    {\n        ImmutableList<E> result = asList;\n        return (result == null) ? asList = createAsList() : result;\n    }\n\n    ImmutableList<E> createAsList()\n    {\n        return new RegularImmutableAsList<E>(this, toArray());\n    }\n\n    abstract static class Indexed<E> extends ImmutableSet<E>\n    {\n        abstract E get(int index);\n\n        @Override\n        public UnmodifiableIterator<E> iterator()\n        {\n            return asList().iterator();\n        }\n\n        @Override\n        public Spliterator<E> spliterator()\n        {\n            return CollectSpliterators.indexed(size(), SPLITERATOR_CHARACTERISTICS, this::get);\n        }\n\n        @Override\n        public void forEach(Consumer<? super E> consumer)\n        {\n            checkNotNull(consumer);\n            int n = size();\n            for (int i = 0; i < n; i++)\n            {\n                consumer.accept(get(i));\n            }\n        }\n\n        @Override\n        int copyIntoArray(Object[] dst, int offset)\n        {\n            return asList().copyIntoArray(dst, offset);\n        }\n\n        @Override\n        ImmutableList<E> createAsList()\n        {\n            return new ImmutableAsList<E>()\n            {\n                @Override\n                public E get(int index)\n                {\n                    return Indexed.this.get(index);\n                }\n\n                @Override\n                Indexed<E> delegateCollection()\n                {\n                    return Indexed.this;\n                }\n            };\n        }\n    }\n\n    /*\n     * This class is used to serialize all ImmutableSet instances, except for\n     * ImmutableEnumSet/ImmutableSortedSet, regardless of implementation type. It\n     * captures their \"logical contents\" and they are reconstructed using public\n     * static factories. This is necessary to ensure that the existence of a\n     * particular implementation type is an implementation detail.\n     */\n    private static class SerializedForm implements Serializable\n    {\n        final Object[] elements;\n\n        SerializedForm(Object[] elements)\n        {\n            this.elements = elements;\n        }\n\n        Object readResolve()\n        {\n            return copyOf(elements);\n        }\n\n        private static final long serialVersionUID = 0;\n    }\n\n    @Override\n    Object writeReplace()\n    {\n        return new SerializedForm(toArray());\n    }\n\n    /**\n     * Returns a new builder. The generated builder is equivalent to the builder created by the {@link\n     * Builder} constructor.\n     */\n    public static <E> Builder<E> builder()\n    {\n        return new Builder<E>();\n    }\n\n    /**\n     * Returns a new builder, expecting the specified number of distinct elements to be added.\n     *\n     * <p>If {@code expectedSize} is exactly the number of distinct elements added to the builder\n     * before {@link Builder#build} is called, the builder is likely to perform better than an unsized\n     * {@link #builder()} would have.\n     *\n     * <p>It is not specified if any performance benefits apply if {@code expectedSize} is close to,\n     * but not exactly, the number of distinct elements added to the builder.\n     *\n     * @since 23.1\n     */\n    @Beta\n    public static <E> Builder<E> builderWithExpectedSize(int expectedSize)\n    {\n        checkNonnegative(expectedSize, \"expectedSize\");\n        return new Builder<E>(expectedSize);\n    }\n\n    /** Builds a new open-addressed hash table from the first n objects in elements. */\n\n    /**\n     * A builder for creating {@code ImmutableSet} instances. Example:\n     *\n     * <pre>{@code\n     * static final ImmutableSet<Color> GOOGLE_COLORS =\n     *     ImmutableSet.<Color>builder()\n     *         .addAll(WEBSAFE_COLORS)\n     *         .add(new Color(0, 191, 255))\n     *         .build();\n     * }</pre>\n     *\n     * <p>Elements appear in the resulting set in the same order they were first added to the builder.\n     *\n     * <p>Building does not change the state of the builder, so it is still possible to add more\n     * elements and to build again.\n     *\n     * @since 2.0\n     */\n    public static class Builder<E> extends ImmutableCollection.Builder<E>\n    {\n        private SetBuilderImpl<E> impl;\n        boolean forceCopy;\n\n        public Builder()\n        {\n            this(DEFAULT_INITIAL_CAPACITY);\n        }\n\n        Builder(int capacity)\n        {\n            impl = new RegularSetBuilderImpl<E>(capacity);\n        }\n\n        Builder(@SuppressWarnings(\"unused\") boolean subclass)\n        {\n            this.impl = null; // unused\n        }\n\n        @VisibleForTesting\n        void forceJdk()\n        {\n            this.impl = new JdkBackedSetBuilderImpl<E>(impl);\n        }\n\n        final void copyIfNecessary()\n        {\n            if (forceCopy)\n            {\n                copy();\n                forceCopy = false;\n            }\n        }\n\n        void copy()\n        {\n            impl = impl.copy();\n        }\n\n        @Override\n        @CanIgnoreReturnValue\n        public Builder<E> add(E element)\n        {\n            checkNotNull(element);\n            copyIfNecessary();\n            impl = impl.add(element);\n            return this;\n        }\n\n        @Override\n        @CanIgnoreReturnValue\n        public Builder<E> add(E... elements)\n        {\n            super.add(elements);\n            return this;\n        }\n\n        @Override\n        /**\n         * Adds each element of {@code elements} to the {@code ImmutableSet}, ignoring duplicate\n         * elements (only the first duplicate element is added).\n         *\n         * @param elements the elements to add\n         * @return this {@code Builder} object\n         * @throws NullPointerException if {@code elements} is null or contains a null element\n         */\n        @CanIgnoreReturnValue\n        public Builder<E> addAll(Iterable<? extends E> elements)\n        {\n            super.addAll(elements);\n            return this;\n        }\n\n        @Override\n        @CanIgnoreReturnValue\n        public Builder<E> addAll(Iterator<? extends E> elements)\n        {\n            super.addAll(elements);\n            return this;\n        }\n\n        Builder<E> combine(Builder<E> other)\n        {\n            copyIfNecessary();\n            this.impl = this.impl.combine(other.impl);\n            return this;\n        }\n\n        @Override\n        public ImmutableSet<E> build()\n        {\n            forceCopy = true;\n            impl = impl.review();\n            return impl.build();\n        }\n    }\n\n    /** Swappable internal implementation of an ImmutableSet.Builder. */\n    private abstract static class SetBuilderImpl<E>\n    {\n        E[] dedupedElements;\n        int distinct;\n\n        @SuppressWarnings(\"unchecked\")\n        SetBuilderImpl(int expectedCapacity)\n        {\n            this.dedupedElements = (E[]) new Object[expectedCapacity];\n            this.distinct = 0;\n        }\n\n        /** Initializes this SetBuilderImpl with a copy of the deduped elements array from toCopy. */\n        SetBuilderImpl(SetBuilderImpl<E> toCopy)\n        {\n            this.dedupedElements = Arrays.copyOf(toCopy.dedupedElements, toCopy.dedupedElements.length);\n            this.distinct = toCopy.distinct;\n        }\n\n        /**\n         * Resizes internal data structures if necessary to store the specified number of distinct\n         * elements.\n         */\n        private void ensureCapacity(int minCapacity)\n        {\n            if (minCapacity > dedupedElements.length)\n            {\n                int newCapacity =\n                    ImmutableCollection.Builder.expandedCapacity(dedupedElements.length, minCapacity);\n                dedupedElements = Arrays.copyOf(dedupedElements, newCapacity);\n            }\n        }\n\n        /** Adds e to the insertion-order array of deduplicated elements. Calls ensureCapacity. */\n        final void addDedupedElement(E e)\n        {\n            ensureCapacity(distinct + 1);\n            dedupedElements[distinct++] = e;\n        }\n\n        /**\n         * Adds e to this SetBuilderImpl, returning the updated result. Only use the returned\n         * SetBuilderImpl, since we may switch implementations if e.g. hash flooding is detected.\n         */\n        abstract SetBuilderImpl<E> add(E e);\n\n        /** Adds all the elements from the specified SetBuilderImpl to this SetBuilderImpl. */\n        final SetBuilderImpl<E> combine(SetBuilderImpl<E> other)\n        {\n            SetBuilderImpl<E> result = this;\n            for (int i = 0; i < other.distinct; i++)\n            {\n                result = result.add(other.dedupedElements[i]);\n            }\n            return result;\n        }\n\n        /**\n         * Creates a new copy of this SetBuilderImpl. Modifications to that SetBuilderImpl will not\n         * affect this SetBuilderImpl or sets constructed from this SetBuilderImpl via build().\n         */\n        abstract SetBuilderImpl<E> copy();\n\n        /**\n         * Call this before build(). Does a final check on the internal data structures, e.g. shrinking\n         * unnecessarily large structures or detecting previously unnoticed hash flooding.\n         */\n        SetBuilderImpl<E> review()\n        {\n            return this;\n        }\n\n        abstract ImmutableSet<E> build();\n    }\n\n    // We use power-of-2 tables, and this is the highest int that's a power of 2\n    static final int MAX_TABLE_SIZE = Ints.MAX_POWER_OF_TWO;\n\n    // Represents how tightly we can pack things, as a maximum.\n    private static final double DESIRED_LOAD_FACTOR = 0.7;\n\n    // If the set has this many elements, it will \"max out\" the table size\n    private static final int CUTOFF = (int) (MAX_TABLE_SIZE * DESIRED_LOAD_FACTOR);\n\n    /**\n     * Returns an array size suitable for the backing array of a hash table that uses open addressing\n     * with linear probing in its implementation. The returned size is the smallest power of two that\n     * can hold setSize elements with the desired load factor. Always returns at least setSize + 2.\n     */\n    @VisibleForTesting\n    static int chooseTableSize(int setSize)\n    {\n        setSize = Math.max(setSize, 2);\n        // Correct the size for open addressing to match desired load factor.\n        if (setSize < CUTOFF)\n        {\n            // Round up to the next highest power of 2.\n            int tableSize = Integer.highestOneBit(setSize - 1) << 1;\n            while (tableSize * DESIRED_LOAD_FACTOR < setSize)\n            {\n                tableSize <<= 1;\n            }\n            return tableSize;\n        }\n\n        // The table can't be completely full or we'll get infinite reprobes\n        checkArgument(setSize < MAX_TABLE_SIZE, \"collection too large\");\n        return MAX_TABLE_SIZE;\n    }\n\n    /**\n     * We attempt to detect deliberate hash flooding attempts, and if one is detected, fall back to a\n     * wrapper around j.u.HashSet, which has built in flooding protection. HASH_FLOODING_FPP is the\n     * maximum allowed probability of falsely detecting a hash flooding attack if the input is\n     * randomly generated.\n     *\n     * <p>MAX_RUN_MULTIPLIER was determined experimentally to match this FPP.\n     */\n    static final double HASH_FLOODING_FPP = 0.001;\n\n    // NB: yes, this is surprisingly high, but that's what the experiments said was necessary\n    // The higher it is, the worse constant factors we are willing to accept.\n    static final int MAX_RUN_MULTIPLIER = 13;\n\n    /**\n     * Checks the whole hash table for poor hash distribution. Takes O(n) in the worst case, O(n / log\n     * n) on average.\n     *\n     * <p>The online hash flooding detecting in RegularSetBuilderImpl.add can detect e.g. many exactly\n     * matching hash codes, which would cause construction to take O(n^2), but can't detect e.g. hash\n     * codes adversarially designed to go into ascending table locations, which keeps construction\n     * O(n) (as desired) but then can have O(n) queries later.\n     *\n     * <p>If this returns false, then no query can take more than O(log n).\n     *\n     * <p>Note that for a RegularImmutableSet with elements with truly random hash codes, contains\n     * operations take expected O(1) time but with high probability take O(log n) for at least some\n     * element. (https://en.wikipedia.org/wiki/Linear_probing#Analysis)\n     *\n     * <p>This method may return {@code true} up to {@link #HASH_FLOODING_FPP} of the time even on\n     * truly random input.\n     *\n     * <p>If this method returns false, there are definitely no runs of length at least {@code\n     * maxRunBeforeFallback(hashTable.length)} nonnull elements. If there are no runs of length at\n     * least {@code maxRunBeforeFallback(hashTable.length) / 2} nonnull elements, this method\n     * definitely returns false. In between those constraints, the result of this method is undefined,\n     * subject to the above {@link #HASH_FLOODING_FPP} constraint.\n     */\n    static boolean hashFloodingDetected(Object[] hashTable)\n    {\n        int maxRunBeforeFallback = maxRunBeforeFallback(hashTable.length);\n\n        // Test for a run wrapping around the end of the table of length at least maxRunBeforeFallback.\n        int endOfStartRun;\n        for (endOfStartRun = 0; endOfStartRun < hashTable.length; )\n        {\n            if (hashTable[endOfStartRun] == null)\n            {\n                break;\n            }\n            endOfStartRun++;\n            if (endOfStartRun > maxRunBeforeFallback)\n            {\n                return true;\n            }\n        }\n        int startOfEndRun;\n        for (startOfEndRun = hashTable.length - 1; startOfEndRun > endOfStartRun; startOfEndRun--)\n        {\n            if (hashTable[startOfEndRun] == null)\n            {\n                break;\n            }\n            if (endOfStartRun + (hashTable.length - 1 - startOfEndRun) > maxRunBeforeFallback)\n            {\n                return true;\n            }\n        }\n\n        // Now, break the remainder of the table into blocks of maxRunBeforeFallback/2 elements and\n        // check that each has at least one null.\n        int testBlockSize = maxRunBeforeFallback / 2;\n        blockLoop:\n        for (int i = endOfStartRun + 1; i + testBlockSize <= startOfEndRun; i += testBlockSize)\n        {\n            for (int j = 0; j < testBlockSize; j++)\n            {\n                if (hashTable[i + j] == null)\n                {\n                    continue blockLoop;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * If more than this many consecutive positions are filled in a table of the specified size,\n     * report probable hash flooding. ({@link #hashFloodingDetected} may also report hash flooding if\n     * fewer consecutive positions are filled; see that method for details.)\n     */\n    private static int maxRunBeforeFallback(int tableSize)\n    {\n        return MAX_RUN_MULTIPLIER * IntMath.log2(tableSize, RoundingMode.UNNECESSARY);\n    }\n\n    /**\n     * Default implementation of the guts of ImmutableSet.Builder, creating an open-addressed hash\n     * table and deduplicating elements as they come, so it only allocates O(max(distinct,\n     * expectedCapacity)) rather than O(calls to add).\n     *\n     * <p>This implementation attempts to detect hash flooding, and if it's identified, falls back to\n     * JdkBackedSetBuilderImpl.\n     */\n    private static final class RegularSetBuilderImpl<E> extends SetBuilderImpl<E>\n    {\n        private Object[] hashTable;\n        private int maxRunBeforeFallback;\n        private int expandTableThreshold;\n        private int hashCode;\n\n        RegularSetBuilderImpl(int expectedCapacity)\n        {\n            super(expectedCapacity);\n            int tableSize = chooseTableSize(expectedCapacity);\n            this.hashTable = new Object[tableSize];\n            this.maxRunBeforeFallback = maxRunBeforeFallback(tableSize);\n            this.expandTableThreshold = (int) (DESIRED_LOAD_FACTOR * tableSize);\n        }\n\n        RegularSetBuilderImpl(RegularSetBuilderImpl<E> toCopy)\n        {\n            super(toCopy);\n            this.hashTable = Arrays.copyOf(toCopy.hashTable, toCopy.hashTable.length);\n            this.maxRunBeforeFallback = toCopy.maxRunBeforeFallback;\n            this.expandTableThreshold = toCopy.expandTableThreshold;\n            this.hashCode = toCopy.hashCode;\n        }\n\n        void ensureTableCapacity(int minCapacity)\n        {\n            if (minCapacity > expandTableThreshold && hashTable.length < MAX_TABLE_SIZE)\n            {\n                int newTableSize = hashTable.length * 2;\n                hashTable = rebuildHashTable(newTableSize, dedupedElements, distinct);\n                maxRunBeforeFallback = maxRunBeforeFallback(newTableSize);\n                expandTableThreshold = (int) (DESIRED_LOAD_FACTOR * newTableSize);\n            }\n        }\n\n        @Override\n        SetBuilderImpl<E> add(E e)\n        {\n            checkNotNull(e);\n            int eHash = e.hashCode();\n            int i0 = Hashing.smear(eHash);\n            int mask = hashTable.length - 1;\n            for (int i = i0; i - i0 < maxRunBeforeFallback; i++)\n            {\n                int index = i & mask;\n                Object tableEntry = hashTable[index];\n                if (tableEntry == null)\n                {\n                    addDedupedElement(e);\n                    hashTable[index] = e;\n                    hashCode += eHash;\n                    ensureTableCapacity(distinct); // rebuilds table if necessary\n                    return this;\n                }\n                else if (tableEntry.equals(e))     // not a new element, ignore\n                {\n                    return this;\n                }\n            }\n            // we fell out of the loop due to a long run; fall back to JDK impl\n            return new JdkBackedSetBuilderImpl<E>(this).add(e);\n        }\n\n        @Override\n        SetBuilderImpl<E> copy()\n        {\n            return new RegularSetBuilderImpl<E>(this);\n        }\n\n        @Override\n        SetBuilderImpl<E> review()\n        {\n            int targetTableSize = chooseTableSize(distinct);\n            if (targetTableSize * 2 < hashTable.length)\n            {\n                hashTable = rebuildHashTable(targetTableSize, dedupedElements, distinct);\n            }\n            return hashFloodingDetected(hashTable) ? new JdkBackedSetBuilderImpl<E>(this) : this;\n        }\n\n        @Override\n        ImmutableSet<E> build()\n        {\n            switch (distinct)\n            {\n            case 0:\n                return of();\n            case 1:\n                return of(dedupedElements[0]);\n            default:\n                Object[] elements =\n                    (distinct == dedupedElements.length)\n                    ? dedupedElements\n                    : Arrays.copyOf(dedupedElements, distinct);\n                return new RegularImmutableSet<E>(elements, hashCode, hashTable, hashTable.length - 1);\n            }\n        }\n    }\n\n    /**\n     * SetBuilderImpl version that uses a JDK HashSet, which has built in hash flooding protection.\n     */\n    private static final class JdkBackedSetBuilderImpl<E> extends SetBuilderImpl<E>\n    {\n        private final Set<Object> delegate;\n\n        JdkBackedSetBuilderImpl(SetBuilderImpl<E> toCopy)\n        {\n            super(toCopy); // initializes dedupedElements and distinct\n            delegate = Sets.newHashSetWithExpectedSize(distinct);\n            for (int i = 0; i < distinct; i++)\n            {\n                delegate.add(dedupedElements[i]);\n            }\n        }\n\n        @Override\n        SetBuilderImpl<E> add(E e)\n        {\n            checkNotNull(e);\n            if (delegate.add(e))\n            {\n                addDedupedElement(e);\n            }\n            return this;\n        }\n\n        @Override\n        SetBuilderImpl<E> copy()\n        {\n            return new JdkBackedSetBuilderImpl<>(this);\n        }\n\n        @Override\n        ImmutableSet<E> build()\n        {\n            switch (distinct)\n            {\n            case 0:\n                return of();\n            case 1:\n                return of(dedupedElements[0]);\n            default:\n                return new JdkBackedImmutableSet<E>(\n                           delegate, ImmutableList.asImmutableList(dedupedElements, distinct));\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/collect/ImmutableSet.java", "func_name": "ImmutableSet.chooseTableSize", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns an array size suitable for the backing array of a hash table that uses open addressing\nwith linear probing in its implementation. The returned size is the smallest power of two that\ncan hold setSize elements with the desired load factor. Always returns at least setSize + 2.", "docstring_tokens": ["Returns", "an", "array", "size", "suitable", "for", "the", "backing", "array", "of", "a", "hash", "table", "that", "uses", "open", "addressing", "with", "linear", "probing", "in", "its", "implementation", ".", "The", "returned", "size", "is", "the", "smallest", "power", "of", "two", "that", "can", "hold", "setSize", "elements", "with", "the", "desired", "load", "factor", ".", "Always", "returns", "at", "least", "setSize", "+", "2", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/collect/ImmutableSet.java#L640-L656", "partition": "valid", "up_fun_num": 26, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.collect.CollectPreconditions.checkNonnegative;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.annotations.VisibleForTesting;", "import com.google.common.math.IntMath;", "import com.google.common.primitives.Ints;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import com.google.errorprone.annotations.concurrent.LazyInit;", "import com.google.j2objc.annotations.RetainedWith;", "import java.io.Serializable;", "import java.math.RoundingMode;", "import java.util.Arrays;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.EnumSet;", "import java.util.Iterator;", "import java.util.Set;", "import java.util.SortedSet;", "import java.util.Spliterator;", "import java.util.function.Consumer;", "import java.util.stream.Collector;", "import org.checkerframework.checker.nullness.qual.Nullable;"], "function": ["public abstract class ImmutableSet<E> extends ImmutableCollection<E> implements Set<E>\n", "    public static <E> Collector<E, ?, ImmutableSet<E>> toImmutableSet()\n", "    public static <E> ImmutableSet<E> of()\n", "    public static <E> ImmutableSet<E> of(E element)\n", "    public static <E> ImmutableSet<E> of(E e1, E e2)\n", "    public static <E> ImmutableSet<E> of(E e1, E e2, E e3)\n", "    public static <E> ImmutableSet<E> of(E e1, E e2, E e3, E e4)\n", "    public static <E> ImmutableSet<E> of(E e1, E e2, E e3, E e4, E e5)\n", "    public static <E> ImmutableSet<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E... others)\n", "    private static <E> ImmutableSet<E> constructUnknownDuplication(int n, Object... elements)\n", "    private static <E> ImmutableSet<E> construct(int n, int expectedSize, Object... elements)\n", "    public static <E> ImmutableSet<E> copyOf(Collection<? extends E> elements)\n", "    public static <E> ImmutableSet<E> copyOf(Iterable<? extends E> elements)\n", "    public static <E> ImmutableSet<E> copyOf(Iterator<? extends E> elements)\n", "    public static <E> ImmutableSet<E> copyOf(E[] elements)\n", "    private static ImmutableSet copyOfEnumSet(EnumSet enumSet)\n", "    boolean isHashCodeFast()\n", "    public boolean equals(@Nullable Object object)\n", "    public int hashCode()\n", "    public abstract UnmodifiableIterator<E> iterator();\n", "    public ImmutableList<E> asList()\n", "    ImmutableList<E> createAsList()\n", "    Object writeReplace()\n", "    public static <E> Builder<E> builder()\n", "    public static <E> Builder<E> builderWithExpectedSize(int expectedSize)\n", "    static Object[] rebuildHashTable(int newTableSize, Object[] elements, int n)\n", "    static boolean hashFloodingDetected(Object[] hashTable)\n", "    private static int maxRunBeforeFallback(int tableSize)\n"], "context": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.collect.CollectPreconditions.checkNonnegative;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.math.IntMath;\nimport com.google.common.primitives.Ints;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.google.errorprone.annotations.concurrent.LazyInit;\nimport com.google.j2objc.annotations.RetainedWith;\nimport java.io.Serializable;\nimport java.math.RoundingMode;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.Spliterator;\nimport java.util.function.Consumer;\nimport java.util.stream.Collector;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\n/**\n * A {@link Set} whose contents will never change, with many other important properties detailed at\n * {@link ImmutableCollection}.\n *\n * @since 2.0\n */\n@GwtCompatible(serializable = true, emulated = true)\n@SuppressWarnings(\"serial\") // we're overriding default serialization\npublic abstract class ImmutableSet<E> extends ImmutableCollection<E> implements Set<E>\n{\n    static final int SPLITERATOR_CHARACTERISTICS =\n        ImmutableCollection.SPLITERATOR_CHARACTERISTICS | Spliterator.DISTINCT;\n\n    /**\n     * Returns a {@code Collector} that accumulates the input elements into a new {@code\n     * ImmutableSet}. Elements appear in the resulting set in the encounter order of the stream; if\n     * the stream contains duplicates (according to {@link Object#equals(Object)}), only the first\n     * duplicate in encounter order will appear in the result.\n     *\n     * @since 21.0\n     */\n    public static <E> Collector<E, ?, ImmutableSet<E>> toImmutableSet()\n    {\n        return CollectCollectors.toImmutableSet();\n    }\n\n    /**\n     * Returns the empty immutable set. Preferred over {@link Collections#emptySet} for code\n     * consistency, and because the return type conveys the immutability guarantee.\n     */\n    @SuppressWarnings({\"unchecked\"}) // fully variant implementation (never actually produces any Es)\n    public static <E> ImmutableSet<E> of()\n    {\n        return (ImmutableSet<E>) RegularImmutableSet.EMPTY;\n    }\n\n    /**\n     * Returns an immutable set containing {@code element}. Preferred over {@link\n     * Collections#singleton} for code consistency, {@code null} rejection, and because the return\n     * type conveys the immutability guarantee.\n     */\n    public static <E> ImmutableSet<E> of(E element)\n    {\n        return new SingletonImmutableSet<E>(element);\n    }\n\n    /**\n     * Returns an immutable set containing the given elements, minus duplicates, in the order each was\n     * first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except\n     * the first are ignored.\n     */\n    public static <E> ImmutableSet<E> of(E e1, E e2)\n    {\n        return construct(2, 2, e1, e2);\n    }\n\n    /**\n     * Returns an immutable set containing the given elements, minus duplicates, in the order each was\n     * first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except\n     * the first are ignored.\n     */\n    public static <E> ImmutableSet<E> of(E e1, E e2, E e3)\n    {\n        return construct(3, 3, e1, e2, e3);\n    }\n\n    /**\n     * Returns an immutable set containing the given elements, minus duplicates, in the order each was\n     * first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except\n     * the first are ignored.\n     */\n    public static <E> ImmutableSet<E> of(E e1, E e2, E e3, E e4)\n    {\n        return construct(4, 4, e1, e2, e3, e4);\n    }\n\n    /**\n     * Returns an immutable set containing the given elements, minus duplicates, in the order each was\n     * first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except\n     * the first are ignored.\n     */\n    public static <E> ImmutableSet<E> of(E e1, E e2, E e3, E e4, E e5)\n    {\n        return construct(5, 5, e1, e2, e3, e4, e5);\n    }\n\n    /**\n     * Returns an immutable set containing the given elements, minus duplicates, in the order each was\n     * first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except\n     * the first are ignored.\n     *\n     * <p>The array {@code others} must not be longer than {@code Integer.MAX_VALUE - 6}.\n     *\n     * @since 3.0 (source-compatible since 2.0)\n     */\n    @SafeVarargs // For Eclipse. For internal javac we have disabled this pointless type of warning.\n    public static <E> ImmutableSet<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E... others)\n    {\n        checkArgument(\n            others.length <= Integer.MAX_VALUE - 6, \"the total number of elements must fit in an int\");\n        final int paramCount = 6;\n        Object[] elements = new Object[paramCount + others.length];\n        elements[0] = e1;\n        elements[1] = e2;\n        elements[2] = e3;\n        elements[3] = e4;\n        elements[4] = e5;\n        elements[5] = e6;\n        System.arraycopy(others, 0, elements, paramCount, others.length);\n        return construct(elements.length, elements.length, elements);\n    }\n\n    /**\n     * Constructs an {@code ImmutableSet} from the first {@code n} elements of the specified array,\n     * which we have no particular reason to believe does or does not contain duplicates. If {@code k}\n     * is the size of the returned {@code ImmutableSet}, then the unique elements of {@code elements}\n     * will be in the first {@code k} positions, and {@code elements[i] == null} for {@code k <= i <\n     * n}.\n     *\n     * <p>This may modify {@code elements}. Additionally, if {@code n == elements.length} and {@code\n     * elements} contains no duplicates, {@code elements} may be used without copying in the returned\n     * {@code ImmutableSet}, in which case the caller must not modify it.\n     *\n     * <p>{@code elements} may contain only values of type {@code E}.\n     *\n     * @throws NullPointerException if any of the first {@code n} elements of {@code elements} is null\n     */\n    private static <E> ImmutableSet<E> constructUnknownDuplication(int n, Object... elements)\n    {\n        // Guess the size is \"halfway between\" all duplicates and no duplicates, on a log scale.\n        return construct(\n                   n,\n                   Math.max(\n                       ImmutableCollection.Builder.DEFAULT_INITIAL_CAPACITY,\n                       IntMath.sqrt(n, RoundingMode.CEILING)),\n                   elements);\n    }\n\n    /**\n     * Constructs an {@code ImmutableSet} from the first {@code n} elements of the specified array. If\n     * {@code k} is the size of the returned {@code ImmutableSet}, then the unique elements of {@code\n     * elements} will be in the first {@code k} positions, and {@code elements[i] == null} for {@code\n     * k <= i < n}.\n     *\n     * <p>This may modify {@code elements}. Additionally, if {@code n == elements.length} and {@code\n     * elements} contains no duplicates, {@code elements} may be used without copying in the returned\n     * {@code ImmutableSet}, in which case it may no longer be modified.\n     *\n     * <p>{@code elements} may contain only values of type {@code E}.\n     *\n     * @throws NullPointerException if any of the first {@code n} elements of {@code elements} is null\n     */\n    private static <E> ImmutableSet<E> construct(int n, int expectedSize, Object... elements)\n    {\n        switch (n)\n        {\n        case 0:\n            return of();\n        case 1:\n            @SuppressWarnings(\"unchecked\") // safe; elements contains only E's\n            E elem = (E) elements[0];\n            return of(elem);\n        default:\n            SetBuilderImpl<E> builder = new RegularSetBuilderImpl<E>(expectedSize);\n            for (int i = 0; i < n; i++)\n            {\n                @SuppressWarnings(\"unchecked\")\n                E e = (E) checkNotNull(elements[i]);\n                builder = builder.add(e);\n            }\n            return builder.review().build();\n        }\n    }\n\n    /**\n     * Returns an immutable set containing each of {@code elements}, minus duplicates, in the order\n     * each appears first in the source collection.\n     *\n     * <p><b>Performance note:</b> This method will sometimes recognize that the actual copy operation\n     * is unnecessary; for example, {@code copyOf(copyOf(anArrayList))} will copy the data only once.\n     * This reduces the expense of habitually making defensive copies at API boundaries. However, the\n     * precise conditions for skipping the copy operation are undefined.\n     *\n     * @throws NullPointerException if any of {@code elements} is null\n     * @since 7.0 (source-compatible since 2.0)\n     */\n    public static <E> ImmutableSet<E> copyOf(Collection<? extends E> elements)\n    {\n        /*\n         * TODO(lowasser): consider checking for ImmutableAsList here\n         * TODO(lowasser): consider checking for Multiset here\n         */\n        // Don't refer to ImmutableSortedSet by name so it won't pull in all that code\n        if (elements instanceof ImmutableSet && !(elements instanceof SortedSet))\n        {\n            @SuppressWarnings(\"unchecked\") // all supported methods are covariant\n            ImmutableSet<E> set = (ImmutableSet<E>) elements;\n            if (!set.isPartialView())\n            {\n                return set;\n            }\n        }\n        else if (elements instanceof EnumSet)\n        {\n            return copyOfEnumSet((EnumSet) elements);\n        }\n        Object[] array = elements.toArray();\n        if (elements instanceof Set)\n        {\n            // assume probably no duplicates (though it might be using different equality semantics)\n            return construct(array.length, array.length, array);\n        }\n        else\n        {\n            return constructUnknownDuplication(array.length, array);\n        }\n    }\n\n    /**\n     * Returns an immutable set containing each of {@code elements}, minus duplicates, in the order\n     * each appears first in the source iterable. This method iterates over {@code elements} only\n     * once.\n     *\n     * <p><b>Performance note:</b> This method will sometimes recognize that the actual copy operation\n     * is unnecessary; for example, {@code copyOf(copyOf(anArrayList))} should copy the data only\n     * once. This reduces the expense of habitually making defensive copies at API boundaries.\n     * However, the precise conditions for skipping the copy operation are undefined.\n     *\n     * @throws NullPointerException if any of {@code elements} is null\n     */\n    public static <E> ImmutableSet<E> copyOf(Iterable<? extends E> elements)\n    {\n        return (elements instanceof Collection)\n               ? copyOf((Collection<? extends E>) elements)\n               : copyOf(elements.iterator());\n    }\n\n    /**\n     * Returns an immutable set containing each of {@code elements}, minus duplicates, in the order\n     * each appears first in the source iterator.\n     *\n     * @throws NullPointerException if any of {@code elements} is null\n     */\n    public static <E> ImmutableSet<E> copyOf(Iterator<? extends E> elements)\n    {\n        // We special-case for 0 or 1 elements, but anything further is madness.\n        if (!elements.hasNext())\n        {\n            return of();\n        }\n        E first = elements.next();\n        if (!elements.hasNext())\n        {\n            return of(first);\n        }\n        else\n        {\n            return new ImmutableSet.Builder<E>().add(first).addAll(elements).build();\n        }\n    }\n\n    /**\n     * Returns an immutable set containing each of {@code elements}, minus duplicates, in the order\n     * each appears first in the source array.\n     *\n     * @throws NullPointerException if any of {@code elements} is null\n     * @since 3.0\n     */\n    public static <E> ImmutableSet<E> copyOf(E[] elements)\n    {\n        switch (elements.length)\n        {\n        case 0:\n            return of();\n        case 1:\n            return of(elements[0]);\n        default:\n            return constructUnknownDuplication(elements.length, elements.clone());\n        }\n    }\n\n    @SuppressWarnings(\"rawtypes\") // necessary to compile against Java 8\n    private static ImmutableSet copyOfEnumSet(EnumSet enumSet)\n    {\n        return ImmutableEnumSet.asImmutable(EnumSet.copyOf(enumSet));\n    }\n\n    ImmutableSet() {}\n\n    /** Returns {@code true} if the {@code hashCode()} method runs quickly. */\n    boolean isHashCodeFast()\n    {\n        return false;\n    }\n\n    @Override\n    public boolean equals(@Nullable Object object)\n    {\n        if (object == this)\n        {\n            return true;\n        }\n        else if (object instanceof ImmutableSet\n                 && isHashCodeFast()\n                 && ((ImmutableSet<?>) object).isHashCodeFast()\n                 && hashCode() != object.hashCode())\n        {\n            return false;\n        }\n        return Sets.equalsImpl(this, object);\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return Sets.hashCodeImpl(this);\n    }\n\n    // This declaration is needed to make Set.iterator() and\n    // ImmutableCollection.iterator() consistent.\n    @Override\n    public abstract UnmodifiableIterator<E> iterator();\n\n    @LazyInit @RetainedWith private transient @Nullable ImmutableList<E> asList;\n\n    @Override\n    public ImmutableList<E> asList()\n    {\n        ImmutableList<E> result = asList;\n        return (result == null) ? asList = createAsList() : result;\n    }\n\n    ImmutableList<E> createAsList()\n    {\n        return new RegularImmutableAsList<E>(this, toArray());\n    }\n\n    abstract static class Indexed<E> extends ImmutableSet<E>\n    {\n        abstract E get(int index);\n\n        @Override\n        public UnmodifiableIterator<E> iterator()\n        {\n            return asList().iterator();\n        }\n\n        @Override\n        public Spliterator<E> spliterator()\n        {\n            return CollectSpliterators.indexed(size(), SPLITERATOR_CHARACTERISTICS, this::get);\n        }\n\n        @Override\n        public void forEach(Consumer<? super E> consumer)\n        {\n            checkNotNull(consumer);\n            int n = size();\n            for (int i = 0; i < n; i++)\n            {\n                consumer.accept(get(i));\n            }\n        }\n\n        @Override\n        int copyIntoArray(Object[] dst, int offset)\n        {\n            return asList().copyIntoArray(dst, offset);\n        }\n\n        @Override\n        ImmutableList<E> createAsList()\n        {\n            return new ImmutableAsList<E>()\n            {\n                @Override\n                public E get(int index)\n                {\n                    return Indexed.this.get(index);\n                }\n\n                @Override\n                Indexed<E> delegateCollection()\n                {\n                    return Indexed.this;\n                }\n            };\n        }\n    }\n\n    /*\n     * This class is used to serialize all ImmutableSet instances, except for\n     * ImmutableEnumSet/ImmutableSortedSet, regardless of implementation type. It\n     * captures their \"logical contents\" and they are reconstructed using public\n     * static factories. This is necessary to ensure that the existence of a\n     * particular implementation type is an implementation detail.\n     */\n    private static class SerializedForm implements Serializable\n    {\n        final Object[] elements;\n\n        SerializedForm(Object[] elements)\n        {\n            this.elements = elements;\n        }\n\n        Object readResolve()\n        {\n            return copyOf(elements);\n        }\n\n        private static final long serialVersionUID = 0;\n    }\n\n    @Override\n    Object writeReplace()\n    {\n        return new SerializedForm(toArray());\n    }\n\n    /**\n     * Returns a new builder. The generated builder is equivalent to the builder created by the {@link\n     * Builder} constructor.\n     */\n    public static <E> Builder<E> builder()\n    {\n        return new Builder<E>();\n    }\n\n    /**\n     * Returns a new builder, expecting the specified number of distinct elements to be added.\n     *\n     * <p>If {@code expectedSize} is exactly the number of distinct elements added to the builder\n     * before {@link Builder#build} is called, the builder is likely to perform better than an unsized\n     * {@link #builder()} would have.\n     *\n     * <p>It is not specified if any performance benefits apply if {@code expectedSize} is close to,\n     * but not exactly, the number of distinct elements added to the builder.\n     *\n     * @since 23.1\n     */\n    @Beta\n    public static <E> Builder<E> builderWithExpectedSize(int expectedSize)\n    {\n        checkNonnegative(expectedSize, \"expectedSize\");\n        return new Builder<E>(expectedSize);\n    }\n\n    /** Builds a new open-addressed hash table from the first n objects in elements. */\n    static Object[] rebuildHashTable(int newTableSize, Object[] elements, int n)\n    {\n        Object[] hashTable = new Object[newTableSize];\n        int mask = hashTable.length - 1;\n        for (int i = 0; i < n; i++)\n        {\n            Object e = elements[i];\n            int j0 = Hashing.smear(e.hashCode());\n            for (int j = j0; ; j++)\n            {\n                int index = j & mask;\n                if (hashTable[index] == null)\n                {\n                    hashTable[index] = e;\n                    break;\n                }\n            }\n        }\n        return hashTable;\n    }\n\n    /**\n     * A builder for creating {@code ImmutableSet} instances. Example:\n     *\n     * <pre>{@code\n     * static final ImmutableSet<Color> GOOGLE_COLORS =\n     *     ImmutableSet.<Color>builder()\n     *         .addAll(WEBSAFE_COLORS)\n     *         .add(new Color(0, 191, 255))\n     *         .build();\n     * }</pre>\n     *\n     * <p>Elements appear in the resulting set in the same order they were first added to the builder.\n     *\n     * <p>Building does not change the state of the builder, so it is still possible to add more\n     * elements and to build again.\n     *\n     * @since 2.0\n     */\n    public static class Builder<E> extends ImmutableCollection.Builder<E>\n    {\n        private SetBuilderImpl<E> impl;\n        boolean forceCopy;\n\n        public Builder()\n        {\n            this(DEFAULT_INITIAL_CAPACITY);\n        }\n\n        Builder(int capacity)\n        {\n            impl = new RegularSetBuilderImpl<E>(capacity);\n        }\n\n        Builder(@SuppressWarnings(\"unused\") boolean subclass)\n        {\n            this.impl = null; // unused\n        }\n\n        @VisibleForTesting\n        void forceJdk()\n        {\n            this.impl = new JdkBackedSetBuilderImpl<E>(impl);\n        }\n\n        final void copyIfNecessary()\n        {\n            if (forceCopy)\n            {\n                copy();\n                forceCopy = false;\n            }\n        }\n\n        void copy()\n        {\n            impl = impl.copy();\n        }\n\n        @Override\n        @CanIgnoreReturnValue\n        public Builder<E> add(E element)\n        {\n            checkNotNull(element);\n            copyIfNecessary();\n            impl = impl.add(element);\n            return this;\n        }\n\n        @Override\n        @CanIgnoreReturnValue\n        public Builder<E> add(E... elements)\n        {\n            super.add(elements);\n            return this;\n        }\n\n        @Override\n        /**\n         * Adds each element of {@code elements} to the {@code ImmutableSet}, ignoring duplicate\n         * elements (only the first duplicate element is added).\n         *\n         * @param elements the elements to add\n         * @return this {@code Builder} object\n         * @throws NullPointerException if {@code elements} is null or contains a null element\n         */\n        @CanIgnoreReturnValue\n        public Builder<E> addAll(Iterable<? extends E> elements)\n        {\n            super.addAll(elements);\n            return this;\n        }\n\n        @Override\n        @CanIgnoreReturnValue\n        public Builder<E> addAll(Iterator<? extends E> elements)\n        {\n            super.addAll(elements);\n            return this;\n        }\n\n        Builder<E> combine(Builder<E> other)\n        {\n            copyIfNecessary();\n            this.impl = this.impl.combine(other.impl);\n            return this;\n        }\n\n        @Override\n        public ImmutableSet<E> build()\n        {\n            forceCopy = true;\n            impl = impl.review();\n            return impl.build();\n        }\n    }\n\n    /** Swappable internal implementation of an ImmutableSet.Builder. */\n    private abstract static class SetBuilderImpl<E>\n    {\n        E[] dedupedElements;\n        int distinct;\n\n        @SuppressWarnings(\"unchecked\")\n        SetBuilderImpl(int expectedCapacity)\n        {\n            this.dedupedElements = (E[]) new Object[expectedCapacity];\n            this.distinct = 0;\n        }\n\n        /** Initializes this SetBuilderImpl with a copy of the deduped elements array from toCopy. */\n        SetBuilderImpl(SetBuilderImpl<E> toCopy)\n        {\n            this.dedupedElements = Arrays.copyOf(toCopy.dedupedElements, toCopy.dedupedElements.length);\n            this.distinct = toCopy.distinct;\n        }\n\n        /**\n         * Resizes internal data structures if necessary to store the specified number of distinct\n         * elements.\n         */\n        private void ensureCapacity(int minCapacity)\n        {\n            if (minCapacity > dedupedElements.length)\n            {\n                int newCapacity =\n                    ImmutableCollection.Builder.expandedCapacity(dedupedElements.length, minCapacity);\n                dedupedElements = Arrays.copyOf(dedupedElements, newCapacity);\n            }\n        }\n\n        /** Adds e to the insertion-order array of deduplicated elements. Calls ensureCapacity. */\n        final void addDedupedElement(E e)\n        {\n            ensureCapacity(distinct + 1);\n            dedupedElements[distinct++] = e;\n        }\n\n        /**\n         * Adds e to this SetBuilderImpl, returning the updated result. Only use the returned\n         * SetBuilderImpl, since we may switch implementations if e.g. hash flooding is detected.\n         */\n        abstract SetBuilderImpl<E> add(E e);\n\n        /** Adds all the elements from the specified SetBuilderImpl to this SetBuilderImpl. */\n        final SetBuilderImpl<E> combine(SetBuilderImpl<E> other)\n        {\n            SetBuilderImpl<E> result = this;\n            for (int i = 0; i < other.distinct; i++)\n            {\n                result = result.add(other.dedupedElements[i]);\n            }\n            return result;\n        }\n\n        /**\n         * Creates a new copy of this SetBuilderImpl. Modifications to that SetBuilderImpl will not\n         * affect this SetBuilderImpl or sets constructed from this SetBuilderImpl via build().\n         */\n        abstract SetBuilderImpl<E> copy();\n\n        /**\n         * Call this before build(). Does a final check on the internal data structures, e.g. shrinking\n         * unnecessarily large structures or detecting previously unnoticed hash flooding.\n         */\n        SetBuilderImpl<E> review()\n        {\n            return this;\n        }\n\n        abstract ImmutableSet<E> build();\n    }\n\n    // We use power-of-2 tables, and this is the highest int that's a power of 2\n    static final int MAX_TABLE_SIZE = Ints.MAX_POWER_OF_TWO;\n\n    // Represents how tightly we can pack things, as a maximum.\n    private static final double DESIRED_LOAD_FACTOR = 0.7;\n\n    // If the set has this many elements, it will \"max out\" the table size\n    private static final int CUTOFF = (int) (MAX_TABLE_SIZE * DESIRED_LOAD_FACTOR);\n\n    /**\n     * Returns an array size suitable for the backing array of a hash table that uses open addressing\n     * with linear probing in its implementation. The returned size is the smallest power of two that\n     * can hold setSize elements with the desired load factor. Always returns at least setSize + 2.\n     */\n\n    /**\n     * We attempt to detect deliberate hash flooding attempts, and if one is detected, fall back to a\n     * wrapper around j.u.HashSet, which has built in flooding protection. HASH_FLOODING_FPP is the\n     * maximum allowed probability of falsely detecting a hash flooding attack if the input is\n     * randomly generated.\n     *\n     * <p>MAX_RUN_MULTIPLIER was determined experimentally to match this FPP.\n     */\n    static final double HASH_FLOODING_FPP = 0.001;\n\n    // NB: yes, this is surprisingly high, but that's what the experiments said was necessary\n    // The higher it is, the worse constant factors we are willing to accept.\n    static final int MAX_RUN_MULTIPLIER = 13;\n\n    /**\n     * Checks the whole hash table for poor hash distribution. Takes O(n) in the worst case, O(n / log\n     * n) on average.\n     *\n     * <p>The online hash flooding detecting in RegularSetBuilderImpl.add can detect e.g. many exactly\n     * matching hash codes, which would cause construction to take O(n^2), but can't detect e.g. hash\n     * codes adversarially designed to go into ascending table locations, which keeps construction\n     * O(n) (as desired) but then can have O(n) queries later.\n     *\n     * <p>If this returns false, then no query can take more than O(log n).\n     *\n     * <p>Note that for a RegularImmutableSet with elements with truly random hash codes, contains\n     * operations take expected O(1) time but with high probability take O(log n) for at least some\n     * element. (https://en.wikipedia.org/wiki/Linear_probing#Analysis)\n     *\n     * <p>This method may return {@code true} up to {@link #HASH_FLOODING_FPP} of the time even on\n     * truly random input.\n     *\n     * <p>If this method returns false, there are definitely no runs of length at least {@code\n     * maxRunBeforeFallback(hashTable.length)} nonnull elements. If there are no runs of length at\n     * least {@code maxRunBeforeFallback(hashTable.length) / 2} nonnull elements, this method\n     * definitely returns false. In between those constraints, the result of this method is undefined,\n     * subject to the above {@link #HASH_FLOODING_FPP} constraint.\n     */\n    static boolean hashFloodingDetected(Object[] hashTable)\n    {\n        int maxRunBeforeFallback = maxRunBeforeFallback(hashTable.length);\n\n        // Test for a run wrapping around the end of the table of length at least maxRunBeforeFallback.\n        int endOfStartRun;\n        for (endOfStartRun = 0; endOfStartRun < hashTable.length; )\n        {\n            if (hashTable[endOfStartRun] == null)\n            {\n                break;\n            }\n            endOfStartRun++;\n            if (endOfStartRun > maxRunBeforeFallback)\n            {\n                return true;\n            }\n        }\n        int startOfEndRun;\n        for (startOfEndRun = hashTable.length - 1; startOfEndRun > endOfStartRun; startOfEndRun--)\n        {\n            if (hashTable[startOfEndRun] == null)\n            {\n                break;\n            }\n            if (endOfStartRun + (hashTable.length - 1 - startOfEndRun) > maxRunBeforeFallback)\n            {\n                return true;\n            }\n        }\n\n        // Now, break the remainder of the table into blocks of maxRunBeforeFallback/2 elements and\n        // check that each has at least one null.\n        int testBlockSize = maxRunBeforeFallback / 2;\n        blockLoop:\n        for (int i = endOfStartRun + 1; i + testBlockSize <= startOfEndRun; i += testBlockSize)\n        {\n            for (int j = 0; j < testBlockSize; j++)\n            {\n                if (hashTable[i + j] == null)\n                {\n                    continue blockLoop;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * If more than this many consecutive positions are filled in a table of the specified size,\n     * report probable hash flooding. ({@link #hashFloodingDetected} may also report hash flooding if\n     * fewer consecutive positions are filled; see that method for details.)\n     */\n    private static int maxRunBeforeFallback(int tableSize)\n    {\n        return MAX_RUN_MULTIPLIER * IntMath.log2(tableSize, RoundingMode.UNNECESSARY);\n    }\n\n    /**\n     * Default implementation of the guts of ImmutableSet.Builder, creating an open-addressed hash\n     * table and deduplicating elements as they come, so it only allocates O(max(distinct,\n     * expectedCapacity)) rather than O(calls to add).\n     *\n     * <p>This implementation attempts to detect hash flooding, and if it's identified, falls back to\n     * JdkBackedSetBuilderImpl.\n     */\n    private static final class RegularSetBuilderImpl<E> extends SetBuilderImpl<E>\n    {\n        private Object[] hashTable;\n        private int maxRunBeforeFallback;\n        private int expandTableThreshold;\n        private int hashCode;\n\n        RegularSetBuilderImpl(int expectedCapacity)\n        {\n            super(expectedCapacity);\n            int tableSize = chooseTableSize(expectedCapacity);\n            this.hashTable = new Object[tableSize];\n            this.maxRunBeforeFallback = maxRunBeforeFallback(tableSize);\n            this.expandTableThreshold = (int) (DESIRED_LOAD_FACTOR * tableSize);\n        }\n\n        RegularSetBuilderImpl(RegularSetBuilderImpl<E> toCopy)\n        {\n            super(toCopy);\n            this.hashTable = Arrays.copyOf(toCopy.hashTable, toCopy.hashTable.length);\n            this.maxRunBeforeFallback = toCopy.maxRunBeforeFallback;\n            this.expandTableThreshold = toCopy.expandTableThreshold;\n            this.hashCode = toCopy.hashCode;\n        }\n\n        void ensureTableCapacity(int minCapacity)\n        {\n            if (minCapacity > expandTableThreshold && hashTable.length < MAX_TABLE_SIZE)\n            {\n                int newTableSize = hashTable.length * 2;\n                hashTable = rebuildHashTable(newTableSize, dedupedElements, distinct);\n                maxRunBeforeFallback = maxRunBeforeFallback(newTableSize);\n                expandTableThreshold = (int) (DESIRED_LOAD_FACTOR * newTableSize);\n            }\n        }\n\n        @Override\n        SetBuilderImpl<E> add(E e)\n        {\n            checkNotNull(e);\n            int eHash = e.hashCode();\n            int i0 = Hashing.smear(eHash);\n            int mask = hashTable.length - 1;\n            for (int i = i0; i - i0 < maxRunBeforeFallback; i++)\n            {\n                int index = i & mask;\n                Object tableEntry = hashTable[index];\n                if (tableEntry == null)\n                {\n                    addDedupedElement(e);\n                    hashTable[index] = e;\n                    hashCode += eHash;\n                    ensureTableCapacity(distinct); // rebuilds table if necessary\n                    return this;\n                }\n                else if (tableEntry.equals(e))     // not a new element, ignore\n                {\n                    return this;\n                }\n            }\n            // we fell out of the loop due to a long run; fall back to JDK impl\n            return new JdkBackedSetBuilderImpl<E>(this).add(e);\n        }\n\n        @Override\n        SetBuilderImpl<E> copy()\n        {\n            return new RegularSetBuilderImpl<E>(this);\n        }\n\n        @Override\n        SetBuilderImpl<E> review()\n        {\n            int targetTableSize = chooseTableSize(distinct);\n            if (targetTableSize * 2 < hashTable.length)\n            {\n                hashTable = rebuildHashTable(targetTableSize, dedupedElements, distinct);\n            }\n            return hashFloodingDetected(hashTable) ? new JdkBackedSetBuilderImpl<E>(this) : this;\n        }\n\n        @Override\n        ImmutableSet<E> build()\n        {\n            switch (distinct)\n            {\n            case 0:\n                return of();\n            case 1:\n                return of(dedupedElements[0]);\n            default:\n                Object[] elements =\n                    (distinct == dedupedElements.length)\n                    ? dedupedElements\n                    : Arrays.copyOf(dedupedElements, distinct);\n                return new RegularImmutableSet<E>(elements, hashCode, hashTable, hashTable.length - 1);\n            }\n        }\n    }\n\n    /**\n     * SetBuilderImpl version that uses a JDK HashSet, which has built in hash flooding protection.\n     */\n    private static final class JdkBackedSetBuilderImpl<E> extends SetBuilderImpl<E>\n    {\n        private final Set<Object> delegate;\n\n        JdkBackedSetBuilderImpl(SetBuilderImpl<E> toCopy)\n        {\n            super(toCopy); // initializes dedupedElements and distinct\n            delegate = Sets.newHashSetWithExpectedSize(distinct);\n            for (int i = 0; i < distinct; i++)\n            {\n                delegate.add(dedupedElements[i]);\n            }\n        }\n\n        @Override\n        SetBuilderImpl<E> add(E e)\n        {\n            checkNotNull(e);\n            if (delegate.add(e))\n            {\n                addDedupedElement(e);\n            }\n            return this;\n        }\n\n        @Override\n        SetBuilderImpl<E> copy()\n        {\n            return new JdkBackedSetBuilderImpl<>(this);\n        }\n\n        @Override\n        ImmutableSet<E> build()\n        {\n            switch (distinct)\n            {\n            case 0:\n                return of();\n            case 1:\n                return of(dedupedElements[0]);\n            default:\n                return new JdkBackedImmutableSet<E>(\n                           delegate, ImmutableList.asImmutableList(dedupedElements, distinct));\n            }\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/ImmutableTable.java", "func_name": "ImmutableTable.of", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns an empty immutable table.", "docstring_tokens": ["Returns", "an", "empty", "immutable", "table", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/ImmutableTable.java#L46-L49", "partition": "valid", "up_fun_num": 1, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.base.MoreObjects;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.io.Serializable;", "import java.util.Comparator;", "import java.util.Iterator;", "import java.util.List;", "import java.util.Map;", "import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>\n", "    public static <R, C, V> ImmutableTable<R, C, V> of(R rowKey, C columnKey, V value)\n", "    public static <R, C, V> ImmutableTable<R, C, V> copyOf(\n", "    private static <R, C, V> ImmutableTable<R, C, V> copyOf(\n", "    public static <R, C, V> Builder<R, C, V> builder()\n", "    static <R, C, V> Cell<R, C, V> cellOf(R rowKey, C columnKey, V value)\n", "    public ImmutableSet<Cell<R, C, V>> cellSet()\n", "    abstract ImmutableSet<Cell<R, C, V>> createCellSet();\n", "    final UnmodifiableIterator<Cell<R, C, V>> cellIterator()\n", "    public ImmutableCollection<V> values()\n", "    abstract ImmutableCollection<V> createValues();\n", "    final Iterator<V> valuesIterator()\n", "    public ImmutableMap<R, V> column(C columnKey)\n", "    public ImmutableSet<C> columnKeySet()\n", "    public abstract ImmutableMap<C, Map<R, V>> columnMap();\n", "    public ImmutableMap<C, V> row(R rowKey)\n", "    public ImmutableSet<R> rowKeySet()\n", "    public abstract ImmutableMap<R, Map<C, V>> rowMap();\n", "    public boolean contains(@NullableDecl Object rowKey, @NullableDecl Object columnKey)\n", "    public boolean containsValue(@NullableDecl Object value)\n", "    public final void clear()\n", "    public final V put(R rowKey, C columnKey, V value)\n", "    public final void putAll(Table<? extends R, ? extends C, ? extends V> table)\n", "    public final V remove(Object rowKey, Object columnKey)\n", "    abstract SerializedForm createSerializedForm();\n", "    final Object writeReplace()\n"], "context": "/*\n * Copyright (C) 2009 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.base.MoreObjects;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.Serializable;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A {@link Table} whose contents will never change, with many other important properties detailed\n * at {@link ImmutableCollection}.\n *\n * <p>See the Guava User Guide article on <a href=\n * \"https://github.com/google/guava/wiki/ImmutableCollectionsExplained\"> immutable collections</a>.\n *\n * @author Gregory Kick\n * @since 11.0\n */\n@GwtCompatible\npublic abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>\n    implements Serializable\n{\n    /** Returns an empty immutable table. */\n\n    /** Returns an immutable table containing a single cell. */\n    public static <R, C, V> ImmutableTable<R, C, V> of(R rowKey, C columnKey, V value)\n    {\n        return new SingletonImmutableTable<>(rowKey, columnKey, value);\n    }\n\n    /**\n     * Returns an immutable copy of the provided table.\n     *\n     * <p>The {@link Table#cellSet()} iteration order of the provided table determines the iteration\n     * ordering of all views in the returned table. Note that some views of the original table and the\n     * copied table may have different iteration orders. For more control over the ordering, create a\n     * {@link Builder} and call {@link Builder#orderRowsBy}, {@link Builder#orderColumnsBy}, and\n     * {@link Builder#putAll}\n     *\n     * <p>Despite the method name, this method attempts to avoid actually copying the data when it is\n     * safe to do so. The exact circumstances under which a copy will or will not be performed are\n     * undocumented and subject to change.\n     */\n    public static <R, C, V> ImmutableTable<R, C, V> copyOf(\n        Table<? extends R, ? extends C, ? extends V> table)\n    {\n        if (table instanceof ImmutableTable)\n        {\n            @SuppressWarnings(\"unchecked\")\n            ImmutableTable<R, C, V> parameterizedTable = (ImmutableTable<R, C, V>) table;\n            return parameterizedTable;\n        }\n        else\n        {\n            return copyOf(table.cellSet());\n        }\n    }\n\n    private static <R, C, V> ImmutableTable<R, C, V> copyOf(\n        Iterable<? extends Cell<? extends R, ? extends C, ? extends V>> cells)\n    {\n        ImmutableTable.Builder<R, C, V> builder = ImmutableTable.builder();\n        for (Cell<? extends R, ? extends C, ? extends V> cell : cells)\n        {\n            builder.put(cell);\n        }\n        return builder.build();\n    }\n\n    /**\n     * Returns a new builder. The generated builder is equivalent to the builder created by the {@link\n     * Builder#Builder() ImmutableTable.Builder()} constructor.\n     */\n    public static <R, C, V> Builder<R, C, V> builder()\n    {\n        return new Builder<>();\n    }\n\n    /**\n     * Verifies that {@code rowKey}, {@code columnKey} and {@code value} are non-null, and returns a\n     * new entry with those values.\n     */\n    static <R, C, V> Cell<R, C, V> cellOf(R rowKey, C columnKey, V value)\n    {\n        return Tables.immutableCell(\n                   checkNotNull(rowKey, \"rowKey\"),\n                   checkNotNull(columnKey, \"columnKey\"),\n                   checkNotNull(value, \"value\"));\n    }\n\n    /**\n     * A builder for creating immutable table instances, especially {@code public static final} tables\n     * (\"constant tables\"). Example:\n     *\n     * <pre>{@code\n     * static final ImmutableTable<Integer, Character, String> SPREADSHEET =\n     *     new ImmutableTable.Builder<Integer, Character, String>()\n     *         .put(1, 'A', \"foo\")\n     *         .put(1, 'B', \"bar\")\n     *         .put(2, 'A', \"baz\")\n     *         .build();\n     * }</pre>\n     *\n     * <p>By default, the order in which cells are added to the builder determines the iteration\n     * ordering of all views in the returned table, with {@link #putAll} following the {@link\n     * Table#cellSet()} iteration order. However, if {@link #orderRowsBy} or {@link #orderColumnsBy}\n     * is called, the views are sorted by the supplied comparators.\n     *\n     * <p>For empty or single-cell immutable tables, {@link #of()} and {@link #of(Object, Object,\n     * Object)} are even more convenient.\n     *\n     * <p>Builder instances can be reused - it is safe to call {@link #build} multiple times to build\n     * multiple tables in series. Each table is a superset of the tables created before it.\n     *\n     * @since 11.0\n     */\n    public static final class Builder<R, C, V>\n    {\n        private final List<Cell<R, C, V>> cells = Lists.newArrayList();\n        @MonotonicNonNullDecl private Comparator<? super R> rowComparator;\n        @MonotonicNonNullDecl private Comparator<? super C> columnComparator;\n\n        /**\n         * Creates a new builder. The returned builder is equivalent to the builder generated by {@link\n         * ImmutableTable#builder}.\n         */\n        public Builder() {}\n\n        /** Specifies the ordering of the generated table's rows. */\n        @CanIgnoreReturnValue\n        public Builder<R, C, V> orderRowsBy(Comparator<? super R> rowComparator)\n        {\n            this.rowComparator = checkNotNull(rowComparator, \"rowComparator\");\n            return this;\n        }\n\n        /** Specifies the ordering of the generated table's columns. */\n        @CanIgnoreReturnValue\n        public Builder<R, C, V> orderColumnsBy(Comparator<? super C> columnComparator)\n        {\n            this.columnComparator = checkNotNull(columnComparator, \"columnComparator\");\n            return this;\n        }\n\n        /**\n         * Associates the ({@code rowKey}, {@code columnKey}) pair with {@code value} in the built\n         * table. Duplicate key pairs are not allowed and will cause {@link #build} to fail.\n         */\n        @CanIgnoreReturnValue\n        public Builder<R, C, V> put(R rowKey, C columnKey, V value)\n        {\n            cells.add(cellOf(rowKey, columnKey, value));\n            return this;\n        }\n\n        /**\n         * Adds the given {@code cell} to the table, making it immutable if necessary. Duplicate key\n         * pairs are not allowed and will cause {@link #build} to fail.\n         */\n        @CanIgnoreReturnValue\n        public Builder<R, C, V> put(Cell<? extends R, ? extends C, ? extends V> cell)\n        {\n            if (cell instanceof Tables.ImmutableCell)\n            {\n                checkNotNull(cell.getRowKey(), \"row\");\n                checkNotNull(cell.getColumnKey(), \"column\");\n                checkNotNull(cell.getValue(), \"value\");\n                @SuppressWarnings(\"unchecked\") // all supported methods are covariant\n                Cell<R, C, V> immutableCell = (Cell<R, C, V>) cell;\n                cells.add(immutableCell);\n            }\n            else\n            {\n                put(cell.getRowKey(), cell.getColumnKey(), cell.getValue());\n            }\n            return this;\n        }\n\n        /**\n         * Associates all of the given table's keys and values in the built table. Duplicate row key\n         * column key pairs are not allowed, and will cause {@link #build} to fail.\n         *\n         * @throws NullPointerException if any key or value in {@code table} is null\n         */\n        @CanIgnoreReturnValue\n        public Builder<R, C, V> putAll(Table<? extends R, ? extends C, ? extends V> table)\n        {\n            for (Cell<? extends R, ? extends C, ? extends V> cell : table.cellSet())\n            {\n                put(cell);\n            }\n            return this;\n        }\n\n        /**\n         * Returns a newly-created immutable table.\n         *\n         * @throws IllegalArgumentException if duplicate key pairs were added\n         */\n        public ImmutableTable<R, C, V> build()\n        {\n            int size = cells.size();\n            switch (size)\n            {\n            case 0:\n                return of();\n            case 1:\n                return new SingletonImmutableTable<>(Iterables.getOnlyElement(cells));\n            default:\n                return RegularImmutableTable.forCells(cells, rowComparator, columnComparator);\n            }\n        }\n    }\n\n    ImmutableTable() {}\n\n    @Override\n    public ImmutableSet<Cell<R, C, V>> cellSet()\n    {\n        return (ImmutableSet<Cell<R, C, V>>) super.cellSet();\n    }\n\n    @Override\n    abstract ImmutableSet<Cell<R, C, V>> createCellSet();\n\n    @Override\n    final UnmodifiableIterator<Cell<R, C, V>> cellIterator()\n    {\n        throw new AssertionError(\"should never be called\");\n    }\n\n    @Override\n    public ImmutableCollection<V> values()\n    {\n        return (ImmutableCollection<V>) super.values();\n    }\n\n    @Override\n    abstract ImmutableCollection<V> createValues();\n\n    @Override\n    final Iterator<V> valuesIterator()\n    {\n        throw new AssertionError(\"should never be called\");\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @throws NullPointerException if {@code columnKey} is {@code null}\n     */\n    @Override\n    public ImmutableMap<R, V> column(C columnKey)\n    {\n        checkNotNull(columnKey, \"columnKey\");\n        return MoreObjects.firstNonNull(\n                   (ImmutableMap<R, V>) columnMap().get(columnKey), ImmutableMap.<R, V>of());\n    }\n\n    @Override\n    public ImmutableSet<C> columnKeySet()\n    {\n        return columnMap().keySet();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>The value {@code Map<R, V>} instances in the returned map are {@link ImmutableMap} instances\n     * as well.\n     */\n    @Override\n    public abstract ImmutableMap<C, Map<R, V>> columnMap();\n\n    /**\n     * {@inheritDoc}\n     *\n     * @throws NullPointerException if {@code rowKey} is {@code null}\n     */\n    @Override\n    public ImmutableMap<C, V> row(R rowKey)\n    {\n        checkNotNull(rowKey, \"rowKey\");\n        return MoreObjects.firstNonNull(\n                   (ImmutableMap<C, V>) rowMap().get(rowKey), ImmutableMap.<C, V>of());\n    }\n\n    @Override\n    public ImmutableSet<R> rowKeySet()\n    {\n        return rowMap().keySet();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>The value {@code Map<C, V>} instances in the returned map are {@link ImmutableMap} instances\n     * as well.\n     */\n    @Override\n    public abstract ImmutableMap<R, Map<C, V>> rowMap();\n\n    @Override\n    public boolean contains(@NullableDecl Object rowKey, @NullableDecl Object columnKey)\n    {\n        return get(rowKey, columnKey) != null;\n    }\n\n    @Override\n    public boolean containsValue(@NullableDecl Object value)\n    {\n        return values().contains(value);\n    }\n\n    /**\n     * Guaranteed to throw an exception and leave the table unmodified.\n     *\n     * @throws UnsupportedOperationException always\n     * @deprecated Unsupported operation.\n     */\n    @Deprecated\n    @Override\n    public final void clear()\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Guaranteed to throw an exception and leave the table unmodified.\n     *\n     * @throws UnsupportedOperationException always\n     * @deprecated Unsupported operation.\n     */\n    @CanIgnoreReturnValue\n    @Deprecated\n    @Override\n    public final V put(R rowKey, C columnKey, V value)\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Guaranteed to throw an exception and leave the table unmodified.\n     *\n     * @throws UnsupportedOperationException always\n     * @deprecated Unsupported operation.\n     */\n    @Deprecated\n    @Override\n    public final void putAll(Table<? extends R, ? extends C, ? extends V> table)\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Guaranteed to throw an exception and leave the table unmodified.\n     *\n     * @throws UnsupportedOperationException always\n     * @deprecated Unsupported operation.\n     */\n    @CanIgnoreReturnValue\n    @Deprecated\n    @Override\n    public final V remove(Object rowKey, Object columnKey)\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    /** Creates the common serialized form for this table. */\n    abstract SerializedForm createSerializedForm();\n\n    /**\n     * Serialized type for all ImmutableTable instances. It captures the logical contents and\n     * preserves iteration order of all views.\n     */\n    static final class SerializedForm implements Serializable\n    {\n        private final Object[] rowKeys;\n        private final Object[] columnKeys;\n\n        private final Object[] cellValues;\n        private final int[] cellRowIndices;\n        private final int[] cellColumnIndices;\n\n        private SerializedForm(\n            Object[] rowKeys,\n            Object[] columnKeys,\n            Object[] cellValues,\n            int[] cellRowIndices,\n            int[] cellColumnIndices)\n        {\n            this.rowKeys = rowKeys;\n            this.columnKeys = columnKeys;\n            this.cellValues = cellValues;\n            this.cellRowIndices = cellRowIndices;\n            this.cellColumnIndices = cellColumnIndices;\n        }\n\n        static SerializedForm create(\n            ImmutableTable<?, ?, ?> table, int[] cellRowIndices, int[] cellColumnIndices)\n        {\n            return new SerializedForm(\n                       table.rowKeySet().toArray(),\n                       table.columnKeySet().toArray(),\n                       table.values().toArray(),\n                       cellRowIndices,\n                       cellColumnIndices);\n        }\n\n        Object readResolve()\n        {\n            if (cellValues.length == 0)\n            {\n                return of();\n            }\n            if (cellValues.length == 1)\n            {\n                return of(rowKeys[0], columnKeys[0], cellValues[0]);\n            }\n            ImmutableList.Builder<Cell<Object, Object, Object>> cellListBuilder =\n                new ImmutableList.Builder<>(cellValues.length);\n            for (int i = 0; i < cellValues.length; i++)\n            {\n                cellListBuilder.add(\n                    cellOf(rowKeys[cellRowIndices[i]], columnKeys[cellColumnIndices[i]], cellValues[i]));\n            }\n            return RegularImmutableTable.forOrderedComponents(\n                       cellListBuilder.build(), ImmutableSet.copyOf(rowKeys), ImmutableSet.copyOf(columnKeys));\n        }\n\n        private static final long serialVersionUID = 0;\n    }\n\n    final Object writeReplace()\n    {\n        return createSerializedForm();\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/ImmutableTable.java", "func_name": "ImmutableTable.of", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns an immutable table containing a single cell.", "docstring_tokens": ["Returns", "an", "immutable", "table", "containing", "a", "single", "cell", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/ImmutableTable.java#L52-L54", "partition": "valid", "up_fun_num": 3, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.base.MoreObjects;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.io.Serializable;", "import java.util.Comparator;", "import java.util.Iterator;", "import java.util.List;", "import java.util.Map;", "import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>\n", "    public static <R, C, V> ImmutableTable<R, C, V> of()\n", "    public static <R, C, V> ImmutableTable<R, C, V> copyOf(\n", "    private static <R, C, V> ImmutableTable<R, C, V> copyOf(\n", "    public static <R, C, V> Builder<R, C, V> builder()\n", "    static <R, C, V> Cell<R, C, V> cellOf(R rowKey, C columnKey, V value)\n", "    public ImmutableSet<Cell<R, C, V>> cellSet()\n", "    abstract ImmutableSet<Cell<R, C, V>> createCellSet();\n", "    final UnmodifiableIterator<Cell<R, C, V>> cellIterator()\n", "    public ImmutableCollection<V> values()\n", "    abstract ImmutableCollection<V> createValues();\n", "    final Iterator<V> valuesIterator()\n", "    public ImmutableMap<R, V> column(C columnKey)\n", "    public ImmutableSet<C> columnKeySet()\n", "    public abstract ImmutableMap<C, Map<R, V>> columnMap();\n", "    public ImmutableMap<C, V> row(R rowKey)\n", "    public ImmutableSet<R> rowKeySet()\n", "    public abstract ImmutableMap<R, Map<C, V>> rowMap();\n", "    public boolean contains(@NullableDecl Object rowKey, @NullableDecl Object columnKey)\n", "    public boolean containsValue(@NullableDecl Object value)\n", "    public final void clear()\n", "    public final V put(R rowKey, C columnKey, V value)\n", "    public final void putAll(Table<? extends R, ? extends C, ? extends V> table)\n", "    public final V remove(Object rowKey, Object columnKey)\n", "    abstract SerializedForm createSerializedForm();\n", "    final Object writeReplace()\n"], "context": "/*\n * Copyright (C) 2009 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.base.MoreObjects;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.Serializable;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A {@link Table} whose contents will never change, with many other important properties detailed\n * at {@link ImmutableCollection}.\n *\n * <p>See the Guava User Guide article on <a href=\n * \"https://github.com/google/guava/wiki/ImmutableCollectionsExplained\"> immutable collections</a>.\n *\n * @author Gregory Kick\n * @since 11.0\n */\n@GwtCompatible\npublic abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>\n    implements Serializable\n{\n    /** Returns an empty immutable table. */\n    @SuppressWarnings(\"unchecked\")\n    public static <R, C, V> ImmutableTable<R, C, V> of()\n    {\n        return (ImmutableTable<R, C, V>) SparseImmutableTable.EMPTY;\n    }\n\n    /** Returns an immutable table containing a single cell. */\n\n    /**\n     * Returns an immutable copy of the provided table.\n     *\n     * <p>The {@link Table#cellSet()} iteration order of the provided table determines the iteration\n     * ordering of all views in the returned table. Note that some views of the original table and the\n     * copied table may have different iteration orders. For more control over the ordering, create a\n     * {@link Builder} and call {@link Builder#orderRowsBy}, {@link Builder#orderColumnsBy}, and\n     * {@link Builder#putAll}\n     *\n     * <p>Despite the method name, this method attempts to avoid actually copying the data when it is\n     * safe to do so. The exact circumstances under which a copy will or will not be performed are\n     * undocumented and subject to change.\n     */\n    public static <R, C, V> ImmutableTable<R, C, V> copyOf(\n        Table<? extends R, ? extends C, ? extends V> table)\n    {\n        if (table instanceof ImmutableTable)\n        {\n            @SuppressWarnings(\"unchecked\")\n            ImmutableTable<R, C, V> parameterizedTable = (ImmutableTable<R, C, V>) table;\n            return parameterizedTable;\n        }\n        else\n        {\n            return copyOf(table.cellSet());\n        }\n    }\n\n    private static <R, C, V> ImmutableTable<R, C, V> copyOf(\n        Iterable<? extends Cell<? extends R, ? extends C, ? extends V>> cells)\n    {\n        ImmutableTable.Builder<R, C, V> builder = ImmutableTable.builder();\n        for (Cell<? extends R, ? extends C, ? extends V> cell : cells)\n        {\n            builder.put(cell);\n        }\n        return builder.build();\n    }\n\n    /**\n     * Returns a new builder. The generated builder is equivalent to the builder created by the {@link\n     * Builder#Builder() ImmutableTable.Builder()} constructor.\n     */\n    public static <R, C, V> Builder<R, C, V> builder()\n    {\n        return new Builder<>();\n    }\n\n    /**\n     * Verifies that {@code rowKey}, {@code columnKey} and {@code value} are non-null, and returns a\n     * new entry with those values.\n     */\n    static <R, C, V> Cell<R, C, V> cellOf(R rowKey, C columnKey, V value)\n    {\n        return Tables.immutableCell(\n                   checkNotNull(rowKey, \"rowKey\"),\n                   checkNotNull(columnKey, \"columnKey\"),\n                   checkNotNull(value, \"value\"));\n    }\n\n    /**\n     * A builder for creating immutable table instances, especially {@code public static final} tables\n     * (\"constant tables\"). Example:\n     *\n     * <pre>{@code\n     * static final ImmutableTable<Integer, Character, String> SPREADSHEET =\n     *     new ImmutableTable.Builder<Integer, Character, String>()\n     *         .put(1, 'A', \"foo\")\n     *         .put(1, 'B', \"bar\")\n     *         .put(2, 'A', \"baz\")\n     *         .build();\n     * }</pre>\n     *\n     * <p>By default, the order in which cells are added to the builder determines the iteration\n     * ordering of all views in the returned table, with {@link #putAll} following the {@link\n     * Table#cellSet()} iteration order. However, if {@link #orderRowsBy} or {@link #orderColumnsBy}\n     * is called, the views are sorted by the supplied comparators.\n     *\n     * <p>For empty or single-cell immutable tables, {@link #of()} and {@link #of(Object, Object,\n     * Object)} are even more convenient.\n     *\n     * <p>Builder instances can be reused - it is safe to call {@link #build} multiple times to build\n     * multiple tables in series. Each table is a superset of the tables created before it.\n     *\n     * @since 11.0\n     */\n    public static final class Builder<R, C, V>\n    {\n        private final List<Cell<R, C, V>> cells = Lists.newArrayList();\n        @MonotonicNonNullDecl private Comparator<? super R> rowComparator;\n        @MonotonicNonNullDecl private Comparator<? super C> columnComparator;\n\n        /**\n         * Creates a new builder. The returned builder is equivalent to the builder generated by {@link\n         * ImmutableTable#builder}.\n         */\n        public Builder() {}\n\n        /** Specifies the ordering of the generated table's rows. */\n        @CanIgnoreReturnValue\n        public Builder<R, C, V> orderRowsBy(Comparator<? super R> rowComparator)\n        {\n            this.rowComparator = checkNotNull(rowComparator, \"rowComparator\");\n            return this;\n        }\n\n        /** Specifies the ordering of the generated table's columns. */\n        @CanIgnoreReturnValue\n        public Builder<R, C, V> orderColumnsBy(Comparator<? super C> columnComparator)\n        {\n            this.columnComparator = checkNotNull(columnComparator, \"columnComparator\");\n            return this;\n        }\n\n        /**\n         * Associates the ({@code rowKey}, {@code columnKey}) pair with {@code value} in the built\n         * table. Duplicate key pairs are not allowed and will cause {@link #build} to fail.\n         */\n        @CanIgnoreReturnValue\n        public Builder<R, C, V> put(R rowKey, C columnKey, V value)\n        {\n            cells.add(cellOf(rowKey, columnKey, value));\n            return this;\n        }\n\n        /**\n         * Adds the given {@code cell} to the table, making it immutable if necessary. Duplicate key\n         * pairs are not allowed and will cause {@link #build} to fail.\n         */\n        @CanIgnoreReturnValue\n        public Builder<R, C, V> put(Cell<? extends R, ? extends C, ? extends V> cell)\n        {\n            if (cell instanceof Tables.ImmutableCell)\n            {\n                checkNotNull(cell.getRowKey(), \"row\");\n                checkNotNull(cell.getColumnKey(), \"column\");\n                checkNotNull(cell.getValue(), \"value\");\n                @SuppressWarnings(\"unchecked\") // all supported methods are covariant\n                Cell<R, C, V> immutableCell = (Cell<R, C, V>) cell;\n                cells.add(immutableCell);\n            }\n            else\n            {\n                put(cell.getRowKey(), cell.getColumnKey(), cell.getValue());\n            }\n            return this;\n        }\n\n        /**\n         * Associates all of the given table's keys and values in the built table. Duplicate row key\n         * column key pairs are not allowed, and will cause {@link #build} to fail.\n         *\n         * @throws NullPointerException if any key or value in {@code table} is null\n         */\n        @CanIgnoreReturnValue\n        public Builder<R, C, V> putAll(Table<? extends R, ? extends C, ? extends V> table)\n        {\n            for (Cell<? extends R, ? extends C, ? extends V> cell : table.cellSet())\n            {\n                put(cell);\n            }\n            return this;\n        }\n\n        /**\n         * Returns a newly-created immutable table.\n         *\n         * @throws IllegalArgumentException if duplicate key pairs were added\n         */\n        public ImmutableTable<R, C, V> build()\n        {\n            int size = cells.size();\n            switch (size)\n            {\n            case 0:\n                return of();\n            case 1:\n                return new SingletonImmutableTable<>(Iterables.getOnlyElement(cells));\n            default:\n                return RegularImmutableTable.forCells(cells, rowComparator, columnComparator);\n            }\n        }\n    }\n\n    ImmutableTable() {}\n\n    @Override\n    public ImmutableSet<Cell<R, C, V>> cellSet()\n    {\n        return (ImmutableSet<Cell<R, C, V>>) super.cellSet();\n    }\n\n    @Override\n    abstract ImmutableSet<Cell<R, C, V>> createCellSet();\n\n    @Override\n    final UnmodifiableIterator<Cell<R, C, V>> cellIterator()\n    {\n        throw new AssertionError(\"should never be called\");\n    }\n\n    @Override\n    public ImmutableCollection<V> values()\n    {\n        return (ImmutableCollection<V>) super.values();\n    }\n\n    @Override\n    abstract ImmutableCollection<V> createValues();\n\n    @Override\n    final Iterator<V> valuesIterator()\n    {\n        throw new AssertionError(\"should never be called\");\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @throws NullPointerException if {@code columnKey} is {@code null}\n     */\n    @Override\n    public ImmutableMap<R, V> column(C columnKey)\n    {\n        checkNotNull(columnKey, \"columnKey\");\n        return MoreObjects.firstNonNull(\n                   (ImmutableMap<R, V>) columnMap().get(columnKey), ImmutableMap.<R, V>of());\n    }\n\n    @Override\n    public ImmutableSet<C> columnKeySet()\n    {\n        return columnMap().keySet();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>The value {@code Map<R, V>} instances in the returned map are {@link ImmutableMap} instances\n     * as well.\n     */\n    @Override\n    public abstract ImmutableMap<C, Map<R, V>> columnMap();\n\n    /**\n     * {@inheritDoc}\n     *\n     * @throws NullPointerException if {@code rowKey} is {@code null}\n     */\n    @Override\n    public ImmutableMap<C, V> row(R rowKey)\n    {\n        checkNotNull(rowKey, \"rowKey\");\n        return MoreObjects.firstNonNull(\n                   (ImmutableMap<C, V>) rowMap().get(rowKey), ImmutableMap.<C, V>of());\n    }\n\n    @Override\n    public ImmutableSet<R> rowKeySet()\n    {\n        return rowMap().keySet();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>The value {@code Map<C, V>} instances in the returned map are {@link ImmutableMap} instances\n     * as well.\n     */\n    @Override\n    public abstract ImmutableMap<R, Map<C, V>> rowMap();\n\n    @Override\n    public boolean contains(@NullableDecl Object rowKey, @NullableDecl Object columnKey)\n    {\n        return get(rowKey, columnKey) != null;\n    }\n\n    @Override\n    public boolean containsValue(@NullableDecl Object value)\n    {\n        return values().contains(value);\n    }\n\n    /**\n     * Guaranteed to throw an exception and leave the table unmodified.\n     *\n     * @throws UnsupportedOperationException always\n     * @deprecated Unsupported operation.\n     */\n    @Deprecated\n    @Override\n    public final void clear()\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Guaranteed to throw an exception and leave the table unmodified.\n     *\n     * @throws UnsupportedOperationException always\n     * @deprecated Unsupported operation.\n     */\n    @CanIgnoreReturnValue\n    @Deprecated\n    @Override\n    public final V put(R rowKey, C columnKey, V value)\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Guaranteed to throw an exception and leave the table unmodified.\n     *\n     * @throws UnsupportedOperationException always\n     * @deprecated Unsupported operation.\n     */\n    @Deprecated\n    @Override\n    public final void putAll(Table<? extends R, ? extends C, ? extends V> table)\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Guaranteed to throw an exception and leave the table unmodified.\n     *\n     * @throws UnsupportedOperationException always\n     * @deprecated Unsupported operation.\n     */\n    @CanIgnoreReturnValue\n    @Deprecated\n    @Override\n    public final V remove(Object rowKey, Object columnKey)\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    /** Creates the common serialized form for this table. */\n    abstract SerializedForm createSerializedForm();\n\n    /**\n     * Serialized type for all ImmutableTable instances. It captures the logical contents and\n     * preserves iteration order of all views.\n     */\n    static final class SerializedForm implements Serializable\n    {\n        private final Object[] rowKeys;\n        private final Object[] columnKeys;\n\n        private final Object[] cellValues;\n        private final int[] cellRowIndices;\n        private final int[] cellColumnIndices;\n\n        private SerializedForm(\n            Object[] rowKeys,\n            Object[] columnKeys,\n            Object[] cellValues,\n            int[] cellRowIndices,\n            int[] cellColumnIndices)\n        {\n            this.rowKeys = rowKeys;\n            this.columnKeys = columnKeys;\n            this.cellValues = cellValues;\n            this.cellRowIndices = cellRowIndices;\n            this.cellColumnIndices = cellColumnIndices;\n        }\n\n        static SerializedForm create(\n            ImmutableTable<?, ?, ?> table, int[] cellRowIndices, int[] cellColumnIndices)\n        {\n            return new SerializedForm(\n                       table.rowKeySet().toArray(),\n                       table.columnKeySet().toArray(),\n                       table.values().toArray(),\n                       cellRowIndices,\n                       cellColumnIndices);\n        }\n\n        Object readResolve()\n        {\n            if (cellValues.length == 0)\n            {\n                return of();\n            }\n            if (cellValues.length == 1)\n            {\n                return of(rowKeys[0], columnKeys[0], cellValues[0]);\n            }\n            ImmutableList.Builder<Cell<Object, Object, Object>> cellListBuilder =\n                new ImmutableList.Builder<>(cellValues.length);\n            for (int i = 0; i < cellValues.length; i++)\n            {\n                cellListBuilder.add(\n                    cellOf(rowKeys[cellRowIndices[i]], columnKeys[cellColumnIndices[i]], cellValues[i]));\n            }\n            return RegularImmutableTable.forOrderedComponents(\n                       cellListBuilder.build(), ImmutableSet.copyOf(rowKeys), ImmutableSet.copyOf(columnKeys));\n        }\n\n        private static final long serialVersionUID = 0;\n    }\n\n    final Object writeReplace()\n    {\n        return createSerializedForm();\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/ImmutableTable.java", "func_name": "ImmutableTable.copyOf", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns an immutable copy of the provided table.\n\n<p>The {@link Table#cellSet()} iteration order of the provided table determines the iteration\nordering of all views in the returned table. Note that some views of the original table and the\ncopied table may have different iteration orders. For more control over the ordering, create a\n{@link Builder} and call {@link Builder#orderRowsBy}, {@link Builder#orderColumnsBy}, and\n{@link Builder#putAll}\n\n<p>Despite the method name, this method attempts to avoid actually copying the data when it is\nsafe to do so. The exact circumstances under which a copy will or will not be performed are\nundocumented and subject to change.", "docstring_tokens": ["Returns", "an", "immutable", "copy", "of", "the", "provided", "table", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/ImmutableTable.java#L69-L78", "partition": "valid", "up_fun_num": 4, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.base.MoreObjects;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.io.Serializable;", "import java.util.Comparator;", "import java.util.Iterator;", "import java.util.List;", "import java.util.Map;", "import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>\n", "    public static <R, C, V> ImmutableTable<R, C, V> of()\n", "    public static <R, C, V> ImmutableTable<R, C, V> of(R rowKey, C columnKey, V value)\n", "    private static <R, C, V> ImmutableTable<R, C, V> copyOf(\n", "    public static <R, C, V> Builder<R, C, V> builder()\n", "    static <R, C, V> Cell<R, C, V> cellOf(R rowKey, C columnKey, V value)\n", "    public ImmutableSet<Cell<R, C, V>> cellSet()\n", "    abstract ImmutableSet<Cell<R, C, V>> createCellSet();\n", "    final UnmodifiableIterator<Cell<R, C, V>> cellIterator()\n", "    public ImmutableCollection<V> values()\n", "    abstract ImmutableCollection<V> createValues();\n", "    final Iterator<V> valuesIterator()\n", "    public ImmutableMap<R, V> column(C columnKey)\n", "    public ImmutableSet<C> columnKeySet()\n", "    public abstract ImmutableMap<C, Map<R, V>> columnMap();\n", "    public ImmutableMap<C, V> row(R rowKey)\n", "    public ImmutableSet<R> rowKeySet()\n", "    public abstract ImmutableMap<R, Map<C, V>> rowMap();\n", "    public boolean contains(@NullableDecl Object rowKey, @NullableDecl Object columnKey)\n", "    public boolean containsValue(@NullableDecl Object value)\n", "    public final void clear()\n", "    public final V put(R rowKey, C columnKey, V value)\n", "    public final void putAll(Table<? extends R, ? extends C, ? extends V> table)\n", "    public final V remove(Object rowKey, Object columnKey)\n", "    abstract SerializedForm createSerializedForm();\n", "    final Object writeReplace()\n"], "context": "/*\n * Copyright (C) 2009 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.base.MoreObjects;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.Serializable;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A {@link Table} whose contents will never change, with many other important properties detailed\n * at {@link ImmutableCollection}.\n *\n * <p>See the Guava User Guide article on <a href=\n * \"https://github.com/google/guava/wiki/ImmutableCollectionsExplained\"> immutable collections</a>.\n *\n * @author Gregory Kick\n * @since 11.0\n */\n@GwtCompatible\npublic abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>\n    implements Serializable\n{\n    /** Returns an empty immutable table. */\n    @SuppressWarnings(\"unchecked\")\n    public static <R, C, V> ImmutableTable<R, C, V> of()\n    {\n        return (ImmutableTable<R, C, V>) SparseImmutableTable.EMPTY;\n    }\n\n    /** Returns an immutable table containing a single cell. */\n    public static <R, C, V> ImmutableTable<R, C, V> of(R rowKey, C columnKey, V value)\n    {\n        return new SingletonImmutableTable<>(rowKey, columnKey, value);\n    }\n\n    /**\n     * Returns an immutable copy of the provided table.\n     *\n     * <p>The {@link Table#cellSet()} iteration order of the provided table determines the iteration\n     * ordering of all views in the returned table. Note that some views of the original table and the\n     * copied table may have different iteration orders. For more control over the ordering, create a\n     * {@link Builder} and call {@link Builder#orderRowsBy}, {@link Builder#orderColumnsBy}, and\n     * {@link Builder#putAll}\n     *\n     * <p>Despite the method name, this method attempts to avoid actually copying the data when it is\n     * safe to do so. The exact circumstances under which a copy will or will not be performed are\n     * undocumented and subject to change.\n     */\n\n    private static <R, C, V> ImmutableTable<R, C, V> copyOf(\n        Iterable<? extends Cell<? extends R, ? extends C, ? extends V>> cells)\n    {\n        ImmutableTable.Builder<R, C, V> builder = ImmutableTable.builder();\n        for (Cell<? extends R, ? extends C, ? extends V> cell : cells)\n        {\n            builder.put(cell);\n        }\n        return builder.build();\n    }\n\n    /**\n     * Returns a new builder. The generated builder is equivalent to the builder created by the {@link\n     * Builder#Builder() ImmutableTable.Builder()} constructor.\n     */\n    public static <R, C, V> Builder<R, C, V> builder()\n    {\n        return new Builder<>();\n    }\n\n    /**\n     * Verifies that {@code rowKey}, {@code columnKey} and {@code value} are non-null, and returns a\n     * new entry with those values.\n     */\n    static <R, C, V> Cell<R, C, V> cellOf(R rowKey, C columnKey, V value)\n    {\n        return Tables.immutableCell(\n                   checkNotNull(rowKey, \"rowKey\"),\n                   checkNotNull(columnKey, \"columnKey\"),\n                   checkNotNull(value, \"value\"));\n    }\n\n    /**\n     * A builder for creating immutable table instances, especially {@code public static final} tables\n     * (\"constant tables\"). Example:\n     *\n     * <pre>{@code\n     * static final ImmutableTable<Integer, Character, String> SPREADSHEET =\n     *     new ImmutableTable.Builder<Integer, Character, String>()\n     *         .put(1, 'A', \"foo\")\n     *         .put(1, 'B', \"bar\")\n     *         .put(2, 'A', \"baz\")\n     *         .build();\n     * }</pre>\n     *\n     * <p>By default, the order in which cells are added to the builder determines the iteration\n     * ordering of all views in the returned table, with {@link #putAll} following the {@link\n     * Table#cellSet()} iteration order. However, if {@link #orderRowsBy} or {@link #orderColumnsBy}\n     * is called, the views are sorted by the supplied comparators.\n     *\n     * <p>For empty or single-cell immutable tables, {@link #of()} and {@link #of(Object, Object,\n     * Object)} are even more convenient.\n     *\n     * <p>Builder instances can be reused - it is safe to call {@link #build} multiple times to build\n     * multiple tables in series. Each table is a superset of the tables created before it.\n     *\n     * @since 11.0\n     */\n    public static final class Builder<R, C, V>\n    {\n        private final List<Cell<R, C, V>> cells = Lists.newArrayList();\n        @MonotonicNonNullDecl private Comparator<? super R> rowComparator;\n        @MonotonicNonNullDecl private Comparator<? super C> columnComparator;\n\n        /**\n         * Creates a new builder. The returned builder is equivalent to the builder generated by {@link\n         * ImmutableTable#builder}.\n         */\n        public Builder() {}\n\n        /** Specifies the ordering of the generated table's rows. */\n        @CanIgnoreReturnValue\n        public Builder<R, C, V> orderRowsBy(Comparator<? super R> rowComparator)\n        {\n            this.rowComparator = checkNotNull(rowComparator, \"rowComparator\");\n            return this;\n        }\n\n        /** Specifies the ordering of the generated table's columns. */\n        @CanIgnoreReturnValue\n        public Builder<R, C, V> orderColumnsBy(Comparator<? super C> columnComparator)\n        {\n            this.columnComparator = checkNotNull(columnComparator, \"columnComparator\");\n            return this;\n        }\n\n        /**\n         * Associates the ({@code rowKey}, {@code columnKey}) pair with {@code value} in the built\n         * table. Duplicate key pairs are not allowed and will cause {@link #build} to fail.\n         */\n        @CanIgnoreReturnValue\n        public Builder<R, C, V> put(R rowKey, C columnKey, V value)\n        {\n            cells.add(cellOf(rowKey, columnKey, value));\n            return this;\n        }\n\n        /**\n         * Adds the given {@code cell} to the table, making it immutable if necessary. Duplicate key\n         * pairs are not allowed and will cause {@link #build} to fail.\n         */\n        @CanIgnoreReturnValue\n        public Builder<R, C, V> put(Cell<? extends R, ? extends C, ? extends V> cell)\n        {\n            if (cell instanceof Tables.ImmutableCell)\n            {\n                checkNotNull(cell.getRowKey(), \"row\");\n                checkNotNull(cell.getColumnKey(), \"column\");\n                checkNotNull(cell.getValue(), \"value\");\n                @SuppressWarnings(\"unchecked\") // all supported methods are covariant\n                Cell<R, C, V> immutableCell = (Cell<R, C, V>) cell;\n                cells.add(immutableCell);\n            }\n            else\n            {\n                put(cell.getRowKey(), cell.getColumnKey(), cell.getValue());\n            }\n            return this;\n        }\n\n        /**\n         * Associates all of the given table's keys and values in the built table. Duplicate row key\n         * column key pairs are not allowed, and will cause {@link #build} to fail.\n         *\n         * @throws NullPointerException if any key or value in {@code table} is null\n         */\n        @CanIgnoreReturnValue\n        public Builder<R, C, V> putAll(Table<? extends R, ? extends C, ? extends V> table)\n        {\n            for (Cell<? extends R, ? extends C, ? extends V> cell : table.cellSet())\n            {\n                put(cell);\n            }\n            return this;\n        }\n\n        /**\n         * Returns a newly-created immutable table.\n         *\n         * @throws IllegalArgumentException if duplicate key pairs were added\n         */\n        public ImmutableTable<R, C, V> build()\n        {\n            int size = cells.size();\n            switch (size)\n            {\n            case 0:\n                return of();\n            case 1:\n                return new SingletonImmutableTable<>(Iterables.getOnlyElement(cells));\n            default:\n                return RegularImmutableTable.forCells(cells, rowComparator, columnComparator);\n            }\n        }\n    }\n\n    ImmutableTable() {}\n\n    @Override\n    public ImmutableSet<Cell<R, C, V>> cellSet()\n    {\n        return (ImmutableSet<Cell<R, C, V>>) super.cellSet();\n    }\n\n    @Override\n    abstract ImmutableSet<Cell<R, C, V>> createCellSet();\n\n    @Override\n    final UnmodifiableIterator<Cell<R, C, V>> cellIterator()\n    {\n        throw new AssertionError(\"should never be called\");\n    }\n\n    @Override\n    public ImmutableCollection<V> values()\n    {\n        return (ImmutableCollection<V>) super.values();\n    }\n\n    @Override\n    abstract ImmutableCollection<V> createValues();\n\n    @Override\n    final Iterator<V> valuesIterator()\n    {\n        throw new AssertionError(\"should never be called\");\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @throws NullPointerException if {@code columnKey} is {@code null}\n     */\n    @Override\n    public ImmutableMap<R, V> column(C columnKey)\n    {\n        checkNotNull(columnKey, \"columnKey\");\n        return MoreObjects.firstNonNull(\n                   (ImmutableMap<R, V>) columnMap().get(columnKey), ImmutableMap.<R, V>of());\n    }\n\n    @Override\n    public ImmutableSet<C> columnKeySet()\n    {\n        return columnMap().keySet();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>The value {@code Map<R, V>} instances in the returned map are {@link ImmutableMap} instances\n     * as well.\n     */\n    @Override\n    public abstract ImmutableMap<C, Map<R, V>> columnMap();\n\n    /**\n     * {@inheritDoc}\n     *\n     * @throws NullPointerException if {@code rowKey} is {@code null}\n     */\n    @Override\n    public ImmutableMap<C, V> row(R rowKey)\n    {\n        checkNotNull(rowKey, \"rowKey\");\n        return MoreObjects.firstNonNull(\n                   (ImmutableMap<C, V>) rowMap().get(rowKey), ImmutableMap.<C, V>of());\n    }\n\n    @Override\n    public ImmutableSet<R> rowKeySet()\n    {\n        return rowMap().keySet();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>The value {@code Map<C, V>} instances in the returned map are {@link ImmutableMap} instances\n     * as well.\n     */\n    @Override\n    public abstract ImmutableMap<R, Map<C, V>> rowMap();\n\n    @Override\n    public boolean contains(@NullableDecl Object rowKey, @NullableDecl Object columnKey)\n    {\n        return get(rowKey, columnKey) != null;\n    }\n\n    @Override\n    public boolean containsValue(@NullableDecl Object value)\n    {\n        return values().contains(value);\n    }\n\n    /**\n     * Guaranteed to throw an exception and leave the table unmodified.\n     *\n     * @throws UnsupportedOperationException always\n     * @deprecated Unsupported operation.\n     */\n    @Deprecated\n    @Override\n    public final void clear()\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Guaranteed to throw an exception and leave the table unmodified.\n     *\n     * @throws UnsupportedOperationException always\n     * @deprecated Unsupported operation.\n     */\n    @CanIgnoreReturnValue\n    @Deprecated\n    @Override\n    public final V put(R rowKey, C columnKey, V value)\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Guaranteed to throw an exception and leave the table unmodified.\n     *\n     * @throws UnsupportedOperationException always\n     * @deprecated Unsupported operation.\n     */\n    @Deprecated\n    @Override\n    public final void putAll(Table<? extends R, ? extends C, ? extends V> table)\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Guaranteed to throw an exception and leave the table unmodified.\n     *\n     * @throws UnsupportedOperationException always\n     * @deprecated Unsupported operation.\n     */\n    @CanIgnoreReturnValue\n    @Deprecated\n    @Override\n    public final V remove(Object rowKey, Object columnKey)\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    /** Creates the common serialized form for this table. */\n    abstract SerializedForm createSerializedForm();\n\n    /**\n     * Serialized type for all ImmutableTable instances. It captures the logical contents and\n     * preserves iteration order of all views.\n     */\n    static final class SerializedForm implements Serializable\n    {\n        private final Object[] rowKeys;\n        private final Object[] columnKeys;\n\n        private final Object[] cellValues;\n        private final int[] cellRowIndices;\n        private final int[] cellColumnIndices;\n\n        private SerializedForm(\n            Object[] rowKeys,\n            Object[] columnKeys,\n            Object[] cellValues,\n            int[] cellRowIndices,\n            int[] cellColumnIndices)\n        {\n            this.rowKeys = rowKeys;\n            this.columnKeys = columnKeys;\n            this.cellValues = cellValues;\n            this.cellRowIndices = cellRowIndices;\n            this.cellColumnIndices = cellColumnIndices;\n        }\n\n        static SerializedForm create(\n            ImmutableTable<?, ?, ?> table, int[] cellRowIndices, int[] cellColumnIndices)\n        {\n            return new SerializedForm(\n                       table.rowKeySet().toArray(),\n                       table.columnKeySet().toArray(),\n                       table.values().toArray(),\n                       cellRowIndices,\n                       cellColumnIndices);\n        }\n\n        Object readResolve()\n        {\n            if (cellValues.length == 0)\n            {\n                return of();\n            }\n            if (cellValues.length == 1)\n            {\n                return of(rowKeys[0], columnKeys[0], cellValues[0]);\n            }\n            ImmutableList.Builder<Cell<Object, Object, Object>> cellListBuilder =\n                new ImmutableList.Builder<>(cellValues.length);\n            for (int i = 0; i < cellValues.length; i++)\n            {\n                cellListBuilder.add(\n                    cellOf(rowKeys[cellRowIndices[i]], columnKeys[cellColumnIndices[i]], cellValues[i]));\n            }\n            return RegularImmutableTable.forOrderedComponents(\n                       cellListBuilder.build(), ImmutableSet.copyOf(rowKeys), ImmutableSet.copyOf(columnKeys));\n        }\n\n        private static final long serialVersionUID = 0;\n    }\n\n    final Object writeReplace()\n    {\n        return createSerializedForm();\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/base/Converter.java", "func_name": "Converter.identity", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns a serializable converter that always converts or reverses an object to itself.", "docstring_tokens": ["Returns", "a", "serializable", "converter", "that", "always", "converts", "or", "reverses", "an", "object", "to", "itself", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/base/Converter.java#L477-L480", "partition": "valid", "up_fun_num": 13, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.GwtCompatible;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import com.google.errorprone.annotations.ForOverride;", "import com.google.errorprone.annotations.concurrent.LazyInit;", "import java.io.Serializable;", "import java.util.Iterator;", "import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public abstract class Converter<A, B> implements Function<A, B>\n", "    protected abstract B doForward(A a);\n", "    protected abstract A doBackward(B b);\n", "    public final B convert(@NullableDecl A a)\n", "    B correctedDoForward(@NullableDecl A a)\n", "    A correctedDoBackward(@NullableDecl B b)\n", "    public Iterable<B> convertAll(final Iterable<? extends A> fromIterable)\n", "    public Converter<B, A> reverse()\n", "    public final <C> Converter<A, C> andThen(Converter<B, C> secondConverter)\n", "    <C> Converter<A, C> doAndThen(Converter<B, C> secondConverter)\n", "    public final B apply(@NullableDecl A a)\n", "    public boolean equals(@NullableDecl Object object)\n", "    public static <A, B> Converter<A, B> from(\n"], "context": "/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.base;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.google.errorprone.annotations.ForOverride;\nimport com.google.errorprone.annotations.concurrent.LazyInit;\nimport java.io.Serializable;\nimport java.util.Iterator;\nimport org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * A function from {@code A} to {@code B} with an associated <i>reverse</i> function from {@code B}\n * to {@code A}; used for converting back and forth between <i>different representations of the same\n * information</i>.\n *\n * <h3>Invertibility</h3>\n *\n * <p>The reverse operation <b>may</b> be a strict <i>inverse</i> (meaning that {@code\n * converter.reverse().convert(converter.convert(a)).equals(a)} is always true). However, it is very\n * common (perhaps <i>more</i> common) for round-trip conversion to be <i>lossy</i>. Consider an\n * example round-trip using {@link com.google.common.primitives.Doubles#stringConverter}:\n *\n * <ol>\n *   <li>{@code stringConverter().convert(\"1.00\")} returns the {@code Double} value {@code 1.0}\n *   <li>{@code stringConverter().reverse().convert(1.0)} returns the string {@code \"1.0\"} --\n *       <i>not</i> the same string ({@code \"1.00\"}) we started with\n * </ol>\n *\n * <p>Note that it should still be the case that the round-tripped and original objects are\n * <i>similar</i>.\n *\n * <h3>Nullability</h3>\n *\n * <p>A converter always converts {@code null} to {@code null} and non-null references to non-null\n * references. It would not make sense to consider {@code null} and a non-null reference to be\n * \"different representations of the same information\", since one is distinguishable from\n * <i>missing</i> information and the other is not. The {@link #convert} method handles this null\n * behavior for all converters; implementations of {@link #doForward} and {@link #doBackward} are\n * guaranteed to never be passed {@code null}, and must never return {@code null}.\n *\n *\n * <h3>Common ways to use</h3>\n *\n * <p>Getting a converter:\n *\n * <ul>\n *   <li>Use a provided converter implementation, such as {@link Enums#stringConverter}, {@link\n *       com.google.common.primitives.Ints#stringConverter Ints.stringConverter} or the {@linkplain\n *       #reverse reverse} views of these.\n *   <li>Convert between specific preset values using {@link\n *       com.google.common.collect.Maps#asConverter Maps.asConverter}. For example, use this to\n *       create a \"fake\" converter for a unit test. It is unnecessary (and confusing) to <i>mock</i>\n *       the {@code Converter} type using a mocking framework.\n *   <li>Extend this class and implement its {@link #doForward} and {@link #doBackward} methods.\n *   <li><b>Java 8 users:</b> you may prefer to pass two lambda expressions or method references to\n *       the {@link #from from} factory method.\n * </ul>\n *\n * <p>Using a converter:\n *\n * <ul>\n *   <li>Convert one instance in the \"forward\" direction using {@code converter.convert(a)}.\n *   <li>Convert multiple instances \"forward\" using {@code converter.convertAll(as)}.\n *   <li>Convert in the \"backward\" direction using {@code converter.reverse().convert(b)} or {@code\n *       converter.reverse().convertAll(bs)}.\n *   <li>Use {@code converter} or {@code converter.reverse()} anywhere a {@link\n *       java.util.function.Function} is accepted (for example {@link java.util.stream.Stream#map\n *       Stream.map}).\n *   <li><b>Do not</b> call {@link #doForward} or {@link #doBackward} directly; these exist only to\n *       be overridden.\n * </ul>\n *\n * <h3>Example</h3>\n *\n * <pre>\n *   return new Converter&lt;Integer, String&gt;() {\n *     protected String doForward(Integer i) {\n *       return Integer.toHexString(i);\n *     }\n *\n *     protected Integer doBackward(String s) {\n *       return parseUnsignedInt(s, 16);\n *     }\n *   };</pre>\n *\n * <p>An alternative using Java 8:\n *\n * <pre>{@code\n * return Converter.from(\n *     Integer::toHexString,\n *     s -> parseUnsignedInt(s, 16));\n * }</pre>\n *\n * @author Mike Ward\n * @author Kurt Alfred Kluever\n * @author Gregory Kick\n * @since 16.0\n */\n@GwtCompatible\npublic abstract class Converter<A, B> implements Function<A, B>\n{\n    private final boolean handleNullAutomatically;\n\n    // We lazily cache the reverse view to avoid allocating on every call to reverse().\n    @LazyInit @MonotonicNonNullDecl private transient Converter<B, A> reverse;\n\n    /** Constructor for use by subclasses. */\n    protected Converter()\n    {\n        this(true);\n    }\n\n    /** Constructor used only by {@code LegacyConverter} to suspend automatic null-handling. */\n    Converter(boolean handleNullAutomatically)\n    {\n        this.handleNullAutomatically = handleNullAutomatically;\n    }\n\n    // SPI methods (what subclasses must implement)\n\n    /**\n     * Returns a representation of {@code a} as an instance of type {@code B}. If {@code a} cannot be\n     * converted, an unchecked exception (such as {@link IllegalArgumentException}) should be thrown.\n     *\n     * @param a the instance to convert; will never be null\n     * @return the converted instance; <b>must not</b> be null\n     */\n    @ForOverride\n    protected abstract B doForward(A a);\n\n    /**\n     * Returns a representation of {@code b} as an instance of type {@code A}. If {@code b} cannot be\n     * converted, an unchecked exception (such as {@link IllegalArgumentException}) should be thrown.\n     *\n     * @param b the instance to convert; will never be null\n     * @return the converted instance; <b>must not</b> be null\n     * @throws UnsupportedOperationException if backward conversion is not implemented; this should be\n     *     very rare. Note that if backward conversion is not only unimplemented but\n     *     unimplement<i>able</i> (for example, consider a {@code Converter<Chicken, ChickenNugget>}),\n     *     then this is not logically a {@code Converter} at all, and should just implement {@link\n     *     Function}.\n     */\n    @ForOverride\n    protected abstract A doBackward(B b);\n\n    // API (consumer-side) methods\n\n    /**\n     * Returns a representation of {@code a} as an instance of type {@code B}.\n     *\n     * @return the converted value; is null <i>if and only if</i> {@code a} is null\n     */\n    @CanIgnoreReturnValue\n    @NullableDecl\n    public final B convert(@NullableDecl A a)\n    {\n        return correctedDoForward(a);\n    }\n\n    @NullableDecl\n    B correctedDoForward(@NullableDecl A a)\n    {\n        if (handleNullAutomatically)\n        {\n            // TODO(kevinb): we shouldn't be checking for a null result at runtime. Assert?\n            return a == null ? null : checkNotNull(doForward(a));\n        }\n        else\n        {\n            return doForward(a);\n        }\n    }\n\n    @NullableDecl\n    A correctedDoBackward(@NullableDecl B b)\n    {\n        if (handleNullAutomatically)\n        {\n            // TODO(kevinb): we shouldn't be checking for a null result at runtime. Assert?\n            return b == null ? null : checkNotNull(doBackward(b));\n        }\n        else\n        {\n            return doBackward(b);\n        }\n    }\n\n    /**\n     * Returns an iterable that applies {@code convert} to each element of {@code fromIterable}. The\n     * conversion is done lazily.\n     *\n     * <p>The returned iterable's iterator supports {@code remove()} if the input iterator does. After\n     * a successful {@code remove()} call, {@code fromIterable} no longer contains the corresponding\n     * element.\n     */\n    @CanIgnoreReturnValue\n    public Iterable<B> convertAll(final Iterable<? extends A> fromIterable)\n    {\n        checkNotNull(fromIterable, \"fromIterable\");\n        return new Iterable<B>()\n        {\n            @Override\n            public Iterator<B> iterator()\n            {\n                return new Iterator<B>()\n                {\n                    private final Iterator<? extends A> fromIterator = fromIterable.iterator();\n\n                    @Override\n                    public boolean hasNext()\n                    {\n                        return fromIterator.hasNext();\n                    }\n\n                    @Override\n                    public B next()\n                    {\n                        return convert(fromIterator.next());\n                    }\n\n                    @Override\n                    public void remove()\n                    {\n                        fromIterator.remove();\n                    }\n                };\n            }\n        };\n    }\n\n    /**\n     * Returns the reversed view of this converter, which converts {@code this.convert(a)} back to a\n     * value roughly equivalent to {@code a}.\n     *\n     * <p>The returned converter is serializable if {@code this} converter is.\n     *\n     * <p><b>Note:</b> you should not override this method. It is non-final for legacy reasons.\n     */\n    @CanIgnoreReturnValue\n    public Converter<B, A> reverse()\n    {\n        Converter<B, A> result = reverse;\n        return (result == null) ? reverse = new ReverseConverter<>(this) : result;\n    }\n\n    private static final class ReverseConverter<A, B> extends Converter<B, A>\n        implements Serializable\n    {\n        final Converter<A, B> original;\n\n        ReverseConverter(Converter<A, B> original)\n        {\n            this.original = original;\n        }\n\n        /*\n         * These gymnastics are a little confusing. Basically this class has neither legacy nor\n         * non-legacy behavior; it just needs to let the behavior of the backing converter shine\n         * through. So, we override the correctedDo* methods, after which the do* methods should never\n         * be reached.\n         */\n\n        @Override\n        protected A doForward(B b)\n        {\n            throw new AssertionError();\n        }\n\n        @Override\n        protected B doBackward(A a)\n        {\n            throw new AssertionError();\n        }\n\n        @Override\n        @NullableDecl\n        A correctedDoForward(@NullableDecl B b)\n        {\n            return original.correctedDoBackward(b);\n        }\n\n        @Override\n        @NullableDecl\n        B correctedDoBackward(@NullableDecl A a)\n        {\n            return original.correctedDoForward(a);\n        }\n\n        @Override\n        public Converter<A, B> reverse()\n        {\n            return original;\n        }\n\n        @Override\n        public boolean equals(@NullableDecl Object object)\n        {\n            if (object instanceof ReverseConverter)\n            {\n                ReverseConverter<?, ?> that = (ReverseConverter<?, ?>) object;\n                return this.original.equals(that.original);\n            }\n            return false;\n        }\n\n        @Override\n        public int hashCode()\n        {\n            return ~original.hashCode();\n        }\n\n        @Override\n        public String toString()\n        {\n            return original + \".reverse()\";\n        }\n\n        private static final long serialVersionUID = 0L;\n    }\n\n    /**\n     * Returns a converter whose {@code convert} method applies {@code secondConverter} to the result\n     * of this converter. Its {@code reverse} method applies the converters in reverse order.\n     *\n     * <p>The returned converter is serializable if {@code this} converter and {@code secondConverter}\n     * are.\n     */\n    public final <C> Converter<A, C> andThen(Converter<B, C> secondConverter)\n    {\n        return doAndThen(secondConverter);\n    }\n\n    /** Package-private non-final implementation of andThen() so only we can override it. */\n    <C> Converter<A, C> doAndThen(Converter<B, C> secondConverter)\n    {\n        return new ConverterComposition<>(this, checkNotNull(secondConverter));\n    }\n\n    private static final class ConverterComposition<A, B, C> extends Converter<A, C>\n        implements Serializable\n    {\n        final Converter<A, B> first;\n        final Converter<B, C> second;\n\n        ConverterComposition(Converter<A, B> first, Converter<B, C> second)\n        {\n            this.first = first;\n            this.second = second;\n        }\n\n        /*\n         * These gymnastics are a little confusing. Basically this class has neither legacy nor\n         * non-legacy behavior; it just needs to let the behaviors of the backing converters shine\n         * through (which might even differ from each other!). So, we override the correctedDo* methods,\n         * after which the do* methods should never be reached.\n         */\n\n        @Override\n        protected C doForward(A a)\n        {\n            throw new AssertionError();\n        }\n\n        @Override\n        protected A doBackward(C c)\n        {\n            throw new AssertionError();\n        }\n\n        @Override\n        @NullableDecl\n        C correctedDoForward(@NullableDecl A a)\n        {\n            return second.correctedDoForward(first.correctedDoForward(a));\n        }\n\n        @Override\n        @NullableDecl\n        A correctedDoBackward(@NullableDecl C c)\n        {\n            return first.correctedDoBackward(second.correctedDoBackward(c));\n        }\n\n        @Override\n        public boolean equals(@NullableDecl Object object)\n        {\n            if (object instanceof ConverterComposition)\n            {\n                ConverterComposition<?, ?, ?> that = (ConverterComposition<?, ?, ?>) object;\n                return this.first.equals(that.first) && this.second.equals(that.second);\n            }\n            return false;\n        }\n\n        @Override\n        public int hashCode()\n        {\n            return 31 * first.hashCode() + second.hashCode();\n        }\n\n        @Override\n        public String toString()\n        {\n            return first + \".andThen(\" + second + \")\";\n        }\n\n        private static final long serialVersionUID = 0L;\n    }\n\n    /**\n     * @deprecated Provided to satisfy the {@code Function} interface; use {@link #convert} instead.\n     */\n    @Deprecated\n    @Override\n    @CanIgnoreReturnValue\n    @NullableDecl\n    public final B apply(@NullableDecl A a)\n    {\n        return convert(a);\n    }\n\n    /**\n     * Indicates whether another object is equal to this converter.\n     *\n     * <p>Most implementations will have no reason to override the behavior of {@link Object#equals}.\n     * However, an implementation may also choose to return {@code true} whenever {@code object} is a\n     * {@link Converter} that it considers <i>interchangeable</i> with this one. \"Interchangeable\"\n     * <i>typically</i> means that {@code Objects.equal(this.convert(a), that.convert(a))} is true for\n     * all {@code a} of type {@code A} (and similarly for {@code reverse}). Note that a {@code false}\n     * result from this method does not imply that the converters are known <i>not</i> to be\n     * interchangeable.\n     */\n    @Override\n    public boolean equals(@NullableDecl Object object)\n    {\n        return super.equals(object);\n    }\n\n    // Static converters\n\n    /**\n     * Returns a converter based on separate forward and backward functions. This is useful if the\n     * function instances already exist, or so that you can supply lambda expressions. If those\n     * circumstances don't apply, you probably don't need to use this; subclass {@code Converter} and\n     * implement its {@link #doForward} and {@link #doBackward} methods directly.\n     *\n     * <p>These functions will never be passed {@code null} and must not under any circumstances\n     * return {@code null}. If a value cannot be converted, the function should throw an unchecked\n     * exception (typically, but not necessarily, {@link IllegalArgumentException}).\n     *\n     * <p>The returned converter is serializable if both provided functions are.\n     *\n     * @since 17.0\n     */\n    public static <A, B> Converter<A, B> from(\n        Function<? super A, ? extends B> forwardFunction,\n        Function<? super B, ? extends A> backwardFunction)\n    {\n        return new FunctionBasedConverter<>(forwardFunction, backwardFunction);\n    }\n\n    private static final class FunctionBasedConverter<A, B> extends Converter<A, B>\n        implements Serializable\n    {\n        private final Function<? super A, ? extends B> forwardFunction;\n        private final Function<? super B, ? extends A> backwardFunction;\n\n        private FunctionBasedConverter(\n            Function<? super A, ? extends B> forwardFunction,\n            Function<? super B, ? extends A> backwardFunction)\n        {\n            this.forwardFunction = checkNotNull(forwardFunction);\n            this.backwardFunction = checkNotNull(backwardFunction);\n        }\n\n        @Override\n        protected B doForward(A a)\n        {\n            return forwardFunction.apply(a);\n        }\n\n        @Override\n        protected A doBackward(B b)\n        {\n            return backwardFunction.apply(b);\n        }\n\n        @Override\n        public boolean equals(@NullableDecl Object object)\n        {\n            if (object instanceof FunctionBasedConverter)\n            {\n                FunctionBasedConverter<?, ?> that = (FunctionBasedConverter<?, ?>) object;\n                return this.forwardFunction.equals(that.forwardFunction)\n                       && this.backwardFunction.equals(that.backwardFunction);\n            }\n            return false;\n        }\n\n        @Override\n        public int hashCode()\n        {\n            return forwardFunction.hashCode() * 31 + backwardFunction.hashCode();\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"Converter.from(\" + forwardFunction + \", \" + backwardFunction + \")\";\n        }\n    }\n\n    /** Returns a serializable converter that always converts or reverses an object to itself. */\n\n    /**\n     * A converter that always converts or reverses an object to itself. Note that T is now a\n     * \"pass-through type\".\n     */\n    private static final class IdentityConverter<T> extends Converter<T, T> implements Serializable\n    {\n        static final IdentityConverter INSTANCE = new IdentityConverter();\n\n        @Override\n        protected T doForward(T t)\n        {\n            return t;\n        }\n\n        @Override\n        protected T doBackward(T t)\n        {\n            return t;\n        }\n\n        @Override\n        public IdentityConverter<T> reverse()\n        {\n            return this;\n        }\n\n        @Override\n        <S> Converter<T, S> doAndThen(Converter<T, S> otherConverter)\n        {\n            return checkNotNull(otherConverter, \"otherConverter\");\n        }\n\n        /*\n         * We *could* override convertAll() to return its input, but it's a rather pointless\n         * optimization and opened up a weird type-safety problem.\n         */\n\n        @Override\n        public String toString()\n        {\n            return \"Converter.identity()\";\n        }\n\n        private Object readResolve()\n        {\n            return INSTANCE;\n        }\n\n        private static final long serialVersionUID = 0L;\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/RegularImmutableTable.java", "func_name": "RegularImmutableTable.forOrderedComponents", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "A factory that chooses the most space-efficient representation of the table.", "docstring_tokens": ["A", "factory", "that", "chooses", "the", "most", "space", "-", "efficient", "representation", "of", "the", "table", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/RegularImmutableTable.java#L161-L170", "partition": "valid", "up_fun_num": 9, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.GwtCompatible;", "import com.google.j2objc.annotations.WeakOuter;", "import java.util.Collections;", "import java.util.Comparator;", "import java.util.LinkedHashSet;", "import java.util.List;", "import java.util.Set;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["abstract class RegularImmutableTable<R, C, V> extends ImmutableTable<R, C, V>\n", "    abstract Cell<R, C, V> getCell(int iterationIndex);\n", "    final ImmutableSet<Cell<R, C, V>> createCellSet()\n", "    abstract V getValue(int iterationIndex);\n", "    final ImmutableCollection<V> createValues()\n", "    static <R, C, V> RegularImmutableTable<R, C, V> forCells(\n", "    static <R, C, V> RegularImmutableTable<R, C, V> forCells(Iterable<Cell<R, C, V>> cells)\n", "    private static <R, C, V> RegularImmutableTable<R, C, V> forCellsInternal(\n", "    final void checkNoDuplicate(R rowKey, C columnKey, V existingValue, V newValue)\n"], "context": "/*\n * Copyright (C) 2009 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.j2objc.annotations.WeakOuter;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * An implementation of {@link ImmutableTable} holding an arbitrary number of cells.\n *\n * @author Gregory Kick\n */\n@GwtCompatible\nabstract class RegularImmutableTable<R, C, V> extends ImmutableTable<R, C, V>\n{\n    RegularImmutableTable() {}\n\n    abstract Cell<R, C, V> getCell(int iterationIndex);\n\n    @Override\n    final ImmutableSet<Cell<R, C, V>> createCellSet()\n    {\n        return isEmpty() ? ImmutableSet.<Cell<R, C, V>>of() : new CellSet();\n    }\n\n    @WeakOuter\n    private final class CellSet extends IndexedImmutableSet<Cell<R, C, V>>\n    {\n        @Override\n        public int size()\n        {\n            return RegularImmutableTable.this.size();\n        }\n\n        @Override\n        Cell<R, C, V> get(int index)\n        {\n            return getCell(index);\n        }\n\n        @Override\n        public boolean contains(@NullableDecl Object object)\n        {\n            if (object instanceof Cell)\n            {\n                Cell<?, ?, ?> cell = (Cell<?, ?, ?>) object;\n                Object value = RegularImmutableTable.this.get(cell.getRowKey(), cell.getColumnKey());\n                return value != null && value.equals(cell.getValue());\n            }\n            return false;\n        }\n\n        @Override\n        boolean isPartialView()\n        {\n            return false;\n        }\n    }\n\n    abstract V getValue(int iterationIndex);\n\n    @Override\n    final ImmutableCollection<V> createValues()\n    {\n        return isEmpty() ? ImmutableList.<V>of() : new Values();\n    }\n\n    @WeakOuter\n    private final class Values extends ImmutableList<V>\n    {\n        @Override\n        public int size()\n        {\n            return RegularImmutableTable.this.size();\n        }\n\n        @Override\n        public V get(int index)\n        {\n            return getValue(index);\n        }\n\n        @Override\n        boolean isPartialView()\n        {\n            return true;\n        }\n    }\n\n    static <R, C, V> RegularImmutableTable<R, C, V> forCells(\n        List<Cell<R, C, V>> cells,\n        @NullableDecl final Comparator<? super R> rowComparator,\n        @NullableDecl final Comparator<? super C> columnComparator)\n    {\n        checkNotNull(cells);\n        if (rowComparator != null || columnComparator != null)\n        {\n            /*\n             * This sorting logic leads to a cellSet() ordering that may not be expected and that isn't\n             * documented in the Javadoc. If a row Comparator is provided, cellSet() iterates across the\n             * columns in the first row, the columns in the second row, etc. If a column Comparator is\n             * provided but a row Comparator isn't, cellSet() iterates across the rows in the first\n             * column, the rows in the second column, etc.\n             */\n            Comparator<Cell<R, C, V>> comparator =\n                new Comparator<Cell<R, C, V>>()\n            {\n                @Override\n                public int compare(Cell<R, C, V> cell1, Cell<R, C, V> cell2)\n                {\n                    int rowCompare =\n                        (rowComparator == null)\n                        ? 0\n                        : rowComparator.compare(cell1.getRowKey(), cell2.getRowKey());\n                    if (rowCompare != 0)\n                    {\n                        return rowCompare;\n                    }\n                    return (columnComparator == null)\n                           ? 0\n                           : columnComparator.compare(cell1.getColumnKey(), cell2.getColumnKey());\n                }\n            };\n            Collections.sort(cells, comparator);\n        }\n        return forCellsInternal(cells, rowComparator, columnComparator);\n    }\n\n    static <R, C, V> RegularImmutableTable<R, C, V> forCells(Iterable<Cell<R, C, V>> cells)\n    {\n        return forCellsInternal(cells, null, null);\n    }\n\n    private static <R, C, V> RegularImmutableTable<R, C, V> forCellsInternal(\n        Iterable<Cell<R, C, V>> cells,\n        @NullableDecl Comparator<? super R> rowComparator,\n        @NullableDecl Comparator<? super C> columnComparator)\n    {\n        Set<R> rowSpaceBuilder = new LinkedHashSet<>();\n        Set<C> columnSpaceBuilder = new LinkedHashSet<>();\n        ImmutableList<Cell<R, C, V>> cellList = ImmutableList.copyOf(cells);\n        for (Cell<R, C, V> cell : cells)\n        {\n            rowSpaceBuilder.add(cell.getRowKey());\n            columnSpaceBuilder.add(cell.getColumnKey());\n        }\n\n        ImmutableSet<R> rowSpace =\n            (rowComparator == null)\n            ? ImmutableSet.copyOf(rowSpaceBuilder)\n            : ImmutableSet.copyOf(ImmutableList.sortedCopyOf(rowComparator, rowSpaceBuilder));\n        ImmutableSet<C> columnSpace =\n            (columnComparator == null)\n            ? ImmutableSet.copyOf(columnSpaceBuilder)\n            : ImmutableSet.copyOf(ImmutableList.sortedCopyOf(columnComparator, columnSpaceBuilder));\n\n        return forOrderedComponents(cellList, rowSpace, columnSpace);\n    }\n\n    /** A factory that chooses the most space-efficient representation of the table. */\n\n    /** @throws IllegalArgumentException if {@code existingValue} is not null. */\n    /*\n     * We could have declared this method 'static' but the additional compile-time checks achieved by\n     * referencing the type variables seem worthwhile.\n     */\n    final void checkNoDuplicate(R rowKey, C columnKey, V existingValue, V newValue)\n    {\n        checkArgument(\n            existingValue == null,\n            \"Duplicate key: (row=%s, column=%s), values: [%s, %s].\",\n            rowKey,\n            columnKey,\n            newValue,\n            existingValue);\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/ImmutableSortedMultiset.java", "func_name": "ImmutableSortedMultiset.of", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns an immutable sorted multiset containing a single element.", "docstring_tokens": ["Returns", "an", "immutable", "sorted", "multiset", "containing", "a", "single", "element", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/ImmutableSortedMultiset.java#L61-L66", "partition": "valid", "up_fun_num": 3, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.annotations.VisibleForTesting;", "import com.google.common.math.IntMath;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import com.google.errorprone.annotations.concurrent.LazyInit;", "import java.io.Serializable;", "import java.util.Arrays;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.Comparator;", "import java.util.Iterator;", "import java.util.List;"], "function": ["public abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultisetFauxverideShim<E>\n", "    public static <E> ImmutableSortedMultiset<E> of()\n", "    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(E e1, E e2)\n", "    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(E e1, E e2, E e3)\n", "    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(\n", "    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(\n", "    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(\n", "    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> copyOf(E[] elements)\n", "    public static <E> ImmutableSortedMultiset<E> copyOf(Iterable<? extends E> elements)\n", "    public static <E> ImmutableSortedMultiset<E> copyOf(Iterator<? extends E> elements)\n", "    public static <E> ImmutableSortedMultiset<E> copyOf(\n", "    public static <E> ImmutableSortedMultiset<E> copyOf(\n", "    public static <E> ImmutableSortedMultiset<E> copyOfSorted(SortedMultiset<E> sortedMultiset)\n", "    private static <E> ImmutableSortedMultiset<E> copyOfSortedEntries(\n", "    static <E> ImmutableSortedMultiset<E> emptyMultiset(Comparator<? super E> comparator)\n", "    public final Comparator<? super E> comparator()\n", "    public abstract ImmutableSortedSet<E> elementSet();\n", "    public ImmutableSortedMultiset<E> descendingMultiset()\n", "    public final Entry<E> pollFirstEntry()\n", "    public final Entry<E> pollLastEntry()\n", "    public abstract ImmutableSortedMultiset<E> headMultiset(E upperBound, BoundType boundType);\n", "    public ImmutableSortedMultiset<E> subMultiset(\n", "    public abstract ImmutableSortedMultiset<E> tailMultiset(E lowerBound, BoundType boundType);\n", "    public static <E> Builder<E> orderedBy(Comparator<E> comparator)\n", "    public static <E extends Comparable<?>> Builder<E> reverseOrder()\n", "    public static <E extends Comparable<?>> Builder<E> naturalOrder()\n", "    Object writeReplace()\n"], "context": "/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the\n * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n * express or implied. See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.math.IntMath;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.google.errorprone.annotations.concurrent.LazyInit;\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * A {@link SortedMultiset} whose contents will never change, with many other important properties\n * detailed at {@link ImmutableCollection}.\n *\n * <p><b>Warning:</b> as with any sorted collection, you are strongly advised not to use a {@link\n * Comparator} or {@link Comparable} type whose comparison behavior is <i>inconsistent with\n * equals</i>. That is, {@code a.compareTo(b)} or {@code comparator.compare(a, b)} should equal zero\n * <i>if and only if</i> {@code a.equals(b)}. If this advice is not followed, the resulting\n * collection will not correctly obey its specification.\n *\n * <p>See the Guava User Guide article on <a href=\n * \"https://github.com/google/guava/wiki/ImmutableCollectionsExplained\"> immutable collections</a>.\n *\n * @author Louis Wasserman\n * @since 12.0\n */\n@GwtIncompatible // hasn't been tested yet\npublic abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultisetFauxverideShim<E>\n    implements SortedMultiset<E>\n{\n    // TODO(lowasser): GWT compatibility\n\n    /** Returns the empty immutable sorted multiset. */\n    @SuppressWarnings(\"unchecked\")\n    public static <E> ImmutableSortedMultiset<E> of()\n    {\n        return (ImmutableSortedMultiset) RegularImmutableSortedMultiset.NATURAL_EMPTY_MULTISET;\n    }\n\n    /** Returns an immutable sorted multiset containing a single element. */\n\n    /**\n     * Returns an immutable sorted multiset containing the given elements sorted by their natural\n     * ordering.\n     *\n     * @throws NullPointerException if any element is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(E e1, E e2)\n    {\n        return copyOf(Ordering.natural(), Arrays.asList(e1, e2));\n    }\n\n    /**\n     * Returns an immutable sorted multiset containing the given elements sorted by their natural\n     * ordering.\n     *\n     * @throws NullPointerException if any element is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(E e1, E e2, E e3)\n    {\n        return copyOf(Ordering.natural(), Arrays.asList(e1, e2, e3));\n    }\n\n    /**\n     * Returns an immutable sorted multiset containing the given elements sorted by their natural\n     * ordering.\n     *\n     * @throws NullPointerException if any element is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(\n        E e1, E e2, E e3, E e4)\n    {\n        return copyOf(Ordering.natural(), Arrays.asList(e1, e2, e3, e4));\n    }\n\n    /**\n     * Returns an immutable sorted multiset containing the given elements sorted by their natural\n     * ordering.\n     *\n     * @throws NullPointerException if any element is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(\n        E e1, E e2, E e3, E e4, E e5)\n    {\n        return copyOf(Ordering.natural(), Arrays.asList(e1, e2, e3, e4, e5));\n    }\n\n    /**\n     * Returns an immutable sorted multiset containing the given elements sorted by their natural\n     * ordering.\n     *\n     * @throws NullPointerException if any element is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(\n        E e1, E e2, E e3, E e4, E e5, E e6, E... remaining)\n    {\n        int size = remaining.length + 6;\n        List<E> all = Lists.newArrayListWithCapacity(size);\n        Collections.addAll(all, e1, e2, e3, e4, e5, e6);\n        Collections.addAll(all, remaining);\n        return copyOf(Ordering.natural(), all);\n    }\n\n    /**\n     * Returns an immutable sorted multiset containing the given elements sorted by their natural\n     * ordering.\n     *\n     * @throws NullPointerException if any of {@code elements} is null\n     */\n    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> copyOf(E[] elements)\n    {\n        return copyOf(Ordering.natural(), Arrays.asList(elements));\n    }\n\n    /**\n     * Returns an immutable sorted multiset containing the given elements sorted by their natural\n     * ordering. To create a copy of a {@code SortedMultiset} that preserves the comparator, call\n     * {@link #copyOfSorted} instead. This method iterates over {@code elements} at most once.\n     *\n     * <p>Note that if {@code s} is a {@code Multiset<String>}, then {@code\n     * ImmutableSortedMultiset.copyOf(s)} returns an {@code ImmutableSortedMultiset<String>}\n     * containing each of the strings in {@code s}, while {@code ImmutableSortedMultiset.of(s)}\n     * returns an {@code ImmutableSortedMultiset<Multiset<String>>} containing one element (the given\n     * multiset itself).\n     *\n     * <p>Despite the method name, this method attempts to avoid actually copying the data when it is\n     * safe to do so. The exact circumstances under which a copy will or will not be performed are\n     * undocumented and subject to change.\n     *\n     * <p>This method is not type-safe, as it may be called on elements that are not mutually\n     * comparable.\n     *\n     * @throws ClassCastException if the elements are not mutually comparable\n     * @throws NullPointerException if any of {@code elements} is null\n     */\n    public static <E> ImmutableSortedMultiset<E> copyOf(Iterable<? extends E> elements)\n    {\n        // Hack around E not being a subtype of Comparable.\n        // Unsafe, see ImmutableSortedMultisetFauxverideShim.\n        @SuppressWarnings(\"unchecked\")\n        Ordering<E> naturalOrder = (Ordering<E>) Ordering.<Comparable>natural();\n        return copyOf(naturalOrder, elements);\n    }\n\n    /**\n     * Returns an immutable sorted multiset containing the given elements sorted by their natural\n     * ordering.\n     *\n     * <p>This method is not type-safe, as it may be called on elements that are not mutually\n     * comparable.\n     *\n     * @throws ClassCastException if the elements are not mutually comparable\n     * @throws NullPointerException if any of {@code elements} is null\n     */\n    public static <E> ImmutableSortedMultiset<E> copyOf(Iterator<? extends E> elements)\n    {\n        // Hack around E not being a subtype of Comparable.\n        // Unsafe, see ImmutableSortedMultisetFauxverideShim.\n        @SuppressWarnings(\"unchecked\")\n        Ordering<E> naturalOrder = (Ordering<E>) Ordering.<Comparable>natural();\n        return copyOf(naturalOrder, elements);\n    }\n\n    /**\n     * Returns an immutable sorted multiset containing the given elements sorted by the given {@code\n     * Comparator}.\n     *\n     * @throws NullPointerException if {@code comparator} or any of {@code elements} is null\n     */\n    public static <E> ImmutableSortedMultiset<E> copyOf(\n        Comparator<? super E> comparator, Iterator<? extends E> elements)\n    {\n        checkNotNull(comparator);\n        return new Builder<E>(comparator).addAll(elements).build();\n    }\n\n    /**\n     * Returns an immutable sorted multiset containing the given elements sorted by the given {@code\n     * Comparator}. This method iterates over {@code elements} at most once.\n     *\n     * <p>Despite the method name, this method attempts to avoid actually copying the data when it is\n     * safe to do so. The exact circumstances under which a copy will or will not be performed are\n     * undocumented and subject to change.\n     *\n     * @throws NullPointerException if {@code comparator} or any of {@code elements} is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E> ImmutableSortedMultiset<E> copyOf(\n        Comparator<? super E> comparator, Iterable<? extends E> elements)\n    {\n        if (elements instanceof ImmutableSortedMultiset)\n        {\n            @SuppressWarnings(\"unchecked\") // immutable collections are always safe for covariant casts\n            ImmutableSortedMultiset<E> multiset = (ImmutableSortedMultiset<E>) elements;\n            if (comparator.equals(multiset.comparator()))\n            {\n                if (multiset.isPartialView())\n                {\n                    return copyOfSortedEntries(comparator, multiset.entrySet().asList());\n                }\n                else\n                {\n                    return multiset;\n                }\n            }\n        }\n        return new ImmutableSortedMultiset.Builder<E>(comparator).addAll(elements).build();\n    }\n\n    /**\n     * Returns an immutable sorted multiset containing the elements of a sorted multiset, sorted by\n     * the same {@code Comparator}. That behavior differs from {@link #copyOf(Iterable)}, which always\n     * uses the natural ordering of the elements.\n     *\n     * <p>Despite the method name, this method attempts to avoid actually copying the data when it is\n     * safe to do so. The exact circumstances under which a copy will or will not be performed are\n     * undocumented and subject to change.\n     *\n     * <p>This method is safe to use even when {@code sortedMultiset} is a synchronized or concurrent\n     * collection that is currently being modified by another thread.\n     *\n     * @throws NullPointerException if {@code sortedMultiset} or any of its elements is null\n     */\n    public static <E> ImmutableSortedMultiset<E> copyOfSorted(SortedMultiset<E> sortedMultiset)\n    {\n        return copyOfSortedEntries(\n                   sortedMultiset.comparator(), Lists.newArrayList(sortedMultiset.entrySet()));\n    }\n\n    private static <E> ImmutableSortedMultiset<E> copyOfSortedEntries(\n        Comparator<? super E> comparator, Collection<Entry<E>> entries)\n    {\n        if (entries.isEmpty())\n        {\n            return emptyMultiset(comparator);\n        }\n        ImmutableList.Builder<E> elementsBuilder = new ImmutableList.Builder<E>(entries.size());\n        long[] cumulativeCounts = new long[entries.size() + 1];\n        int i = 0;\n        for (Entry<E> entry : entries)\n        {\n            elementsBuilder.add(entry.getElement());\n            cumulativeCounts[i + 1] = cumulativeCounts[i] + entry.getCount();\n            i++;\n        }\n        return new RegularImmutableSortedMultiset<E>(\n                   new RegularImmutableSortedSet<E>(elementsBuilder.build(), comparator),\n                   cumulativeCounts,\n                   0,\n                   entries.size());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    static <E> ImmutableSortedMultiset<E> emptyMultiset(Comparator<? super E> comparator)\n    {\n        if (Ordering.natural().equals(comparator))\n        {\n            return (ImmutableSortedMultiset<E>) RegularImmutableSortedMultiset.NATURAL_EMPTY_MULTISET;\n        }\n        else\n        {\n            return new RegularImmutableSortedMultiset<E>(comparator);\n        }\n    }\n\n    ImmutableSortedMultiset() {}\n\n    @Override\n    public final Comparator<? super E> comparator()\n    {\n        return elementSet().comparator();\n    }\n\n    @Override\n    public abstract ImmutableSortedSet<E> elementSet();\n\n    @LazyInit transient ImmutableSortedMultiset<E> descendingMultiset;\n\n    @Override\n    public ImmutableSortedMultiset<E> descendingMultiset()\n    {\n        ImmutableSortedMultiset<E> result = descendingMultiset;\n        if (result == null)\n        {\n            return descendingMultiset =\n                       this.isEmpty()\n                       ? emptyMultiset(Ordering.from(comparator()).reverse())\n                       : new DescendingImmutableSortedMultiset<E>(this);\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>This implementation is guaranteed to throw an {@link UnsupportedOperationException}.\n     *\n     * @throws UnsupportedOperationException always\n     * @deprecated Unsupported operation.\n     */\n    @CanIgnoreReturnValue\n    @Deprecated\n    @Override\n    public final Entry<E> pollFirstEntry()\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>This implementation is guaranteed to throw an {@link UnsupportedOperationException}.\n     *\n     * @throws UnsupportedOperationException always\n     * @deprecated Unsupported operation.\n     */\n    @CanIgnoreReturnValue\n    @Deprecated\n    @Override\n    public final Entry<E> pollLastEntry()\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public abstract ImmutableSortedMultiset<E> headMultiset(E upperBound, BoundType boundType);\n\n    @Override\n    public ImmutableSortedMultiset<E> subMultiset(\n        E lowerBound, BoundType lowerBoundType, E upperBound, BoundType upperBoundType)\n    {\n        checkArgument(\n            comparator().compare(lowerBound, upperBound) <= 0,\n            \"Expected lowerBound <= upperBound but %s > %s\",\n            lowerBound,\n            upperBound);\n        return tailMultiset(lowerBound, lowerBoundType).headMultiset(upperBound, upperBoundType);\n    }\n\n    @Override\n    public abstract ImmutableSortedMultiset<E> tailMultiset(E lowerBound, BoundType boundType);\n\n    /**\n     * Returns a builder that creates immutable sorted multisets with an explicit comparator. If the\n     * comparator has a more general type than the set being generated, such as creating a {@code\n     * SortedMultiset<Integer>} with a {@code Comparator<Number>}, use the {@link Builder} constructor\n     * instead.\n     *\n     * @throws NullPointerException if {@code comparator} is null\n     */\n    public static <E> Builder<E> orderedBy(Comparator<E> comparator)\n    {\n        return new Builder<E>(comparator);\n    }\n\n    /**\n     * Returns a builder that creates immutable sorted multisets whose elements are ordered by the\n     * reverse of their natural ordering.\n     *\n     * <p>Note: the type parameter {@code E} extends {@code Comparable<?>} rather than {@code\n     * Comparable<? super E>} as a workaround for javac <a\n     * href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6468354\">bug 6468354</a>.\n     */\n    public static <E extends Comparable<?>> Builder<E> reverseOrder()\n    {\n        return new Builder<E>(Ordering.natural().reverse());\n    }\n\n    /**\n     * Returns a builder that creates immutable sorted multisets whose elements are ordered by their\n     * natural ordering. The sorted multisets use {@link Ordering#natural()} as the comparator. This\n     * method provides more type-safety than {@link #builder}, as it can be called only for classes\n     * that implement {@link Comparable}.\n     *\n     * <p>Note: the type parameter {@code E} extends {@code Comparable<?>} rather than {@code\n     * Comparable<? super E>} as a workaround for javac <a\n     * href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6468354\">bug 6468354</a>.\n     */\n    public static <E extends Comparable<?>> Builder<E> naturalOrder()\n    {\n        return new Builder<E>(Ordering.natural());\n    }\n\n    /**\n     * A builder for creating immutable multiset instances, especially {@code public static final}\n     * multisets (\"constant multisets\"). Example:\n     *\n     * <pre>{@code\n     * public static final ImmutableSortedMultiset<Bean> BEANS =\n     *     new ImmutableSortedMultiset.Builder<Bean>(colorComparator())\n     *         .addCopies(Bean.COCOA, 4)\n     *         .addCopies(Bean.GARDEN, 6)\n     *         .addCopies(Bean.RED, 8)\n     *         .addCopies(Bean.BLACK_EYED, 10)\n     *         .build();\n     * }</pre>\n     *\n     * <p>Builder instances can be reused; it is safe to call {@link #build} multiple times to build\n     * multiple multisets in series.\n     *\n     * @since 12.0\n     */\n    public static class Builder<E> extends ImmutableMultiset.Builder<E>\n    {\n        /*\n         * We keep an array of elements and counts.  Periodically -- when we need more room in the\n         * array, or when we're building, or the like -- we sort, deduplicate, and combine the counts.\n         * Negative counts indicate a setCount operation with ~counts[i].\n         */\n\n        private final Comparator<? super E> comparator;\n\n        @VisibleForTesting E[] elements;\n        private int[] counts;\n\n        /*\n         * The number of used positions in the elements array.  We deduplicate periodically, so this\n         * may fluctuate up and down.\n         */\n        private int length;\n\n        // True if we just called build() and the elements array is being used by a created ISM, meaning\n        // we shouldn't modify that array further.\n        private boolean forceCopyElements;\n\n        /**\n         * Creates a new builder. The returned builder is equivalent to the builder generated by {@link\n         * ImmutableSortedMultiset#orderedBy(Comparator)}.\n         */\n        @SuppressWarnings(\"unchecked\")\n        public Builder(Comparator<? super E> comparator)\n        {\n            super(true); // doesn't allocate hash table in supertype\n            this.comparator = checkNotNull(comparator);\n            this.elements = (E[]) new Object[ImmutableCollection.Builder.DEFAULT_INITIAL_CAPACITY];\n            this.counts = new int[ImmutableCollection.Builder.DEFAULT_INITIAL_CAPACITY];\n        }\n\n        /** Check if we need to do deduplication and coalescing, and if so, do it. */\n        private void maintenance()\n        {\n            if (length == elements.length)\n            {\n                dedupAndCoalesce(true);\n            }\n            else if (forceCopyElements)\n            {\n                this.elements = Arrays.copyOf(elements, elements.length);\n                // we don't currently need to copy the counts array, because we don't use it directly\n                // in built ISMs\n            }\n            forceCopyElements = false;\n        }\n\n        private void dedupAndCoalesce(boolean maybeExpand)\n        {\n            if (length == 0)\n            {\n                return;\n            }\n            E[] sortedElements = Arrays.copyOf(elements, length);\n            Arrays.sort(sortedElements, comparator);\n            int uniques = 1;\n            for (int i = 1; i < sortedElements.length; i++)\n            {\n                if (comparator.compare(sortedElements[uniques - 1], sortedElements[i]) < 0)\n                {\n                    sortedElements[uniques] = sortedElements[i];\n                    uniques++;\n                }\n            }\n            Arrays.fill(sortedElements, uniques, length, null);\n            if (maybeExpand && uniques * 4 > length * 3)\n            {\n                // lots of nonduplicated elements, expand the array by 50%\n                sortedElements =\n                    Arrays.copyOf(sortedElements, IntMath.saturatedAdd(length, length / 2 + 1));\n            }\n            int[] sortedCounts = new int[sortedElements.length];\n            for (int i = 0; i < length; i++)\n            {\n                int index = Arrays.binarySearch(sortedElements, 0, uniques, elements[i], comparator);\n                if (counts[i] >= 0)\n                {\n                    sortedCounts[index] += counts[i];\n                }\n                else\n                {\n                    sortedCounts[index] = ~counts[i];\n                }\n            }\n            // Note that we're not getting rid, yet, of elements with count 0.  We'll do that in build().\n            this.elements = sortedElements;\n            this.counts = sortedCounts;\n            this.length = uniques;\n        }\n\n        /**\n         * Adds {@code element} to the {@code ImmutableSortedMultiset}.\n         *\n         * @param element the element to add\n         * @return this {@code Builder} object\n         * @throws NullPointerException if {@code element} is null\n         */\n        @CanIgnoreReturnValue\n        @Override\n        public Builder<E> add(E element)\n        {\n            return addCopies(element, 1);\n        }\n\n        /**\n         * Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.\n         *\n         * @param elements the elements to add\n         * @return this {@code Builder} object\n         * @throws NullPointerException if {@code elements} is null or contains a null element\n         */\n        @CanIgnoreReturnValue\n        @Override\n        public Builder<E> add(E... elements)\n        {\n            for (E element : elements)\n            {\n                add(element);\n            }\n            return this;\n        }\n\n        /**\n         * Adds a number of occurrences of an element to this {@code ImmutableSortedMultiset}.\n         *\n         * @param element the element to add\n         * @param occurrences the number of occurrences of the element to add. May be zero, in which\n         *     case no change will be made.\n         * @return this {@code Builder} object\n         * @throws NullPointerException if {@code element} is null\n         * @throws IllegalArgumentException if {@code occurrences} is negative, or if this operation\n         *     would result in more than {@link Integer#MAX_VALUE} occurrences of the element\n         */\n        @CanIgnoreReturnValue\n        @Override\n        public Builder<E> addCopies(E element, int occurrences)\n        {\n            checkNotNull(element);\n            CollectPreconditions.checkNonnegative(occurrences, \"occurrences\");\n            if (occurrences == 0)\n            {\n                return this;\n            }\n            maintenance();\n            elements[length] = element;\n            counts[length] = occurrences;\n            length++;\n            return this;\n        }\n\n        /**\n         * Adds or removes the necessary occurrences of an element such that the element attains the\n         * desired count.\n         *\n         * @param element the element to add or remove occurrences of\n         * @param count the desired count of the element in this multiset\n         * @return this {@code Builder} object\n         * @throws NullPointerException if {@code element} is null\n         * @throws IllegalArgumentException if {@code count} is negative\n         */\n        @CanIgnoreReturnValue\n        @Override\n        public Builder<E> setCount(E element, int count)\n        {\n            checkNotNull(element);\n            CollectPreconditions.checkNonnegative(count, \"count\");\n            maintenance();\n            elements[length] = element;\n            counts[length] = ~count;\n            length++;\n            return this;\n        }\n\n        /**\n         * Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.\n         *\n         * @param elements the {@code Iterable} to add to the {@code ImmutableSortedMultiset}\n         * @return this {@code Builder} object\n         * @throws NullPointerException if {@code elements} is null or contains a null element\n         */\n        @CanIgnoreReturnValue\n        @Override\n        public Builder<E> addAll(Iterable<? extends E> elements)\n        {\n            if (elements instanceof Multiset)\n            {\n                for (Entry<? extends E> entry : ((Multiset<? extends E>) elements).entrySet())\n                {\n                    addCopies(entry.getElement(), entry.getCount());\n                }\n            }\n            else\n            {\n                for (E e : elements)\n                {\n                    add(e);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.\n         *\n         * @param elements the elements to add to the {@code ImmutableSortedMultiset}\n         * @return this {@code Builder} object\n         * @throws NullPointerException if {@code elements} is null or contains a null element\n         */\n        @CanIgnoreReturnValue\n        @Override\n        public Builder<E> addAll(Iterator<? extends E> elements)\n        {\n            while (elements.hasNext())\n            {\n                add(elements.next());\n            }\n            return this;\n        }\n\n        private void dedupAndCoalesceAndDeleteEmpty()\n        {\n            dedupAndCoalesce(false);\n\n            // If there was a setCount(elem, 0), those elements are still present.  Eliminate them.\n            int size = 0;\n            for (int i = 0; i < length; i++)\n            {\n                if (counts[i] > 0)\n                {\n                    elements[size] = elements[i];\n                    counts[size] = counts[i];\n                    size++;\n                }\n            }\n            Arrays.fill(elements, size, length, null);\n            Arrays.fill(counts, size, length, 0);\n            length = size;\n        }\n\n        /**\n         * Returns a newly-created {@code ImmutableSortedMultiset} based on the contents of the {@code\n         * Builder}.\n         */\n        @Override\n        public ImmutableSortedMultiset<E> build()\n        {\n            dedupAndCoalesceAndDeleteEmpty();\n            if (length == 0)\n            {\n                return emptyMultiset(comparator);\n            }\n            RegularImmutableSortedSet<E> elementSet =\n                (RegularImmutableSortedSet<E>) ImmutableSortedSet.construct(comparator, length, elements);\n            long[] cumulativeCounts = new long[length + 1];\n            for (int i = 0; i < length; i++)\n            {\n                cumulativeCounts[i + 1] = cumulativeCounts[i] + counts[i];\n            }\n            forceCopyElements = true;\n            return new RegularImmutableSortedMultiset<E>(elementSet, cumulativeCounts, 0, length);\n        }\n    }\n\n    private static final class SerializedForm<E> implements Serializable\n    {\n        final Comparator<? super E> comparator;\n        final E[] elements;\n        final int[] counts;\n\n        @SuppressWarnings(\"unchecked\")\n        SerializedForm(SortedMultiset<E> multiset)\n        {\n            this.comparator = multiset.comparator();\n            int n = multiset.entrySet().size();\n            elements = (E[]) new Object[n];\n            counts = new int[n];\n            int i = 0;\n            for (Entry<E> entry : multiset.entrySet())\n            {\n                elements[i] = entry.getElement();\n                counts[i] = entry.getCount();\n                i++;\n            }\n        }\n\n        Object readResolve()\n        {\n            int n = elements.length;\n            Builder<E> builder = new Builder<>(comparator);\n            for (int i = 0; i < n; i++)\n            {\n                builder.addCopies(elements[i], counts[i]);\n            }\n            return builder.build();\n        }\n    }\n\n    @Override\n    Object writeReplace()\n    {\n        return new SerializedForm<E>(this);\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/ImmutableSortedMultiset.java", "func_name": "ImmutableSortedMultiset.reverseOrder", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns a builder that creates immutable sorted multisets whose elements are ordered by the\nreverse of their natural ordering.\n\n<p>Note: the type parameter {@code E} extends {@code Comparable<?>} rather than {@code\nComparable<? super E>} as a workaround for javac <a\nhref=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6468354\">bug 6468354</a>.", "docstring_tokens": ["Returns", "a", "builder", "that", "creates", "immutable", "sorted", "multisets", "whose", "elements", "are", "ordered", "by", "the", "reverse", "of", "their", "natural", "ordering", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/ImmutableSortedMultiset.java#L365-L367", "partition": "valid", "up_fun_num": 26, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.GwtIncompatible;", "import com.google.common.annotations.VisibleForTesting;", "import com.google.common.math.IntMath;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import com.google.errorprone.annotations.concurrent.LazyInit;", "import java.io.Serializable;", "import java.util.Arrays;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.Comparator;", "import java.util.Iterator;", "import java.util.List;"], "function": ["public abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultisetFauxverideShim<E>\n", "    public static <E> ImmutableSortedMultiset<E> of()\n", "    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(E element)\n", "    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(E e1, E e2)\n", "    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(E e1, E e2, E e3)\n", "    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(\n", "    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(\n", "    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(\n", "    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> copyOf(E[] elements)\n", "    public static <E> ImmutableSortedMultiset<E> copyOf(Iterable<? extends E> elements)\n", "    public static <E> ImmutableSortedMultiset<E> copyOf(Iterator<? extends E> elements)\n", "    public static <E> ImmutableSortedMultiset<E> copyOf(\n", "    public static <E> ImmutableSortedMultiset<E> copyOf(\n", "    public static <E> ImmutableSortedMultiset<E> copyOfSorted(SortedMultiset<E> sortedMultiset)\n", "    private static <E> ImmutableSortedMultiset<E> copyOfSortedEntries(\n", "    static <E> ImmutableSortedMultiset<E> emptyMultiset(Comparator<? super E> comparator)\n", "    public final Comparator<? super E> comparator()\n", "    public abstract ImmutableSortedSet<E> elementSet();\n", "    public ImmutableSortedMultiset<E> descendingMultiset()\n", "    public final Entry<E> pollFirstEntry()\n", "    public final Entry<E> pollLastEntry()\n", "    public abstract ImmutableSortedMultiset<E> headMultiset(E upperBound, BoundType boundType);\n", "    public ImmutableSortedMultiset<E> subMultiset(\n", "    public abstract ImmutableSortedMultiset<E> tailMultiset(E lowerBound, BoundType boundType);\n", "    public static <E> Builder<E> orderedBy(Comparator<E> comparator)\n", "    public static <E extends Comparable<?>> Builder<E> naturalOrder()\n", "    Object writeReplace()\n"], "context": "/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the\n * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n * express or implied. See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.math.IntMath;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.google.errorprone.annotations.concurrent.LazyInit;\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * A {@link SortedMultiset} whose contents will never change, with many other important properties\n * detailed at {@link ImmutableCollection}.\n *\n * <p><b>Warning:</b> as with any sorted collection, you are strongly advised not to use a {@link\n * Comparator} or {@link Comparable} type whose comparison behavior is <i>inconsistent with\n * equals</i>. That is, {@code a.compareTo(b)} or {@code comparator.compare(a, b)} should equal zero\n * <i>if and only if</i> {@code a.equals(b)}. If this advice is not followed, the resulting\n * collection will not correctly obey its specification.\n *\n * <p>See the Guava User Guide article on <a href=\n * \"https://github.com/google/guava/wiki/ImmutableCollectionsExplained\"> immutable collections</a>.\n *\n * @author Louis Wasserman\n * @since 12.0\n */\n@GwtIncompatible // hasn't been tested yet\npublic abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultisetFauxverideShim<E>\n    implements SortedMultiset<E>\n{\n    // TODO(lowasser): GWT compatibility\n\n    /** Returns the empty immutable sorted multiset. */\n    @SuppressWarnings(\"unchecked\")\n    public static <E> ImmutableSortedMultiset<E> of()\n    {\n        return (ImmutableSortedMultiset) RegularImmutableSortedMultiset.NATURAL_EMPTY_MULTISET;\n    }\n\n    /** Returns an immutable sorted multiset containing a single element. */\n    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(E element)\n    {\n        RegularImmutableSortedSet<E> elementSet =\n            (RegularImmutableSortedSet<E>) ImmutableSortedSet.of(element);\n        long[] cumulativeCounts = {0, 1};\n        return new RegularImmutableSortedMultiset<E>(elementSet, cumulativeCounts, 0, 1);\n    }\n\n    /**\n     * Returns an immutable sorted multiset containing the given elements sorted by their natural\n     * ordering.\n     *\n     * @throws NullPointerException if any element is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(E e1, E e2)\n    {\n        return copyOf(Ordering.natural(), Arrays.asList(e1, e2));\n    }\n\n    /**\n     * Returns an immutable sorted multiset containing the given elements sorted by their natural\n     * ordering.\n     *\n     * @throws NullPointerException if any element is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(E e1, E e2, E e3)\n    {\n        return copyOf(Ordering.natural(), Arrays.asList(e1, e2, e3));\n    }\n\n    /**\n     * Returns an immutable sorted multiset containing the given elements sorted by their natural\n     * ordering.\n     *\n     * @throws NullPointerException if any element is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(\n        E e1, E e2, E e3, E e4)\n    {\n        return copyOf(Ordering.natural(), Arrays.asList(e1, e2, e3, e4));\n    }\n\n    /**\n     * Returns an immutable sorted multiset containing the given elements sorted by their natural\n     * ordering.\n     *\n     * @throws NullPointerException if any element is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(\n        E e1, E e2, E e3, E e4, E e5)\n    {\n        return copyOf(Ordering.natural(), Arrays.asList(e1, e2, e3, e4, e5));\n    }\n\n    /**\n     * Returns an immutable sorted multiset containing the given elements sorted by their natural\n     * ordering.\n     *\n     * @throws NullPointerException if any element is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(\n        E e1, E e2, E e3, E e4, E e5, E e6, E... remaining)\n    {\n        int size = remaining.length + 6;\n        List<E> all = Lists.newArrayListWithCapacity(size);\n        Collections.addAll(all, e1, e2, e3, e4, e5, e6);\n        Collections.addAll(all, remaining);\n        return copyOf(Ordering.natural(), all);\n    }\n\n    /**\n     * Returns an immutable sorted multiset containing the given elements sorted by their natural\n     * ordering.\n     *\n     * @throws NullPointerException if any of {@code elements} is null\n     */\n    public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> copyOf(E[] elements)\n    {\n        return copyOf(Ordering.natural(), Arrays.asList(elements));\n    }\n\n    /**\n     * Returns an immutable sorted multiset containing the given elements sorted by their natural\n     * ordering. To create a copy of a {@code SortedMultiset} that preserves the comparator, call\n     * {@link #copyOfSorted} instead. This method iterates over {@code elements} at most once.\n     *\n     * <p>Note that if {@code s} is a {@code Multiset<String>}, then {@code\n     * ImmutableSortedMultiset.copyOf(s)} returns an {@code ImmutableSortedMultiset<String>}\n     * containing each of the strings in {@code s}, while {@code ImmutableSortedMultiset.of(s)}\n     * returns an {@code ImmutableSortedMultiset<Multiset<String>>} containing one element (the given\n     * multiset itself).\n     *\n     * <p>Despite the method name, this method attempts to avoid actually copying the data when it is\n     * safe to do so. The exact circumstances under which a copy will or will not be performed are\n     * undocumented and subject to change.\n     *\n     * <p>This method is not type-safe, as it may be called on elements that are not mutually\n     * comparable.\n     *\n     * @throws ClassCastException if the elements are not mutually comparable\n     * @throws NullPointerException if any of {@code elements} is null\n     */\n    public static <E> ImmutableSortedMultiset<E> copyOf(Iterable<? extends E> elements)\n    {\n        // Hack around E not being a subtype of Comparable.\n        // Unsafe, see ImmutableSortedMultisetFauxverideShim.\n        @SuppressWarnings(\"unchecked\")\n        Ordering<E> naturalOrder = (Ordering<E>) Ordering.<Comparable>natural();\n        return copyOf(naturalOrder, elements);\n    }\n\n    /**\n     * Returns an immutable sorted multiset containing the given elements sorted by their natural\n     * ordering.\n     *\n     * <p>This method is not type-safe, as it may be called on elements that are not mutually\n     * comparable.\n     *\n     * @throws ClassCastException if the elements are not mutually comparable\n     * @throws NullPointerException if any of {@code elements} is null\n     */\n    public static <E> ImmutableSortedMultiset<E> copyOf(Iterator<? extends E> elements)\n    {\n        // Hack around E not being a subtype of Comparable.\n        // Unsafe, see ImmutableSortedMultisetFauxverideShim.\n        @SuppressWarnings(\"unchecked\")\n        Ordering<E> naturalOrder = (Ordering<E>) Ordering.<Comparable>natural();\n        return copyOf(naturalOrder, elements);\n    }\n\n    /**\n     * Returns an immutable sorted multiset containing the given elements sorted by the given {@code\n     * Comparator}.\n     *\n     * @throws NullPointerException if {@code comparator} or any of {@code elements} is null\n     */\n    public static <E> ImmutableSortedMultiset<E> copyOf(\n        Comparator<? super E> comparator, Iterator<? extends E> elements)\n    {\n        checkNotNull(comparator);\n        return new Builder<E>(comparator).addAll(elements).build();\n    }\n\n    /**\n     * Returns an immutable sorted multiset containing the given elements sorted by the given {@code\n     * Comparator}. This method iterates over {@code elements} at most once.\n     *\n     * <p>Despite the method name, this method attempts to avoid actually copying the data when it is\n     * safe to do so. The exact circumstances under which a copy will or will not be performed are\n     * undocumented and subject to change.\n     *\n     * @throws NullPointerException if {@code comparator} or any of {@code elements} is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E> ImmutableSortedMultiset<E> copyOf(\n        Comparator<? super E> comparator, Iterable<? extends E> elements)\n    {\n        if (elements instanceof ImmutableSortedMultiset)\n        {\n            @SuppressWarnings(\"unchecked\") // immutable collections are always safe for covariant casts\n            ImmutableSortedMultiset<E> multiset = (ImmutableSortedMultiset<E>) elements;\n            if (comparator.equals(multiset.comparator()))\n            {\n                if (multiset.isPartialView())\n                {\n                    return copyOfSortedEntries(comparator, multiset.entrySet().asList());\n                }\n                else\n                {\n                    return multiset;\n                }\n            }\n        }\n        return new ImmutableSortedMultiset.Builder<E>(comparator).addAll(elements).build();\n    }\n\n    /**\n     * Returns an immutable sorted multiset containing the elements of a sorted multiset, sorted by\n     * the same {@code Comparator}. That behavior differs from {@link #copyOf(Iterable)}, which always\n     * uses the natural ordering of the elements.\n     *\n     * <p>Despite the method name, this method attempts to avoid actually copying the data when it is\n     * safe to do so. The exact circumstances under which a copy will or will not be performed are\n     * undocumented and subject to change.\n     *\n     * <p>This method is safe to use even when {@code sortedMultiset} is a synchronized or concurrent\n     * collection that is currently being modified by another thread.\n     *\n     * @throws NullPointerException if {@code sortedMultiset} or any of its elements is null\n     */\n    public static <E> ImmutableSortedMultiset<E> copyOfSorted(SortedMultiset<E> sortedMultiset)\n    {\n        return copyOfSortedEntries(\n                   sortedMultiset.comparator(), Lists.newArrayList(sortedMultiset.entrySet()));\n    }\n\n    private static <E> ImmutableSortedMultiset<E> copyOfSortedEntries(\n        Comparator<? super E> comparator, Collection<Entry<E>> entries)\n    {\n        if (entries.isEmpty())\n        {\n            return emptyMultiset(comparator);\n        }\n        ImmutableList.Builder<E> elementsBuilder = new ImmutableList.Builder<E>(entries.size());\n        long[] cumulativeCounts = new long[entries.size() + 1];\n        int i = 0;\n        for (Entry<E> entry : entries)\n        {\n            elementsBuilder.add(entry.getElement());\n            cumulativeCounts[i + 1] = cumulativeCounts[i] + entry.getCount();\n            i++;\n        }\n        return new RegularImmutableSortedMultiset<E>(\n                   new RegularImmutableSortedSet<E>(elementsBuilder.build(), comparator),\n                   cumulativeCounts,\n                   0,\n                   entries.size());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    static <E> ImmutableSortedMultiset<E> emptyMultiset(Comparator<? super E> comparator)\n    {\n        if (Ordering.natural().equals(comparator))\n        {\n            return (ImmutableSortedMultiset<E>) RegularImmutableSortedMultiset.NATURAL_EMPTY_MULTISET;\n        }\n        else\n        {\n            return new RegularImmutableSortedMultiset<E>(comparator);\n        }\n    }\n\n    ImmutableSortedMultiset() {}\n\n    @Override\n    public final Comparator<? super E> comparator()\n    {\n        return elementSet().comparator();\n    }\n\n    @Override\n    public abstract ImmutableSortedSet<E> elementSet();\n\n    @LazyInit transient ImmutableSortedMultiset<E> descendingMultiset;\n\n    @Override\n    public ImmutableSortedMultiset<E> descendingMultiset()\n    {\n        ImmutableSortedMultiset<E> result = descendingMultiset;\n        if (result == null)\n        {\n            return descendingMultiset =\n                       this.isEmpty()\n                       ? emptyMultiset(Ordering.from(comparator()).reverse())\n                       : new DescendingImmutableSortedMultiset<E>(this);\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>This implementation is guaranteed to throw an {@link UnsupportedOperationException}.\n     *\n     * @throws UnsupportedOperationException always\n     * @deprecated Unsupported operation.\n     */\n    @CanIgnoreReturnValue\n    @Deprecated\n    @Override\n    public final Entry<E> pollFirstEntry()\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>This implementation is guaranteed to throw an {@link UnsupportedOperationException}.\n     *\n     * @throws UnsupportedOperationException always\n     * @deprecated Unsupported operation.\n     */\n    @CanIgnoreReturnValue\n    @Deprecated\n    @Override\n    public final Entry<E> pollLastEntry()\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public abstract ImmutableSortedMultiset<E> headMultiset(E upperBound, BoundType boundType);\n\n    @Override\n    public ImmutableSortedMultiset<E> subMultiset(\n        E lowerBound, BoundType lowerBoundType, E upperBound, BoundType upperBoundType)\n    {\n        checkArgument(\n            comparator().compare(lowerBound, upperBound) <= 0,\n            \"Expected lowerBound <= upperBound but %s > %s\",\n            lowerBound,\n            upperBound);\n        return tailMultiset(lowerBound, lowerBoundType).headMultiset(upperBound, upperBoundType);\n    }\n\n    @Override\n    public abstract ImmutableSortedMultiset<E> tailMultiset(E lowerBound, BoundType boundType);\n\n    /**\n     * Returns a builder that creates immutable sorted multisets with an explicit comparator. If the\n     * comparator has a more general type than the set being generated, such as creating a {@code\n     * SortedMultiset<Integer>} with a {@code Comparator<Number>}, use the {@link Builder} constructor\n     * instead.\n     *\n     * @throws NullPointerException if {@code comparator} is null\n     */\n    public static <E> Builder<E> orderedBy(Comparator<E> comparator)\n    {\n        return new Builder<E>(comparator);\n    }\n\n    /**\n     * Returns a builder that creates immutable sorted multisets whose elements are ordered by the\n     * reverse of their natural ordering.\n     *\n     * <p>Note: the type parameter {@code E} extends {@code Comparable<?>} rather than {@code\n     * Comparable<? super E>} as a workaround for javac <a\n     * href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6468354\">bug 6468354</a>.\n     */\n\n    /**\n     * Returns a builder that creates immutable sorted multisets whose elements are ordered by their\n     * natural ordering. The sorted multisets use {@link Ordering#natural()} as the comparator. This\n     * method provides more type-safety than {@link #builder}, as it can be called only for classes\n     * that implement {@link Comparable}.\n     *\n     * <p>Note: the type parameter {@code E} extends {@code Comparable<?>} rather than {@code\n     * Comparable<? super E>} as a workaround for javac <a\n     * href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6468354\">bug 6468354</a>.\n     */\n    public static <E extends Comparable<?>> Builder<E> naturalOrder()\n    {\n        return new Builder<E>(Ordering.natural());\n    }\n\n    /**\n     * A builder for creating immutable multiset instances, especially {@code public static final}\n     * multisets (\"constant multisets\"). Example:\n     *\n     * <pre>{@code\n     * public static final ImmutableSortedMultiset<Bean> BEANS =\n     *     new ImmutableSortedMultiset.Builder<Bean>(colorComparator())\n     *         .addCopies(Bean.COCOA, 4)\n     *         .addCopies(Bean.GARDEN, 6)\n     *         .addCopies(Bean.RED, 8)\n     *         .addCopies(Bean.BLACK_EYED, 10)\n     *         .build();\n     * }</pre>\n     *\n     * <p>Builder instances can be reused; it is safe to call {@link #build} multiple times to build\n     * multiple multisets in series.\n     *\n     * @since 12.0\n     */\n    public static class Builder<E> extends ImmutableMultiset.Builder<E>\n    {\n        /*\n         * We keep an array of elements and counts.  Periodically -- when we need more room in the\n         * array, or when we're building, or the like -- we sort, deduplicate, and combine the counts.\n         * Negative counts indicate a setCount operation with ~counts[i].\n         */\n\n        private final Comparator<? super E> comparator;\n\n        @VisibleForTesting E[] elements;\n        private int[] counts;\n\n        /*\n         * The number of used positions in the elements array.  We deduplicate periodically, so this\n         * may fluctuate up and down.\n         */\n        private int length;\n\n        // True if we just called build() and the elements array is being used by a created ISM, meaning\n        // we shouldn't modify that array further.\n        private boolean forceCopyElements;\n\n        /**\n         * Creates a new builder. The returned builder is equivalent to the builder generated by {@link\n         * ImmutableSortedMultiset#orderedBy(Comparator)}.\n         */\n        @SuppressWarnings(\"unchecked\")\n        public Builder(Comparator<? super E> comparator)\n        {\n            super(true); // doesn't allocate hash table in supertype\n            this.comparator = checkNotNull(comparator);\n            this.elements = (E[]) new Object[ImmutableCollection.Builder.DEFAULT_INITIAL_CAPACITY];\n            this.counts = new int[ImmutableCollection.Builder.DEFAULT_INITIAL_CAPACITY];\n        }\n\n        /** Check if we need to do deduplication and coalescing, and if so, do it. */\n        private void maintenance()\n        {\n            if (length == elements.length)\n            {\n                dedupAndCoalesce(true);\n            }\n            else if (forceCopyElements)\n            {\n                this.elements = Arrays.copyOf(elements, elements.length);\n                // we don't currently need to copy the counts array, because we don't use it directly\n                // in built ISMs\n            }\n            forceCopyElements = false;\n        }\n\n        private void dedupAndCoalesce(boolean maybeExpand)\n        {\n            if (length == 0)\n            {\n                return;\n            }\n            E[] sortedElements = Arrays.copyOf(elements, length);\n            Arrays.sort(sortedElements, comparator);\n            int uniques = 1;\n            for (int i = 1; i < sortedElements.length; i++)\n            {\n                if (comparator.compare(sortedElements[uniques - 1], sortedElements[i]) < 0)\n                {\n                    sortedElements[uniques] = sortedElements[i];\n                    uniques++;\n                }\n            }\n            Arrays.fill(sortedElements, uniques, length, null);\n            if (maybeExpand && uniques * 4 > length * 3)\n            {\n                // lots of nonduplicated elements, expand the array by 50%\n                sortedElements =\n                    Arrays.copyOf(sortedElements, IntMath.saturatedAdd(length, length / 2 + 1));\n            }\n            int[] sortedCounts = new int[sortedElements.length];\n            for (int i = 0; i < length; i++)\n            {\n                int index = Arrays.binarySearch(sortedElements, 0, uniques, elements[i], comparator);\n                if (counts[i] >= 0)\n                {\n                    sortedCounts[index] += counts[i];\n                }\n                else\n                {\n                    sortedCounts[index] = ~counts[i];\n                }\n            }\n            // Note that we're not getting rid, yet, of elements with count 0.  We'll do that in build().\n            this.elements = sortedElements;\n            this.counts = sortedCounts;\n            this.length = uniques;\n        }\n\n        /**\n         * Adds {@code element} to the {@code ImmutableSortedMultiset}.\n         *\n         * @param element the element to add\n         * @return this {@code Builder} object\n         * @throws NullPointerException if {@code element} is null\n         */\n        @CanIgnoreReturnValue\n        @Override\n        public Builder<E> add(E element)\n        {\n            return addCopies(element, 1);\n        }\n\n        /**\n         * Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.\n         *\n         * @param elements the elements to add\n         * @return this {@code Builder} object\n         * @throws NullPointerException if {@code elements} is null or contains a null element\n         */\n        @CanIgnoreReturnValue\n        @Override\n        public Builder<E> add(E... elements)\n        {\n            for (E element : elements)\n            {\n                add(element);\n            }\n            return this;\n        }\n\n        /**\n         * Adds a number of occurrences of an element to this {@code ImmutableSortedMultiset}.\n         *\n         * @param element the element to add\n         * @param occurrences the number of occurrences of the element to add. May be zero, in which\n         *     case no change will be made.\n         * @return this {@code Builder} object\n         * @throws NullPointerException if {@code element} is null\n         * @throws IllegalArgumentException if {@code occurrences} is negative, or if this operation\n         *     would result in more than {@link Integer#MAX_VALUE} occurrences of the element\n         */\n        @CanIgnoreReturnValue\n        @Override\n        public Builder<E> addCopies(E element, int occurrences)\n        {\n            checkNotNull(element);\n            CollectPreconditions.checkNonnegative(occurrences, \"occurrences\");\n            if (occurrences == 0)\n            {\n                return this;\n            }\n            maintenance();\n            elements[length] = element;\n            counts[length] = occurrences;\n            length++;\n            return this;\n        }\n\n        /**\n         * Adds or removes the necessary occurrences of an element such that the element attains the\n         * desired count.\n         *\n         * @param element the element to add or remove occurrences of\n         * @param count the desired count of the element in this multiset\n         * @return this {@code Builder} object\n         * @throws NullPointerException if {@code element} is null\n         * @throws IllegalArgumentException if {@code count} is negative\n         */\n        @CanIgnoreReturnValue\n        @Override\n        public Builder<E> setCount(E element, int count)\n        {\n            checkNotNull(element);\n            CollectPreconditions.checkNonnegative(count, \"count\");\n            maintenance();\n            elements[length] = element;\n            counts[length] = ~count;\n            length++;\n            return this;\n        }\n\n        /**\n         * Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.\n         *\n         * @param elements the {@code Iterable} to add to the {@code ImmutableSortedMultiset}\n         * @return this {@code Builder} object\n         * @throws NullPointerException if {@code elements} is null or contains a null element\n         */\n        @CanIgnoreReturnValue\n        @Override\n        public Builder<E> addAll(Iterable<? extends E> elements)\n        {\n            if (elements instanceof Multiset)\n            {\n                for (Entry<? extends E> entry : ((Multiset<? extends E>) elements).entrySet())\n                {\n                    addCopies(entry.getElement(), entry.getCount());\n                }\n            }\n            else\n            {\n                for (E e : elements)\n                {\n                    add(e);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.\n         *\n         * @param elements the elements to add to the {@code ImmutableSortedMultiset}\n         * @return this {@code Builder} object\n         * @throws NullPointerException if {@code elements} is null or contains a null element\n         */\n        @CanIgnoreReturnValue\n        @Override\n        public Builder<E> addAll(Iterator<? extends E> elements)\n        {\n            while (elements.hasNext())\n            {\n                add(elements.next());\n            }\n            return this;\n        }\n\n        private void dedupAndCoalesceAndDeleteEmpty()\n        {\n            dedupAndCoalesce(false);\n\n            // If there was a setCount(elem, 0), those elements are still present.  Eliminate them.\n            int size = 0;\n            for (int i = 0; i < length; i++)\n            {\n                if (counts[i] > 0)\n                {\n                    elements[size] = elements[i];\n                    counts[size] = counts[i];\n                    size++;\n                }\n            }\n            Arrays.fill(elements, size, length, null);\n            Arrays.fill(counts, size, length, 0);\n            length = size;\n        }\n\n        /**\n         * Returns a newly-created {@code ImmutableSortedMultiset} based on the contents of the {@code\n         * Builder}.\n         */\n        @Override\n        public ImmutableSortedMultiset<E> build()\n        {\n            dedupAndCoalesceAndDeleteEmpty();\n            if (length == 0)\n            {\n                return emptyMultiset(comparator);\n            }\n            RegularImmutableSortedSet<E> elementSet =\n                (RegularImmutableSortedSet<E>) ImmutableSortedSet.construct(comparator, length, elements);\n            long[] cumulativeCounts = new long[length + 1];\n            for (int i = 0; i < length; i++)\n            {\n                cumulativeCounts[i + 1] = cumulativeCounts[i] + counts[i];\n            }\n            forceCopyElements = true;\n            return new RegularImmutableSortedMultiset<E>(elementSet, cumulativeCounts, 0, length);\n        }\n    }\n\n    private static final class SerializedForm<E> implements Serializable\n    {\n        final Comparator<? super E> comparator;\n        final E[] elements;\n        final int[] counts;\n\n        @SuppressWarnings(\"unchecked\")\n        SerializedForm(SortedMultiset<E> multiset)\n        {\n            this.comparator = multiset.comparator();\n            int n = multiset.entrySet().size();\n            elements = (E[]) new Object[n];\n            counts = new int[n];\n            int i = 0;\n            for (Entry<E> entry : multiset.entrySet())\n            {\n                elements[i] = entry.getElement();\n                counts[i] = entry.getCount();\n                i++;\n            }\n        }\n\n        Object readResolve()\n        {\n            int n = elements.length;\n            Builder<E> builder = new Builder<>(comparator);\n            for (int i = 0; i < n; i++)\n            {\n                builder.addCopies(elements[i], counts[i]);\n            }\n            return builder.build();\n        }\n    }\n\n    @Override\n    Object writeReplace()\n    {\n        return new SerializedForm<E>(this);\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/collect/Multisets.java", "func_name": "Multisets.retainOccurrencesImpl", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Delegate implementation which cares about the element type.", "docstring_tokens": ["Delegate", "implementation", "which", "cares", "about", "the", "element", "type", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/collect/Multisets.java#L716-L735", "partition": "valid", "up_fun_num": 15, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.collect.CollectPreconditions.checkNonnegative;", "import static com.google.common.collect.CollectPreconditions.checkRemove;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.base.Objects;", "import com.google.common.base.Predicate;", "import com.google.common.base.Predicates;", "import com.google.common.collect.Multiset.Entry;", "import com.google.common.math.IntMath;", "import com.google.common.primitives.Ints;", "import com.google.errorprone.annotations.CanIgnoreReturnValue;", "import java.io.Serializable;", "import java.util.Arrays;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.Comparator;", "import java.util.Iterator;", "import java.util.NoSuchElementException;", "import java.util.Set;", "import java.util.Spliterator;", "import java.util.stream.Collector;", "import org.checkerframework.checker.nullness.qual.MonotonicNonNull;", "import org.checkerframework.checker.nullness.qual.Nullable;"], "function": ["public final class Multisets\n", "    public static <T, E, M extends Multiset<E>> Collector<T, ?, M> toMultiset(\n", "    public static <E> Multiset<E> unmodifiableMultiset(Multiset<? extends E> multiset)\n", "    public static <E> Multiset<E> unmodifiableMultiset(ImmutableMultiset<E> multiset)\n", "    public static <E> SortedMultiset<E> unmodifiableSortedMultiset(SortedMultiset<E> sortedMultiset)\n", "    public static <E> Multiset.Entry<E> immutableEntry(@Nullable E e, int n)\n", "    public static <E> Multiset<E> filter(Multiset<E> unfiltered, Predicate<? super E> predicate)\n", "    static int inferDistinctElements(Iterable<?> elements)\n", "    public static <E> Multiset<E> union(\n", "    public static <E> Multiset<E> intersection(\n", "    public static <E> Multiset<E> sum(\n", "    public static <E> Multiset<E> difference(\n", "    public static boolean containsOccurrences(Multiset<?> superMultiset, Multiset<?> subMultiset)\n", "    public static boolean retainOccurrences(\n", "    public static boolean removeOccurrences(\n", "    public static boolean removeOccurrences(\n", "    static boolean equalsImpl(Multiset<?> multiset, @Nullable Object object)\n", "    static <E> boolean addAllImpl(Multiset<E> self, Collection<? extends E> elements)\n", "    private static <E> boolean addAllImpl(Multiset<E> self, Multiset<? extends E> elements)\n", "    static boolean removeAllImpl(Multiset<?> self, Collection<?> elementsToRemove)\n", "    static boolean retainAllImpl(Multiset<?> self, Collection<?> elementsToRetain)\n", "    static <E> int setCountImpl(Multiset<E> self, E element, int count)\n", "    static <E> boolean setCountImpl(Multiset<E> self, E element, int oldCount, int newCount)\n", "    static <E> Iterator<E> elementIterator(Iterator<Entry<E>> entryIterator)\n", "    static <E> Iterator<E> iteratorImpl(Multiset<E> multiset)\n", "    static <E> Spliterator<E> spliteratorImpl(Multiset<E> multiset)\n", "    static int linearTimeSizeImpl(Multiset<?> multiset)\n", "    static <T> Multiset<T> cast(Iterable<T> iterable)\n", "    public static <E> ImmutableMultiset<E> copyHighestCountFirst(Multiset<E> multiset)\n"], "context": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.collect.CollectPreconditions.checkNonnegative;\nimport static com.google.common.collect.CollectPreconditions.checkRemove;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.base.Objects;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport com.google.common.collect.Multiset.Entry;\nimport com.google.common.math.IntMath;\nimport com.google.common.primitives.Ints;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\nimport java.util.Spliterator;\nimport java.util.stream.Collector;\nimport org.checkerframework.checker.nullness.qual.MonotonicNonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\n/**\n * Provides static utility methods for creating and working with {@link Multiset} instances.\n *\n * <p>See the Guava User Guide article on <a href=\n * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#multisets\"> {@code\n * Multisets}</a>.\n *\n * @author Kevin Bourrillion\n * @author Mike Bostock\n * @author Louis Wasserman\n * @since 2.0\n */\n@GwtCompatible\npublic final class Multisets\n{\n    private Multisets() {}\n\n    /**\n     * Returns a {@code Collector} that accumulates elements into a multiset created via the specified\n     * {@code Supplier}, whose elements are the result of applying {@code elementFunction} to the\n     * inputs, with counts equal to the result of applying {@code countFunction} to the inputs.\n     * Elements are added in encounter order.\n     *\n     * <p>If the mapped elements contain duplicates (according to {@link Object#equals}), the element\n     * will be added more than once, with the count summed over all appearances of the element.\n     *\n     * <p>Note that {@code stream.collect(toMultiset(function, e -> 1, supplier))} is equivalent to\n     * {@code stream.map(function).collect(Collectors.toCollection(supplier))}.\n     *\n     * @since 22.0\n     */\n    public static <T, E, M extends Multiset<E>> Collector<T, ?, M> toMultiset(\n        java.util.function.Function<? super T, E> elementFunction,\n        java.util.function.ToIntFunction<? super T> countFunction,\n        java.util.function.Supplier<M> multisetSupplier)\n    {\n        checkNotNull(elementFunction);\n        checkNotNull(countFunction);\n        checkNotNull(multisetSupplier);\n        return Collector.of(\n                   multisetSupplier,\n                   (ms, t) -> ms.add(elementFunction.apply(t), countFunction.applyAsInt(t)),\n                   (ms1, ms2) ->\n        {\n            ms1.addAll(ms2);\n            return ms1;\n        });\n    }\n\n    /**\n     * Returns an unmodifiable view of the specified multiset. Query operations on the returned\n     * multiset \"read through\" to the specified multiset, and attempts to modify the returned multiset\n     * result in an {@link UnsupportedOperationException}.\n     *\n     * <p>The returned multiset will be serializable if the specified multiset is serializable.\n     *\n     * @param multiset the multiset for which an unmodifiable view is to be generated\n     * @return an unmodifiable view of the multiset\n     */\n    public static <E> Multiset<E> unmodifiableMultiset(Multiset<? extends E> multiset)\n    {\n        if (multiset instanceof UnmodifiableMultiset || multiset instanceof ImmutableMultiset)\n        {\n            @SuppressWarnings(\"unchecked\") // Since it's unmodifiable, the covariant cast is safe\n            Multiset<E> result = (Multiset<E>) multiset;\n            return result;\n        }\n        return new UnmodifiableMultiset<E>(checkNotNull(multiset));\n    }\n\n    /**\n     * Simply returns its argument.\n     *\n     * @deprecated no need to use this\n     * @since 10.0\n     */\n    @Deprecated\n    public static <E> Multiset<E> unmodifiableMultiset(ImmutableMultiset<E> multiset)\n    {\n        return checkNotNull(multiset);\n    }\n\n    static class UnmodifiableMultiset<E> extends ForwardingMultiset<E> implements Serializable\n    {\n        final Multiset<? extends E> delegate;\n\n        UnmodifiableMultiset(Multiset<? extends E> delegate)\n        {\n            this.delegate = delegate;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        protected Multiset<E> delegate()\n        {\n            // This is safe because all non-covariant methods are overridden\n            return (Multiset<E>) delegate;\n        }\n\n        @MonotonicNonNull transient Set<E> elementSet;\n\n        Set<E> createElementSet()\n        {\n            return Collections.<E>unmodifiableSet(delegate.elementSet());\n        }\n\n        @Override\n        public Set<E> elementSet()\n        {\n            Set<E> es = elementSet;\n            return (es == null) ? elementSet = createElementSet() : es;\n        }\n\n        @MonotonicNonNull transient Set<Multiset.Entry<E>> entrySet;\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public Set<Multiset.Entry<E>> entrySet()\n        {\n            Set<Multiset.Entry<E>> es = entrySet;\n            return (es == null)\n                   // Safe because the returned set is made unmodifiable and Entry\n                   // itself is readonly\n                   ? entrySet = (Set) Collections.unmodifiableSet(delegate.entrySet())\n                                : es;\n        }\n\n        @Override\n        public Iterator<E> iterator()\n        {\n            return Iterators.<E>unmodifiableIterator(delegate.iterator());\n        }\n\n        @Override\n        public boolean add(E element)\n        {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public int add(E element, int occurences)\n        {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean addAll(Collection<? extends E> elementsToAdd)\n        {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean remove(Object element)\n        {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public int remove(Object element, int occurrences)\n        {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean removeAll(Collection<?> elementsToRemove)\n        {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean retainAll(Collection<?> elementsToRetain)\n        {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public void clear()\n        {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public int setCount(E element, int count)\n        {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean setCount(E element, int oldCount, int newCount)\n        {\n            throw new UnsupportedOperationException();\n        }\n\n        private static final long serialVersionUID = 0;\n    }\n\n    /**\n     * Returns an unmodifiable view of the specified sorted multiset. Query operations on the returned\n     * multiset \"read through\" to the specified multiset, and attempts to modify the returned multiset\n     * result in an {@link UnsupportedOperationException}.\n     *\n     * <p>The returned multiset will be serializable if the specified multiset is serializable.\n     *\n     * @param sortedMultiset the sorted multiset for which an unmodifiable view is to be generated\n     * @return an unmodifiable view of the multiset\n     * @since 11.0\n     */\n    @Beta\n    public static <E> SortedMultiset<E> unmodifiableSortedMultiset(SortedMultiset<E> sortedMultiset)\n    {\n        // it's in its own file so it can be emulated for GWT\n        return new UnmodifiableSortedMultiset<E>(checkNotNull(sortedMultiset));\n    }\n\n    /**\n     * Returns an immutable multiset entry with the specified element and count. The entry will be\n     * serializable if {@code e} is.\n     *\n     * @param e the element to be associated with the returned entry\n     * @param n the count to be associated with the returned entry\n     * @throws IllegalArgumentException if {@code n} is negative\n     */\n    public static <E> Multiset.Entry<E> immutableEntry(@Nullable E e, int n)\n    {\n        return new ImmutableEntry<E>(e, n);\n    }\n\n    static class ImmutableEntry<E> extends AbstractEntry<E> implements Serializable\n    {\n        private final @Nullable E element;\n        private final int count;\n\n        ImmutableEntry(@Nullable E element, int count)\n        {\n            this.element = element;\n            this.count = count;\n            checkNonnegative(count, \"count\");\n        }\n\n        @Override\n        public final @Nullable E getElement()\n        {\n            return element;\n        }\n\n        @Override\n        public final int getCount()\n        {\n            return count;\n        }\n\n        public ImmutableEntry<E> nextInBucket()\n        {\n            return null;\n        }\n\n        private static final long serialVersionUID = 0;\n    }\n\n    /**\n     * Returns a view of the elements of {@code unfiltered} that satisfy a predicate. The returned\n     * multiset is a live view of {@code unfiltered}; changes to one affect the other.\n     *\n     * <p>The resulting multiset's iterators, and those of its {@code entrySet()} and {@code\n     * elementSet()}, do not support {@code remove()}. However, all other multiset methods supported\n     * by {@code unfiltered} are supported by the returned multiset. When given an element that\n     * doesn't satisfy the predicate, the multiset's {@code add()} and {@code addAll()} methods throw\n     * an {@link IllegalArgumentException}. When methods such as {@code removeAll()} and {@code\n     * clear()} are called on the filtered multiset, only elements that satisfy the filter will be\n     * removed from the underlying multiset.\n     *\n     * <p>The returned multiset isn't threadsafe or serializable, even if {@code unfiltered} is.\n     *\n     * <p>Many of the filtered multiset's methods, such as {@code size()}, iterate across every\n     * element in the underlying multiset and determine which elements satisfy the filter. When a live\n     * view is <i>not</i> needed, it may be faster to copy the returned multiset and use the copy.\n     *\n     * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>, as documented at\n     * {@link Predicate#apply}. Do not provide a predicate such as {@code\n     * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link\n     * Iterables#filter(Iterable, Class)} for related functionality.)\n     *\n     * @since 14.0\n     */\n    @Beta\n    public static <E> Multiset<E> filter(Multiset<E> unfiltered, Predicate<? super E> predicate)\n    {\n        if (unfiltered instanceof FilteredMultiset)\n        {\n            // Support clear(), removeAll(), and retainAll() when filtering a filtered\n            // collection.\n            FilteredMultiset<E> filtered = (FilteredMultiset<E>) unfiltered;\n            Predicate<E> combinedPredicate = Predicates.<E> and (filtered.predicate, predicate);\n            return new FilteredMultiset<E>(filtered.unfiltered, combinedPredicate);\n        }\n        return new FilteredMultiset<E>(unfiltered, predicate);\n    }\n\n    private static final class FilteredMultiset<E> extends ViewMultiset<E>\n    {\n        final Multiset<E> unfiltered;\n        final Predicate<? super E> predicate;\n\n        FilteredMultiset(Multiset<E> unfiltered, Predicate<? super E> predicate)\n        {\n            this.unfiltered = checkNotNull(unfiltered);\n            this.predicate = checkNotNull(predicate);\n        }\n\n        @Override\n        public UnmodifiableIterator<E> iterator()\n        {\n            return Iterators.filter(unfiltered.iterator(), predicate);\n        }\n\n        @Override\n        Set<E> createElementSet()\n        {\n            return Sets.filter(unfiltered.elementSet(), predicate);\n        }\n\n        @Override\n        Iterator<E> elementIterator()\n        {\n            throw new AssertionError(\"should never be called\");\n        }\n\n        @Override\n        Set<Entry<E>> createEntrySet()\n        {\n            return Sets.filter(\n                       unfiltered.entrySet(),\n                       new Predicate<Entry<E>>()\n            {\n                @Override\n                public boolean apply(Entry<E> entry)\n                {\n                    return predicate.apply(entry.getElement());\n                }\n            });\n        }\n\n        @Override\n        Iterator<Entry<E>> entryIterator()\n        {\n            throw new AssertionError(\"should never be called\");\n        }\n\n        @Override\n        public int count(@Nullable Object element)\n        {\n            int count = unfiltered.count(element);\n            if (count > 0)\n            {\n                @SuppressWarnings(\"unchecked\") // element is equal to an E\n                E e = (E) element;\n                return predicate.apply(e) ? count : 0;\n            }\n            return 0;\n        }\n\n        @Override\n        public int add(@Nullable E element, int occurrences)\n        {\n            checkArgument(\n                predicate.apply(element), \"Element %s does not match predicate %s\", element, predicate);\n            return unfiltered.add(element, occurrences);\n        }\n\n        @Override\n        public int remove(@Nullable Object element, int occurrences)\n        {\n            checkNonnegative(occurrences, \"occurrences\");\n            if (occurrences == 0)\n            {\n                return count(element);\n            }\n            else\n            {\n                return contains(element) ? unfiltered.remove(element, occurrences) : 0;\n            }\n        }\n    }\n\n    /**\n     * Returns the expected number of distinct elements given the specified elements. The number of\n     * distinct elements is only computed if {@code elements} is an instance of {@code Multiset};\n     * otherwise the default value of 11 is returned.\n     */\n    static int inferDistinctElements(Iterable<?> elements)\n    {\n        if (elements instanceof Multiset)\n        {\n            return ((Multiset<?>) elements).elementSet().size();\n        }\n        return 11; // initial capacity will be rounded up to 16\n    }\n\n    /**\n     * Returns an unmodifiable view of the union of two multisets. In the returned multiset, the count\n     * of each element is the <i>maximum</i> of its counts in the two backing multisets. The iteration\n     * order of the returned multiset matches that of the element set of {@code multiset1} followed by\n     * the members of the element set of {@code multiset2} that are not contained in {@code\n     * multiset1}, with repeated occurrences of the same element appearing consecutively.\n     *\n     * <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different\n     * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).\n     *\n     * @since 14.0\n     */\n    @Beta\n    public static <E> Multiset<E> union(\n        final Multiset<? extends E> multiset1, final Multiset<? extends E> multiset2)\n    {\n        checkNotNull(multiset1);\n        checkNotNull(multiset2);\n\n        return new ViewMultiset<E>()\n        {\n            @Override\n            public boolean contains(@Nullable Object element)\n            {\n                return multiset1.contains(element) || multiset2.contains(element);\n            }\n\n            @Override\n            public boolean isEmpty()\n            {\n                return multiset1.isEmpty() && multiset2.isEmpty();\n            }\n\n            @Override\n            public int count(Object element)\n            {\n                return Math.max(multiset1.count(element), multiset2.count(element));\n            }\n\n            @Override\n            Set<E> createElementSet()\n            {\n                return Sets.union(multiset1.elementSet(), multiset2.elementSet());\n            }\n\n            @Override\n            Iterator<E> elementIterator()\n            {\n                throw new AssertionError(\"should never be called\");\n            }\n\n            @Override\n            Iterator<Entry<E>> entryIterator()\n            {\n                final Iterator<? extends Entry<? extends E>> iterator1 = multiset1.entrySet().iterator();\n                final Iterator<? extends Entry<? extends E>> iterator2 = multiset2.entrySet().iterator();\n                // TODO(lowasser): consider making the entries live views\n                return new AbstractIterator<Entry<E>>()\n                {\n                    @Override\n                    protected Entry<E> computeNext()\n                    {\n                        if (iterator1.hasNext())\n                        {\n                            Entry<? extends E> entry1 = iterator1.next();\n                            E element = entry1.getElement();\n                            int count = Math.max(entry1.getCount(), multiset2.count(element));\n                            return immutableEntry(element, count);\n                        }\n                        while (iterator2.hasNext())\n                        {\n                            Entry<? extends E> entry2 = iterator2.next();\n                            E element = entry2.getElement();\n                            if (!multiset1.contains(element))\n                            {\n                                return immutableEntry(element, entry2.getCount());\n                            }\n                        }\n                        return endOfData();\n                    }\n                };\n            }\n        };\n    }\n\n    /**\n     * Returns an unmodifiable view of the intersection of two multisets. In the returned multiset,\n     * the count of each element is the <i>minimum</i> of its counts in the two backing multisets,\n     * with elements that would have a count of 0 not included. The iteration order of the returned\n     * multiset matches that of the element set of {@code multiset1}, with repeated occurrences of the\n     * same element appearing consecutively.\n     *\n     * <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different\n     * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).\n     *\n     * @since 2.0\n     */\n    public static <E> Multiset<E> intersection(\n        final Multiset<E> multiset1, final Multiset<?> multiset2)\n    {\n        checkNotNull(multiset1);\n        checkNotNull(multiset2);\n\n        return new ViewMultiset<E>()\n        {\n            @Override\n            public int count(Object element)\n            {\n                int count1 = multiset1.count(element);\n                return (count1 == 0) ? 0 : Math.min(count1, multiset2.count(element));\n            }\n\n            @Override\n            Set<E> createElementSet()\n            {\n                return Sets.intersection(multiset1.elementSet(), multiset2.elementSet());\n            }\n\n            @Override\n            Iterator<E> elementIterator()\n            {\n                throw new AssertionError(\"should never be called\");\n            }\n\n            @Override\n            Iterator<Entry<E>> entryIterator()\n            {\n                final Iterator<Entry<E>> iterator1 = multiset1.entrySet().iterator();\n                // TODO(lowasser): consider making the entries live views\n                return new AbstractIterator<Entry<E>>()\n                {\n                    @Override\n                    protected Entry<E> computeNext()\n                    {\n                        while (iterator1.hasNext())\n                        {\n                            Entry<E> entry1 = iterator1.next();\n                            E element = entry1.getElement();\n                            int count = Math.min(entry1.getCount(), multiset2.count(element));\n                            if (count > 0)\n                            {\n                                return immutableEntry(element, count);\n                            }\n                        }\n                        return endOfData();\n                    }\n                };\n            }\n        };\n    }\n\n    /**\n     * Returns an unmodifiable view of the sum of two multisets. In the returned multiset, the count\n     * of each element is the <i>sum</i> of its counts in the two backing multisets. The iteration\n     * order of the returned multiset matches that of the element set of {@code multiset1} followed by\n     * the members of the element set of {@code multiset2} that are not contained in {@code\n     * multiset1}, with repeated occurrences of the same element appearing consecutively.\n     *\n     * <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different\n     * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).\n     *\n     * @since 14.0\n     */\n    @Beta\n    public static <E> Multiset<E> sum(\n        final Multiset<? extends E> multiset1, final Multiset<? extends E> multiset2)\n    {\n        checkNotNull(multiset1);\n        checkNotNull(multiset2);\n\n        // TODO(lowasser): consider making the entries live views\n        return new ViewMultiset<E>()\n        {\n            @Override\n            public boolean contains(@Nullable Object element)\n            {\n                return multiset1.contains(element) || multiset2.contains(element);\n            }\n\n            @Override\n            public boolean isEmpty()\n            {\n                return multiset1.isEmpty() && multiset2.isEmpty();\n            }\n\n            @Override\n            public int size()\n            {\n                return IntMath.saturatedAdd(multiset1.size(), multiset2.size());\n            }\n\n            @Override\n            public int count(Object element)\n            {\n                return multiset1.count(element) + multiset2.count(element);\n            }\n\n            @Override\n            Set<E> createElementSet()\n            {\n                return Sets.union(multiset1.elementSet(), multiset2.elementSet());\n            }\n\n            @Override\n            Iterator<E> elementIterator()\n            {\n                throw new AssertionError(\"should never be called\");\n            }\n\n            @Override\n            Iterator<Entry<E>> entryIterator()\n            {\n                final Iterator<? extends Entry<? extends E>> iterator1 = multiset1.entrySet().iterator();\n                final Iterator<? extends Entry<? extends E>> iterator2 = multiset2.entrySet().iterator();\n                return new AbstractIterator<Entry<E>>()\n                {\n                    @Override\n                    protected Entry<E> computeNext()\n                    {\n                        if (iterator1.hasNext())\n                        {\n                            Entry<? extends E> entry1 = iterator1.next();\n                            E element = entry1.getElement();\n                            int count = entry1.getCount() + multiset2.count(element);\n                            return immutableEntry(element, count);\n                        }\n                        while (iterator2.hasNext())\n                        {\n                            Entry<? extends E> entry2 = iterator2.next();\n                            E element = entry2.getElement();\n                            if (!multiset1.contains(element))\n                            {\n                                return immutableEntry(element, entry2.getCount());\n                            }\n                        }\n                        return endOfData();\n                    }\n                };\n            }\n        };\n    }\n\n    /**\n     * Returns an unmodifiable view of the difference of two multisets. In the returned multiset, the\n     * count of each element is the result of the <i>zero-truncated subtraction</i> of its count in\n     * the second multiset from its count in the first multiset, with elements that would have a count\n     * of 0 not included. The iteration order of the returned multiset matches that of the element set\n     * of {@code multiset1}, with repeated occurrences of the same element appearing consecutively.\n     *\n     * <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different\n     * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).\n     *\n     * @since 14.0\n     */\n    @Beta\n    public static <E> Multiset<E> difference(\n        final Multiset<E> multiset1, final Multiset<?> multiset2)\n    {\n        checkNotNull(multiset1);\n        checkNotNull(multiset2);\n\n        // TODO(lowasser): consider making the entries live views\n        return new ViewMultiset<E>()\n        {\n            @Override\n            public int count(@Nullable Object element)\n            {\n                int count1 = multiset1.count(element);\n                return (count1 == 0) ? 0 : Math.max(0, count1 - multiset2.count(element));\n            }\n\n            @Override\n            public void clear()\n            {\n                throw new UnsupportedOperationException();\n            }\n\n            @Override\n            Iterator<E> elementIterator()\n            {\n                final Iterator<Entry<E>> iterator1 = multiset1.entrySet().iterator();\n                return new AbstractIterator<E>()\n                {\n                    @Override\n                    protected E computeNext()\n                    {\n                        while (iterator1.hasNext())\n                        {\n                            Entry<E> entry1 = iterator1.next();\n                            E element = entry1.getElement();\n                            if (entry1.getCount() > multiset2.count(element))\n                            {\n                                return element;\n                            }\n                        }\n                        return endOfData();\n                    }\n                };\n            }\n\n            @Override\n            Iterator<Entry<E>> entryIterator()\n            {\n                final Iterator<Entry<E>> iterator1 = multiset1.entrySet().iterator();\n                return new AbstractIterator<Entry<E>>()\n                {\n                    @Override\n                    protected Entry<E> computeNext()\n                    {\n                        while (iterator1.hasNext())\n                        {\n                            Entry<E> entry1 = iterator1.next();\n                            E element = entry1.getElement();\n                            int count = entry1.getCount() - multiset2.count(element);\n                            if (count > 0)\n                            {\n                                return immutableEntry(element, count);\n                            }\n                        }\n                        return endOfData();\n                    }\n                };\n            }\n\n            @Override\n            int distinctElements()\n            {\n                return Iterators.size(entryIterator());\n            }\n        };\n    }\n\n    /**\n     * Returns {@code true} if {@code subMultiset.count(o) <= superMultiset.count(o)} for all {@code\n     * o}.\n     *\n     * @since 10.0\n     */\n    @CanIgnoreReturnValue\n    public static boolean containsOccurrences(Multiset<?> superMultiset, Multiset<?> subMultiset)\n    {\n        checkNotNull(superMultiset);\n        checkNotNull(subMultiset);\n        for (Entry<?> entry : subMultiset.entrySet())\n        {\n            int superCount = superMultiset.count(entry.getElement());\n            if (superCount < entry.getCount())\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Modifies {@code multisetToModify} so that its count for an element {@code e} is at most {@code\n     * multisetToRetain.count(e)}.\n     *\n     * <p>To be precise, {@code multisetToModify.count(e)} is set to {@code\n     * Math.min(multisetToModify.count(e), multisetToRetain.count(e))}. This is similar to {@link\n     * #intersection(Multiset, Multiset) intersection} {@code (multisetToModify, multisetToRetain)},\n     * but mutates {@code multisetToModify} instead of returning a view.\n     *\n     * <p>In contrast, {@code multisetToModify.retainAll(multisetToRetain)} keeps all occurrences of\n     * elements that appear at all in {@code multisetToRetain}, and deletes all occurrences of all\n     * other elements.\n     *\n     * @return {@code true} if {@code multisetToModify} was changed as a result of this operation\n     * @since 10.0\n     */\n    @CanIgnoreReturnValue\n    public static boolean retainOccurrences(\n        Multiset<?> multisetToModify, Multiset<?> multisetToRetain)\n    {\n        return retainOccurrencesImpl(multisetToModify, multisetToRetain);\n    }\n\n    /** Delegate implementation which cares about the element type. */\n\n    /**\n     * For each occurrence of an element {@code e} in {@code occurrencesToRemove}, removes one\n     * occurrence of {@code e} in {@code multisetToModify}.\n     *\n     * <p>Equivalently, this method modifies {@code multisetToModify} so that {@code\n     * multisetToModify.count(e)} is set to {@code Math.max(0, multisetToModify.count(e) -\n     * Iterables.frequency(occurrencesToRemove, e))}.\n     *\n     * <p>This is <i>not</i> the same as {@code multisetToModify.} {@link Multiset#removeAll\n     * removeAll}{@code (occurrencesToRemove)}, which removes all occurrences of elements that appear\n     * in {@code occurrencesToRemove}. However, this operation <i>is</i> equivalent to, albeit\n     * sometimes more efficient than, the following:\n     *\n     * <pre>{@code\n     * for (E e : occurrencesToRemove) {\n     *   multisetToModify.remove(e);\n     * }\n     * }</pre>\n     *\n     * @return {@code true} if {@code multisetToModify} was changed as a result of this operation\n     * @since 18.0 (present in 10.0 with a requirement that the second parameter be a {@code\n     *     Multiset})\n     */\n    @CanIgnoreReturnValue\n    public static boolean removeOccurrences(\n        Multiset<?> multisetToModify, Iterable<?> occurrencesToRemove)\n    {\n        if (occurrencesToRemove instanceof Multiset)\n        {\n            return removeOccurrences(multisetToModify, (Multiset<?>) occurrencesToRemove);\n        }\n        else\n        {\n            checkNotNull(multisetToModify);\n            checkNotNull(occurrencesToRemove);\n            boolean changed = false;\n            for (Object o : occurrencesToRemove)\n            {\n                changed |= multisetToModify.remove(o);\n            }\n            return changed;\n        }\n    }\n\n    /**\n     * For each occurrence of an element {@code e} in {@code occurrencesToRemove}, removes one\n     * occurrence of {@code e} in {@code multisetToModify}.\n     *\n     * <p>Equivalently, this method modifies {@code multisetToModify} so that {@code\n     * multisetToModify.count(e)} is set to {@code Math.max(0, multisetToModify.count(e) -\n     * occurrencesToRemove.count(e))}.\n     *\n     * <p>This is <i>not</i> the same as {@code multisetToModify.} {@link Multiset#removeAll\n     * removeAll}{@code (occurrencesToRemove)}, which removes all occurrences of elements that appear\n     * in {@code occurrencesToRemove}. However, this operation <i>is</i> equivalent to, albeit\n     * sometimes more efficient than, the following:\n     *\n     * <pre>{@code\n     * for (E e : occurrencesToRemove) {\n     *   multisetToModify.remove(e);\n     * }\n     * }</pre>\n     *\n     * @return {@code true} if {@code multisetToModify} was changed as a result of this operation\n     * @since 10.0 (missing in 18.0 when only the overload taking an {@code Iterable} was present)\n     */\n    @CanIgnoreReturnValue\n    public static boolean removeOccurrences(\n        Multiset<?> multisetToModify, Multiset<?> occurrencesToRemove)\n    {\n        checkNotNull(multisetToModify);\n        checkNotNull(occurrencesToRemove);\n\n        boolean changed = false;\n        Iterator<? extends Entry<?>> entryIterator = multisetToModify.entrySet().iterator();\n        while (entryIterator.hasNext())\n        {\n            Entry<?> entry = entryIterator.next();\n            int removeCount = occurrencesToRemove.count(entry.getElement());\n            if (removeCount >= entry.getCount())\n            {\n                entryIterator.remove();\n                changed = true;\n            }\n            else if (removeCount > 0)\n            {\n                multisetToModify.remove(entry.getElement(), removeCount);\n                changed = true;\n            }\n        }\n        return changed;\n    }\n\n    /**\n     * Implementation of the {@code equals}, {@code hashCode}, and {@code toString} methods of {@link\n     * Multiset.Entry}.\n     */\n    abstract static class AbstractEntry<E> implements Multiset.Entry<E>\n    {\n        /**\n         * Indicates whether an object equals this entry, following the behavior specified in {@link\n         * Multiset.Entry#equals}.\n         */\n        @Override\n        public boolean equals(@Nullable Object object)\n        {\n            if (object instanceof Multiset.Entry)\n            {\n                Multiset.Entry<?> that = (Multiset.Entry<?>) object;\n                return this.getCount() == that.getCount()\n                       && Objects.equal(this.getElement(), that.getElement());\n            }\n            return false;\n        }\n\n        /**\n         * Return this entry's hash code, following the behavior specified in {@link\n         * Multiset.Entry#hashCode}.\n         */\n        @Override\n        public int hashCode()\n        {\n            E e = getElement();\n            return ((e == null) ? 0 : e.hashCode()) ^ getCount();\n        }\n\n        /**\n         * Returns a string representation of this multiset entry. The string representation consists of\n         * the associated element if the associated count is one, and otherwise the associated element\n         * followed by the characters \" x \" (space, x and space) followed by the count. Elements and\n         * counts are converted to strings as by {@code String.valueOf}.\n         */\n        @Override\n        public String toString()\n        {\n            String text = String.valueOf(getElement());\n            int n = getCount();\n            return (n == 1) ? text : (text + \" x \" + n);\n        }\n    }\n\n    /** An implementation of {@link Multiset#equals}. */\n    static boolean equalsImpl(Multiset<?> multiset, @Nullable Object object)\n    {\n        if (object == multiset)\n        {\n            return true;\n        }\n        if (object instanceof Multiset)\n        {\n            Multiset<?> that = (Multiset<?>) object;\n            /*\n             * We can't simply check whether the entry sets are equal, since that\n             * approach fails when a TreeMultiset has a comparator that returns 0\n             * when passed unequal elements.\n             */\n\n            if (multiset.size() != that.size() || multiset.entrySet().size() != that.entrySet().size())\n            {\n                return false;\n            }\n            for (Entry<?> entry : that.entrySet())\n            {\n                if (multiset.count(entry.getElement()) != entry.getCount())\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /** An implementation of {@link Multiset#addAll}. */\n    static <E> boolean addAllImpl(Multiset<E> self, Collection<? extends E> elements)\n    {\n        checkNotNull(self);\n        checkNotNull(elements);\n        if (elements instanceof Multiset)\n        {\n            return addAllImpl(self, cast(elements));\n        }\n        else if (elements.isEmpty())\n        {\n            return false;\n        }\n        else\n        {\n            return Iterators.addAll(self, elements.iterator());\n        }\n    }\n\n    /** A specialization of {@code addAllImpl} for when {@code elements} is itself a Multiset. */\n    private static <E> boolean addAllImpl(Multiset<E> self, Multiset<? extends E> elements)\n    {\n        if (elements.isEmpty())\n        {\n            return false;\n        }\n        elements.forEachEntry(self::add);\n        return true;\n    }\n\n    /** An implementation of {@link Multiset#removeAll}. */\n    static boolean removeAllImpl(Multiset<?> self, Collection<?> elementsToRemove)\n    {\n        Collection<?> collection =\n            (elementsToRemove instanceof Multiset)\n            ? ((Multiset<?>) elementsToRemove).elementSet()\n            : elementsToRemove;\n\n        return self.elementSet().removeAll(collection);\n    }\n\n    /** An implementation of {@link Multiset#retainAll}. */\n    static boolean retainAllImpl(Multiset<?> self, Collection<?> elementsToRetain)\n    {\n        checkNotNull(elementsToRetain);\n        Collection<?> collection =\n            (elementsToRetain instanceof Multiset)\n            ? ((Multiset<?>) elementsToRetain).elementSet()\n            : elementsToRetain;\n\n        return self.elementSet().retainAll(collection);\n    }\n\n    /** An implementation of {@link Multiset#setCount(Object, int)}. */\n    static <E> int setCountImpl(Multiset<E> self, E element, int count)\n    {\n        checkNonnegative(count, \"count\");\n\n        int oldCount = self.count(element);\n\n        int delta = count - oldCount;\n        if (delta > 0)\n        {\n            self.add(element, delta);\n        }\n        else if (delta < 0)\n        {\n            self.remove(element, -delta);\n        }\n\n        return oldCount;\n    }\n\n    /** An implementation of {@link Multiset#setCount(Object, int, int)}. */\n    static <E> boolean setCountImpl(Multiset<E> self, E element, int oldCount, int newCount)\n    {\n        checkNonnegative(oldCount, \"oldCount\");\n        checkNonnegative(newCount, \"newCount\");\n\n        if (self.count(element) == oldCount)\n        {\n            self.setCount(element, newCount);\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n    static <E> Iterator<E> elementIterator(Iterator<Entry<E>> entryIterator)\n    {\n        return new TransformedIterator<Entry<E>, E>(entryIterator)\n        {\n            @Override\n            E transform(Entry<E> entry)\n            {\n                return entry.getElement();\n            }\n        };\n    }\n\n    abstract static class ElementSet<E> extends Sets.ImprovedAbstractSet<E>\n    {\n        abstract Multiset<E> multiset();\n\n        @Override\n        public void clear()\n        {\n            multiset().clear();\n        }\n\n        @Override\n        public boolean contains(Object o)\n        {\n            return multiset().contains(o);\n        }\n\n        @Override\n        public boolean containsAll(Collection<?> c)\n        {\n            return multiset().containsAll(c);\n        }\n\n        @Override\n        public boolean isEmpty()\n        {\n            return multiset().isEmpty();\n        }\n\n        @Override\n        public abstract Iterator<E> iterator();\n\n        @Override\n        public boolean remove(Object o)\n        {\n            return multiset().remove(o, Integer.MAX_VALUE) > 0;\n        }\n\n        @Override\n        public int size()\n        {\n            return multiset().entrySet().size();\n        }\n    }\n\n    abstract static class EntrySet<E> extends Sets.ImprovedAbstractSet<Entry<E>>\n    {\n        abstract Multiset<E> multiset();\n\n        @Override\n        public boolean contains(@Nullable Object o)\n        {\n            if (o instanceof Entry)\n            {\n                /*\n                 * The GWT compiler wrongly issues a warning here.\n                 */\n                @SuppressWarnings(\"cast\")\n                Entry<?> entry = (Entry<?>) o;\n                if (entry.getCount() <= 0)\n                {\n                    return false;\n                }\n                int count = multiset().count(entry.getElement());\n                return count == entry.getCount();\n            }\n            return false;\n        }\n\n        // GWT compiler warning; see contains().\n        @SuppressWarnings(\"cast\")\n        @Override\n        public boolean remove(Object object)\n        {\n            if (object instanceof Multiset.Entry)\n            {\n                Entry<?> entry = (Entry<?>) object;\n                Object element = entry.getElement();\n                int entryCount = entry.getCount();\n                if (entryCount != 0)\n                {\n                    // Safe as long as we never add a new entry, which we won't.\n                    @SuppressWarnings(\"unchecked\")\n                    Multiset<Object> multiset = (Multiset) multiset();\n                    return multiset.setCount(element, entryCount, 0);\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public void clear()\n        {\n            multiset().clear();\n        }\n    }\n\n    /** An implementation of {@link Multiset#iterator}. */\n    static <E> Iterator<E> iteratorImpl(Multiset<E> multiset)\n    {\n        return new MultisetIteratorImpl<E>(multiset, multiset.entrySet().iterator());\n    }\n\n    static final class MultisetIteratorImpl<E> implements Iterator<E>\n    {\n        private final Multiset<E> multiset;\n        private final Iterator<Entry<E>> entryIterator;\n        @MonotonicNonNull private Entry<E> currentEntry;\n\n        /** Count of subsequent elements equal to current element */\n        private int laterCount;\n\n        /** Count of all elements equal to current element */\n        private int totalCount;\n\n        private boolean canRemove;\n\n        MultisetIteratorImpl(Multiset<E> multiset, Iterator<Entry<E>> entryIterator)\n        {\n            this.multiset = multiset;\n            this.entryIterator = entryIterator;\n        }\n\n        @Override\n        public boolean hasNext()\n        {\n            return laterCount > 0 || entryIterator.hasNext();\n        }\n\n        @Override\n        public E next()\n        {\n            if (!hasNext())\n            {\n                throw new NoSuchElementException();\n            }\n            if (laterCount == 0)\n            {\n                currentEntry = entryIterator.next();\n                totalCount = laterCount = currentEntry.getCount();\n            }\n            laterCount--;\n            canRemove = true;\n            return currentEntry.getElement();\n        }\n\n        @Override\n        public void remove()\n        {\n            checkRemove(canRemove);\n            if (totalCount == 1)\n            {\n                entryIterator.remove();\n            }\n            else\n            {\n                multiset.remove(currentEntry.getElement());\n            }\n            totalCount--;\n            canRemove = false;\n        }\n    }\n\n    static <E> Spliterator<E> spliteratorImpl(Multiset<E> multiset)\n    {\n        Spliterator<Entry<E>> entrySpliterator = multiset.entrySet().spliterator();\n        return CollectSpliterators.flatMap(\n                   entrySpliterator,\n                   entry -> Collections.nCopies(entry.getCount(), entry.getElement()).spliterator(),\n                   Spliterator.SIZED\n                   | (entrySpliterator.characteristics()\n                      & (Spliterator.ORDERED | Spliterator.NONNULL | Spliterator.IMMUTABLE)),\n                   multiset.size());\n    }\n\n    /** An implementation of {@link Multiset#size}. */\n    static int linearTimeSizeImpl(Multiset<?> multiset)\n    {\n        long size = 0;\n        for (Entry<?> entry : multiset.entrySet())\n        {\n            size += entry.getCount();\n        }\n        return Ints.saturatedCast(size);\n    }\n\n    /** Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557 */\n    static <T> Multiset<T> cast(Iterable<T> iterable)\n    {\n        return (Multiset<T>) iterable;\n    }\n\n    /**\n     * Returns a copy of {@code multiset} as an {@link ImmutableMultiset} whose iteration order is\n     * highest count first, with ties broken by the iteration order of the original multiset.\n     *\n     * @since 11.0\n     */\n    @Beta\n    public static <E> ImmutableMultiset<E> copyHighestCountFirst(Multiset<E> multiset)\n    {\n        Entry<E>[] entries = (Entry<E>[]) multiset.entrySet().toArray(new Entry[0]);\n        Arrays.sort(entries, DecreasingCount.INSTANCE);\n        return ImmutableMultiset.copyFromEntries(Arrays.asList(entries));\n    }\n\n    private static final class DecreasingCount implements Comparator<Entry<?>>\n    {\n        static final DecreasingCount INSTANCE = new DecreasingCount();\n\n        @Override\n        public int compare(Entry<?> entry1, Entry<?> entry2)\n        {\n            return entry2.getCount() - entry1.getCount(); // subtracting two nonnegative integers\n        }\n    }\n\n    /**\n     * An {@link AbstractMultiset} with additional default implementations, some of them linear-time\n     * implementations in terms of {@code elementSet} and {@code entrySet}.\n     */\n    private abstract static class ViewMultiset<E> extends AbstractMultiset<E>\n    {\n        @Override\n        public int size()\n        {\n            return linearTimeSizeImpl(this);\n        }\n\n        @Override\n        public void clear()\n        {\n            elementSet().clear();\n        }\n\n        @Override\n        public Iterator<E> iterator()\n        {\n            return iteratorImpl(this);\n        }\n\n        @Override\n        int distinctElements()\n        {\n            return elementSet().size();\n        }\n    }\n}"}
{"repo": "google/guava", "path": "guava/src/com/google/common/collect/TreeTraverser.java", "func_name": "TreeTraverser.preOrderTraversal", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns an unmodifiable iterable over the nodes in a tree structure, using pre-order traversal.\nThat is, each node's subtrees are traversed after the node itself is returned.\n\n<p>No guarantees are made about the behavior of the traversal when nodes change while iteration\nis in progress or when the iterators generated by {@link #children} are advanced.\n\n@deprecated Use {@link com.google.common.graph.Traverser#depthFirstPreOrder} instead, which has\nthe same behavior.", "docstring_tokens": ["Returns", "an", "unmodifiable", "iterable", "over", "the", "nodes", "in", "a", "tree", "structure", "using", "pre", "-", "order", "traversal", ".", "That", "is", "each", "node", "s", "subtrees", "are", "traversed", "after", "the", "node", "itself", "is", "returned", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/collect/TreeTraverser.java#L114-L135", "partition": "valid", "up_fun_num": 3, "levels": [0, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkNotNull;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.base.Function;", "import java.util.ArrayDeque;", "import java.util.Deque;", "import java.util.Iterator;", "import java.util.Queue;", "import java.util.function.Consumer;"], "function": ["public abstract class TreeTraverser<T>\n", "    public static <T> TreeTraverser<T> using(\n", "    public abstract Iterable<T> children(T root);\n", "    UnmodifiableIterator<T> preOrderIterator(T root)\n", "    public final FluentIterable<T> postOrderTraversal(final T root)\n", "    UnmodifiableIterator<T> postOrderIterator(T root)\n", "    public final FluentIterable<T> breadthFirstTraversal(final T root)\n"], "context": "/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.base.Function;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Iterator;\nimport java.util.Queue;\nimport java.util.function.Consumer;\n\n/**\n * Views elements of a type {@code T} as nodes in a tree, and provides methods to traverse the trees\n * induced by this traverser.\n *\n * <p>For example, the tree\n *\n * <pre>{@code\n *        h\n *      / | \\\n *     /  e  \\\n *    d       g\n *   /|\\      |\n *  / | \\     f\n * a  b  c\n * }</pre>\n *\n * <p>can be iterated over in preorder (hdabcegf), postorder (abcdefgh), or breadth-first order\n * (hdegabcf).\n *\n * <p>Null nodes are strictly forbidden.\n *\n * <p><b>For Java 8 users:</b> Because this is an abstract class, not an interface, you can't use a\n * lambda expression to extend it:\n *\n * <pre>{@code\n * // won't work\n * TreeTraverser<NodeType> traverser = node -> node.getChildNodes();\n * }</pre>\n *\n * Instead, you can pass a lambda expression to the {@code using} factory method:\n *\n * <pre>{@code\n * TreeTraverser<NodeType> traverser = TreeTraverser.using(node -> node.getChildNodes());\n * }</pre>\n *\n * @author Louis Wasserman\n * @since 15.0\n * @deprecated Use {@link com.google.common.graph.Traverser} instead. All instance methods have\n *     their equivalent on the result of {@code Traverser.forTree(tree)} where {@code tree}\n *     implements {@code SuccessorsFunction}, which has a similar API as {@link #children} or can be\n *     the same lambda function as passed into {@link #using(Function)}.\n *     <p>This class is scheduled to be removed in January 2019.\n */\n// TODO(b/68134636): Remove by 2019-01\n@Deprecated\n@Beta\n@GwtCompatible\npublic abstract class TreeTraverser<T>\n{\n\n    /**\n     * Returns a tree traverser that uses the given function to navigate from a node to its children.\n     * This is useful if the function instance already exists, or so that you can supply a lambda\n     * expressions. If those circumstances don't apply, you probably don't need to use this; subclass\n     * {@code TreeTraverser} and implement its {@link #children} method directly.\n     *\n     * @since 20.0\n     * @deprecated Use {@link com.google.common.graph.Traverser#forTree} instead. If you are using a\n     *     lambda, these methods have exactly the same signature.\n     */\n    @Deprecated\n    public static <T> TreeTraverser<T> using(\n        final Function<T, ? extends Iterable<T>> nodeToChildrenFunction)\n    {\n        checkNotNull(nodeToChildrenFunction);\n        return new TreeTraverser<T>()\n        {\n            @Override\n            public Iterable<T> children(T root)\n            {\n                return nodeToChildrenFunction.apply(root);\n            }\n        };\n    }\n\n    /** Returns the children of the specified node. Must not contain null. */\n    public abstract Iterable<T> children(T root);\n\n    /**\n     * Returns an unmodifiable iterable over the nodes in a tree structure, using pre-order traversal.\n     * That is, each node's subtrees are traversed after the node itself is returned.\n     *\n     * <p>No guarantees are made about the behavior of the traversal when nodes change while iteration\n     * is in progress or when the iterators generated by {@link #children} are advanced.\n     *\n     * @deprecated Use {@link com.google.common.graph.Traverser#depthFirstPreOrder} instead, which has\n     *     the same behavior.\n     */\n\n    UnmodifiableIterator<T> preOrderIterator(T root)\n    {\n        return new PreOrderIterator(root);\n    }\n\n    private final class PreOrderIterator extends UnmodifiableIterator<T>\n    {\n        private final Deque<Iterator<T>> stack;\n\n        PreOrderIterator(T root)\n        {\n            this.stack = new ArrayDeque<>();\n            stack.addLast(Iterators.singletonIterator(checkNotNull(root)));\n        }\n\n        @Override\n        public boolean hasNext()\n        {\n            return !stack.isEmpty();\n        }\n\n        @Override\n        public T next()\n        {\n            Iterator<T> itr = stack.getLast(); // throws NSEE if empty\n            T result = checkNotNull(itr.next());\n            if (!itr.hasNext())\n            {\n                stack.removeLast();\n            }\n            Iterator<T> childItr = children(result).iterator();\n            if (childItr.hasNext())\n            {\n                stack.addLast(childItr);\n            }\n            return result;\n        }\n    }\n\n    /**\n     * Returns an unmodifiable iterable over the nodes in a tree structure, using post-order\n     * traversal. That is, each node's subtrees are traversed before the node itself is returned.\n     *\n     * <p>No guarantees are made about the behavior of the traversal when nodes change while iteration\n     * is in progress or when the iterators generated by {@link #children} are advanced.\n     *\n     * @deprecated Use {@link com.google.common.graph.Traverser#depthFirstPostOrder} instead, which\n     *     has the same behavior.\n     */\n    @Deprecated\n    public final FluentIterable<T> postOrderTraversal(final T root)\n    {\n        checkNotNull(root);\n        return new FluentIterable<T>()\n        {\n            @Override\n            public UnmodifiableIterator<T> iterator()\n            {\n                return postOrderIterator(root);\n            }\n\n            @Override\n            public void forEach(Consumer<? super T> action)\n            {\n                checkNotNull(action);\n                new Consumer<T>()\n                {\n                    @Override\n                    public void accept(T t)\n                    {\n                        children(t).forEach(this);\n                        action.accept(t);\n                    }\n                } .accept(root);\n            }\n        };\n    }\n\n    UnmodifiableIterator<T> postOrderIterator(T root)\n    {\n        return new PostOrderIterator(root);\n    }\n\n    private static final class PostOrderNode<T>\n    {\n        final T root;\n        final Iterator<T> childIterator;\n\n        PostOrderNode(T root, Iterator<T> childIterator)\n        {\n            this.root = checkNotNull(root);\n            this.childIterator = checkNotNull(childIterator);\n        }\n    }\n\n    private final class PostOrderIterator extends AbstractIterator<T>\n    {\n        private final ArrayDeque<PostOrderNode<T>> stack;\n\n        PostOrderIterator(T root)\n        {\n            this.stack = new ArrayDeque<>();\n            stack.addLast(expand(root));\n        }\n\n        @Override\n        protected T computeNext()\n        {\n            while (!stack.isEmpty())\n            {\n                PostOrderNode<T> top = stack.getLast();\n                if (top.childIterator.hasNext())\n                {\n                    T child = top.childIterator.next();\n                    stack.addLast(expand(child));\n                }\n                else\n                {\n                    stack.removeLast();\n                    return top.root;\n                }\n            }\n            return endOfData();\n        }\n\n        private PostOrderNode<T> expand(T t)\n        {\n            return new PostOrderNode<T>(t, children(t).iterator());\n        }\n    }\n\n    /**\n     * Returns an unmodifiable iterable over the nodes in a tree structure, using breadth-first\n     * traversal. That is, all the nodes of depth 0 are returned, then depth 1, then 2, and so on.\n     *\n     * <p>No guarantees are made about the behavior of the traversal when nodes change while iteration\n     * is in progress or when the iterators generated by {@link #children} are advanced.\n     *\n     * @deprecated Use {@link com.google.common.graph.Traverser#breadthFirst} instead, which has the\n     *     same behavior.\n     */\n    @Deprecated\n    public final FluentIterable<T> breadthFirstTraversal(final T root)\n    {\n        checkNotNull(root);\n        return new FluentIterable<T>()\n        {\n            @Override\n            public UnmodifiableIterator<T> iterator()\n            {\n                return new BreadthFirstIterator(root);\n            }\n        };\n    }\n\n    private final class BreadthFirstIterator extends UnmodifiableIterator<T>\n        implements PeekingIterator<T>\n    {\n        private final Queue<T> queue;\n\n        BreadthFirstIterator(T root)\n        {\n            this.queue = new ArrayDeque<T>();\n            queue.add(root);\n        }\n\n        @Override\n        public boolean hasNext()\n        {\n            return !queue.isEmpty();\n        }\n\n        @Override\n        public T peek()\n        {\n            return queue.element();\n        }\n\n        @Override\n        public T next()\n        {\n            T result = queue.remove();\n            Iterables.addAll(queue, children(result));\n            return result;\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/Collections2.java", "func_name": "Collections2.newStringBuilderForCollection", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns best-effort-sized StringBuilder based on the given collection size.", "docstring_tokens": ["Returns", "best", "-", "effort", "-", "sized", "StringBuilder", "based", "on", "the", "given", "collection", "size", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/Collections2.java#L327-L330", "partition": "valid", "up_fun_num": 8, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.collect.CollectPreconditions.checkNonnegative;", "import com.google.common.annotations.Beta;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.base.Function;", "import com.google.common.base.Predicate;", "import com.google.common.base.Predicates;", "import com.google.common.math.IntMath;", "import com.google.common.primitives.Ints;", "import java.util.AbstractCollection;", "import java.util.ArrayList;", "import java.util.Arrays;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.Comparator;", "import java.util.Iterator;", "import java.util.List;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class Collections2\n", "    public static <E> Collection<E> filter(Collection<E> unfiltered, Predicate<? super E> predicate)\n", "    static boolean safeContains(Collection<?> collection, @NullableDecl Object object)\n", "    static boolean safeRemove(Collection<?> collection, @NullableDecl Object object)\n", "    public static <F, T> Collection<T> transform(\n", "    static boolean containsAllImpl(Collection<?> self, Collection<?> c)\n", "    static String toStringImpl(final Collection<?> collection)\n", "    static <T> Collection<T> cast(Iterable<T> iterable)\n", "    public static <E extends Comparable<? super E>> Collection<List<E>> orderedPermutations(\n", "    public static <E> Collection<List<E>> orderedPermutations(\n", "    public static <E> Collection<List<E>> permutations(Collection<E> elements)\n", "    private static boolean isPermutation(List<?> first, List<?> second)\n", "    private static <E> ObjectCountHashMap<E> counts(Collection<E> collection)\n"], "context": "/*\n * Copyright (C) 2008 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.collect.CollectPreconditions.checkNonnegative;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.base.Function;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport com.google.common.math.IntMath;\nimport com.google.common.primitives.Ints;\nimport java.util.AbstractCollection;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * Provides static methods for working with {@code Collection} instances.\n *\n * <p><b>Java 8 users:</b> several common uses for this class are now more comprehensively addressed\n * by the new {@link java.util.stream.Stream} library. Read the method documentation below for\n * comparisons. These methods are not being deprecated, but we gently encourage you to migrate to\n * streams.\n *\n * @author Chris Povirk\n * @author Mike Bostock\n * @author Jared Levy\n * @since 2.0\n */\n@GwtCompatible\npublic final class Collections2\n{\n    private Collections2() {}\n\n    /**\n     * Returns the elements of {@code unfiltered} that satisfy a predicate. The returned collection is\n     * a live view of {@code unfiltered}; changes to one affect the other.\n     *\n     * <p>The resulting collection's iterator does not support {@code remove()}, but all other\n     * collection methods are supported. When given an element that doesn't satisfy the predicate, the\n     * collection's {@code add()} and {@code addAll()} methods throw an {@link\n     * IllegalArgumentException}. When methods such as {@code removeAll()} and {@code clear()} are\n     * called on the filtered collection, only elements that satisfy the filter will be removed from\n     * the underlying collection.\n     *\n     * <p>The returned collection isn't threadsafe or serializable, even if {@code unfiltered} is.\n     *\n     * <p>Many of the filtered collection's methods, such as {@code size()}, iterate across every\n     * element in the underlying collection and determine which elements satisfy the filter. When a\n     * live view is <i>not</i> needed, it may be faster to copy {@code Iterables.filter(unfiltered,\n     * predicate)} and use the copy.\n     *\n     * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>, as documented at\n     * {@link Predicate#apply}. Do not provide a predicate such as {@code\n     * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link\n     * Iterables#filter(Iterable, Class)} for related functionality.)\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link java.util.stream.Stream#filter Stream.filter}.\n     */\n    // TODO(kevinb): how can we omit that Iterables link when building gwt\n    // javadoc?\n    public static <E> Collection<E> filter(Collection<E> unfiltered, Predicate<? super E> predicate)\n    {\n        if (unfiltered instanceof FilteredCollection)\n        {\n            // Support clear(), removeAll(), and retainAll() when filtering a filtered\n            // collection.\n            return ((FilteredCollection<E>) unfiltered).createCombined(predicate);\n        }\n\n        return new FilteredCollection<E>(checkNotNull(unfiltered), checkNotNull(predicate));\n    }\n\n    /**\n     * Delegates to {@link Collection#contains}. Returns {@code false} if the {@code contains} method\n     * throws a {@code ClassCastException} or {@code NullPointerException}.\n     */\n    static boolean safeContains(Collection<?> collection, @NullableDecl Object object)\n    {\n        checkNotNull(collection);\n        try\n        {\n            return collection.contains(object);\n        }\n        catch (ClassCastException | NullPointerException e)\n        {\n            return false;\n        }\n    }\n\n    /**\n     * Delegates to {@link Collection#remove}. Returns {@code false} if the {@code remove} method\n     * throws a {@code ClassCastException} or {@code NullPointerException}.\n     */\n    static boolean safeRemove(Collection<?> collection, @NullableDecl Object object)\n    {\n        checkNotNull(collection);\n        try\n        {\n            return collection.remove(object);\n        }\n        catch (ClassCastException | NullPointerException e)\n        {\n            return false;\n        }\n    }\n\n    static class FilteredCollection<E> extends AbstractCollection<E>\n    {\n        final Collection<E> unfiltered;\n        final Predicate<? super E> predicate;\n\n        FilteredCollection(Collection<E> unfiltered, Predicate<? super E> predicate)\n        {\n            this.unfiltered = unfiltered;\n            this.predicate = predicate;\n        }\n\n        FilteredCollection<E> createCombined(Predicate<? super E> newPredicate)\n        {\n            return new FilteredCollection<E>(unfiltered, Predicates.<E> and (predicate, newPredicate));\n            // .<E> above needed to compile in JDK 5\n        }\n\n        @Override\n        public boolean add(E element)\n        {\n            checkArgument(predicate.apply(element));\n            return unfiltered.add(element);\n        }\n\n        @Override\n        public boolean addAll(Collection<? extends E> collection)\n        {\n            for (E element : collection)\n            {\n                checkArgument(predicate.apply(element));\n            }\n            return unfiltered.addAll(collection);\n        }\n\n        @Override\n        public void clear()\n        {\n            Iterables.removeIf(unfiltered, predicate);\n        }\n\n        @Override\n        public boolean contains(@NullableDecl Object element)\n        {\n            if (safeContains(unfiltered, element))\n            {\n                @SuppressWarnings(\"unchecked\") // element is in unfiltered, so it must be an E\n                E e = (E) element;\n                return predicate.apply(e);\n            }\n            return false;\n        }\n\n        @Override\n        public boolean containsAll(Collection<?> collection)\n        {\n            return containsAllImpl(this, collection);\n        }\n\n        @Override\n        public boolean isEmpty()\n        {\n            return !Iterables.any(unfiltered, predicate);\n        }\n\n        @Override\n        public Iterator<E> iterator()\n        {\n            return Iterators.filter(unfiltered.iterator(), predicate);\n        }\n\n        @Override\n        public boolean remove(Object element)\n        {\n            return contains(element) && unfiltered.remove(element);\n        }\n\n        @Override\n        public boolean removeAll(final Collection<?> collection)\n        {\n            boolean changed = false;\n            Iterator<E> itr = unfiltered.iterator();\n            while (itr.hasNext())\n            {\n                E e = itr.next();\n                if (predicate.apply(e) && collection.contains(e))\n                {\n                    itr.remove();\n                    changed = true;\n                }\n            }\n            return changed;\n        }\n\n        @Override\n        public boolean retainAll(final Collection<?> collection)\n        {\n            boolean changed = false;\n            Iterator<E> itr = unfiltered.iterator();\n            while (itr.hasNext())\n            {\n                E e = itr.next();\n                if (predicate.apply(e) && !collection.contains(e))\n                {\n                    itr.remove();\n                    changed = true;\n                }\n            }\n            return changed;\n        }\n\n        @Override\n        public int size()\n        {\n            int size = 0;\n            for (E e : unfiltered)\n            {\n                if (predicate.apply(e))\n                {\n                    size++;\n                }\n            }\n            return size;\n        }\n\n        @Override\n        public Object[] toArray()\n        {\n            // creating an ArrayList so filtering happens once\n            return Lists.newArrayList(iterator()).toArray();\n        }\n\n        @Override\n        public <T> T[] toArray(T[] array)\n        {\n            return Lists.newArrayList(iterator()).toArray(array);\n        }\n    }\n\n    /**\n     * Returns a collection that applies {@code function} to each element of {@code fromCollection}.\n     * The returned collection is a live view of {@code fromCollection}; changes to one affect the\n     * other.\n     *\n     * <p>The returned collection's {@code add()} and {@code addAll()} methods throw an {@link\n     * UnsupportedOperationException}. All other collection methods are supported, as long as {@code\n     * fromCollection} supports them.\n     *\n     * <p>The returned collection isn't threadsafe or serializable, even if {@code fromCollection} is.\n     *\n     * <p>When a live view is <i>not</i> needed, it may be faster to copy the transformed collection\n     * and use the copy.\n     *\n     * <p>If the input {@code Collection} is known to be a {@code List}, consider {@link\n     * Lists#transform}. If only an {@code Iterable} is available, use {@link Iterables#transform}.\n     *\n     * <p><b>{@code Stream} equivalent:</b> {@link java.util.stream.Stream#map Stream.map}.\n     */\n    public static <F, T> Collection<T> transform(\n        Collection<F> fromCollection, Function<? super F, T> function)\n    {\n        return new TransformedCollection<>(fromCollection, function);\n    }\n\n    static class TransformedCollection<F, T> extends AbstractCollection<T>\n    {\n        final Collection<F> fromCollection;\n        final Function<? super F, ? extends T> function;\n\n        TransformedCollection(Collection<F> fromCollection, Function<? super F, ? extends T> function)\n        {\n            this.fromCollection = checkNotNull(fromCollection);\n            this.function = checkNotNull(function);\n        }\n\n        @Override\n        public void clear()\n        {\n            fromCollection.clear();\n        }\n\n        @Override\n        public boolean isEmpty()\n        {\n            return fromCollection.isEmpty();\n        }\n\n        @Override\n        public Iterator<T> iterator()\n        {\n            return Iterators.transform(fromCollection.iterator(), function);\n        }\n\n        @Override\n        public int size()\n        {\n            return fromCollection.size();\n        }\n    }\n\n    /**\n     * Returns {@code true} if the collection {@code self} contains all of the elements in the\n     * collection {@code c}.\n     *\n     * <p>This method iterates over the specified collection {@code c}, checking each element returned\n     * by the iterator in turn to see if it is contained in the specified collection {@code self}. If\n     * all elements are so contained, {@code true} is returned, otherwise {@code false}.\n     *\n     * @param self a collection which might contain all elements in {@code c}\n     * @param c a collection whose elements might be contained by {@code self}\n     */\n    static boolean containsAllImpl(Collection<?> self, Collection<?> c)\n    {\n        for (Object o : c)\n        {\n            if (!self.contains(o))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /** An implementation of {@link Collection#toString()}. */\n    static String toStringImpl(final Collection<?> collection)\n    {\n        StringBuilder sb = newStringBuilderForCollection(collection.size()).append('[');\n        boolean first = true;\n        for (Object o : collection)\n        {\n            if (!first)\n            {\n                sb.append(\", \");\n            }\n            first = false;\n            if (o == collection)\n            {\n                sb.append(\"(this Collection)\");\n            }\n            else\n            {\n                sb.append(o);\n            }\n        }\n        return sb.append(']').toString();\n    }\n\n    /** Returns best-effort-sized StringBuilder based on the given collection size. */\n\n    /** Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557 */\n    static <T> Collection<T> cast(Iterable<T> iterable)\n    {\n        return (Collection<T>) iterable;\n    }\n\n    /**\n     * Returns a {@link Collection} of all the permutations of the specified {@link Iterable}.\n     *\n     * <p><i>Notes:</i> This is an implementation of the algorithm for Lexicographical Permutations\n     * Generation, described in Knuth's \"The Art of Computer Programming\", Volume 4, Chapter 7,\n     * Section 7.2.1.2. The iteration order follows the lexicographical order. This means that the\n     * first permutation will be in ascending order, and the last will be in descending order.\n     *\n     * <p>Duplicate elements are considered equal. For example, the list [1, 1] will have only one\n     * permutation, instead of two. This is why the elements have to implement {@link Comparable}.\n     *\n     * <p>An empty iterable has only one permutation, which is an empty list.\n     *\n     * <p>This method is equivalent to {@code Collections2.orderedPermutations(list,\n     * Ordering.natural())}.\n     *\n     * @param elements the original iterable whose elements have to be permuted.\n     * @return an immutable {@link Collection} containing all the different permutations of the\n     *     original iterable.\n     * @throws NullPointerException if the specified iterable is null or has any null elements.\n     * @since 12.0\n     */\n    @Beta\n    public static <E extends Comparable<? super E>> Collection<List<E>> orderedPermutations(\n        Iterable<E> elements)\n    {\n        return orderedPermutations(elements, Ordering.natural());\n    }\n\n    /**\n     * Returns a {@link Collection} of all the permutations of the specified {@link Iterable} using\n     * the specified {@link Comparator} for establishing the lexicographical ordering.\n     *\n     * <p>Examples:\n     *\n     * <pre>{@code\n     * for (List<String> perm : orderedPermutations(asList(\"b\", \"c\", \"a\"))) {\n     *   println(perm);\n     * }\n     * // -> [\"a\", \"b\", \"c\"]\n     * // -> [\"a\", \"c\", \"b\"]\n     * // -> [\"b\", \"a\", \"c\"]\n     * // -> [\"b\", \"c\", \"a\"]\n     * // -> [\"c\", \"a\", \"b\"]\n     * // -> [\"c\", \"b\", \"a\"]\n     *\n     * for (List<Integer> perm : orderedPermutations(asList(1, 2, 2, 1))) {\n     *   println(perm);\n     * }\n     * // -> [1, 1, 2, 2]\n     * // -> [1, 2, 1, 2]\n     * // -> [1, 2, 2, 1]\n     * // -> [2, 1, 1, 2]\n     * // -> [2, 1, 2, 1]\n     * // -> [2, 2, 1, 1]\n     * }</pre>\n     *\n     * <p><i>Notes:</i> This is an implementation of the algorithm for Lexicographical Permutations\n     * Generation, described in Knuth's \"The Art of Computer Programming\", Volume 4, Chapter 7,\n     * Section 7.2.1.2. The iteration order follows the lexicographical order. This means that the\n     * first permutation will be in ascending order, and the last will be in descending order.\n     *\n     * <p>Elements that compare equal are considered equal and no new permutations are created by\n     * swapping them.\n     *\n     * <p>An empty iterable has only one permutation, which is an empty list.\n     *\n     * @param elements the original iterable whose elements have to be permuted.\n     * @param comparator a comparator for the iterable's elements.\n     * @return an immutable {@link Collection} containing all the different permutations of the\n     *     original iterable.\n     * @throws NullPointerException If the specified iterable is null, has any null elements, or if\n     *     the specified comparator is null.\n     * @since 12.0\n     */\n    @Beta\n    public static <E> Collection<List<E>> orderedPermutations(\n        Iterable<E> elements, Comparator<? super E> comparator)\n    {\n        return new OrderedPermutationCollection<E>(elements, comparator);\n    }\n\n    private static final class OrderedPermutationCollection<E> extends AbstractCollection<List<E>>\n    {\n        final ImmutableList<E> inputList;\n        final Comparator<? super E> comparator;\n        final int size;\n\n        OrderedPermutationCollection(Iterable<E> input, Comparator<? super E> comparator)\n        {\n            this.inputList = ImmutableList.sortedCopyOf(comparator, input);\n            this.comparator = comparator;\n            this.size = calculateSize(inputList, comparator);\n        }\n\n        /**\n         * The number of permutations with repeated elements is calculated as follows:\n         *\n         * <ul>\n         *   <li>For an empty list, it is 1 (base case).\n         *   <li>When r numbers are added to a list of n-r elements, the number of permutations is\n         *       increased by a factor of (n choose r).\n         * </ul>\n         */\n        private static <E> int calculateSize(\n            List<E> sortedInputList, Comparator<? super E> comparator)\n        {\n            int permutations = 1;\n            int n = 1;\n            int r = 1;\n            while (n < sortedInputList.size())\n            {\n                int comparison = comparator.compare(sortedInputList.get(n - 1), sortedInputList.get(n));\n                if (comparison < 0)\n                {\n                    // We move to the next non-repeated element.\n                    permutations = IntMath.saturatedMultiply(permutations, IntMath.binomial(n, r));\n                    r = 0;\n                    if (permutations == Integer.MAX_VALUE)\n                    {\n                        return Integer.MAX_VALUE;\n                    }\n                }\n                n++;\n                r++;\n            }\n            return IntMath.saturatedMultiply(permutations, IntMath.binomial(n, r));\n        }\n\n        @Override\n        public int size()\n        {\n            return size;\n        }\n\n        @Override\n        public boolean isEmpty()\n        {\n            return false;\n        }\n\n        @Override\n        public Iterator<List<E>> iterator()\n        {\n            return new OrderedPermutationIterator<E>(inputList, comparator);\n        }\n\n        @Override\n        public boolean contains(@NullableDecl Object obj)\n        {\n            if (obj instanceof List)\n            {\n                List<?> list = (List<?>) obj;\n                return isPermutation(inputList, list);\n            }\n            return false;\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"orderedPermutationCollection(\" + inputList + \")\";\n        }\n    }\n\n    private static final class OrderedPermutationIterator<E> extends AbstractIterator<List<E>>\n    {\n        @NullableDecl List<E> nextPermutation;\n        final Comparator<? super E> comparator;\n\n        OrderedPermutationIterator(List<E> list, Comparator<? super E> comparator)\n        {\n            this.nextPermutation = Lists.newArrayList(list);\n            this.comparator = comparator;\n        }\n\n        @Override\n        protected List<E> computeNext()\n        {\n            if (nextPermutation == null)\n            {\n                return endOfData();\n            }\n            ImmutableList<E> next = ImmutableList.copyOf(nextPermutation);\n            calculateNextPermutation();\n            return next;\n        }\n\n        void calculateNextPermutation()\n        {\n            int j = findNextJ();\n            if (j == -1)\n            {\n                nextPermutation = null;\n                return;\n            }\n\n            int l = findNextL(j);\n            Collections.swap(nextPermutation, j, l);\n            int n = nextPermutation.size();\n            Collections.reverse(nextPermutation.subList(j + 1, n));\n        }\n\n        int findNextJ()\n        {\n            for (int k = nextPermutation.size() - 2; k >= 0; k--)\n            {\n                if (comparator.compare(nextPermutation.get(k), nextPermutation.get(k + 1)) < 0)\n                {\n                    return k;\n                }\n            }\n            return -1;\n        }\n\n        int findNextL(int j)\n        {\n            E ak = nextPermutation.get(j);\n            for (int l = nextPermutation.size() - 1; l > j; l--)\n            {\n                if (comparator.compare(ak, nextPermutation.get(l)) < 0)\n                {\n                    return l;\n                }\n            }\n            throw new AssertionError(\"this statement should be unreachable\");\n        }\n    }\n\n    /**\n     * Returns a {@link Collection} of all the permutations of the specified {@link Collection}.\n     *\n     * <p><i>Notes:</i> This is an implementation of the Plain Changes algorithm for permutations\n     * generation, described in Knuth's \"The Art of Computer Programming\", Volume 4, Chapter 7,\n     * Section 7.2.1.2.\n     *\n     * <p>If the input list contains equal elements, some of the generated permutations will be equal.\n     *\n     * <p>An empty collection has only one permutation, which is an empty list.\n     *\n     * @param elements the original collection whose elements have to be permuted.\n     * @return an immutable {@link Collection} containing all the different permutations of the\n     *     original collection.\n     * @throws NullPointerException if the specified collection is null or has any null elements.\n     * @since 12.0\n     */\n    @Beta\n    public static <E> Collection<List<E>> permutations(Collection<E> elements)\n    {\n        return new PermutationCollection<E>(ImmutableList.copyOf(elements));\n    }\n\n    private static final class PermutationCollection<E> extends AbstractCollection<List<E>>\n    {\n        final ImmutableList<E> inputList;\n\n        PermutationCollection(ImmutableList<E> input)\n        {\n            this.inputList = input;\n        }\n\n        @Override\n        public int size()\n        {\n            return IntMath.factorial(inputList.size());\n        }\n\n        @Override\n        public boolean isEmpty()\n        {\n            return false;\n        }\n\n        @Override\n        public Iterator<List<E>> iterator()\n        {\n            return new PermutationIterator<E>(inputList);\n        }\n\n        @Override\n        public boolean contains(@NullableDecl Object obj)\n        {\n            if (obj instanceof List)\n            {\n                List<?> list = (List<?>) obj;\n                return isPermutation(inputList, list);\n            }\n            return false;\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"permutations(\" + inputList + \")\";\n        }\n    }\n\n    private static class PermutationIterator<E> extends AbstractIterator<List<E>>\n    {\n        final List<E> list;\n        final int[] c;\n        final int[] o;\n        int j;\n\n        PermutationIterator(List<E> list)\n        {\n            this.list = new ArrayList<E>(list);\n            int n = list.size();\n            c = new int[n];\n            o = new int[n];\n            Arrays.fill(c, 0);\n            Arrays.fill(o, 1);\n            j = Integer.MAX_VALUE;\n        }\n\n        @Override\n        protected List<E> computeNext()\n        {\n            if (j <= 0)\n            {\n                return endOfData();\n            }\n            ImmutableList<E> next = ImmutableList.copyOf(list);\n            calculateNextPermutation();\n            return next;\n        }\n\n        void calculateNextPermutation()\n        {\n            j = list.size() - 1;\n            int s = 0;\n\n            // Handle the special case of an empty list. Skip the calculation of the\n            // next permutation.\n            if (j == -1)\n            {\n                return;\n            }\n\n            while (true)\n            {\n                int q = c[j] + o[j];\n                if (q < 0)\n                {\n                    switchDirection();\n                    continue;\n                }\n                if (q == j + 1)\n                {\n                    if (j == 0)\n                    {\n                        break;\n                    }\n                    s++;\n                    switchDirection();\n                    continue;\n                }\n\n                Collections.swap(list, j - c[j] + s, j - q + s);\n                c[j] = q;\n                break;\n            }\n        }\n\n        void switchDirection()\n        {\n            o[j] = -o[j];\n            j--;\n        }\n    }\n\n    /** Returns {@code true} if the second list is a permutation of the first. */\n    private static boolean isPermutation(List<?> first, List<?> second)\n    {\n        if (first.size() != second.size())\n        {\n            return false;\n        }\n        ObjectCountHashMap<?> firstCounts = counts(first);\n        ObjectCountHashMap<?> secondCounts = counts(second);\n        if (first.size() != second.size())\n        {\n            return false;\n        }\n        for (int i = 0; i < first.size(); i++)\n        {\n            if (firstCounts.getValue(i) != secondCounts.get(firstCounts.getKey(i)))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static <E> ObjectCountHashMap<E> counts(Collection<E> collection)\n    {\n        ObjectCountHashMap<E> map = new ObjectCountHashMap<>();\n        for (E e : collection)\n        {\n            map.put(e, map.get(e) + 1);\n        }\n        return map;\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/reflect/TypeResolver.java", "func_name": "TypeResolver.invariantly", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Returns a resolver that resolves types \"invariantly\".\n\n<p>For example, when resolving {@code List<T>} in the context of {@code ArrayList<?>}, {@code\n<T>} cannot be invariantly resolved to {@code <?>} because otherwise the parameter type of\n{@code List::set} will be {@code <?>} and it'll falsely say any object can be passed into\n{@code ArrayList<?>::set}.\n\n<p>Instead, {@code <?>} will be resolved to a capture in the form of a type variable {@code\n<capture-of-? extends Object>}, effectively preventing {@code set} from accepting any type.", "docstring_tokens": ["Returns", "a", "resolver", "that", "resolves", "types", "invariantly", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/reflect/TypeResolver.java#L89-L92", "partition": "valid", "up_fun_num": 3, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.base.Preconditions.checkState;", "import static java.util.Arrays.asList;", "import com.google.common.annotations.Beta;", "import com.google.common.base.Joiner;", "import com.google.common.base.Objects;", "import com.google.common.collect.ImmutableMap;", "import com.google.common.collect.Maps;", "import java.lang.reflect.GenericArrayType;", "import java.lang.reflect.ParameterizedType;", "import java.lang.reflect.Type;", "import java.lang.reflect.TypeVariable;", "import java.lang.reflect.WildcardType;", "import java.util.Arrays;", "import java.util.LinkedHashSet;", "import java.util.Map;", "import java.util.Map.Entry;", "import java.util.Set;", "import java.util.concurrent.atomic.AtomicInteger;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["public final class TypeResolver\n", "    static TypeResolver covariantly(Type contextType)\n", "    public TypeResolver where(Type formal, Type actual)\n", "    TypeResolver where(Map<TypeVariableKey, ? extends Type> mappings)\n", "    private static void populateTypeMappings(\n", "    public Type resolveType(Type type)\n", "    Type[] resolveTypesInPlace(Type[] types)\n", "    private Type[] resolveTypes(Type[] types)\n", "    private WildcardType resolveWildcardType(WildcardType type)\n", "    private Type resolveGenericArrayType(GenericArrayType type)\n", "    private ParameterizedType resolveParameterizedType(ParameterizedType type)\n", "    private static <T> T expectArgument(Class<T> type, Object arg)\n"], "context": "/*\n * Copyright (C) 2009 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.reflect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static java.util.Arrays.asList;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Objects;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.Maps;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * An object of this class encapsulates type mappings from type variables. Mappings are established\n * with {@link #where} and types are resolved using {@link #resolveType}.\n *\n * <p>Note that usually type mappings are already implied by the static type hierarchy (for example,\n * the {@code E} type variable declared by class {@code List} naturally maps to {@code String} in\n * the context of {@code class MyStringList implements List<String>}. In such case, prefer to use\n * {@link TypeToken#resolveType} since it's simpler and more type safe. This class should only be\n * used when the type mapping isn't implied by the static type hierarchy, but provided through other\n * means such as an annotation or external configuration file.\n *\n * @author Ben Yu\n * @since 15.0\n */\n@Beta\npublic final class TypeResolver\n{\n\n    private final TypeTable typeTable;\n\n    public TypeResolver()\n    {\n        this.typeTable = new TypeTable();\n    }\n\n    private TypeResolver(TypeTable typeTable)\n    {\n        this.typeTable = typeTable;\n    }\n\n    /**\n     * Returns a resolver that resolves types \"covariantly\".\n     *\n     * <p>For example, when resolving {@code List<T>} in the context of {@code ArrayList<?>}, {@code\n     * <T>} is covariantly resolved to {@code <?>} such that return type of {@code List::get} is\n     * {@code <?>}.\n     */\n    static TypeResolver covariantly(Type contextType)\n    {\n        return new TypeResolver().where(TypeMappingIntrospector.getTypeMappings(contextType));\n    }\n\n    /**\n     * Returns a resolver that resolves types \"invariantly\".\n     *\n     * <p>For example, when resolving {@code List<T>} in the context of {@code ArrayList<?>}, {@code\n     * <T>} cannot be invariantly resolved to {@code <?>} because otherwise the parameter type of\n     * {@code List::set} will be {@code <?>} and it'll falsely say any object can be passed into\n     * {@code ArrayList<?>::set}.\n     *\n     * <p>Instead, {@code <?>} will be resolved to a capture in the form of a type variable {@code\n     * <capture-of-? extends Object>}, effectively preventing {@code set} from accepting any type.\n     */\n\n    /**\n     * Returns a new {@code TypeResolver} with type variables in {@code formal} mapping to types in\n     * {@code actual}.\n     *\n     * <p>For example, if {@code formal} is a {@code TypeVariable T}, and {@code actual} is {@code\n     * String.class}, then {@code new TypeResolver().where(formal, actual)} will {@linkplain\n     * #resolveType resolve} {@code ParameterizedType List<T>} to {@code List<String>}, and resolve\n     * {@code Map<T, Something>} to {@code Map<String, Something>} etc. Similarly, {@code formal} and\n     * {@code actual} can be {@code Map<K, V>} and {@code Map<String, Integer>} respectively, or they\n     * can be {@code E[]} and {@code String[]} respectively, or even any arbitrary combination\n     * thereof.\n     *\n     * @param formal The type whose type variables or itself is mapped to other type(s). It's almost\n     *     always a bug if {@code formal} isn't a type variable and contains no type variable. Make\n     *     sure you are passing the two parameters in the right order.\n     * @param actual The type that the formal type variable(s) are mapped to. It can be or contain yet\n     *     other type variables, in which case these type variables will be further resolved if\n     *     corresponding mappings exist in the current {@code TypeResolver} instance.\n     */\n    public TypeResolver where(Type formal, Type actual)\n    {\n        Map<TypeVariableKey, Type> mappings = Maps.newHashMap();\n        populateTypeMappings(mappings, checkNotNull(formal), checkNotNull(actual));\n        return where(mappings);\n    }\n\n    /** Returns a new {@code TypeResolver} with {@code variable} mapping to {@code type}. */\n    TypeResolver where(Map<TypeVariableKey, ? extends Type> mappings)\n    {\n        return new TypeResolver(typeTable.where(mappings));\n    }\n\n    private static void populateTypeMappings(\n        final Map<TypeVariableKey, Type> mappings, final Type from, final Type to)\n    {\n        if (from.equals(to))\n        {\n            return;\n        }\n        new TypeVisitor()\n        {\n            @Override\n            void visitTypeVariable(TypeVariable<?> typeVariable)\n            {\n                mappings.put(new TypeVariableKey(typeVariable), to);\n            }\n\n            @Override\n            void visitWildcardType(WildcardType fromWildcardType)\n            {\n                if (!(to instanceof WildcardType))\n                {\n                    return; // okay to say <?> is anything\n                }\n                WildcardType toWildcardType = (WildcardType) to;\n                Type[] fromUpperBounds = fromWildcardType.getUpperBounds();\n                Type[] toUpperBounds = toWildcardType.getUpperBounds();\n                Type[] fromLowerBounds = fromWildcardType.getLowerBounds();\n                Type[] toLowerBounds = toWildcardType.getLowerBounds();\n                checkArgument(\n                    fromUpperBounds.length == toUpperBounds.length\n                    && fromLowerBounds.length == toLowerBounds.length,\n                    \"Incompatible type: %s vs. %s\",\n                    fromWildcardType,\n                    to);\n                for (int i = 0; i < fromUpperBounds.length; i++)\n                {\n                    populateTypeMappings(mappings, fromUpperBounds[i], toUpperBounds[i]);\n                }\n                for (int i = 0; i < fromLowerBounds.length; i++)\n                {\n                    populateTypeMappings(mappings, fromLowerBounds[i], toLowerBounds[i]);\n                }\n            }\n\n            @Override\n            void visitParameterizedType(ParameterizedType fromParameterizedType)\n            {\n                if (to instanceof WildcardType)\n                {\n                    return; // Okay to say Foo<A> is <?>\n                }\n                ParameterizedType toParameterizedType = expectArgument(ParameterizedType.class, to);\n                if (fromParameterizedType.getOwnerType() != null\n                        && toParameterizedType.getOwnerType() != null)\n                {\n                    populateTypeMappings(\n                        mappings, fromParameterizedType.getOwnerType(), toParameterizedType.getOwnerType());\n                }\n                checkArgument(\n                    fromParameterizedType.getRawType().equals(toParameterizedType.getRawType()),\n                    \"Inconsistent raw type: %s vs. %s\",\n                    fromParameterizedType,\n                    to);\n                Type[] fromArgs = fromParameterizedType.getActualTypeArguments();\n                Type[] toArgs = toParameterizedType.getActualTypeArguments();\n                checkArgument(\n                    fromArgs.length == toArgs.length,\n                    \"%s not compatible with %s\",\n                    fromParameterizedType,\n                    toParameterizedType);\n                for (int i = 0; i < fromArgs.length; i++)\n                {\n                    populateTypeMappings(mappings, fromArgs[i], toArgs[i]);\n                }\n            }\n\n            @Override\n            void visitGenericArrayType(GenericArrayType fromArrayType)\n            {\n                if (to instanceof WildcardType)\n                {\n                    return; // Okay to say A[] is <?>\n                }\n                Type componentType = Types.getComponentType(to);\n                checkArgument(componentType != null, \"%s is not an array type.\", to);\n                populateTypeMappings(mappings, fromArrayType.getGenericComponentType(), componentType);\n            }\n\n            @Override\n            void visitClass(Class<?> fromClass)\n            {\n                if (to instanceof WildcardType)\n                {\n                    return; // Okay to say Foo is <?>\n                }\n                // Can't map from a raw class to anything other than itself or a wildcard.\n                // You can't say \"assuming String is Integer\".\n                // And we don't support \"assuming String is T\"; user has to say \"assuming T is String\".\n                throw new IllegalArgumentException(\"No type mapping from \" + fromClass + \" to \" + to);\n            }\n        } .visit(from);\n    }\n\n    /**\n     * Resolves all type variables in {@code type} and all downstream types and returns a\n     * corresponding type with type variables resolved.\n     */\n    public Type resolveType(Type type)\n    {\n        checkNotNull(type);\n        if (type instanceof TypeVariable)\n        {\n            return typeTable.resolve((TypeVariable<?>) type);\n        }\n        else if (type instanceof ParameterizedType)\n        {\n            return resolveParameterizedType((ParameterizedType) type);\n        }\n        else if (type instanceof GenericArrayType)\n        {\n            return resolveGenericArrayType((GenericArrayType) type);\n        }\n        else if (type instanceof WildcardType)\n        {\n            return resolveWildcardType((WildcardType) type);\n        }\n        else\n        {\n            // if Class<?>, no resolution needed, we are done.\n            return type;\n        }\n    }\n\n    Type[] resolveTypesInPlace(Type[] types)\n    {\n        for (int i = 0; i < types.length; i++)\n        {\n            types[i] = resolveType(types[i]);\n        }\n        return types;\n    }\n\n    private Type[] resolveTypes(Type[] types)\n    {\n        Type[] result = new Type[types.length];\n        for (int i = 0; i < types.length; i++)\n        {\n            result[i] = resolveType(types[i]);\n        }\n        return result;\n    }\n\n    private WildcardType resolveWildcardType(WildcardType type)\n    {\n        Type[] lowerBounds = type.getLowerBounds();\n        Type[] upperBounds = type.getUpperBounds();\n        return new Types.WildcardTypeImpl(resolveTypes(lowerBounds), resolveTypes(upperBounds));\n    }\n\n    private Type resolveGenericArrayType(GenericArrayType type)\n    {\n        Type componentType = type.getGenericComponentType();\n        Type resolvedComponentType = resolveType(componentType);\n        return Types.newArrayType(resolvedComponentType);\n    }\n\n    private ParameterizedType resolveParameterizedType(ParameterizedType type)\n    {\n        Type owner = type.getOwnerType();\n        Type resolvedOwner = (owner == null) ? null : resolveType(owner);\n        Type resolvedRawType = resolveType(type.getRawType());\n\n        Type[] args = type.getActualTypeArguments();\n        Type[] resolvedArgs = resolveTypes(args);\n        return Types.newParameterizedTypeWithOwner(\n                   resolvedOwner, (Class<?>) resolvedRawType, resolvedArgs);\n    }\n\n    private static <T> T expectArgument(Class<T> type, Object arg)\n    {\n        try\n        {\n            return type.cast(arg);\n        }\n        catch (ClassCastException e)\n        {\n            throw new IllegalArgumentException(arg + \" is not a \" + type.getSimpleName());\n        }\n    }\n\n    /** A TypeTable maintains mapping from {@link TypeVariable} to types. */\n    private static class TypeTable\n    {\n        private final ImmutableMap<TypeVariableKey, Type> map;\n\n        TypeTable()\n        {\n            this.map = ImmutableMap.of();\n        }\n\n        private TypeTable(ImmutableMap<TypeVariableKey, Type> map)\n        {\n            this.map = map;\n        }\n\n        /** Returns a new {@code TypeResolver} with {@code variable} mapping to {@code type}. */\n        final TypeTable where(Map<TypeVariableKey, ? extends Type> mappings)\n        {\n            ImmutableMap.Builder<TypeVariableKey, Type> builder = ImmutableMap.builder();\n            builder.putAll(map);\n            for (Entry<TypeVariableKey, ? extends Type> mapping : mappings.entrySet())\n            {\n                TypeVariableKey variable = mapping.getKey();\n                Type type = mapping.getValue();\n                checkArgument(!variable.equalsType(type), \"Type variable %s bound to itself\", variable);\n                builder.put(variable, type);\n            }\n            return new TypeTable(builder.build());\n        }\n\n        final Type resolve(final TypeVariable<?> var)\n        {\n            final TypeTable unguarded = this;\n            TypeTable guarded =\n                new TypeTable()\n            {\n                @Override\n                public Type resolveInternal(TypeVariable<?> intermediateVar, TypeTable forDependent)\n                {\n                    if (intermediateVar.getGenericDeclaration().equals(var.getGenericDeclaration()))\n                    {\n                        return intermediateVar;\n                    }\n                    return unguarded.resolveInternal(intermediateVar, forDependent);\n                }\n            };\n            return resolveInternal(var, guarded);\n        }\n\n        /**\n         * Resolves {@code var} using the encapsulated type mapping. If it maps to yet another\n         * non-reified type or has bounds, {@code forDependants} is used to do further resolution, which\n         * doesn't try to resolve any type variable on generic declarations that are already being\n         * resolved.\n         *\n         * <p>Should only be called and overridden by {@link #resolve(TypeVariable)}.\n         */\n        Type resolveInternal(TypeVariable<?> var, TypeTable forDependants)\n        {\n            Type type = map.get(new TypeVariableKey(var));\n            if (type == null)\n            {\n                Type[] bounds = var.getBounds();\n                if (bounds.length == 0)\n                {\n                    return var;\n                }\n                Type[] resolvedBounds = new TypeResolver(forDependants).resolveTypes(bounds);\n                /*\n                 * We'd like to simply create our own TypeVariable with the newly resolved bounds. There's\n                 * just one problem: Starting with JDK 7u51, the JDK TypeVariable's equals() method doesn't\n                 * recognize instances of our TypeVariable implementation. This is a problem because users\n                 * compare TypeVariables from the JDK against TypeVariables returned by TypeResolver. To\n                 * work with all JDK versions, TypeResolver must return the appropriate TypeVariable\n                 * implementation in each of the three possible cases:\n                 *\n                 * 1. Prior to JDK 7u51, the JDK TypeVariable implementation interoperates with ours.\n                 * Therefore, we can always create our own TypeVariable.\n                 *\n                 * 2. Starting with JDK 7u51, the JDK TypeVariable implementations does not interoperate\n                 * with ours. Therefore, we have to be careful about whether we create our own TypeVariable:\n                 *\n                 * 2a. If the resolved types are identical to the original types, then we can return the\n                 * original, identical JDK TypeVariable. By doing so, we sidestep the problem entirely.\n                 *\n                 * 2b. If the resolved types are different from the original types, things are trickier. The\n                 * only way to get a TypeVariable instance for the resolved types is to create our own. The\n                 * created TypeVariable will not interoperate with any JDK TypeVariable. But this is OK: We\n                 * don't _want_ our new TypeVariable to be equal to the JDK TypeVariable because it has\n                 * _different bounds_ than the JDK TypeVariable. And it wouldn't make sense for our new\n                 * TypeVariable to be equal to any _other_ JDK TypeVariable, either, because any other JDK\n                 * TypeVariable must have a different declaration or name. The only TypeVariable that our\n                 * new TypeVariable _will_ be equal to is an equivalent TypeVariable that was also created\n                 * by us. And that equality is guaranteed to hold because it doesn't involve the JDK\n                 * TypeVariable implementation at all.\n                 */\n                if (Types.NativeTypeVariableEquals.NATIVE_TYPE_VARIABLE_ONLY\n                        && Arrays.equals(bounds, resolvedBounds))\n                {\n                    return var;\n                }\n                return Types.newArtificialTypeVariable(\n                           var.getGenericDeclaration(), var.getName(), resolvedBounds);\n            }\n            // in case the type is yet another type variable.\n            return new TypeResolver(forDependants).resolveType(type);\n        }\n    }\n\n    private static final class TypeMappingIntrospector extends TypeVisitor\n    {\n\n        private final Map<TypeVariableKey, Type> mappings = Maps.newHashMap();\n\n        /**\n         * Returns type mappings using type parameters and type arguments found in the generic\n         * superclass and the super interfaces of {@code contextClass}.\n         */\n        static ImmutableMap<TypeVariableKey, Type> getTypeMappings(Type contextType)\n        {\n            checkNotNull(contextType);\n            TypeMappingIntrospector introspector = new TypeMappingIntrospector();\n            introspector.visit(contextType);\n            return ImmutableMap.copyOf(introspector.mappings);\n        }\n\n        @Override\n        void visitClass(Class<?> clazz)\n        {\n            visit(clazz.getGenericSuperclass());\n            visit(clazz.getGenericInterfaces());\n        }\n\n        @Override\n        void visitParameterizedType(ParameterizedType parameterizedType)\n        {\n            Class<?> rawClass = (Class<?>) parameterizedType.getRawType();\n            TypeVariable<?>[] vars = rawClass.getTypeParameters();\n            Type[] typeArgs = parameterizedType.getActualTypeArguments();\n            checkState(vars.length == typeArgs.length);\n            for (int i = 0; i < vars.length; i++)\n            {\n                map(new TypeVariableKey(vars[i]), typeArgs[i]);\n            }\n            visit(rawClass);\n            visit(parameterizedType.getOwnerType());\n        }\n\n        @Override\n        void visitTypeVariable(TypeVariable<?> t)\n        {\n            visit(t.getBounds());\n        }\n\n        @Override\n        void visitWildcardType(WildcardType t)\n        {\n            visit(t.getUpperBounds());\n        }\n\n        private void map(final TypeVariableKey var, final Type arg)\n        {\n            if (mappings.containsKey(var))\n            {\n                // Mapping already established\n                // This is possible when following both superClass -> enclosingClass\n                // and enclosingclass -> superClass paths.\n                // Since we follow the path of superclass first, enclosing second,\n                // superclass mapping should take precedence.\n                return;\n            }\n            // First, check whether var -> arg forms a cycle\n            for (Type t = arg; t != null; t = mappings.get(TypeVariableKey.forLookup(t)))\n            {\n                if (var.equalsType(t))\n                {\n                    // cycle detected, remove the entire cycle from the mapping so that\n                    // each type variable resolves deterministically to itself.\n                    // Otherwise, a F -> T cycle will end up resolving both F and T\n                    // nondeterministically to either F or T.\n                    for (Type x = arg; x != null; x = mappings.remove(TypeVariableKey.forLookup(x))) {}\n                    return;\n                }\n            }\n            mappings.put(var, arg);\n        }\n    }\n\n    // This is needed when resolving types against a context with wildcards\n    // For example:\n    // class Holder<T> {\n    //   void set(T data) {...}\n    // }\n    // Holder<List<?>> should *not* resolve the set() method to set(List<?> data).\n    // Instead, it should create a capture of the wildcard so that set() rejects any List<T>.\n    private static class WildcardCapturer\n    {\n\n        static final WildcardCapturer INSTANCE = new WildcardCapturer();\n\n        private final AtomicInteger id;\n\n        private WildcardCapturer()\n        {\n            this(new AtomicInteger());\n        }\n\n        private WildcardCapturer(AtomicInteger id)\n        {\n            this.id = id;\n        }\n\n        final Type capture(Type type)\n        {\n            checkNotNull(type);\n            if (type instanceof Class)\n            {\n                return type;\n            }\n            if (type instanceof TypeVariable)\n            {\n                return type;\n            }\n            if (type instanceof GenericArrayType)\n            {\n                GenericArrayType arrayType = (GenericArrayType) type;\n                return Types.newArrayType(\n                           notForTypeVariable().capture(arrayType.getGenericComponentType()));\n            }\n            if (type instanceof ParameterizedType)\n            {\n                ParameterizedType parameterizedType = (ParameterizedType) type;\n                Class<?> rawType = (Class<?>) parameterizedType.getRawType();\n                TypeVariable<?>[] typeVars = rawType.getTypeParameters();\n                Type[] typeArgs = parameterizedType.getActualTypeArguments();\n                for (int i = 0; i < typeArgs.length; i++)\n                {\n                    typeArgs[i] = forTypeVariable(typeVars[i]).capture(typeArgs[i]);\n                }\n                return Types.newParameterizedTypeWithOwner(\n                           notForTypeVariable().captureNullable(parameterizedType.getOwnerType()),\n                           rawType,\n                           typeArgs);\n            }\n            if (type instanceof WildcardType)\n            {\n                WildcardType wildcardType = (WildcardType) type;\n                Type[] lowerBounds = wildcardType.getLowerBounds();\n                if (lowerBounds.length == 0)   // ? extends something changes to capture-of\n                {\n                    return captureAsTypeVariable(wildcardType.getUpperBounds());\n                }\n                else\n                {\n                    // TODO(benyu): handle ? super T somehow.\n                    return type;\n                }\n            }\n            throw new AssertionError(\"must have been one of the known types\");\n        }\n\n        TypeVariable<?> captureAsTypeVariable(Type[] upperBounds)\n        {\n            String name =\n                \"capture#\" + id.incrementAndGet() + \"-of ? extends \" + Joiner.on('&').join(upperBounds);\n            return Types.newArtificialTypeVariable(WildcardCapturer.class, name, upperBounds);\n        }\n\n        private WildcardCapturer forTypeVariable(final TypeVariable<?> typeParam)\n        {\n            return new WildcardCapturer(id)\n            {\n                @Override\n                TypeVariable<?> captureAsTypeVariable(Type[] upperBounds)\n                {\n                    Set<Type> combined = new LinkedHashSet<>(asList(upperBounds));\n                    // Since this is an artifically generated type variable, we don't bother checking\n                    // subtyping between declared type bound and actual type bound. So it's possible that we\n                    // may generate something like <capture#1-of ? extends Foo&SubFoo>.\n                    // Checking subtype between declared and actual type bounds\n                    // adds recursive isSubtypeOf() call and feels complicated.\n                    // There is no contract one way or another as long as isSubtypeOf() works as expected.\n                    combined.addAll(asList(typeParam.getBounds()));\n                    if (combined.size() > 1)   // Object is implicit and only useful if it's the only bound.\n                    {\n                        combined.remove(Object.class);\n                    }\n                    return super.captureAsTypeVariable(combined.toArray(new Type[0]));\n                }\n            };\n        }\n\n        private WildcardCapturer notForTypeVariable()\n        {\n            return new WildcardCapturer(id);\n        }\n\n        private Type captureNullable(@NullableDecl Type type)\n        {\n            if (type == null)\n            {\n                return null;\n            }\n            return capture(type);\n        }\n    }\n\n    /**\n     * Wraps around {@code TypeVariable<?>} to ensure that any two type variables are equal as long as\n     * they are declared by the same {@link java.lang.reflect.GenericDeclaration} and have the same\n     * name, even if their bounds differ.\n     *\n     * <p>While resolving a type variable from a {@code var -> type} map, we don't care whether the\n     * type variable's bound has been partially resolved. As long as the type variable \"identity\"\n     * matches.\n     *\n     * <p>On the other hand, if for example we are resolving {@code List<A extends B>} to {@code\n     * List<A extends String>}, we need to compare that {@code <A extends B>} is unequal to {@code <A\n     * extends String>} in order to decide to use the transformed type instead of the original type.\n     */\n    static final class TypeVariableKey\n    {\n        private final TypeVariable<?> var;\n\n        TypeVariableKey(TypeVariable<?> var)\n        {\n            this.var = checkNotNull(var);\n        }\n\n        @Override\n        public int hashCode()\n        {\n            return Objects.hashCode(var.getGenericDeclaration(), var.getName());\n        }\n\n        @Override\n        public boolean equals(Object obj)\n        {\n            if (obj instanceof TypeVariableKey)\n            {\n                TypeVariableKey that = (TypeVariableKey) obj;\n                return equalsTypeVariable(that.var);\n            }\n            else\n            {\n                return false;\n            }\n        }\n\n        @Override\n        public String toString()\n        {\n            return var.toString();\n        }\n\n        /** Wraps {@code t} in a {@code TypeVariableKey} if it's a type variable. */\n        static TypeVariableKey forLookup(Type t)\n        {\n            if (t instanceof TypeVariable)\n            {\n                return new TypeVariableKey((TypeVariable<?>) t);\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        /**\n         * Returns true if {@code type} is a {@code TypeVariable} with the same name and declared by the\n         * same {@code GenericDeclaration}.\n         */\n        boolean equalsType(Type type)\n        {\n            if (type instanceof TypeVariable)\n            {\n                return equalsTypeVariable((TypeVariable<?>) type);\n            }\n            else\n            {\n                return false;\n            }\n        }\n\n        private boolean equalsTypeVariable(TypeVariable<?> that)\n        {\n            return var.getGenericDeclaration().equals(that.getGenericDeclaration())\n                   && var.getName().equals(that.getName());\n        }\n    }\n}"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/AbstractMapBasedMultimap.java", "func_name": "AbstractMapBasedMultimap.setMap", "original_string": "", "language": "java", "code": "", "code_tokens": [], "docstring": "Used during deserialization only.", "docstring_tokens": ["Used", "during", "deserialization", "only", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/AbstractMapBasedMultimap.java#L121-L128", "partition": "valid", "up_fun_num": 2, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import static com.google.common.base.Preconditions.checkArgument;", "import static com.google.common.base.Preconditions.checkNotNull;", "import static com.google.common.collect.CollectPreconditions.checkRemove;", "import com.google.common.annotations.GwtCompatible;", "import com.google.common.collect.Maps.ViewCachingAbstractMap;", "import com.google.j2objc.annotations.WeakOuter;", "import java.io.Serializable;", "import java.util.AbstractCollection;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.Comparator;", "import java.util.ConcurrentModificationException;", "import java.util.Iterator;", "import java.util.List;", "import java.util.ListIterator;", "import java.util.Map;", "import java.util.Map.Entry;", "import java.util.NavigableMap;", "import java.util.NavigableSet;", "import java.util.RandomAccess;", "import java.util.Set;", "import java.util.SortedMap;", "import java.util.SortedSet;", "import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;", "import org.checkerframework.checker.nullness.compatqual.NullableDecl;"], "function": ["abstract class AbstractMapBasedMultimap<K, V> extends AbstractMultimap<K, V>\n", "    Collection<V> createUnmodifiableEmptyCollection()\n", "    abstract Collection<V> createCollection();\n", "    Collection<V> createCollection(@NullableDecl K key)\n", "    Map<K, Collection<V>> backingMap()\n", "    public int size()\n", "    public boolean containsKey(@NullableDecl Object key)\n", "    public boolean put(@NullableDecl K key, @NullableDecl V value)\n", "    private Collection<V> getOrCreateCollection(@NullableDecl K key)\n", "    public Collection<V> replaceValues(@NullableDecl K key, Iterable<? extends V> values)\n", "    public Collection<V> removeAll(@NullableDecl Object key)\n", "    <E> Collection<E> unmodifiableCollectionSubclass(Collection<E> collection)\n", "    public void clear()\n", "    public Collection<V> get(@NullableDecl K key)\n", "    Collection<V> wrapCollection(@NullableDecl K key, Collection<V> collection)\n", "    final List<V> wrapList(\n", "    private static <E> Iterator<E> iteratorOrListIterator(Collection<E> collection)\n", "    Set<K> createKeySet()\n", "    final Set<K> createMaybeNavigableKeySet()\n", "    private void removeValuesForKey(Object key)\n", "    public Collection<V> values()\n", "    Collection<V> createValues()\n", "    Iterator<V> valueIterator()\n", "    Multiset<K> createKeys()\n", "    public Collection<Entry<K, V>> entries()\n", "    Collection<Entry<K, V>> createEntries()\n", "    Iterator<Entry<K, V>> entryIterator()\n", "    Map<K, Collection<V>> createAsMap()\n", "    final Map<K, Collection<V>> createMaybeNavigableAsMap()\n"], "context": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.collect.CollectPreconditions.checkRemove;\n\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.collect.Maps.ViewCachingAbstractMap;\nimport com.google.j2objc.annotations.WeakOuter;\nimport java.io.Serializable;\nimport java.util.AbstractCollection;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.ConcurrentModificationException;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NavigableMap;\nimport java.util.NavigableSet;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.SortedSet;\nimport org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * Basic implementation of the {@link Multimap} interface. This class represents a multimap as a map\n * that associates each key with a collection of values. All methods of {@link Multimap} are\n * supported, including those specified as optional in the interface.\n *\n * <p>To implement a multimap, a subclass must define the method {@link #createCollection()}, which\n * creates an empty collection of values for a key.\n *\n * <p>The multimap constructor takes a map that has a single entry for each distinct key. When you\n * insert a key-value pair with a key that isn't already in the multimap, {@code\n * AbstractMapBasedMultimap} calls {@link #createCollection()} to create the collection of values\n * for that key. The subclass should not call {@link #createCollection()} directly, and a new\n * instance should be created every time the method is called.\n *\n * <p>For example, the subclass could pass a {@link java.util.TreeMap} during construction, and\n * {@link #createCollection()} could return a {@link java.util.TreeSet}, in which case the\n * multimap's iterators would propagate through the keys and values in sorted order.\n *\n * <p>Keys and values may be null, as long as the underlying collection classes support null\n * elements.\n *\n * <p>The collections created by {@link #createCollection()} may or may not allow duplicates. If the\n * collection, such as a {@link Set}, does not support duplicates, an added key-value pair will\n * replace an existing pair with the same key and value, if such a pair is present. With collections\n * like {@link List} that allow duplicates, the collection will keep the existing key-value pairs\n * while adding a new pair.\n *\n * <p>This class is not threadsafe when any concurrent operations update the multimap, even if the\n * underlying map and {@link #createCollection()} method return threadsafe classes. Concurrent read\n * operations will work correctly. To allow concurrent update operations, wrap your multimap with a\n * call to {@link Multimaps#synchronizedMultimap}.\n *\n * <p>For serialization to work, the subclass must specify explicit {@code readObject} and {@code\n * writeObject} methods.\n *\n * @author Jared Levy\n * @author Louis Wasserman\n */\n@GwtCompatible\nabstract class AbstractMapBasedMultimap<K, V> extends AbstractMultimap<K, V>\n    implements Serializable\n{\n    /*\n     * Here's an outline of the overall design.\n     *\n     * The map variable contains the collection of values associated with each\n     * key. When a key-value pair is added to a multimap that didn't previously\n     * contain any values for that key, a new collection generated by\n     * createCollection is added to the map. That same collection instance\n     * remains in the map as long as the multimap has any values for the key. If\n     * all values for the key are removed, the key and collection are removed\n     * from the map.\n     *\n     * The get method returns a WrappedCollection, which decorates the collection\n     * in the map (if the key is present) or an empty collection (if the key is\n     * not present). When the collection delegate in the WrappedCollection is\n     * empty, the multimap may contain subsequently added values for that key. To\n     * handle that situation, the WrappedCollection checks whether map contains\n     * an entry for the provided key, and if so replaces the delegate.\n     */\n\n    private transient Map<K, Collection<V>> map;\n    private transient int totalSize;\n\n    /**\n     * Creates a new multimap that uses the provided map.\n     *\n     * @param map place to store the mapping from each key to its corresponding values\n     * @throws IllegalArgumentException if {@code map} is not empty\n     */\n    protected AbstractMapBasedMultimap(Map<K, Collection<V>> map)\n    {\n        checkArgument(map.isEmpty());\n        this.map = map;\n    }\n\n    /** Used during deserialization only. */\n\n    /**\n     * Creates an unmodifiable, empty collection of values.\n     *\n     * <p>This is used in {@link #removeAll} on an empty key.\n     */\n    Collection<V> createUnmodifiableEmptyCollection()\n    {\n        return unmodifiableCollectionSubclass(createCollection());\n    }\n\n    /**\n     * Creates the collection of values for a single key.\n     *\n     * <p>Collections with weak, soft, or phantom references are not supported. Each call to {@code\n     * createCollection} should create a new instance.\n     *\n     * <p>The returned collection class determines whether duplicate key-value pairs are allowed.\n     *\n     * @return an empty collection of values\n     */\n    abstract Collection<V> createCollection();\n\n    /**\n     * Creates the collection of values for an explicitly provided key. By default, it simply calls\n     * {@link #createCollection()}, which is the correct behavior for most implementations. The {@link\n     * LinkedHashMultimap} class overrides it.\n     *\n     * @param key key to associate with values in the collection\n     * @return an empty collection of values\n     */\n    Collection<V> createCollection(@NullableDecl K key)\n    {\n        return createCollection();\n    }\n\n    Map<K, Collection<V>> backingMap()\n    {\n        return map;\n    }\n\n    // Query Operations\n\n    @Override\n    public int size()\n    {\n        return totalSize;\n    }\n\n    @Override\n    public boolean containsKey(@NullableDecl Object key)\n    {\n        return map.containsKey(key);\n    }\n\n    // Modification Operations\n\n    @Override\n    public boolean put(@NullableDecl K key, @NullableDecl V value)\n    {\n        Collection<V> collection = map.get(key);\n        if (collection == null)\n        {\n            collection = createCollection(key);\n            if (collection.add(value))\n            {\n                totalSize++;\n                map.put(key, collection);\n                return true;\n            }\n            else\n            {\n                throw new AssertionError(\"New Collection violated the Collection spec\");\n            }\n        }\n        else if (collection.add(value))\n        {\n            totalSize++;\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n    private Collection<V> getOrCreateCollection(@NullableDecl K key)\n    {\n        Collection<V> collection = map.get(key);\n        if (collection == null)\n        {\n            collection = createCollection(key);\n            map.put(key, collection);\n        }\n        return collection;\n    }\n\n    // Bulk Operations\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>The returned collection is immutable.\n     */\n    @Override\n    public Collection<V> replaceValues(@NullableDecl K key, Iterable<? extends V> values)\n    {\n        Iterator<? extends V> iterator = values.iterator();\n        if (!iterator.hasNext())\n        {\n            return removeAll(key);\n        }\n\n        // TODO(lowasser): investigate atomic failure?\n        Collection<V> collection = getOrCreateCollection(key);\n        Collection<V> oldValues = createCollection();\n        oldValues.addAll(collection);\n\n        totalSize -= collection.size();\n        collection.clear();\n\n        while (iterator.hasNext())\n        {\n            if (collection.add(iterator.next()))\n            {\n                totalSize++;\n            }\n        }\n\n        return unmodifiableCollectionSubclass(oldValues);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>The returned collection is immutable.\n     */\n    @Override\n    public Collection<V> removeAll(@NullableDecl Object key)\n    {\n        Collection<V> collection = map.remove(key);\n\n        if (collection == null)\n        {\n            return createUnmodifiableEmptyCollection();\n        }\n\n        Collection<V> output = createCollection();\n        output.addAll(collection);\n        totalSize -= collection.size();\n        collection.clear();\n\n        return unmodifiableCollectionSubclass(output);\n    }\n\n    <E> Collection<E> unmodifiableCollectionSubclass(Collection<E> collection)\n    {\n        return Collections.unmodifiableCollection(collection);\n    }\n\n    @Override\n    public void clear()\n    {\n        // Clear each collection, to make previously returned collections empty.\n        for (Collection<V> collection : map.values())\n        {\n            collection.clear();\n        }\n        map.clear();\n        totalSize = 0;\n    }\n\n    // Views\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>The returned collection is not serializable.\n     */\n    @Override\n    public Collection<V> get(@NullableDecl K key)\n    {\n        Collection<V> collection = map.get(key);\n        if (collection == null)\n        {\n            collection = createCollection(key);\n        }\n        return wrapCollection(key, collection);\n    }\n\n    /**\n     * Generates a decorated collection that remains consistent with the values in the multimap for\n     * the provided key. Changes to the multimap may alter the returned collection, and vice versa.\n     */\n    Collection<V> wrapCollection(@NullableDecl K key, Collection<V> collection)\n    {\n        return new WrappedCollection(key, collection, null);\n    }\n\n    final List<V> wrapList(\n        @NullableDecl K key, List<V> list, @NullableDecl WrappedCollection ancestor)\n    {\n        return (list instanceof RandomAccess)\n               ? new RandomAccessWrappedList(key, list, ancestor)\n               : new WrappedList(key, list, ancestor);\n    }\n\n    /**\n     * Collection decorator that stays in sync with the multimap values for a key. There are two kinds\n     * of wrapped collections: full and subcollections. Both have a delegate pointing to the\n     * underlying collection class.\n     *\n     * <p>Full collections, identified by a null ancestor field, contain all multimap values for a\n     * given key. Its delegate is a value in {@link AbstractMapBasedMultimap#map} whenever the\n     * delegate is non-empty. The {@code refreshIfEmpty}, {@code removeIfEmpty}, and {@code addToMap}\n     * methods ensure that the {@code WrappedCollection} and map remain consistent.\n     *\n     * <p>A subcollection, such as a sublist, contains some of the values for a given key. Its\n     * ancestor field points to the full wrapped collection with all values for the key. The\n     * subcollection {@code refreshIfEmpty}, {@code removeIfEmpty}, and {@code addToMap} methods call\n     * the corresponding methods of the full wrapped collection.\n     */\n    @WeakOuter\n    class WrappedCollection extends AbstractCollection<V>\n    {\n        @NullableDecl final K key;\n        Collection<V> delegate;\n        @NullableDecl final WrappedCollection ancestor;\n        @NullableDecl final Collection<V> ancestorDelegate;\n\n        WrappedCollection(\n            @NullableDecl K key, Collection<V> delegate, @NullableDecl WrappedCollection ancestor)\n        {\n            this.key = key;\n            this.delegate = delegate;\n            this.ancestor = ancestor;\n            this.ancestorDelegate = (ancestor == null) ? null : ancestor.getDelegate();\n        }\n\n        /**\n         * If the delegate collection is empty, but the multimap has values for the key, replace the\n         * delegate with the new collection for the key.\n         *\n         * <p>For a subcollection, refresh its ancestor and validate that the ancestor delegate hasn't\n         * changed.\n         */\n        void refreshIfEmpty()\n        {\n            if (ancestor != null)\n            {\n                ancestor.refreshIfEmpty();\n                if (ancestor.getDelegate() != ancestorDelegate)\n                {\n                    throw new ConcurrentModificationException();\n                }\n            }\n            else if (delegate.isEmpty())\n            {\n                Collection<V> newDelegate = map.get(key);\n                if (newDelegate != null)\n                {\n                    delegate = newDelegate;\n                }\n            }\n        }\n\n        /**\n         * If collection is empty, remove it from {@code AbstractMapBasedMultimap.this.map}. For\n         * subcollections, check whether the ancestor collection is empty.\n         */\n        void removeIfEmpty()\n        {\n            if (ancestor != null)\n            {\n                ancestor.removeIfEmpty();\n            }\n            else if (delegate.isEmpty())\n            {\n                map.remove(key);\n            }\n        }\n\n        K getKey()\n        {\n            return key;\n        }\n\n        /**\n         * Add the delegate to the map. Other {@code WrappedCollection} methods should call this method\n         * after adding elements to a previously empty collection.\n         *\n         * <p>Subcollection add the ancestor's delegate instead.\n         */\n        void addToMap()\n        {\n            if (ancestor != null)\n            {\n                ancestor.addToMap();\n            }\n            else\n            {\n                map.put(key, delegate);\n            }\n        }\n\n        @Override\n        public int size()\n        {\n            refreshIfEmpty();\n            return delegate.size();\n        }\n\n        @Override\n        public boolean equals(@NullableDecl Object object)\n        {\n            if (object == this)\n            {\n                return true;\n            }\n            refreshIfEmpty();\n            return delegate.equals(object);\n        }\n\n        @Override\n        public int hashCode()\n        {\n            refreshIfEmpty();\n            return delegate.hashCode();\n        }\n\n        @Override\n        public String toString()\n        {\n            refreshIfEmpty();\n            return delegate.toString();\n        }\n\n        Collection<V> getDelegate()\n        {\n            return delegate;\n        }\n\n        @Override\n        public Iterator<V> iterator()\n        {\n            refreshIfEmpty();\n            return new WrappedIterator();\n        }\n\n        /** Collection iterator for {@code WrappedCollection}. */\n        class WrappedIterator implements Iterator<V>\n        {\n            final Iterator<V> delegateIterator;\n            final Collection<V> originalDelegate = delegate;\n\n            WrappedIterator()\n            {\n                delegateIterator = iteratorOrListIterator(delegate);\n            }\n\n            WrappedIterator(Iterator<V> delegateIterator)\n            {\n                this.delegateIterator = delegateIterator;\n            }\n\n            /**\n             * If the delegate changed since the iterator was created, the iterator is no longer valid.\n             */\n            void validateIterator()\n            {\n                refreshIfEmpty();\n                if (delegate != originalDelegate)\n                {\n                    throw new ConcurrentModificationException();\n                }\n            }\n\n            @Override\n            public boolean hasNext()\n            {\n                validateIterator();\n                return delegateIterator.hasNext();\n            }\n\n            @Override\n            public V next()\n            {\n                validateIterator();\n                return delegateIterator.next();\n            }\n\n            @Override\n            public void remove()\n            {\n                delegateIterator.remove();\n                totalSize--;\n                removeIfEmpty();\n            }\n\n            Iterator<V> getDelegateIterator()\n            {\n                validateIterator();\n                return delegateIterator;\n            }\n        }\n\n        @Override\n        public boolean add(V value)\n        {\n            refreshIfEmpty();\n            boolean wasEmpty = delegate.isEmpty();\n            boolean changed = delegate.add(value);\n            if (changed)\n            {\n                totalSize++;\n                if (wasEmpty)\n                {\n                    addToMap();\n                }\n            }\n            return changed;\n        }\n\n        WrappedCollection getAncestor()\n        {\n            return ancestor;\n        }\n\n        // The following methods are provided for better performance.\n\n        @Override\n        public boolean addAll(Collection<? extends V> collection)\n        {\n            if (collection.isEmpty())\n            {\n                return false;\n            }\n            int oldSize = size(); // calls refreshIfEmpty\n            boolean changed = delegate.addAll(collection);\n            if (changed)\n            {\n                int newSize = delegate.size();\n                totalSize += (newSize - oldSize);\n                if (oldSize == 0)\n                {\n                    addToMap();\n                }\n            }\n            return changed;\n        }\n\n        @Override\n        public boolean contains(Object o)\n        {\n            refreshIfEmpty();\n            return delegate.contains(o);\n        }\n\n        @Override\n        public boolean containsAll(Collection<?> c)\n        {\n            refreshIfEmpty();\n            return delegate.containsAll(c);\n        }\n\n        @Override\n        public void clear()\n        {\n            int oldSize = size(); // calls refreshIfEmpty\n            if (oldSize == 0)\n            {\n                return;\n            }\n            delegate.clear();\n            totalSize -= oldSize;\n            removeIfEmpty(); // maybe shouldn't be removed if this is a sublist\n        }\n\n        @Override\n        public boolean remove(Object o)\n        {\n            refreshIfEmpty();\n            boolean changed = delegate.remove(o);\n            if (changed)\n            {\n                totalSize--;\n                removeIfEmpty();\n            }\n            return changed;\n        }\n\n        @Override\n        public boolean removeAll(Collection<?> c)\n        {\n            if (c.isEmpty())\n            {\n                return false;\n            }\n            int oldSize = size(); // calls refreshIfEmpty\n            boolean changed = delegate.removeAll(c);\n            if (changed)\n            {\n                int newSize = delegate.size();\n                totalSize += (newSize - oldSize);\n                removeIfEmpty();\n            }\n            return changed;\n        }\n\n        @Override\n        public boolean retainAll(Collection<?> c)\n        {\n            checkNotNull(c);\n            int oldSize = size(); // calls refreshIfEmpty\n            boolean changed = delegate.retainAll(c);\n            if (changed)\n            {\n                int newSize = delegate.size();\n                totalSize += (newSize - oldSize);\n                removeIfEmpty();\n            }\n            return changed;\n        }\n    }\n\n    private static <E> Iterator<E> iteratorOrListIterator(Collection<E> collection)\n    {\n        return (collection instanceof List)\n               ? ((List<E>) collection).listIterator()\n               : collection.iterator();\n    }\n\n    /** Set decorator that stays in sync with the multimap values for a key. */\n    @WeakOuter\n    class WrappedSet extends WrappedCollection implements Set<V>\n    {\n        WrappedSet(@NullableDecl K key, Set<V> delegate)\n        {\n            super(key, delegate, null);\n        }\n\n        @Override\n        public boolean removeAll(Collection<?> c)\n        {\n            if (c.isEmpty())\n            {\n                return false;\n            }\n            int oldSize = size(); // calls refreshIfEmpty\n\n            // Guava issue 1013: AbstractSet and most JDK set implementations are\n            // susceptible to quadratic removeAll performance on lists;\n            // use a slightly smarter implementation here\n            boolean changed = Sets.removeAllImpl((Set<V>) delegate, c);\n            if (changed)\n            {\n                int newSize = delegate.size();\n                totalSize += (newSize - oldSize);\n                removeIfEmpty();\n            }\n            return changed;\n        }\n    }\n\n    /** SortedSet decorator that stays in sync with the multimap values for a key. */\n    @WeakOuter\n    class WrappedSortedSet extends WrappedCollection implements SortedSet<V>\n    {\n        WrappedSortedSet(\n            @NullableDecl K key, SortedSet<V> delegate, @NullableDecl WrappedCollection ancestor)\n        {\n            super(key, delegate, ancestor);\n        }\n\n        SortedSet<V> getSortedSetDelegate()\n        {\n            return (SortedSet<V>) getDelegate();\n        }\n\n        @Override\n        public Comparator<? super V> comparator()\n        {\n            return getSortedSetDelegate().comparator();\n        }\n\n        @Override\n        public V first()\n        {\n            refreshIfEmpty();\n            return getSortedSetDelegate().first();\n        }\n\n        @Override\n        public V last()\n        {\n            refreshIfEmpty();\n            return getSortedSetDelegate().last();\n        }\n\n        @Override\n        public SortedSet<V> headSet(V toElement)\n        {\n            refreshIfEmpty();\n            return new WrappedSortedSet(\n                       getKey(),\n                       getSortedSetDelegate().headSet(toElement),\n                       (getAncestor() == null) ? this : getAncestor());\n        }\n\n        @Override\n        public SortedSet<V> subSet(V fromElement, V toElement)\n        {\n            refreshIfEmpty();\n            return new WrappedSortedSet(\n                       getKey(),\n                       getSortedSetDelegate().subSet(fromElement, toElement),\n                       (getAncestor() == null) ? this : getAncestor());\n        }\n\n        @Override\n        public SortedSet<V> tailSet(V fromElement)\n        {\n            refreshIfEmpty();\n            return new WrappedSortedSet(\n                       getKey(),\n                       getSortedSetDelegate().tailSet(fromElement),\n                       (getAncestor() == null) ? this : getAncestor());\n        }\n    }\n\n    @WeakOuter\n    class WrappedNavigableSet extends WrappedSortedSet implements NavigableSet<V>\n    {\n        WrappedNavigableSet(\n            @NullableDecl K key, NavigableSet<V> delegate, @NullableDecl WrappedCollection ancestor)\n        {\n            super(key, delegate, ancestor);\n        }\n\n        @Override\n        NavigableSet<V> getSortedSetDelegate()\n        {\n            return (NavigableSet<V>) super.getSortedSetDelegate();\n        }\n\n        @Override\n        public V lower(V v)\n        {\n            return getSortedSetDelegate().lower(v);\n        }\n\n        @Override\n        public V floor(V v)\n        {\n            return getSortedSetDelegate().floor(v);\n        }\n\n        @Override\n        public V ceiling(V v)\n        {\n            return getSortedSetDelegate().ceiling(v);\n        }\n\n        @Override\n        public V higher(V v)\n        {\n            return getSortedSetDelegate().higher(v);\n        }\n\n        @Override\n        public V pollFirst()\n        {\n            return Iterators.pollNext(iterator());\n        }\n\n        @Override\n        public V pollLast()\n        {\n            return Iterators.pollNext(descendingIterator());\n        }\n\n        private NavigableSet<V> wrap(NavigableSet<V> wrapped)\n        {\n            return new WrappedNavigableSet(key, wrapped, (getAncestor() == null) ? this : getAncestor());\n        }\n\n        @Override\n        public NavigableSet<V> descendingSet()\n        {\n            return wrap(getSortedSetDelegate().descendingSet());\n        }\n\n        @Override\n        public Iterator<V> descendingIterator()\n        {\n            return new WrappedIterator(getSortedSetDelegate().descendingIterator());\n        }\n\n        @Override\n        public NavigableSet<V> subSet(\n            V fromElement, boolean fromInclusive, V toElement, boolean toInclusive)\n        {\n            return wrap(\n                       getSortedSetDelegate().subSet(fromElement, fromInclusive, toElement, toInclusive));\n        }\n\n        @Override\n        public NavigableSet<V> headSet(V toElement, boolean inclusive)\n        {\n            return wrap(getSortedSetDelegate().headSet(toElement, inclusive));\n        }\n\n        @Override\n        public NavigableSet<V> tailSet(V fromElement, boolean inclusive)\n        {\n            return wrap(getSortedSetDelegate().tailSet(fromElement, inclusive));\n        }\n    }\n\n    /** List decorator that stays in sync with the multimap values for a key. */\n    @WeakOuter\n    class WrappedList extends WrappedCollection implements List<V>\n    {\n        WrappedList(@NullableDecl K key, List<V> delegate, @NullableDecl WrappedCollection ancestor)\n        {\n            super(key, delegate, ancestor);\n        }\n\n        List<V> getListDelegate()\n        {\n            return (List<V>) getDelegate();\n        }\n\n        @Override\n        public boolean addAll(int index, Collection<? extends V> c)\n        {\n            if (c.isEmpty())\n            {\n                return false;\n            }\n            int oldSize = size(); // calls refreshIfEmpty\n            boolean changed = getListDelegate().addAll(index, c);\n            if (changed)\n            {\n                int newSize = getDelegate().size();\n                totalSize += (newSize - oldSize);\n                if (oldSize == 0)\n                {\n                    addToMap();\n                }\n            }\n            return changed;\n        }\n\n        @Override\n        public V get(int index)\n        {\n            refreshIfEmpty();\n            return getListDelegate().get(index);\n        }\n\n        @Override\n        public V set(int index, V element)\n        {\n            refreshIfEmpty();\n            return getListDelegate().set(index, element);\n        }\n\n        @Override\n        public void add(int index, V element)\n        {\n            refreshIfEmpty();\n            boolean wasEmpty = getDelegate().isEmpty();\n            getListDelegate().add(index, element);\n            totalSize++;\n            if (wasEmpty)\n            {\n                addToMap();\n            }\n        }\n\n        @Override\n        public V remove(int index)\n        {\n            refreshIfEmpty();\n            V value = getListDelegate().remove(index);\n            totalSize--;\n            removeIfEmpty();\n            return value;\n        }\n\n        @Override\n        public int indexOf(Object o)\n        {\n            refreshIfEmpty();\n            return getListDelegate().indexOf(o);\n        }\n\n        @Override\n        public int lastIndexOf(Object o)\n        {\n            refreshIfEmpty();\n            return getListDelegate().lastIndexOf(o);\n        }\n\n        @Override\n        public ListIterator<V> listIterator()\n        {\n            refreshIfEmpty();\n            return new WrappedListIterator();\n        }\n\n        @Override\n        public ListIterator<V> listIterator(int index)\n        {\n            refreshIfEmpty();\n            return new WrappedListIterator(index);\n        }\n\n        @Override\n        public List<V> subList(int fromIndex, int toIndex)\n        {\n            refreshIfEmpty();\n            return wrapList(\n                       getKey(),\n                       getListDelegate().subList(fromIndex, toIndex),\n                       (getAncestor() == null) ? this : getAncestor());\n        }\n\n        /** ListIterator decorator. */\n        private class WrappedListIterator extends WrappedIterator implements ListIterator<V>\n        {\n            WrappedListIterator() {}\n\n            public WrappedListIterator(int index)\n            {\n                super(getListDelegate().listIterator(index));\n            }\n\n            private ListIterator<V> getDelegateListIterator()\n            {\n                return (ListIterator<V>) getDelegateIterator();\n            }\n\n            @Override\n            public boolean hasPrevious()\n            {\n                return getDelegateListIterator().hasPrevious();\n            }\n\n            @Override\n            public V previous()\n            {\n                return getDelegateListIterator().previous();\n            }\n\n            @Override\n            public int nextIndex()\n            {\n                return getDelegateListIterator().nextIndex();\n            }\n\n            @Override\n            public int previousIndex()\n            {\n                return getDelegateListIterator().previousIndex();\n            }\n\n            @Override\n            public void set(V value)\n            {\n                getDelegateListIterator().set(value);\n            }\n\n            @Override\n            public void add(V value)\n            {\n                boolean wasEmpty = isEmpty();\n                getDelegateListIterator().add(value);\n                totalSize++;\n                if (wasEmpty)\n                {\n                    addToMap();\n                }\n            }\n        }\n    }\n\n    /**\n     * List decorator that stays in sync with the multimap values for a key and supports rapid random\n     * access.\n     */\n    private class RandomAccessWrappedList extends WrappedList implements RandomAccess\n    {\n        RandomAccessWrappedList(\n            @NullableDecl K key, List<V> delegate, @NullableDecl WrappedCollection ancestor)\n        {\n            super(key, delegate, ancestor);\n        }\n    }\n\n    @Override\n    Set<K> createKeySet()\n    {\n        return new KeySet(map);\n    }\n\n    final Set<K> createMaybeNavigableKeySet()\n    {\n        if (map instanceof NavigableMap)\n        {\n            return new NavigableKeySet((NavigableMap<K, Collection<V>>) map);\n        }\n        else if (map instanceof SortedMap)\n        {\n            return new SortedKeySet((SortedMap<K, Collection<V>>) map);\n        }\n        else\n        {\n            return new KeySet(map);\n        }\n    }\n\n    @WeakOuter\n    private class KeySet extends Maps.KeySet<K, Collection<V>>\n    {\n        KeySet(final Map<K, Collection<V>> subMap)\n        {\n            super(subMap);\n        }\n\n        @Override\n        public Iterator<K> iterator()\n        {\n            final Iterator<Entry<K, Collection<V>>> entryIterator = map().entrySet().iterator();\n            return new Iterator<K>()\n            {\n                @NullableDecl Entry<K, Collection<V>> entry;\n\n                @Override\n                public boolean hasNext()\n                {\n                    return entryIterator.hasNext();\n                }\n\n                @Override\n                public K next()\n                {\n                    entry = entryIterator.next();\n                    return entry.getKey();\n                }\n\n                @Override\n                public void remove()\n                {\n                    checkRemove(entry != null);\n                    Collection<V> collection = entry.getValue();\n                    entryIterator.remove();\n                    totalSize -= collection.size();\n                    collection.clear();\n                    entry = null;\n                }\n            };\n        }\n\n        // The following methods are included for better performance.\n\n        @Override\n        public boolean remove(Object key)\n        {\n            int count = 0;\n            Collection<V> collection = map().remove(key);\n            if (collection != null)\n            {\n                count = collection.size();\n                collection.clear();\n                totalSize -= count;\n            }\n            return count > 0;\n        }\n\n        @Override\n        public void clear()\n        {\n            Iterators.clear(iterator());\n        }\n\n        @Override\n        public boolean containsAll(Collection<?> c)\n        {\n            return map().keySet().containsAll(c);\n        }\n\n        @Override\n        public boolean equals(@NullableDecl Object object)\n        {\n            return this == object || this.map().keySet().equals(object);\n        }\n\n        @Override\n        public int hashCode()\n        {\n            return map().keySet().hashCode();\n        }\n    }\n\n    @WeakOuter\n    private class SortedKeySet extends KeySet implements SortedSet<K>\n    {\n\n        SortedKeySet(SortedMap<K, Collection<V>> subMap)\n        {\n            super(subMap);\n        }\n\n        SortedMap<K, Collection<V>> sortedMap()\n        {\n            return (SortedMap<K, Collection<V>>) super.map();\n        }\n\n        @Override\n        public Comparator<? super K> comparator()\n        {\n            return sortedMap().comparator();\n        }\n\n        @Override\n        public K first()\n        {\n            return sortedMap().firstKey();\n        }\n\n        @Override\n        public SortedSet<K> headSet(K toElement)\n        {\n            return new SortedKeySet(sortedMap().headMap(toElement));\n        }\n\n        @Override\n        public K last()\n        {\n            return sortedMap().lastKey();\n        }\n\n        @Override\n        public SortedSet<K> subSet(K fromElement, K toElement)\n        {\n            return new SortedKeySet(sortedMap().subMap(fromElement, toElement));\n        }\n\n        @Override\n        public SortedSet<K> tailSet(K fromElement)\n        {\n            return new SortedKeySet(sortedMap().tailMap(fromElement));\n        }\n    }\n\n    @WeakOuter\n    class NavigableKeySet extends SortedKeySet implements NavigableSet<K>\n    {\n        NavigableKeySet(NavigableMap<K, Collection<V>> subMap)\n        {\n            super(subMap);\n        }\n\n        @Override\n        NavigableMap<K, Collection<V>> sortedMap()\n        {\n            return (NavigableMap<K, Collection<V>>) super.sortedMap();\n        }\n\n        @Override\n        public K lower(K k)\n        {\n            return sortedMap().lowerKey(k);\n        }\n\n        @Override\n        public K floor(K k)\n        {\n            return sortedMap().floorKey(k);\n        }\n\n        @Override\n        public K ceiling(K k)\n        {\n            return sortedMap().ceilingKey(k);\n        }\n\n        @Override\n        public K higher(K k)\n        {\n            return sortedMap().higherKey(k);\n        }\n\n        @Override\n        public K pollFirst()\n        {\n            return Iterators.pollNext(iterator());\n        }\n\n        @Override\n        public K pollLast()\n        {\n            return Iterators.pollNext(descendingIterator());\n        }\n\n        @Override\n        public NavigableSet<K> descendingSet()\n        {\n            return new NavigableKeySet(sortedMap().descendingMap());\n        }\n\n        @Override\n        public Iterator<K> descendingIterator()\n        {\n            return descendingSet().iterator();\n        }\n\n        @Override\n        public NavigableSet<K> headSet(K toElement)\n        {\n            return headSet(toElement, false);\n        }\n\n        @Override\n        public NavigableSet<K> headSet(K toElement, boolean inclusive)\n        {\n            return new NavigableKeySet(sortedMap().headMap(toElement, inclusive));\n        }\n\n        @Override\n        public NavigableSet<K> subSet(K fromElement, K toElement)\n        {\n            return subSet(fromElement, true, toElement, false);\n        }\n\n        @Override\n        public NavigableSet<K> subSet(\n            K fromElement, boolean fromInclusive, K toElement, boolean toInclusive)\n        {\n            return new NavigableKeySet(\n                       sortedMap().subMap(fromElement, fromInclusive, toElement, toInclusive));\n        }\n\n        @Override\n        public NavigableSet<K> tailSet(K fromElement)\n        {\n            return tailSet(fromElement, true);\n        }\n\n        @Override\n        public NavigableSet<K> tailSet(K fromElement, boolean inclusive)\n        {\n            return new NavigableKeySet(sortedMap().tailMap(fromElement, inclusive));\n        }\n    }\n\n    /** Removes all values for the provided key. */\n    private void removeValuesForKey(Object key)\n    {\n        Collection<V> collection = Maps.safeRemove(map, key);\n\n        if (collection != null)\n        {\n            int count = collection.size();\n            collection.clear();\n            totalSize -= count;\n        }\n    }\n\n    private abstract class Itr<T> implements Iterator<T>\n    {\n        final Iterator<Entry<K, Collection<V>>> keyIterator;\n        @NullableDecl K key;\n        @MonotonicNonNullDecl Collection<V> collection;\n        Iterator<V> valueIterator;\n\n        Itr()\n        {\n            keyIterator = map.entrySet().iterator();\n            key = null;\n            collection = null;\n            valueIterator = Iterators.emptyModifiableIterator();\n        }\n\n        abstract T output(K key, V value);\n\n        @Override\n        public boolean hasNext()\n        {\n            return keyIterator.hasNext() || valueIterator.hasNext();\n        }\n\n        @Override\n        public T next()\n        {\n            if (!valueIterator.hasNext())\n            {\n                Entry<K, Collection<V>> mapEntry = keyIterator.next();\n                key = mapEntry.getKey();\n                collection = mapEntry.getValue();\n                valueIterator = collection.iterator();\n            }\n            return output(key, valueIterator.next());\n        }\n\n        @Override\n        public void remove()\n        {\n            valueIterator.remove();\n            if (collection.isEmpty())\n            {\n                keyIterator.remove();\n            }\n            totalSize--;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>The iterator generated by the returned collection traverses the values for one key, followed\n     * by the values of a second key, and so on.\n     */\n    @Override\n    public Collection<V> values()\n    {\n        return super.values();\n    }\n\n    @Override\n    Collection<V> createValues()\n    {\n        return new Values();\n    }\n\n    @Override\n    Iterator<V> valueIterator()\n    {\n        return new Itr<V>()\n        {\n            @Override\n            V output(K key, V value)\n            {\n                return value;\n            }\n        };\n    }\n\n    /*\n     * TODO(kevinb): should we copy this javadoc to each concrete class, so that\n     * classes like LinkedHashMultimap that need to say something different are\n     * still able to {@inheritDoc} all the way from Multimap?\n     */\n\n    @Override\n    Multiset<K> createKeys()\n    {\n        return new Multimaps.Keys<K, V>(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>The iterator generated by the returned collection traverses the values for one key, followed\n     * by the values of a second key, and so on.\n     *\n     * <p>Each entry is an immutable snapshot of a key-value mapping in the multimap, taken at the\n     * time the entry is returned by a method call to the collection or its iterator.\n     */\n    @Override\n    public Collection<Entry<K, V>> entries()\n    {\n        return super.entries();\n    }\n\n    @Override\n    Collection<Entry<K, V>> createEntries()\n    {\n        if (this instanceof SetMultimap)\n        {\n            return new EntrySet();\n        }\n        else\n        {\n            return new Entries();\n        }\n    }\n\n    /**\n     * Returns an iterator across all key-value map entries, used by {@code entries().iterator()} and\n     * {@code values().iterator()}. The default behavior, which traverses the values for one key, the\n     * values for a second key, and so on, suffices for most {@code AbstractMapBasedMultimap}\n     * implementations.\n     *\n     * @return an iterator across map entries\n     */\n    @Override\n    Iterator<Entry<K, V>> entryIterator()\n    {\n        return new Itr<Entry<K, V>>()\n        {\n            @Override\n            Entry<K, V> output(K key, V value)\n            {\n                return Maps.immutableEntry(key, value);\n            }\n        };\n    }\n\n    @Override\n    Map<K, Collection<V>> createAsMap()\n    {\n        return new AsMap(map);\n    }\n\n    final Map<K, Collection<V>> createMaybeNavigableAsMap()\n    {\n        if (map instanceof NavigableMap)\n        {\n            return new NavigableAsMap((NavigableMap<K, Collection<V>>) map);\n        }\n        else if (map instanceof SortedMap)\n        {\n            return new SortedAsMap((SortedMap<K, Collection<V>>) map);\n        }\n        else\n        {\n            return new AsMap(map);\n        }\n    }\n\n    @WeakOuter\n    private class AsMap extends ViewCachingAbstractMap<K, Collection<V>>\n    {\n        /**\n         * Usually the same as map, but smaller for the headMap(), tailMap(), or subMap() of a\n         * SortedAsMap.\n         */\n        final transient Map<K, Collection<V>> submap;\n\n        AsMap(Map<K, Collection<V>> submap)\n        {\n            this.submap = submap;\n        }\n\n        @Override\n        protected Set<Entry<K, Collection<V>>> createEntrySet()\n        {\n            return new AsMapEntries();\n        }\n\n        // The following methods are included for performance.\n\n        @Override\n        public boolean containsKey(Object key)\n        {\n            return Maps.safeContainsKey(submap, key);\n        }\n\n        @Override\n        public Collection<V> get(Object key)\n        {\n            Collection<V> collection = Maps.safeGet(submap, key);\n            if (collection == null)\n            {\n                return null;\n            }\n            @SuppressWarnings(\"unchecked\")\n            K k = (K) key;\n            return wrapCollection(k, collection);\n        }\n\n        @Override\n        public Set<K> keySet()\n        {\n            return AbstractMapBasedMultimap.this.keySet();\n        }\n\n        @Override\n        public int size()\n        {\n            return submap.size();\n        }\n\n        @Override\n        public Collection<V> remove(Object key)\n        {\n            Collection<V> collection = submap.remove(key);\n            if (collection == null)\n            {\n                return null;\n            }\n\n            Collection<V> output = createCollection();\n            output.addAll(collection);\n            totalSize -= collection.size();\n            collection.clear();\n            return output;\n        }\n\n        @Override\n        public boolean equals(@NullableDecl Object object)\n        {\n            return this == object || submap.equals(object);\n        }\n\n        @Override\n        public int hashCode()\n        {\n            return submap.hashCode();\n        }\n\n        @Override\n        public String toString()\n        {\n            return submap.toString();\n        }\n\n        @Override\n        public void clear()\n        {\n            if (submap == map)\n            {\n                AbstractMapBasedMultimap.this.clear();\n            }\n            else\n            {\n                Iterators.clear(new AsMapIterator());\n            }\n        }\n\n        Entry<K, Collection<V>> wrapEntry(Entry<K, Collection<V>> entry)\n        {\n            K key = entry.getKey();\n            return Maps.immutableEntry(key, wrapCollection(key, entry.getValue()));\n        }\n\n        @WeakOuter\n        class AsMapEntries extends Maps.EntrySet<K, Collection<V>>\n        {\n            @Override\n            Map<K, Collection<V>> map()\n            {\n                return AsMap.this;\n            }\n\n            @Override\n            public Iterator<Entry<K, Collection<V>>> iterator()\n            {\n                return new AsMapIterator();\n            }\n\n            // The following methods are included for performance.\n\n            @Override\n            public boolean contains(Object o)\n            {\n                return Collections2.safeContains(submap.entrySet(), o);\n            }\n\n            @Override\n            public boolean remove(Object o)\n            {\n                if (!contains(o))\n                {\n                    return false;\n                }\n                Entry<?, ?> entry = (Entry<?, ?>) o;\n                removeValuesForKey(entry.getKey());\n                return true;\n            }\n        }\n\n        /** Iterator across all keys and value collections. */\n        class AsMapIterator implements Iterator<Entry<K, Collection<V>>>\n        {\n            final Iterator<Entry<K, Collection<V>>> delegateIterator = submap.entrySet().iterator();\n            @NullableDecl Collection<V> collection;\n\n            @Override\n            public boolean hasNext()\n            {\n                return delegateIterator.hasNext();\n            }\n\n            @Override\n            public Entry<K, Collection<V>> next()\n            {\n                Entry<K, Collection<V>> entry = delegateIterator.next();\n                collection = entry.getValue();\n                return wrapEntry(entry);\n            }\n\n            @Override\n            public void remove()\n            {\n                checkRemove(collection != null);\n                delegateIterator.remove();\n                totalSize -= collection.size();\n                collection.clear();\n                collection = null;\n            }\n        }\n    }\n\n    @WeakOuter\n    private class SortedAsMap extends AsMap implements SortedMap<K, Collection<V>>\n    {\n        SortedAsMap(SortedMap<K, Collection<V>> submap)\n        {\n            super(submap);\n        }\n\n        SortedMap<K, Collection<V>> sortedMap()\n        {\n            return (SortedMap<K, Collection<V>>) submap;\n        }\n\n        @Override\n        public Comparator<? super K> comparator()\n        {\n            return sortedMap().comparator();\n        }\n\n        @Override\n        public K firstKey()\n        {\n            return sortedMap().firstKey();\n        }\n\n        @Override\n        public K lastKey()\n        {\n            return sortedMap().lastKey();\n        }\n\n        @Override\n        public SortedMap<K, Collection<V>> headMap(K toKey)\n        {\n            return new SortedAsMap(sortedMap().headMap(toKey));\n        }\n\n        @Override\n        public SortedMap<K, Collection<V>> subMap(K fromKey, K toKey)\n        {\n            return new SortedAsMap(sortedMap().subMap(fromKey, toKey));\n        }\n\n        @Override\n        public SortedMap<K, Collection<V>> tailMap(K fromKey)\n        {\n            return new SortedAsMap(sortedMap().tailMap(fromKey));\n        }\n\n        @MonotonicNonNullDecl SortedSet<K> sortedKeySet;\n\n        // returns a SortedSet, even though returning a Set would be sufficient to\n        // satisfy the SortedMap.keySet() interface\n        @Override\n        public SortedSet<K> keySet()\n        {\n            SortedSet<K> result = sortedKeySet;\n            return (result == null) ? sortedKeySet = createKeySet() : result;\n        }\n\n        @Override\n        SortedSet<K> createKeySet()\n        {\n            return new SortedKeySet(sortedMap());\n        }\n    }\n\n    class NavigableAsMap extends SortedAsMap implements NavigableMap<K, Collection<V>>\n    {\n\n        NavigableAsMap(NavigableMap<K, Collection<V>> submap)\n        {\n            super(submap);\n        }\n\n        @Override\n        NavigableMap<K, Collection<V>> sortedMap()\n        {\n            return (NavigableMap<K, Collection<V>>) super.sortedMap();\n        }\n\n        @Override\n        public Entry<K, Collection<V>> lowerEntry(K key)\n        {\n            Entry<K, Collection<V>> entry = sortedMap().lowerEntry(key);\n            return (entry == null) ? null : wrapEntry(entry);\n        }\n\n        @Override\n        public K lowerKey(K key)\n        {\n            return sortedMap().lowerKey(key);\n        }\n\n        @Override\n        public Entry<K, Collection<V>> floorEntry(K key)\n        {\n            Entry<K, Collection<V>> entry = sortedMap().floorEntry(key);\n            return (entry == null) ? null : wrapEntry(entry);\n        }\n\n        @Override\n        public K floorKey(K key)\n        {\n            return sortedMap().floorKey(key);\n        }\n\n        @Override\n        public Entry<K, Collection<V>> ceilingEntry(K key)\n        {\n            Entry<K, Collection<V>> entry = sortedMap().ceilingEntry(key);\n            return (entry == null) ? null : wrapEntry(entry);\n        }\n\n        @Override\n        public K ceilingKey(K key)\n        {\n            return sortedMap().ceilingKey(key);\n        }\n\n        @Override\n        public Entry<K, Collection<V>> higherEntry(K key)\n        {\n            Entry<K, Collection<V>> entry = sortedMap().higherEntry(key);\n            return (entry == null) ? null : wrapEntry(entry);\n        }\n\n        @Override\n        public K higherKey(K key)\n        {\n            return sortedMap().higherKey(key);\n        }\n\n        @Override\n        public Entry<K, Collection<V>> firstEntry()\n        {\n            Entry<K, Collection<V>> entry = sortedMap().firstEntry();\n            return (entry == null) ? null : wrapEntry(entry);\n        }\n\n        @Override\n        public Entry<K, Collection<V>> lastEntry()\n        {\n            Entry<K, Collection<V>> entry = sortedMap().lastEntry();\n            return (entry == null) ? null : wrapEntry(entry);\n        }\n\n        @Override\n        public Entry<K, Collection<V>> pollFirstEntry()\n        {\n            return pollAsMapEntry(entrySet().iterator());\n        }\n\n        @Override\n        public Entry<K, Collection<V>> pollLastEntry()\n        {\n            return pollAsMapEntry(descendingMap().entrySet().iterator());\n        }\n\n        Entry<K, Collection<V>> pollAsMapEntry(Iterator<Entry<K, Collection<V>>> entryIterator)\n        {\n            if (!entryIterator.hasNext())\n            {\n                return null;\n            }\n            Entry<K, Collection<V>> entry = entryIterator.next();\n            Collection<V> output = createCollection();\n            output.addAll(entry.getValue());\n            entryIterator.remove();\n            return Maps.immutableEntry(entry.getKey(), unmodifiableCollectionSubclass(output));\n        }\n\n        @Override\n        public NavigableMap<K, Collection<V>> descendingMap()\n        {\n            return new NavigableAsMap(sortedMap().descendingMap());\n        }\n\n        @Override\n        public NavigableSet<K> keySet()\n        {\n            return (NavigableSet<K>) super.keySet();\n        }\n\n        @Override\n        NavigableSet<K> createKeySet()\n        {\n            return new NavigableKeySet(sortedMap());\n        }\n\n        @Override\n        public NavigableSet<K> navigableKeySet()\n        {\n            return keySet();\n        }\n\n        @Override\n        public NavigableSet<K> descendingKeySet()\n        {\n            return descendingMap().navigableKeySet();\n        }\n\n        @Override\n        public NavigableMap<K, Collection<V>> subMap(K fromKey, K toKey)\n        {\n            return subMap(fromKey, true, toKey, false);\n        }\n\n        @Override\n        public NavigableMap<K, Collection<V>> subMap(\n            K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)\n        {\n            return new NavigableAsMap(sortedMap().subMap(fromKey, fromInclusive, toKey, toInclusive));\n        }\n\n        @Override\n        public NavigableMap<K, Collection<V>> headMap(K toKey)\n        {\n            return headMap(toKey, false);\n        }\n\n        @Override\n        public NavigableMap<K, Collection<V>> headMap(K toKey, boolean inclusive)\n        {\n            return new NavigableAsMap(sortedMap().headMap(toKey, inclusive));\n        }\n\n        @Override\n        public NavigableMap<K, Collection<V>> tailMap(K fromKey)\n        {\n            return tailMap(fromKey, true);\n        }\n\n        @Override\n        public NavigableMap<K, Collection<V>> tailMap(K fromKey, boolean inclusive)\n        {\n            return new NavigableAsMap(sortedMap().tailMap(fromKey, inclusive));\n        }\n    }\n\n    private static final long serialVersionUID = 2447537837011683357L;\n}"}
