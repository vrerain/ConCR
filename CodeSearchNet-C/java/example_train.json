{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/effect/height/Sobel.java", "func_name": "Sobel.apply", "original_string": "@Override\n    public ImageSource apply(ImageSource input) {\n        final int[][] pixelMatrix = new int[3][3];\n\n        int w = input.getWidth();\n        int h = input.getHeight();\n\n        int[][] output = new int[h][w];\n\n        for (int j = 1; j < h - 1; j++) {\n            for (int i = 1; i < w - 1; i++) {\n                pixelMatrix[0][0] = input.getR(i - 1, j - 1);\n                pixelMatrix[0][1] = input.getRGB(i - 1, j);\n                pixelMatrix[0][2] = input.getRGB(i - 1, j + 1);\n                pixelMatrix[1][0] = input.getRGB(i, j - 1);\n                pixelMatrix[1][2] = input.getRGB(i, j + 1);\n                pixelMatrix[2][0] = input.getRGB(i + 1, j - 1);\n                pixelMatrix[2][1] = input.getRGB(i + 1, j);\n                pixelMatrix[2][2] = input.getRGB(i + 1, j + 1);\n\n                int edge = (int) convolution(pixelMatrix);\n                int rgb = (edge << 16 | edge << 8 | edge);\n                output[j][i] = rgb;\n            }\n        }\n\n        MatrixSource source = new MatrixSource(output);\n        return source;\n    }", "language": "java", "code": "@Override\n    public ImageSource apply(ImageSource input) {\n        final int[][] pixelMatrix = new int[3][3];\n\n        int w = input.getWidth();\n        int h = input.getHeight();\n\n        int[][] output = new int[h][w];\n\n        for (int j = 1; j < h - 1; j++) {\n            for (int i = 1; i < w - 1; i++) {\n                pixelMatrix[0][0] = input.getR(i - 1, j - 1);\n                pixelMatrix[0][1] = input.getRGB(i - 1, j);\n                pixelMatrix[0][2] = input.getRGB(i - 1, j + 1);\n                pixelMatrix[1][0] = input.getRGB(i, j - 1);\n                pixelMatrix[1][2] = input.getRGB(i, j + 1);\n                pixelMatrix[2][0] = input.getRGB(i + 1, j - 1);\n                pixelMatrix[2][1] = input.getRGB(i + 1, j);\n                pixelMatrix[2][2] = input.getRGB(i + 1, j + 1);\n\n                int edge = (int) convolution(pixelMatrix);\n                int rgb = (edge << 16 | edge << 8 | edge);\n                output[j][i] = rgb;\n            }\n        }\n\n        MatrixSource source = new MatrixSource(output);\n        return source;\n    }", "code_tokens": ["@", "Override", "public", "ImageSource", "apply", "(", "ImageSource", "input", ")", "{", "final", "int", "[", "]", "[", "]", "pixelMatrix", "=", "new", "int", "[", "3", "]", "[", "3", "]", ";", "int", "w", "=", "input", ".", "getWidth", "(", ")", ";", "int", "h", "=", "input", ".", "getHeight", "(", ")", ";", "int", "[", "]", "[", "]", "output", "=", "new", "int", "[", "h", "]", "[", "w", "]", ";", "for", "(", "int", "j", "=", "1", ";", "j", "<", "h", "-", "1", ";", "j", "++", ")", "{", "for", "(", "int", "i", "=", "1", ";", "i", "<", "w", "-", "1", ";", "i", "++", ")", "{", "pixelMatrix", "[", "0", "]", "[", "0", "]", "=", "input", ".", "getR", "(", "i", "-", "1", ",", "j", "-", "1", ")", ";", "pixelMatrix", "[", "0", "]", "[", "1", "]", "=", "input", ".", "getRGB", "(", "i", "-", "1", ",", "j", ")", ";", "pixelMatrix", "[", "0", "]", "[", "2", "]", "=", "input", ".", "getRGB", "(", "i", "-", "1", ",", "j", "+", "1", ")", ";", "pixelMatrix", "[", "1", "]", "[", "0", "]", "=", "input", ".", "getRGB", "(", "i", ",", "j", "-", "1", ")", ";", "pixelMatrix", "[", "1", "]", "[", "2", "]", "=", "input", ".", "getRGB", "(", "i", ",", "j", "+", "1", ")", ";", "pixelMatrix", "[", "2", "]", "[", "0", "]", "=", "input", ".", "getRGB", "(", "i", "+", "1", ",", "j", "-", "1", ")", ";", "pixelMatrix", "[", "2", "]", "[", "1", "]", "=", "input", ".", "getRGB", "(", "i", "+", "1", ",", "j", ")", ";", "pixelMatrix", "[", "2", "]", "[", "2", "]", "=", "input", ".", "getRGB", "(", "i", "+", "1", ",", "j", "+", "1", ")", ";", "int", "edge", "=", "(", "int", ")", "convolution", "(", "pixelMatrix", ")", ";", "int", "rgb", "=", "(", "edge", "<<", "16", "|", "edge", "<<", "8", "|", "edge", ")", ";", "output", "[", "j", "]", "[", "i", "]", "=", "rgb", ";", "}", "}", "MatrixSource", "source", "=", "new", "MatrixSource", "(", "output", ")", ";", "return", "source", ";", "}"], "docstring": "Expects a height mat as input\n\n@param input - A grayscale height map\n@return edges", "docstring_tokens": ["Expects", "a", "height", "mat", "as", "input"], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/effect/height/Sobel.java#L19-L47", "partition": "train", "up_fun_num": 1, "levels": [0, 1], "package": ["import com.harium.keel.core.Effect;", "import com.harium.keel.core.source.ImageSource;", "import com.harium.keel.core.source.MatrixSource;"], "function": ["public class Sobel implements Effect\n", "    private static double convolution(int[][] pixelMatrix)\n"], "context": "package com.harium.keel.effect.height;\n\nimport com.harium.keel.core.Effect;\nimport com.harium.keel.core.source.ImageSource;\nimport com.harium.keel.core.source.MatrixSource;\n\n/**\n * Sobel Filter\n * Code from: https://stackoverflow.com/a/30511674\n */\npublic class Sobel implements Effect\n{\n\n    /**\n     * Expects a height mat as input\n     *\n     * @param input - A grayscale height map\n     * @return edges\n     */\n\n    private static double convolution(int[][] pixelMatrix)\n    {\n        int gy = (pixelMatrix[0][0] * -1) + (pixelMatrix[0][1] * -2) + (pixelMatrix[0][2] * -1) + (pixelMatrix[2][0]) + (pixelMatrix[2][1] * 2) + (pixelMatrix[2][2] * 1);\n        int gx = (pixelMatrix[0][0]) + (pixelMatrix[0][2] * -1) + (pixelMatrix[1][0] * 2) + (pixelMatrix[1][2] * -2) + (pixelMatrix[2][0]) + (pixelMatrix[2][2] * -1);\n\n        return Math.sqrt(Math.pow(gy, 2) + Math.pow(gx, 2));\n    }\n\n}"}
{"repo": "skuzzle/jeve", "path": "jeve/src/main/java/de/skuzzle/jeve/providers/EventStackImpl.java", "func_name": "EventStackImpl.popEvent", "original_string": "public <L extends Listener> void popEvent(Event<?, L> expected) {\n        synchronized (this.stack) {\n            final Event<?, ?> actual = this.stack.pop();\n            if (actual != expected) {\n                throw new IllegalStateException(String.format(\n                        \"Unbalanced pop: expected '%s' but encountered '%s'\",\n                        expected.getListenerClass(), actual));\n            }\n        }\n    }", "language": "java", "code": "public <L extends Listener> void popEvent(Event<?, L> expected) {\n        synchronized (this.stack) {\n            final Event<?, ?> actual = this.stack.pop();\n            if (actual != expected) {\n                throw new IllegalStateException(String.format(\n                        \"Unbalanced pop: expected '%s' but encountered '%s'\",\n                        expected.getListenerClass(), actual));\n            }\n        }\n    }", "code_tokens": ["public", "<", "L", "extends", "Listener", ">", "void", "popEvent", "(", "Event", "<", "?", ",", "L", ">", "expected", ")", "{", "synchronized", "(", "this", ".", "stack", ")", "{", "final", "Event", "<", "?", ",", "?", ">", "actual", "=", "this", ".", "stack", ".", "pop", "(", ")", ";", "if", "(", "actual", "!=", "expected", ")", "{", "throw", "new", "IllegalStateException", "(", "String", ".", "format", "(", "\"Unbalanced pop: expected '%s' but encountered '%s'\"", ",", "expected", ".", "getListenerClass", "(", ")", ",", "actual", ")", ")", ";", "}", "}", "}"], "docstring": "Pops the top event off the current event stack. This action has to be\nperformed immediately after the event has been dispatched to all\nlisteners.\n\n@param <L> Type of the listener.\n@param expected The Event which is expected at the top of the stack.\n@see #pushEvent(Event)", "docstring_tokens": ["Pops", "the", "top", "event", "off", "the", "current", "event", "stack", ".", "This", "action", "has", "to", "be", "performed", "immediately", "after", "the", "event", "has", "been", "dispatched", "to", "all", "listeners", "."], "sha": "42cc18947c9c8596c34410336e4e375e9fcd7c47", "url": "https://github.com/skuzzle/jeve/blob/42cc18947c9c8596c34410336e4e375e9fcd7c47/jeve/src/main/java/de/skuzzle/jeve/providers/EventStackImpl.java#L114-L123", "partition": "train", "up_fun_num": 7, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import java.io.PrintStream;", "import java.util.Collection;", "import java.util.Deque;", "import java.util.Iterator;", "import java.util.LinkedList;", "import java.util.Optional;", "import java.util.function.Consumer;", "import org.slf4j.Logger;", "import org.slf4j.LoggerFactory;", "import de.skuzzle.jeve.Event;", "import de.skuzzle.jeve.EventStack;", "import de.skuzzle.jeve.Listener;", "import de.skuzzle.jeve.SequentialEvent;"], "function": ["class EventStackImpl implements EventStack\n", "    public void dumpStack()\n", "    public void dumpStack(PrintStream out)\n", "    private void dumpInternal(Consumer<Event<?, ?>> c)\n", "    public Optional<Event<?, ?>> peek()\n", "    public <L extends Listener> void pushEvent(Event<?, L> event)\n", "    public boolean isActive(Event<?, ?> event)\n", "    public boolean isAnyActive(Collection<? extends Class<? extends Listener>> c)\n", "    public boolean isActive(Class<? extends Listener> listenerClass)\n", "    public Optional<SequentialEvent<?, ?>> preventDispatch(Event<?, ?> event)\n", "    public Optional<SequentialEvent<?, ?>> preventDispatch(\n"], "context": "package de.skuzzle.jeve.providers;\n\nimport java.io.PrintStream;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Optional;\nimport java.util.function.Consumer;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport de.skuzzle.jeve.Event;\nimport de.skuzzle.jeve.EventStack;\nimport de.skuzzle.jeve.Listener;\nimport de.skuzzle.jeve.SequentialEvent;\n\n/**\n * Stack class which is used to keep track of currently dispatched {@link Event\n * Events}. Before an Event is being dispatched, it is pushed onto this stack\n * and right after it has been dispatched to all listeners it is popped off\n * again. This allows queries such as which events are currently active.\n *\n * <p>\n * This class is thread safe.\n * </p>\n *\n * @author Simon Taddiken\n * @since 3.0.0\n */\nclass EventStackImpl implements EventStack\n{\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(EventStackImpl.class);\n\n    /**\n     * Contains the listener classes for which a dispatch action is currently\n     * active.\n     */\n    private final Deque<Event<?, ?>> stack;\n\n    /**\n     * Creates a new EventStackImpl.\n     */\n    public EventStackImpl()\n    {\n        this.stack = new LinkedList<>();\n    }\n\n    @Override\n    public void dumpStack()\n    {\n        LOGGER.debug(\"jeve event stack:\");\n        if (this.stack.isEmpty())\n        {\n            LOGGER.debug(\"\\t<empty>\");\n            return;\n        }\n\n        dumpInternal(e -> LOGGER.debug(\"\\t{}:{}\",\n                                       e.getListenerClass().getSimpleName(), e));\n    }\n\n    @Override\n    public void dumpStack(PrintStream out)\n    {\n        if (out == null)\n        {\n            throw new IllegalArgumentException(\"out is null\");\n        }\n        out.println(\"jeve event stack:\");\n        if (this.stack.isEmpty())\n        {\n            out.println(\"\\t<empty>\");\n            return;\n        }\n        dumpInternal(e -> out.printf(\"\\t%s:%s%n\",\n                                     e.getListenerClass().getSimpleName(), e));\n    }\n\n    private void dumpInternal(Consumer<Event<?, ?>> c)\n    {\n        synchronized (this.stack)\n        {\n            final Iterator<Event<?, ?>> it = this.stack.iterator();\n            it.forEachRemaining(c);\n        }\n    }\n\n    @Override\n    public Optional<Event<?, ?>> peek()\n    {\n        return this.stack.isEmpty()\n               ? Optional.empty()\n               : Optional.of(this.stack.peek());\n    }\n\n    /**\n     * Pushes the event onto the event stack. This action must be performed\n     * immediately before the event is being dispatched. Additionally, after the\n     * event has been dispatched, it has to be {@link #popEvent(Event) popped}\n     * off the stack again.\n     *\n     * @param <L> Type of the listener.\n     * @param event The event which will be dispatched.\n     * @see #popEvent(Event)\n     */\n    public <L extends Listener> void pushEvent(Event<?, L> event)\n    {\n        synchronized (this.stack)\n        {\n            this.stack.push(event);\n        }\n    }\n\n    /**\n     * Pops the top event off the current event stack. This action has to be\n     * performed immediately after the event has been dispatched to all\n     * listeners.\n     *\n     * @param <L> Type of the listener.\n     * @param expected The Event which is expected at the top of the stack.\n     * @see #pushEvent(Event)\n     */\n\n    @Override\n    public boolean isActive(Event<?, ?> event)\n    {\n        return isActive(event.getListenerClass());\n    }\n\n    @Override\n    public boolean isAnyActive(Collection<? extends Class<? extends Listener>> c)\n    {\n        synchronized (this.stack)\n        {\n            return this.stack.stream()\n                   .anyMatch(event -> c.contains(event.getListenerClass()));\n        }\n    }\n\n    @Override\n    public boolean isActive(Class<? extends Listener> listenerClass)\n    {\n        synchronized (this.stack)\n        {\n            return this.stack.stream()\n                   .anyMatch(event -> event.getListenerClass() == listenerClass);\n        }\n    }\n\n    @Override\n    public Optional<SequentialEvent<?, ?>> preventDispatch(Event<?, ?> event)\n    {\n        return preventDispatch(event.getListenerClass());\n    }\n\n    @Override\n    public Optional<SequentialEvent<?, ?>> preventDispatch(\n        Class<? extends Listener> listenerClass)\n    {\n        synchronized (this.stack)\n        {\n            final Iterator<Event<?, ?>> it = this.stack.descendingIterator();\n            while (it.hasNext())\n            {\n                final Event<?, ?> event = it.next();\n                if (event instanceof SequentialEvent<?, ?>)\n                {\n                    SequentialEvent<?, ?> synchEvent = (SequentialEvent<?, ?>) event;\n                    if (synchEvent.getPrevented().contains(listenerClass))\n                    {\n                        return Optional.of(synchEvent);\n                    }\n                }\n            }\n            return Optional.empty();\n        }\n    }\n}"}
{"repo": "skuzzle/jeve", "path": "jeve/src/main/java/de/skuzzle/jeve/stores/AbstractSynchronizedListenerSource.java", "func_name": "AbstractSynchronizedListenerSource.modify", "original_string": "protected void modify(Transaction t) {\n        try {\n            this.lock.writeLock().lock();\n            t.perform();\n        } finally {\n            this.lock.writeLock().unlock();\n        }\n    }", "language": "java", "code": "protected void modify(Transaction t) {\n        try {\n            this.lock.writeLock().lock();\n            t.perform();\n        } finally {\n            this.lock.writeLock().unlock();\n        }\n    }", "code_tokens": ["protected", "void", "modify", "(", "Transaction", "t", ")", "{", "try", "{", "this", ".", "lock", ".", "writeLock", "(", ")", ".", "lock", "(", ")", ";", "t", ".", "perform", "(", ")", ";", "}", "finally", "{", "this", ".", "lock", ".", "writeLock", "(", ")", ".", "unlock", "(", ")", ";", "}", "}"], "docstring": "Executes the given transaction within the context of a write lock.\n\n@param t The transaction to execute.", "docstring_tokens": ["Executes", "the", "given", "transaction", "within", "the", "context", "of", "a", "write", "lock", "."], "sha": "42cc18947c9c8596c34410336e4e375e9fcd7c47", "url": "https://github.com/skuzzle/jeve/blob/42cc18947c9c8596c34410336e4e375e9fcd7c47/jeve/src/main/java/de/skuzzle/jeve/stores/AbstractSynchronizedListenerSource.java#L48-L55", "partition": "train", "up_fun_num": 2, "levels": [0, 1, 1, 1, 1], "package": ["import java.util.concurrent.locks.ReadWriteLock;", "import java.util.concurrent.locks.ReentrantReadWriteLock;", "import java.util.function.Supplier;", "import java.util.stream.Stream;", "import de.skuzzle.jeve.Listener;", "import de.skuzzle.jeve.ListenerSource;"], "function": ["public abstract class AbstractSynchronizedListenerSource<T extends ListenerSource>\n", "    protected <E> E read(Supplier<E> sup)\n", "    public abstract T synchronizedView();\n", "    public <L extends Listener> Stream<L> get(Class<L> listenerClass)\n", "    public void close()\n"], "context": "package de.skuzzle.jeve.stores;\n\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.function.Supplier;\nimport java.util.stream.Stream;\n\nimport de.skuzzle.jeve.Listener;\nimport de.skuzzle.jeve.ListenerSource;\n\npublic abstract class AbstractSynchronizedListenerSource<T extends ListenerSource>\n    implements ListenerSource\n{\n\n    /**\n     * Represents an atomic write transaction. Actions within {@link #perform()}\n     * will be executed in the context of a write lock when passed to the\n     * {@link AbstractSynchronizedListenerStore#modify(Transaction)}.\n     *\n     * @author Simon Taddiken\n     * @since 3.0.0\n     */\n    @FunctionalInterface\n    protected static interface Transaction\n    {\n        /**\n         * Can be executed atomically by passing an instance of this interface\n         * to {@link AbstractSynchronizedListenerStore#modify(Transaction)}.\n         */\n        public void perform();\n    }\n\n    protected final ReadWriteLock lock;\n    /** The wrapped store */\n    protected final T wrapped;\n\n    protected AbstractSynchronizedListenerSource(T wrapped)\n    {\n        if (wrapped == null)\n        {\n            throw new IllegalArgumentException(\"wrapped is null\");\n        }\n        this.wrapped = wrapped;\n        this.lock = new ReentrantReadWriteLock();\n    }\n\n    /**\n     * Executes the given transaction within the context of a write lock.\n     *\n     * @param t The transaction to execute.\n     */\n\n    /**\n     * Executes the given supplier within the context of a read lock.\n     *\n     * @param <E> The result type.\n     * @param sup The supplier.\n     * @return The result of {@link Supplier#get()}.\n     */\n    protected <E> E read(Supplier<E> sup)\n    {\n        try\n        {\n            this.lock.readLock().lock();\n            return sup.get();\n        }\n        finally\n        {\n            this.lock.readLock().unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>\n     * <b>Note:</b> This method should be implemented to return this store\n     * itself.\n     * </p>\n     */\n    @Override\n    public abstract T synchronizedView();\n\n    @Override\n    public <L extends Listener> Stream<L> get(Class<L> listenerClass)\n    {\n        return read(() -> this.wrapped.get(listenerClass));\n    }\n\n    @Override\n    public void close()\n    {\n        modify(() -> this.wrapped.close());\n    }\n\n}"}
{"repo": "skuzzle/jeve", "path": "jeve/src/main/java/de/skuzzle/jeve/stores/AbstractSynchronizedListenerSource.java", "func_name": "AbstractSynchronizedListenerSource.read", "original_string": "protected <E> E read(Supplier<E> sup) {\n        try {\n            this.lock.readLock().lock();\n            return sup.get();\n        } finally {\n            this.lock.readLock().unlock();\n        }\n    }", "language": "java", "code": "protected <E> E read(Supplier<E> sup) {\n        try {\n            this.lock.readLock().lock();\n            return sup.get();\n        } finally {\n            this.lock.readLock().unlock();\n        }\n    }", "code_tokens": ["protected", "<", "E", ">", "E", "read", "(", "Supplier", "<", "E", ">", "sup", ")", "{", "try", "{", "this", ".", "lock", ".", "readLock", "(", ")", ".", "lock", "(", ")", ";", "return", "sup", ".", "get", "(", ")", ";", "}", "finally", "{", "this", ".", "lock", ".", "readLock", "(", ")", ".", "unlock", "(", ")", ";", "}", "}"], "docstring": "Executes the given supplier within the context of a read lock.\n\n@param <E> The result type.\n@param sup The supplier.\n@return The result of {@link Supplier#get()}.", "docstring_tokens": ["Executes", "the", "given", "supplier", "within", "the", "context", "of", "a", "read", "lock", "."], "sha": "42cc18947c9c8596c34410336e4e375e9fcd7c47", "url": "https://github.com/skuzzle/jeve/blob/42cc18947c9c8596c34410336e4e375e9fcd7c47/jeve/src/main/java/de/skuzzle/jeve/stores/AbstractSynchronizedListenerSource.java#L64-L71", "partition": "train", "up_fun_num": 3, "levels": [0, 1, 1, 1, 1], "package": ["import java.util.concurrent.locks.ReadWriteLock;", "import java.util.concurrent.locks.ReentrantReadWriteLock;", "import java.util.function.Supplier;", "import java.util.stream.Stream;", "import de.skuzzle.jeve.Listener;", "import de.skuzzle.jeve.ListenerSource;"], "function": ["public abstract class AbstractSynchronizedListenerSource<T extends ListenerSource>\n", "    protected void modify(Transaction t)\n", "    public abstract T synchronizedView();\n", "    public <L extends Listener> Stream<L> get(Class<L> listenerClass)\n", "    public void close()\n"], "context": "package de.skuzzle.jeve.stores;\n\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.function.Supplier;\nimport java.util.stream.Stream;\n\nimport de.skuzzle.jeve.Listener;\nimport de.skuzzle.jeve.ListenerSource;\n\npublic abstract class AbstractSynchronizedListenerSource<T extends ListenerSource>\n    implements ListenerSource\n{\n\n    /**\n     * Represents an atomic write transaction. Actions within {@link #perform()}\n     * will be executed in the context of a write lock when passed to the\n     * {@link AbstractSynchronizedListenerStore#modify(Transaction)}.\n     *\n     * @author Simon Taddiken\n     * @since 3.0.0\n     */\n    @FunctionalInterface\n    protected static interface Transaction\n    {\n        /**\n         * Can be executed atomically by passing an instance of this interface\n         * to {@link AbstractSynchronizedListenerStore#modify(Transaction)}.\n         */\n        public void perform();\n    }\n\n    protected final ReadWriteLock lock;\n    /** The wrapped store */\n    protected final T wrapped;\n\n    protected AbstractSynchronizedListenerSource(T wrapped)\n    {\n        if (wrapped == null)\n        {\n            throw new IllegalArgumentException(\"wrapped is null\");\n        }\n        this.wrapped = wrapped;\n        this.lock = new ReentrantReadWriteLock();\n    }\n\n    /**\n     * Executes the given transaction within the context of a write lock.\n     *\n     * @param t The transaction to execute.\n     */\n    protected void modify(Transaction t)\n    {\n        try\n        {\n            this.lock.writeLock().lock();\n            t.perform();\n        }\n        finally\n        {\n            this.lock.writeLock().unlock();\n        }\n    }\n\n    /**\n     * Executes the given supplier within the context of a read lock.\n     *\n     * @param <E> The result type.\n     * @param sup The supplier.\n     * @return The result of {@link Supplier#get()}.\n     */\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>\n     * <b>Note:</b> This method should be implemented to return this store\n     * itself.\n     * </p>\n     */\n    @Override\n    public abstract T synchronizedView();\n\n    @Override\n    public <L extends Listener> Stream<L> get(Class<L> listenerClass)\n    {\n        return read(() -> this.wrapped.get(listenerClass));\n    }\n\n    @Override\n    public void close()\n    {\n        modify(() -> this.wrapped.close());\n    }\n\n}"}
{"repo": "vnesek/nmote-iim4j", "path": "src/main/java/com/nmote/iim4j/stream/SubIIMInputStream.java", "func_name": "SubIIMInputStream.setOffsetAndLength", "original_string": "protected void setOffsetAndLength(long offset, int length) throws IOException {\r\n\t\tthis.offset = offset;\r\n\t\tthis.length = length;\r\n\t\tthis.position = 0;\r\n\r\n\t\tif (subStream.position() != offset) {\r\n\t\t\tsubStream.seek(offset);\r\n\t\t}\r\n\t}", "language": "java", "code": "protected void setOffsetAndLength(long offset, int length) throws IOException {\r\n\t\tthis.offset = offset;\r\n\t\tthis.length = length;\r\n\t\tthis.position = 0;\r\n\r\n\t\tif (subStream.position() != offset) {\r\n\t\t\tsubStream.seek(offset);\r\n\t\t}\r\n\t}", "code_tokens": ["protected", "void", "setOffsetAndLength", "(", "long", "offset", ",", "int", "length", ")", "throws", "IOException", "{", "this", ".", "offset", "=", "offset", ";", "this", ".", "length", "=", "length", ";", "this", ".", "position", "=", "0", ";", "if", "(", "subStream", ".", "position", "(", ")", "!=", "offset", ")", "{", "subStream", ".", "seek", "(", "offset", ")", ";", "}", "}"], "docstring": "This should be called from a subclass constructor, if offset or length\nare unknown at a time when SubIIMInputStream constructor is called. This\nmethod shouldn't be called more than once.\n\n@param offset\nbyte offset\n@param length\nbyte length\n@throws IOException\nif underlying stream can't be read", "docstring_tokens": ["This", "should", "be", "called", "from", "a", "subclass", "constructor", "if", "offset", "or", "length", "are", "unknown", "at", "a", "time", "when", "SubIIMInputStream", "constructor", "is", "called", ".", "This", "method", "shouldn", "t", "be", "called", "more", "than", "once", "."], "sha": "ec55b02fc644cd722e93051ac0bdb96b00cb42a8", "url": "https://github.com/vnesek/nmote-iim4j/blob/ec55b02fc644cd722e93051ac0bdb96b00cb42a8/src/main/java/com/nmote/iim4j/stream/SubIIMInputStream.java#L64-L72", "partition": "train", "up_fun_num": 2, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import java.io.EOFException;", "import java.io.IOException;"], "function": ["public class SubIIMInputStream implements IIMInputStream\n", "    public boolean isCached()\n", "    public void seek(long position) throws IOException\n", "    public long position() throws IOException\n", "    public long length() throws IOException\n", "    public int read() throws IOException\n", "    public int read(byte[] buffer) throws IOException\n", "    public int read(byte[] buffer, int boffset, int blength) throws IOException\n", "    public void close() throws IOException\n"], "context": "/*\n * Copyright (c) Nmote Ltd. 2004-2015. All rights reserved.\n * See LICENSE doc in a root of project folder for additional information.\n */\n\npackage com.nmote.iim4j.stream;\n\nimport java.io.EOFException;\nimport java.io.IOException;\n\n/**\n * SubIIMInputStream is an IIMInputStream that is subset of another\n * IIMInputStream from a given offset with a given length.\n */\npublic class SubIIMInputStream implements IIMInputStream\n{\n\n    /**\n     * Constructs a SubIIMInputStream from a given stream, offset and length.\n     *\n     * @param subStream\n     *            underlying stream\n     * @param offset\n     *            byte offset\n     * @param length\n     *            byte length\n     * @throws IOException\n     *             if underlying stream can't be read\n     */\n    public SubIIMInputStream(IIMInputStream subStream, long offset, int length) throws IOException\n    {\n        this(subStream);\n        setOffsetAndLength(offset, length);\n    }\n\n    /**\n     * This constructor should be used by subclasses that can't determine offset\n     * and length. Such subclasses should call setOffsetAndLength() from\n     * constructor to finish initialization.\n     *\n     * @param subStream\n     *            underlying stream\n     * @throws IOException\n     *             if underlying stream can't be read\n     */\n    protected SubIIMInputStream(IIMInputStream subStream) throws IOException\n    {\n        if (!subStream.isCached())\n        {\n            throw new IOException(\"SubIIMInputStream can only be constructed from cached IIMINputStreams\");\n        }\n        this.subStream = subStream;\n\n    }\n\n    /**\n     * This should be called from a subclass constructor, if offset or length\n     * are unknown at a time when SubIIMInputStream constructor is called. This\n     * method shouldn't be called more than once.\n     *\n     * @param offset\n     *            byte offset\n     * @param length\n     *            byte length\n     * @throws IOException\n     *             if underlying stream can't be read\n     */\n\n    public boolean isCached()\n    {\n        return true;\n    }\n\n    public void seek(long position) throws IOException\n    {\n        if (position > length)\n        {\n            throw new EOFException(\"seek past end of file (pos=\" + position + \", length=\" + length);\n        }\n        this.position = position;\n    }\n\n    public long position() throws IOException\n    {\n        return position;\n    }\n\n    public long length() throws IOException\n    {\n        return length;\n    }\n\n    public int read() throws IOException\n    {\n        subStream.seek(position + offset);\n        int r;\n        if (position >= length)\n        {\n            r = -1;\n        }\n        else\n        {\n            ++position;\n            r = subStream.read();\n        }\n        return r;\n    }\n\n    public int read(byte[] buffer) throws IOException\n    {\n        return read(buffer, 0, buffer.length);\n    }\n\n    public int read(byte[] buffer, int boffset, int blength) throws IOException\n    {\n        subStream.seek(position + offset);\n        if (position + blength > length)\n        {\n            blength = (int) (length - position);\n        }\n        int r = subStream.read(buffer, boffset, blength);\n        if (r > 0)\n        {\n            position += r;\n        }\n        return r;\n    }\n\n    public void close() throws IOException\n    {\n        subStream.close();\n    }\n\n    private final IIMInputStream subStream;\n    private long position;\n    private long offset;\n    private int length;\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/function/Bessel.java", "func_name": "Bessel.J0", "original_string": "public static double J0(double x) {\r\n        double ax;\r\n\r\n        if ((ax = Math.abs(x)) < 8.0) {\r\n            double y = x * x;\r\n            double ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7\r\n                    + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));\r\n            double ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718\r\n                    + y * (59272.64853 + y * (267.8532712 + y * 1.0))));\r\n\r\n            return ans1 / ans2;\r\n        } else {\r\n            double z = 8.0 / ax;\r\n            double y = z * z;\r\n            double xx = ax - 0.785398164;\r\n            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\r\n                    + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\r\n            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\r\n                    + y * (-0.6911147651e-5 + y * (0.7621095161e-6\r\n                    - y * 0.934935152e-7)));\r\n\r\n            return Math.sqrt(0.636619772 / ax) *\r\n                    (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);\r\n        }\r\n    }", "language": "java", "code": "public static double J0(double x) {\r\n        double ax;\r\n\r\n        if ((ax = Math.abs(x)) < 8.0) {\r\n            double y = x * x;\r\n            double ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7\r\n                    + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));\r\n            double ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718\r\n                    + y * (59272.64853 + y * (267.8532712 + y * 1.0))));\r\n\r\n            return ans1 / ans2;\r\n        } else {\r\n            double z = 8.0 / ax;\r\n            double y = z * z;\r\n            double xx = ax - 0.785398164;\r\n            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\r\n                    + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\r\n            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\r\n                    + y * (-0.6911147651e-5 + y * (0.7621095161e-6\r\n                    - y * 0.934935152e-7)));\r\n\r\n            return Math.sqrt(0.636619772 / ax) *\r\n                    (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);\r\n        }\r\n    }", "code_tokens": ["public", "static", "double", "J0", "(", "double", "x", ")", "{", "double", "ax", ";", "if", "(", "(", "ax", "=", "Math", ".", "abs", "(", "x", ")", ")", "<", "8.0", ")", "{", "double", "y", "=", "x", "*", "x", ";", "double", "ans1", "=", "57568490574.0", "+", "y", "*", "(", "-", "13362590354.0", "+", "y", "*", "(", "651619640.7", "+", "y", "*", "(", "-", "11214424.18", "+", "y", "*", "(", "77392.33017", "+", "y", "*", "(", "-", "184.9052456", ")", ")", ")", ")", ")", ";", "double", "ans2", "=", "57568490411.0", "+", "y", "*", "(", "1029532985.0", "+", "y", "*", "(", "9494680.718", "+", "y", "*", "(", "59272.64853", "+", "y", "*", "(", "267.8532712", "+", "y", "*", "1.0", ")", ")", ")", ")", ";", "return", "ans1", "/", "ans2", ";", "}", "else", "{", "double", "z", "=", "8.0", "/", "ax", ";", "double", "y", "=", "z", "*", "z", ";", "double", "xx", "=", "ax", "-", "0.785398164", ";", "double", "ans1", "=", "1.0", "+", "y", "*", "(", "-", "0.1098628627e-2", "+", "y", "*", "(", "0.2734510407e-4", "+", "y", "*", "(", "-", "0.2073370639e-5", "+", "y", "*", "0.2093887211e-6", ")", ")", ")", ";", "double", "ans2", "=", "-", "0.1562499995e-1", "+", "y", "*", "(", "0.1430488765e-3", "+", "y", "*", "(", "-", "0.6911147651e-5", "+", "y", "*", "(", "0.7621095161e-6", "-", "y", "*", "0.934935152e-7", ")", ")", ")", ";", "return", "Math", ".", "sqrt", "(", "0.636619772", "/", "ax", ")", "*", "(", "Math", ".", "cos", "(", "xx", ")", "*", "ans1", "-", "z", "*", "Math", ".", "sin", "(", "xx", ")", "*", "ans2", ")", ";", "}", "}"], "docstring": "Bessel function of order 0.\n\n@param x Value.\n@return J0 value.", "docstring_tokens": ["Bessel", "function", "of", "order", "0", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/function/Bessel.java#L66-L90", "partition": "train", "up_fun_num": 2, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1], "package": [], "function": ["public final class Bessel\n", "    public static double J(double x)\n", "    public static double J(int n, double x)\n", "    public static double Y0(double x)\n", "    public static double Y(double x)\n", "    public static double Y(int n, double x)\n", "    public static double I0(double x)\n", "    public static double I(double x)\n", "    public static double I(int n, double x)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2013\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\n// Contains functions from the Cephes Math Library Release 2.8:\n// June, 2000 Copyright 1984, 1987, 1988, 2000 by Stephen L. Moshier\n//\n// Original license is listed below:\n//\n//   Some software in this archive may be from the book _Methods and\n// Programs for Mathematical Functions_ (Prentice-Hall or Simon & Schuster\n// International, 1989) or from the Cephes Mathematical Library, a\n// commercial product. In either event, it is copyrighted by the author.\n// What you see here may be used freely but it comes with no support or\n// guarantee.\n//\n//   The two known misprints in the book are repaired here in the\n// source listings for the gamma function and the incomplete beta\n// integral.\n//\n//\n//   Stephen L. Moshier\n//   moshier@na-net.ornl.gov\n//\n\npackage com.harium.keel.catalano.math.function;\n\n/**\n * Bessel functions.\n * <para> Bessel functions, first defined by the mathematician Daniel Bernoulli and generalized by Friedrich Bessel,\n * are the canonical solutions y(x) of Bessel's differential equation.</para>\n *\n * @author Diego Catalano\n */\npublic final class Bessel\n{\n\n    private Bessel()\n    {\n    }\n\n    /**\n     * Bessel function of order 0.\n     *\n     * @param x Value.\n     * @return J0 value.\n     */\n\n    /**\n     * Bessel function of order 1.\n     *\n     * @param x Value.\n     * @return J value.\n     */\n    public static double J(double x)\n    {\n        double ax;\n        double y;\n        double ans1, ans2;\n\n        if ((ax = Math.abs(x)) < 8.0)\n        {\n            y = x * x;\n            ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1\n                                             + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));\n            ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74\n                                         + y * (99447.43394 + y * (376.9991397 + y * 1.0))));\n            return ans1 / ans2;\n        }\n        else\n        {\n            double z = 8.0 / ax;\n            double xx = ax - 2.356194491;\n            y = z * z;\n\n            ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4\n                                                 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));\n            ans2 = 0.04687499995 + y * (-0.2002690873e-3\n                                        + y * (0.8449199096e-5 + y * (-0.88228987e-6\n                                                + y * 0.105787412e-6)));\n            double ans = Math.sqrt(0.636619772 / ax) *\n                         (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);\n            if (x < 0.0) ans = -ans;\n            return ans;\n        }\n    }\n\n    /**\n     * Bessel function of order n.\n     *\n     * @param n Order.\n     * @param x Value.\n     * @return J value.\n     */\n    public static double J(int n, double x)\n    {\n        int j, m;\n        double ax, bj, bjm, bjp, sum, tox, ans;\n        boolean jsum;\n\n        double ACC = 40.0;\n        double BIGNO = 1.0e+10;\n        double BIGNI = 1.0e-10;\n\n        if (n == 0) return J0(x);\n        if (n == 1) return J(x);\n\n        ax = Math.abs(x);\n        if (ax == 0.0) return 0.0;\n        else if (ax > (double) n)\n        {\n            tox = 2.0 / ax;\n            bjm = J0(ax);\n            bj = J(ax);\n            for (j = 1; j < n; j++)\n            {\n                bjp = j * tox * bj - bjm;\n                bjm = bj;\n                bj = bjp;\n            }\n            ans = bj;\n        }\n        else\n        {\n            tox = 2.0 / ax;\n            m = 2 * ((n + (int) Math.sqrt(ACC * n)) / 2);\n            jsum = false;\n            bjp = ans = sum = 0.0;\n            bj = 1.0;\n            for (j = m; j > 0; j--)\n            {\n                bjm = j * tox * bj - bjp;\n                bjp = bj;\n                bj = bjm;\n                if (Math.abs(bj) > BIGNO)\n                {\n                    bj *= BIGNI;\n                    bjp *= BIGNI;\n                    ans *= BIGNI;\n                    sum *= BIGNI;\n                }\n                if (jsum) sum += bj;\n                jsum = !jsum;\n                if (j == n) ans = bjp;\n            }\n            sum = 2.0 * sum - bj;\n            ans /= sum;\n        }\n\n        return x < 0.0 && n % 2 == 1 ? -ans : ans;\n    }\n\n    /**\n     * Bessel function of the second kind, of order 0.\n     *\n     * @param x Value.\n     * @return Y0 value.\n     */\n    public static double Y0(double x)\n    {\n        if (x < 8.0)\n        {\n            double y = x * x;\n\n            double ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6\n                                               + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));\n            double ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438\n                                               + y * (47447.26470 + y * (226.1030244 + y * 1.0))));\n\n            return (ans1 / ans2) + 0.636619772 * J0(x) * Math.log(x);\n        }\n        else\n        {\n            double z = 8.0 / x;\n            double y = z * z;\n            double xx = x - 0.785398164;\n\n            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\n                                     + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\n            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\n                                                  + y * (-0.6911147651e-5 + y * (0.7621095161e-6\n                                                          + y * (-0.934945152e-7))));\n            return Math.sqrt(0.636619772 / x) *\n                   (Math.sin(xx) * ans1 + z * Math.cos(xx) * ans2);\n        }\n    }\n\n    /**\n     * Bessel function of the second kind, of order 1.\n     *\n     * @param x Value.\n     * @return Y value.\n     */\n    public static double Y(double x)\n    {\n        if (x < 8.0)\n        {\n            double y = x * x;\n            double ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13\n                               + y * (-0.5153438139e11 + y * (0.7349264551e9\n                                       + y * (-0.4237922726e7 + y * 0.8511937935e4)))));\n            double ans2 = 0.2499580570e14 + y * (0.4244419664e12\n                                                 + y * (0.3733650367e10 + y * (0.2245904002e8\n                                                         + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));\n            return (ans1 / ans2) + 0.636619772 * (J(x) * Math.log(x) - 1.0 / x);\n        }\n        else\n        {\n            double z = 8.0 / x;\n            double y = z * z;\n            double xx = x - 2.356194491;\n            double ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4\n                                     + y * (0.2457520174e-5 + y * (-0.240337019e-6))));\n            double ans2 = 0.04687499995 + y * (-0.2002690873e-3\n                                               + y * (0.8449199096e-5 + y * (-0.88228987e-6\n                                                       + y * 0.105787412e-6)));\n            return Math.sqrt(0.636619772 / x) *\n                   (Math.sin(xx) * ans1 + z * Math.cos(xx) * ans2);\n        }\n    }\n\n    /**\n     * Bessel function of the second kind, of order n.\n     *\n     * @param n Order.\n     * @param x Value.\n     * @return Y value.\n     */\n    public static double Y(int n, double x)\n    {\n        double by, bym, byp, tox;\n\n        if (n == 0) return Y0(x);\n        if (n == 1) return Y(x);\n\n        tox = 2.0 / x;\n        by = Y(x);\n        bym = Y0(x);\n        for (int j = 1; j < n; j++)\n        {\n            byp = j * tox * by - bym;\n            bym = by;\n            by = byp;\n        }\n        return by;\n    }\n\n    /**\n     * Bessel function of the first kind, of order 0.\n     *\n     * @param x Value.\n     * @return I0 value.\n     */\n    public static double I0(double x)\n    {\n        double ans;\n        double ax = Math.abs(x);\n\n        if (ax < 3.75)\n        {\n            double y = x / 3.75;\n            y = y * y;\n            ans = 1.0 + y * (3.5156229 + y * (3.0899424 + y * (1.2067492\n                                              + y * (0.2659732 + y * (0.360768e-1 + y * 0.45813e-2)))));\n        }\n        else\n        {\n            double y = 3.75 / ax;\n            ans = (Math.exp(ax) / Math.sqrt(ax)) * (0.39894228 + y * (0.1328592e-1\n                                                    + y * (0.225319e-2 + y * (-0.157565e-2 + y * (0.916281e-2\n                                                            + y * (-0.2057706e-1 + y * (0.2635537e-1 + y * (-0.1647633e-1\n                                                                    + y * 0.392377e-2))))))));\n        }\n\n        return ans;\n    }\n\n    /**\n     * Bessel function of the first kind, of order 1.\n     *\n     * @param x Value.\n     * @return I value.\n     */\n    public static double I(double x)\n    {\n        double ans;\n\n        double ax = Math.abs(x);\n\n        if (ax < 3.75)\n        {\n            double y = x / 3.75;\n            y = y * y;\n            ans = ax * (0.5 + y * (0.87890594 + y * (0.51498869 + y * (0.15084934\n                                   + y * (0.2658733e-1 + y * (0.301532e-2 + y * 0.32411e-3))))));\n        }\n        else\n        {\n            double y = 3.75 / ax;\n            ans = 0.2282967e-1 + y * (-0.2895312e-1 + y * (0.1787654e-1 - y * 0.420059e-2));\n            ans = 0.39894228 + y * (-0.3988024e-1 + y * (-0.362018e-2 + y * (0.163801e-2 + y * (-0.1031555e-1 + y * ans))));\n            ans *= Math.exp(ax) / Math.sqrt(ax);\n        }\n        return x < 0.0 ? -ans : ans;\n    }\n\n    /**\n     * Bessel function of the first kind, of order n.\n     *\n     * @param n Order.\n     * @param x Value.\n     * @return I value.\n     */\n    public static double I(int n, double x)\n    {\n        if (n < 0)\n            throw new IllegalArgumentException(\"the variable n out of range.\");\n        else if (n == 0)\n            return I0(x);\n        else if (n == 1)\n            return I(x);\n\n        if (x == 0.0)\n            return 0.0;\n\n        double ACC = 40.0;\n        double BIGNO = 1.0e+10;\n        double BIGNI = 1.0e-10;\n\n        double tox = 2.0 / Math.abs(x);\n        double bip = 0, ans = 0.0;\n        double bi = 1.0;\n\n        for (int j = 2 * (n + (int) Math.sqrt(ACC * n)); j > 0; j--)\n        {\n            double bim = bip + j * tox * bi;\n            bip = bi;\n            bi = bim;\n\n            if (Math.abs(bi) > BIGNO)\n            {\n                ans *= BIGNI;\n                bi *= BIGNI;\n                bip *= BIGNI;\n            }\n\n            if (j == n)\n                ans = bip;\n        }\n\n        ans *= I0(x) / bi;\n        return x < 0.0 && n % 2 == 1 ? -ans : ans;\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/function/Bessel.java", "func_name": "Bessel.J", "original_string": "public static double J(int n, double x) {\r\n        int j, m;\r\n        double ax, bj, bjm, bjp, sum, tox, ans;\r\n        boolean jsum;\r\n\r\n        double ACC = 40.0;\r\n        double BIGNO = 1.0e+10;\r\n        double BIGNI = 1.0e-10;\r\n\r\n        if (n == 0) return J0(x);\r\n        if (n == 1) return J(x);\r\n\r\n        ax = Math.abs(x);\r\n        if (ax == 0.0) return 0.0;\r\n        else if (ax > (double) n) {\r\n            tox = 2.0 / ax;\r\n            bjm = J0(ax);\r\n            bj = J(ax);\r\n            for (j = 1; j < n; j++) {\r\n                bjp = j * tox * bj - bjm;\r\n                bjm = bj;\r\n                bj = bjp;\r\n            }\r\n            ans = bj;\r\n        } else {\r\n            tox = 2.0 / ax;\r\n            m = 2 * ((n + (int) Math.sqrt(ACC * n)) / 2);\r\n            jsum = false;\r\n            bjp = ans = sum = 0.0;\r\n            bj = 1.0;\r\n            for (j = m; j > 0; j--) {\r\n                bjm = j * tox * bj - bjp;\r\n                bjp = bj;\r\n                bj = bjm;\r\n                if (Math.abs(bj) > BIGNO) {\r\n                    bj *= BIGNI;\r\n                    bjp *= BIGNI;\r\n                    ans *= BIGNI;\r\n                    sum *= BIGNI;\r\n                }\r\n                if (jsum) sum += bj;\r\n                jsum = !jsum;\r\n                if (j == n) ans = bjp;\r\n            }\r\n            sum = 2.0 * sum - bj;\r\n            ans /= sum;\r\n        }\r\n\r\n        return x < 0.0 && n % 2 == 1 ? -ans : ans;\r\n    }", "language": "java", "code": "public static double J(int n, double x) {\r\n        int j, m;\r\n        double ax, bj, bjm, bjp, sum, tox, ans;\r\n        boolean jsum;\r\n\r\n        double ACC = 40.0;\r\n        double BIGNO = 1.0e+10;\r\n        double BIGNI = 1.0e-10;\r\n\r\n        if (n == 0) return J0(x);\r\n        if (n == 1) return J(x);\r\n\r\n        ax = Math.abs(x);\r\n        if (ax == 0.0) return 0.0;\r\n        else if (ax > (double) n) {\r\n            tox = 2.0 / ax;\r\n            bjm = J0(ax);\r\n            bj = J(ax);\r\n            for (j = 1; j < n; j++) {\r\n                bjp = j * tox * bj - bjm;\r\n                bjm = bj;\r\n                bj = bjp;\r\n            }\r\n            ans = bj;\r\n        } else {\r\n            tox = 2.0 / ax;\r\n            m = 2 * ((n + (int) Math.sqrt(ACC * n)) / 2);\r\n            jsum = false;\r\n            bjp = ans = sum = 0.0;\r\n            bj = 1.0;\r\n            for (j = m; j > 0; j--) {\r\n                bjm = j * tox * bj - bjp;\r\n                bjp = bj;\r\n                bj = bjm;\r\n                if (Math.abs(bj) > BIGNO) {\r\n                    bj *= BIGNI;\r\n                    bjp *= BIGNI;\r\n                    ans *= BIGNI;\r\n                    sum *= BIGNI;\r\n                }\r\n                if (jsum) sum += bj;\r\n                jsum = !jsum;\r\n                if (j == n) ans = bjp;\r\n            }\r\n            sum = 2.0 * sum - bj;\r\n            ans /= sum;\r\n        }\r\n\r\n        return x < 0.0 && n % 2 == 1 ? -ans : ans;\r\n    }", "code_tokens": ["public", "static", "double", "J", "(", "int", "n", ",", "double", "x", ")", "{", "int", "j", ",", "m", ";", "double", "ax", ",", "bj", ",", "bjm", ",", "bjp", ",", "sum", ",", "tox", ",", "ans", ";", "boolean", "jsum", ";", "double", "ACC", "=", "40.0", ";", "double", "BIGNO", "=", "1.0e+10", ";", "double", "BIGNI", "=", "1.0e-10", ";", "if", "(", "n", "==", "0", ")", "return", "J0", "(", "x", ")", ";", "if", "(", "n", "==", "1", ")", "return", "J", "(", "x", ")", ";", "ax", "=", "Math", ".", "abs", "(", "x", ")", ";", "if", "(", "ax", "==", "0.0", ")", "return", "0.0", ";", "else", "if", "(", "ax", ">", "(", "double", ")", "n", ")", "{", "tox", "=", "2.0", "/", "ax", ";", "bjm", "=", "J0", "(", "ax", ")", ";", "bj", "=", "J", "(", "ax", ")", ";", "for", "(", "j", "=", "1", ";", "j", "<", "n", ";", "j", "++", ")", "{", "bjp", "=", "j", "*", "tox", "*", "bj", "-", "bjm", ";", "bjm", "=", "bj", ";", "bj", "=", "bjp", ";", "}", "ans", "=", "bj", ";", "}", "else", "{", "tox", "=", "2.0", "/", "ax", ";", "m", "=", "2", "*", "(", "(", "n", "+", "(", "int", ")", "Math", ".", "sqrt", "(", "ACC", "*", "n", ")", ")", "/", "2", ")", ";", "jsum", "=", "false", ";", "bjp", "=", "ans", "=", "sum", "=", "0.0", ";", "bj", "=", "1.0", ";", "for", "(", "j", "=", "m", ";", "j", ">", "0", ";", "j", "--", ")", "{", "bjm", "=", "j", "*", "tox", "*", "bj", "-", "bjp", ";", "bjp", "=", "bj", ";", "bj", "=", "bjm", ";", "if", "(", "Math", ".", "abs", "(", "bj", ")", ">", "BIGNO", ")", "{", "bj", "*=", "BIGNI", ";", "bjp", "*=", "BIGNI", ";", "ans", "*=", "BIGNI", ";", "sum", "*=", "BIGNI", ";", "}", "if", "(", "jsum", ")", "sum", "+=", "bj", ";", "jsum", "=", "!", "jsum", ";", "if", "(", "j", "==", "n", ")", "ans", "=", "bjp", ";", "}", "sum", "=", "2.0", "*", "sum", "-", "bj", ";", "ans", "/=", "sum", ";", "}", "return", "x", "<", "0.0", "&&", "n", "%", "2", "==", "1", "?", "-", "ans", ":", "ans", ";", "}"], "docstring": "Bessel function of order n.\n\n@param n Order.\n@param x Value.\n@return J value.", "docstring_tokens": ["Bessel", "function", "of", "order", "n", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/function/Bessel.java#L134-L183", "partition": "train", "up_fun_num": 4, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1], "package": [], "function": ["public final class Bessel\n", "    public static double J0(double x)\n", "    public static double J(double x)\n", "    public static double Y0(double x)\n", "    public static double Y(double x)\n", "    public static double Y(int n, double x)\n", "    public static double I0(double x)\n", "    public static double I(double x)\n", "    public static double I(int n, double x)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2013\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\n// Contains functions from the Cephes Math Library Release 2.8:\n// June, 2000 Copyright 1984, 1987, 1988, 2000 by Stephen L. Moshier\n//\n// Original license is listed below:\n//\n//   Some software in this archive may be from the book _Methods and\n// Programs for Mathematical Functions_ (Prentice-Hall or Simon & Schuster\n// International, 1989) or from the Cephes Mathematical Library, a\n// commercial product. In either event, it is copyrighted by the author.\n// What you see here may be used freely but it comes with no support or\n// guarantee.\n//\n//   The two known misprints in the book are repaired here in the\n// source listings for the gamma function and the incomplete beta\n// integral.\n//\n//\n//   Stephen L. Moshier\n//   moshier@na-net.ornl.gov\n//\n\npackage com.harium.keel.catalano.math.function;\n\n/**\n * Bessel functions.\n * <para> Bessel functions, first defined by the mathematician Daniel Bernoulli and generalized by Friedrich Bessel,\n * are the canonical solutions y(x) of Bessel's differential equation.</para>\n *\n * @author Diego Catalano\n */\npublic final class Bessel\n{\n\n    private Bessel()\n    {\n    }\n\n    /**\n     * Bessel function of order 0.\n     *\n     * @param x Value.\n     * @return J0 value.\n     */\n    public static double J0(double x)\n    {\n        double ax;\n\n        if ((ax = Math.abs(x)) < 8.0)\n        {\n            double y = x * x;\n            double ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7\n                                               + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));\n            double ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718\n                                               + y * (59272.64853 + y * (267.8532712 + y * 1.0))));\n\n            return ans1 / ans2;\n        }\n        else\n        {\n            double z = 8.0 / ax;\n            double y = z * z;\n            double xx = ax - 0.785398164;\n            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\n                                     + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\n            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\n                                                  + y * (-0.6911147651e-5 + y * (0.7621095161e-6\n                                                          - y * 0.934935152e-7)));\n\n            return Math.sqrt(0.636619772 / ax) *\n                   (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);\n        }\n    }\n\n    /**\n     * Bessel function of order 1.\n     *\n     * @param x Value.\n     * @return J value.\n     */\n    public static double J(double x)\n    {\n        double ax;\n        double y;\n        double ans1, ans2;\n\n        if ((ax = Math.abs(x)) < 8.0)\n        {\n            y = x * x;\n            ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1\n                                             + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));\n            ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74\n                                         + y * (99447.43394 + y * (376.9991397 + y * 1.0))));\n            return ans1 / ans2;\n        }\n        else\n        {\n            double z = 8.0 / ax;\n            double xx = ax - 2.356194491;\n            y = z * z;\n\n            ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4\n                                                 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));\n            ans2 = 0.04687499995 + y * (-0.2002690873e-3\n                                        + y * (0.8449199096e-5 + y * (-0.88228987e-6\n                                                + y * 0.105787412e-6)));\n            double ans = Math.sqrt(0.636619772 / ax) *\n                         (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);\n            if (x < 0.0) ans = -ans;\n            return ans;\n        }\n    }\n\n    /**\n     * Bessel function of order n.\n     *\n     * @param n Order.\n     * @param x Value.\n     * @return J value.\n     */\n\n    /**\n     * Bessel function of the second kind, of order 0.\n     *\n     * @param x Value.\n     * @return Y0 value.\n     */\n    public static double Y0(double x)\n    {\n        if (x < 8.0)\n        {\n            double y = x * x;\n\n            double ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6\n                                               + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));\n            double ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438\n                                               + y * (47447.26470 + y * (226.1030244 + y * 1.0))));\n\n            return (ans1 / ans2) + 0.636619772 * J0(x) * Math.log(x);\n        }\n        else\n        {\n            double z = 8.0 / x;\n            double y = z * z;\n            double xx = x - 0.785398164;\n\n            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\n                                     + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\n            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\n                                                  + y * (-0.6911147651e-5 + y * (0.7621095161e-6\n                                                          + y * (-0.934945152e-7))));\n            return Math.sqrt(0.636619772 / x) *\n                   (Math.sin(xx) * ans1 + z * Math.cos(xx) * ans2);\n        }\n    }\n\n    /**\n     * Bessel function of the second kind, of order 1.\n     *\n     * @param x Value.\n     * @return Y value.\n     */\n    public static double Y(double x)\n    {\n        if (x < 8.0)\n        {\n            double y = x * x;\n            double ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13\n                               + y * (-0.5153438139e11 + y * (0.7349264551e9\n                                       + y * (-0.4237922726e7 + y * 0.8511937935e4)))));\n            double ans2 = 0.2499580570e14 + y * (0.4244419664e12\n                                                 + y * (0.3733650367e10 + y * (0.2245904002e8\n                                                         + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));\n            return (ans1 / ans2) + 0.636619772 * (J(x) * Math.log(x) - 1.0 / x);\n        }\n        else\n        {\n            double z = 8.0 / x;\n            double y = z * z;\n            double xx = x - 2.356194491;\n            double ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4\n                                     + y * (0.2457520174e-5 + y * (-0.240337019e-6))));\n            double ans2 = 0.04687499995 + y * (-0.2002690873e-3\n                                               + y * (0.8449199096e-5 + y * (-0.88228987e-6\n                                                       + y * 0.105787412e-6)));\n            return Math.sqrt(0.636619772 / x) *\n                   (Math.sin(xx) * ans1 + z * Math.cos(xx) * ans2);\n        }\n    }\n\n    /**\n     * Bessel function of the second kind, of order n.\n     *\n     * @param n Order.\n     * @param x Value.\n     * @return Y value.\n     */\n    public static double Y(int n, double x)\n    {\n        double by, bym, byp, tox;\n\n        if (n == 0) return Y0(x);\n        if (n == 1) return Y(x);\n\n        tox = 2.0 / x;\n        by = Y(x);\n        bym = Y0(x);\n        for (int j = 1; j < n; j++)\n        {\n            byp = j * tox * by - bym;\n            bym = by;\n            by = byp;\n        }\n        return by;\n    }\n\n    /**\n     * Bessel function of the first kind, of order 0.\n     *\n     * @param x Value.\n     * @return I0 value.\n     */\n    public static double I0(double x)\n    {\n        double ans;\n        double ax = Math.abs(x);\n\n        if (ax < 3.75)\n        {\n            double y = x / 3.75;\n            y = y * y;\n            ans = 1.0 + y * (3.5156229 + y * (3.0899424 + y * (1.2067492\n                                              + y * (0.2659732 + y * (0.360768e-1 + y * 0.45813e-2)))));\n        }\n        else\n        {\n            double y = 3.75 / ax;\n            ans = (Math.exp(ax) / Math.sqrt(ax)) * (0.39894228 + y * (0.1328592e-1\n                                                    + y * (0.225319e-2 + y * (-0.157565e-2 + y * (0.916281e-2\n                                                            + y * (-0.2057706e-1 + y * (0.2635537e-1 + y * (-0.1647633e-1\n                                                                    + y * 0.392377e-2))))))));\n        }\n\n        return ans;\n    }\n\n    /**\n     * Bessel function of the first kind, of order 1.\n     *\n     * @param x Value.\n     * @return I value.\n     */\n    public static double I(double x)\n    {\n        double ans;\n\n        double ax = Math.abs(x);\n\n        if (ax < 3.75)\n        {\n            double y = x / 3.75;\n            y = y * y;\n            ans = ax * (0.5 + y * (0.87890594 + y * (0.51498869 + y * (0.15084934\n                                   + y * (0.2658733e-1 + y * (0.301532e-2 + y * 0.32411e-3))))));\n        }\n        else\n        {\n            double y = 3.75 / ax;\n            ans = 0.2282967e-1 + y * (-0.2895312e-1 + y * (0.1787654e-1 - y * 0.420059e-2));\n            ans = 0.39894228 + y * (-0.3988024e-1 + y * (-0.362018e-2 + y * (0.163801e-2 + y * (-0.1031555e-1 + y * ans))));\n            ans *= Math.exp(ax) / Math.sqrt(ax);\n        }\n        return x < 0.0 ? -ans : ans;\n    }\n\n    /**\n     * Bessel function of the first kind, of order n.\n     *\n     * @param n Order.\n     * @param x Value.\n     * @return I value.\n     */\n    public static double I(int n, double x)\n    {\n        if (n < 0)\n            throw new IllegalArgumentException(\"the variable n out of range.\");\n        else if (n == 0)\n            return I0(x);\n        else if (n == 1)\n            return I(x);\n\n        if (x == 0.0)\n            return 0.0;\n\n        double ACC = 40.0;\n        double BIGNO = 1.0e+10;\n        double BIGNI = 1.0e-10;\n\n        double tox = 2.0 / Math.abs(x);\n        double bip = 0, ans = 0.0;\n        double bi = 1.0;\n\n        for (int j = 2 * (n + (int) Math.sqrt(ACC * n)); j > 0; j--)\n        {\n            double bim = bip + j * tox * bi;\n            bip = bi;\n            bi = bim;\n\n            if (Math.abs(bi) > BIGNO)\n            {\n                ans *= BIGNI;\n                bi *= BIGNI;\n                bip *= BIGNI;\n            }\n\n            if (j == n)\n                ans = bip;\n        }\n\n        ans *= I0(x) / bi;\n        return x < 0.0 && n % 2 == 1 ? -ans : ans;\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/function/Bessel.java", "func_name": "Bessel.Y0", "original_string": "public static double Y0(double x) {\r\n        if (x < 8.0) {\r\n            double y = x * x;\r\n\r\n            double ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6\r\n                    + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));\r\n            double ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438\r\n                    + y * (47447.26470 + y * (226.1030244 + y * 1.0))));\r\n\r\n            return (ans1 / ans2) + 0.636619772 * J0(x) * Math.log(x);\r\n        } else {\r\n            double z = 8.0 / x;\r\n            double y = z * z;\r\n            double xx = x - 0.785398164;\r\n\r\n            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\r\n                    + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\r\n            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\r\n                    + y * (-0.6911147651e-5 + y * (0.7621095161e-6\r\n                    + y * (-0.934945152e-7))));\r\n            return Math.sqrt(0.636619772 / x) *\r\n                    (Math.sin(xx) * ans1 + z * Math.cos(xx) * ans2);\r\n        }\r\n    }", "language": "java", "code": "public static double Y0(double x) {\r\n        if (x < 8.0) {\r\n            double y = x * x;\r\n\r\n            double ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6\r\n                    + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));\r\n            double ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438\r\n                    + y * (47447.26470 + y * (226.1030244 + y * 1.0))));\r\n\r\n            return (ans1 / ans2) + 0.636619772 * J0(x) * Math.log(x);\r\n        } else {\r\n            double z = 8.0 / x;\r\n            double y = z * z;\r\n            double xx = x - 0.785398164;\r\n\r\n            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\r\n                    + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\r\n            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\r\n                    + y * (-0.6911147651e-5 + y * (0.7621095161e-6\r\n                    + y * (-0.934945152e-7))));\r\n            return Math.sqrt(0.636619772 / x) *\r\n                    (Math.sin(xx) * ans1 + z * Math.cos(xx) * ans2);\r\n        }\r\n    }", "code_tokens": ["public", "static", "double", "Y0", "(", "double", "x", ")", "{", "if", "(", "x", "<", "8.0", ")", "{", "double", "y", "=", "x", "*", "x", ";", "double", "ans1", "=", "-", "2957821389.0", "+", "y", "*", "(", "7062834065.0", "+", "y", "*", "(", "-", "512359803.6", "+", "y", "*", "(", "10879881.29", "+", "y", "*", "(", "-", "86327.92757", "+", "y", "*", "228.4622733", ")", ")", ")", ")", ";", "double", "ans2", "=", "40076544269.0", "+", "y", "*", "(", "745249964.8", "+", "y", "*", "(", "7189466.438", "+", "y", "*", "(", "47447.26470", "+", "y", "*", "(", "226.1030244", "+", "y", "*", "1.0", ")", ")", ")", ")", ";", "return", "(", "ans1", "/", "ans2", ")", "+", "0.636619772", "*", "J0", "(", "x", ")", "*", "Math", ".", "log", "(", "x", ")", ";", "}", "else", "{", "double", "z", "=", "8.0", "/", "x", ";", "double", "y", "=", "z", "*", "z", ";", "double", "xx", "=", "x", "-", "0.785398164", ";", "double", "ans1", "=", "1.0", "+", "y", "*", "(", "-", "0.1098628627e-2", "+", "y", "*", "(", "0.2734510407e-4", "+", "y", "*", "(", "-", "0.2073370639e-5", "+", "y", "*", "0.2093887211e-6", ")", ")", ")", ";", "double", "ans2", "=", "-", "0.1562499995e-1", "+", "y", "*", "(", "0.1430488765e-3", "+", "y", "*", "(", "-", "0.6911147651e-5", "+", "y", "*", "(", "0.7621095161e-6", "+", "y", "*", "(", "-", "0.934945152e-7", ")", ")", ")", ")", ";", "return", "Math", ".", "sqrt", "(", "0.636619772", "/", "x", ")", "*", "(", "Math", ".", "sin", "(", "xx", ")", "*", "ans1", "+", "z", "*", "Math", ".", "cos", "(", "xx", ")", "*", "ans2", ")", ";", "}", "}"], "docstring": "Bessel function of the second kind, of order 0.\n\n@param x Value.\n@return Y0 value.", "docstring_tokens": ["Bessel", "function", "of", "the", "second", "kind", "of", "order", "0", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/function/Bessel.java#L191-L214", "partition": "train", "up_fun_num": 5, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1], "package": [], "function": ["public final class Bessel\n", "    public static double J0(double x)\n", "    public static double J(double x)\n", "    public static double J(int n, double x)\n", "    public static double Y(double x)\n", "    public static double Y(int n, double x)\n", "    public static double I0(double x)\n", "    public static double I(double x)\n", "    public static double I(int n, double x)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2013\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\n// Contains functions from the Cephes Math Library Release 2.8:\n// June, 2000 Copyright 1984, 1987, 1988, 2000 by Stephen L. Moshier\n//\n// Original license is listed below:\n//\n//   Some software in this archive may be from the book _Methods and\n// Programs for Mathematical Functions_ (Prentice-Hall or Simon & Schuster\n// International, 1989) or from the Cephes Mathematical Library, a\n// commercial product. In either event, it is copyrighted by the author.\n// What you see here may be used freely but it comes with no support or\n// guarantee.\n//\n//   The two known misprints in the book are repaired here in the\n// source listings for the gamma function and the incomplete beta\n// integral.\n//\n//\n//   Stephen L. Moshier\n//   moshier@na-net.ornl.gov\n//\n\npackage com.harium.keel.catalano.math.function;\n\n/**\n * Bessel functions.\n * <para> Bessel functions, first defined by the mathematician Daniel Bernoulli and generalized by Friedrich Bessel,\n * are the canonical solutions y(x) of Bessel's differential equation.</para>\n *\n * @author Diego Catalano\n */\npublic final class Bessel\n{\n\n    private Bessel()\n    {\n    }\n\n    /**\n     * Bessel function of order 0.\n     *\n     * @param x Value.\n     * @return J0 value.\n     */\n    public static double J0(double x)\n    {\n        double ax;\n\n        if ((ax = Math.abs(x)) < 8.0)\n        {\n            double y = x * x;\n            double ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7\n                                               + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));\n            double ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718\n                                               + y * (59272.64853 + y * (267.8532712 + y * 1.0))));\n\n            return ans1 / ans2;\n        }\n        else\n        {\n            double z = 8.0 / ax;\n            double y = z * z;\n            double xx = ax - 0.785398164;\n            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\n                                     + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\n            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\n                                                  + y * (-0.6911147651e-5 + y * (0.7621095161e-6\n                                                          - y * 0.934935152e-7)));\n\n            return Math.sqrt(0.636619772 / ax) *\n                   (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);\n        }\n    }\n\n    /**\n     * Bessel function of order 1.\n     *\n     * @param x Value.\n     * @return J value.\n     */\n    public static double J(double x)\n    {\n        double ax;\n        double y;\n        double ans1, ans2;\n\n        if ((ax = Math.abs(x)) < 8.0)\n        {\n            y = x * x;\n            ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1\n                                             + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));\n            ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74\n                                         + y * (99447.43394 + y * (376.9991397 + y * 1.0))));\n            return ans1 / ans2;\n        }\n        else\n        {\n            double z = 8.0 / ax;\n            double xx = ax - 2.356194491;\n            y = z * z;\n\n            ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4\n                                                 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));\n            ans2 = 0.04687499995 + y * (-0.2002690873e-3\n                                        + y * (0.8449199096e-5 + y * (-0.88228987e-6\n                                                + y * 0.105787412e-6)));\n            double ans = Math.sqrt(0.636619772 / ax) *\n                         (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);\n            if (x < 0.0) ans = -ans;\n            return ans;\n        }\n    }\n\n    /**\n     * Bessel function of order n.\n     *\n     * @param n Order.\n     * @param x Value.\n     * @return J value.\n     */\n    public static double J(int n, double x)\n    {\n        int j, m;\n        double ax, bj, bjm, bjp, sum, tox, ans;\n        boolean jsum;\n\n        double ACC = 40.0;\n        double BIGNO = 1.0e+10;\n        double BIGNI = 1.0e-10;\n\n        if (n == 0) return J0(x);\n        if (n == 1) return J(x);\n\n        ax = Math.abs(x);\n        if (ax == 0.0) return 0.0;\n        else if (ax > (double) n)\n        {\n            tox = 2.0 / ax;\n            bjm = J0(ax);\n            bj = J(ax);\n            for (j = 1; j < n; j++)\n            {\n                bjp = j * tox * bj - bjm;\n                bjm = bj;\n                bj = bjp;\n            }\n            ans = bj;\n        }\n        else\n        {\n            tox = 2.0 / ax;\n            m = 2 * ((n + (int) Math.sqrt(ACC * n)) / 2);\n            jsum = false;\n            bjp = ans = sum = 0.0;\n            bj = 1.0;\n            for (j = m; j > 0; j--)\n            {\n                bjm = j * tox * bj - bjp;\n                bjp = bj;\n                bj = bjm;\n                if (Math.abs(bj) > BIGNO)\n                {\n                    bj *= BIGNI;\n                    bjp *= BIGNI;\n                    ans *= BIGNI;\n                    sum *= BIGNI;\n                }\n                if (jsum) sum += bj;\n                jsum = !jsum;\n                if (j == n) ans = bjp;\n            }\n            sum = 2.0 * sum - bj;\n            ans /= sum;\n        }\n\n        return x < 0.0 && n % 2 == 1 ? -ans : ans;\n    }\n\n    /**\n     * Bessel function of the second kind, of order 0.\n     *\n     * @param x Value.\n     * @return Y0 value.\n     */\n\n    /**\n     * Bessel function of the second kind, of order 1.\n     *\n     * @param x Value.\n     * @return Y value.\n     */\n    public static double Y(double x)\n    {\n        if (x < 8.0)\n        {\n            double y = x * x;\n            double ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13\n                               + y * (-0.5153438139e11 + y * (0.7349264551e9\n                                       + y * (-0.4237922726e7 + y * 0.8511937935e4)))));\n            double ans2 = 0.2499580570e14 + y * (0.4244419664e12\n                                                 + y * (0.3733650367e10 + y * (0.2245904002e8\n                                                         + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));\n            return (ans1 / ans2) + 0.636619772 * (J(x) * Math.log(x) - 1.0 / x);\n        }\n        else\n        {\n            double z = 8.0 / x;\n            double y = z * z;\n            double xx = x - 2.356194491;\n            double ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4\n                                     + y * (0.2457520174e-5 + y * (-0.240337019e-6))));\n            double ans2 = 0.04687499995 + y * (-0.2002690873e-3\n                                               + y * (0.8449199096e-5 + y * (-0.88228987e-6\n                                                       + y * 0.105787412e-6)));\n            return Math.sqrt(0.636619772 / x) *\n                   (Math.sin(xx) * ans1 + z * Math.cos(xx) * ans2);\n        }\n    }\n\n    /**\n     * Bessel function of the second kind, of order n.\n     *\n     * @param n Order.\n     * @param x Value.\n     * @return Y value.\n     */\n    public static double Y(int n, double x)\n    {\n        double by, bym, byp, tox;\n\n        if (n == 0) return Y0(x);\n        if (n == 1) return Y(x);\n\n        tox = 2.0 / x;\n        by = Y(x);\n        bym = Y0(x);\n        for (int j = 1; j < n; j++)\n        {\n            byp = j * tox * by - bym;\n            bym = by;\n            by = byp;\n        }\n        return by;\n    }\n\n    /**\n     * Bessel function of the first kind, of order 0.\n     *\n     * @param x Value.\n     * @return I0 value.\n     */\n    public static double I0(double x)\n    {\n        double ans;\n        double ax = Math.abs(x);\n\n        if (ax < 3.75)\n        {\n            double y = x / 3.75;\n            y = y * y;\n            ans = 1.0 + y * (3.5156229 + y * (3.0899424 + y * (1.2067492\n                                              + y * (0.2659732 + y * (0.360768e-1 + y * 0.45813e-2)))));\n        }\n        else\n        {\n            double y = 3.75 / ax;\n            ans = (Math.exp(ax) / Math.sqrt(ax)) * (0.39894228 + y * (0.1328592e-1\n                                                    + y * (0.225319e-2 + y * (-0.157565e-2 + y * (0.916281e-2\n                                                            + y * (-0.2057706e-1 + y * (0.2635537e-1 + y * (-0.1647633e-1\n                                                                    + y * 0.392377e-2))))))));\n        }\n\n        return ans;\n    }\n\n    /**\n     * Bessel function of the first kind, of order 1.\n     *\n     * @param x Value.\n     * @return I value.\n     */\n    public static double I(double x)\n    {\n        double ans;\n\n        double ax = Math.abs(x);\n\n        if (ax < 3.75)\n        {\n            double y = x / 3.75;\n            y = y * y;\n            ans = ax * (0.5 + y * (0.87890594 + y * (0.51498869 + y * (0.15084934\n                                   + y * (0.2658733e-1 + y * (0.301532e-2 + y * 0.32411e-3))))));\n        }\n        else\n        {\n            double y = 3.75 / ax;\n            ans = 0.2282967e-1 + y * (-0.2895312e-1 + y * (0.1787654e-1 - y * 0.420059e-2));\n            ans = 0.39894228 + y * (-0.3988024e-1 + y * (-0.362018e-2 + y * (0.163801e-2 + y * (-0.1031555e-1 + y * ans))));\n            ans *= Math.exp(ax) / Math.sqrt(ax);\n        }\n        return x < 0.0 ? -ans : ans;\n    }\n\n    /**\n     * Bessel function of the first kind, of order n.\n     *\n     * @param n Order.\n     * @param x Value.\n     * @return I value.\n     */\n    public static double I(int n, double x)\n    {\n        if (n < 0)\n            throw new IllegalArgumentException(\"the variable n out of range.\");\n        else if (n == 0)\n            return I0(x);\n        else if (n == 1)\n            return I(x);\n\n        if (x == 0.0)\n            return 0.0;\n\n        double ACC = 40.0;\n        double BIGNO = 1.0e+10;\n        double BIGNI = 1.0e-10;\n\n        double tox = 2.0 / Math.abs(x);\n        double bip = 0, ans = 0.0;\n        double bi = 1.0;\n\n        for (int j = 2 * (n + (int) Math.sqrt(ACC * n)); j > 0; j--)\n        {\n            double bim = bip + j * tox * bi;\n            bip = bi;\n            bi = bim;\n\n            if (Math.abs(bi) > BIGNO)\n            {\n                ans *= BIGNI;\n                bi *= BIGNI;\n                bip *= BIGNI;\n            }\n\n            if (j == n)\n                ans = bip;\n        }\n\n        ans *= I0(x) / bi;\n        return x < 0.0 && n % 2 == 1 ? -ans : ans;\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/function/Bessel.java", "func_name": "Bessel.Y", "original_string": "public static double Y(double x) {\r\n        if (x < 8.0) {\r\n            double y = x * x;\r\n            double ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13\r\n                    + y * (-0.5153438139e11 + y * (0.7349264551e9\r\n                    + y * (-0.4237922726e7 + y * 0.8511937935e4)))));\r\n            double ans2 = 0.2499580570e14 + y * (0.4244419664e12\r\n                    + y * (0.3733650367e10 + y * (0.2245904002e8\r\n                    + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));\r\n            return (ans1 / ans2) + 0.636619772 * (J(x) * Math.log(x) - 1.0 / x);\r\n        } else {\r\n            double z = 8.0 / x;\r\n            double y = z * z;\r\n            double xx = x - 2.356194491;\r\n            double ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4\r\n                    + y * (0.2457520174e-5 + y * (-0.240337019e-6))));\r\n            double ans2 = 0.04687499995 + y * (-0.2002690873e-3\r\n                    + y * (0.8449199096e-5 + y * (-0.88228987e-6\r\n                    + y * 0.105787412e-6)));\r\n            return Math.sqrt(0.636619772 / x) *\r\n                    (Math.sin(xx) * ans1 + z * Math.cos(xx) * ans2);\r\n        }\r\n    }", "language": "java", "code": "public static double Y(double x) {\r\n        if (x < 8.0) {\r\n            double y = x * x;\r\n            double ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13\r\n                    + y * (-0.5153438139e11 + y * (0.7349264551e9\r\n                    + y * (-0.4237922726e7 + y * 0.8511937935e4)))));\r\n            double ans2 = 0.2499580570e14 + y * (0.4244419664e12\r\n                    + y * (0.3733650367e10 + y * (0.2245904002e8\r\n                    + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));\r\n            return (ans1 / ans2) + 0.636619772 * (J(x) * Math.log(x) - 1.0 / x);\r\n        } else {\r\n            double z = 8.0 / x;\r\n            double y = z * z;\r\n            double xx = x - 2.356194491;\r\n            double ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4\r\n                    + y * (0.2457520174e-5 + y * (-0.240337019e-6))));\r\n            double ans2 = 0.04687499995 + y * (-0.2002690873e-3\r\n                    + y * (0.8449199096e-5 + y * (-0.88228987e-6\r\n                    + y * 0.105787412e-6)));\r\n            return Math.sqrt(0.636619772 / x) *\r\n                    (Math.sin(xx) * ans1 + z * Math.cos(xx) * ans2);\r\n        }\r\n    }", "code_tokens": ["public", "static", "double", "Y", "(", "double", "x", ")", "{", "if", "(", "x", "<", "8.0", ")", "{", "double", "y", "=", "x", "*", "x", ";", "double", "ans1", "=", "x", "*", "(", "-", "0.4900604943e13", "+", "y", "*", "(", "0.1275274390e13", "+", "y", "*", "(", "-", "0.5153438139e11", "+", "y", "*", "(", "0.7349264551e9", "+", "y", "*", "(", "-", "0.4237922726e7", "+", "y", "*", "0.8511937935e4", ")", ")", ")", ")", ")", ";", "double", "ans2", "=", "0.2499580570e14", "+", "y", "*", "(", "0.4244419664e12", "+", "y", "*", "(", "0.3733650367e10", "+", "y", "*", "(", "0.2245904002e8", "+", "y", "*", "(", "0.1020426050e6", "+", "y", "*", "(", "0.3549632885e3", "+", "y", ")", ")", ")", ")", ")", ";", "return", "(", "ans1", "/", "ans2", ")", "+", "0.636619772", "*", "(", "J", "(", "x", ")", "*", "Math", ".", "log", "(", "x", ")", "-", "1.0", "/", "x", ")", ";", "}", "else", "{", "double", "z", "=", "8.0", "/", "x", ";", "double", "y", "=", "z", "*", "z", ";", "double", "xx", "=", "x", "-", "2.356194491", ";", "double", "ans1", "=", "1.0", "+", "y", "*", "(", "0.183105e-2", "+", "y", "*", "(", "-", "0.3516396496e-4", "+", "y", "*", "(", "0.2457520174e-5", "+", "y", "*", "(", "-", "0.240337019e-6", ")", ")", ")", ")", ";", "double", "ans2", "=", "0.04687499995", "+", "y", "*", "(", "-", "0.2002690873e-3", "+", "y", "*", "(", "0.8449199096e-5", "+", "y", "*", "(", "-", "0.88228987e-6", "+", "y", "*", "0.105787412e-6", ")", ")", ")", ";", "return", "Math", ".", "sqrt", "(", "0.636619772", "/", "x", ")", "*", "(", "Math", ".", "sin", "(", "xx", ")", "*", "ans1", "+", "z", "*", "Math", ".", "cos", "(", "xx", ")", "*", "ans2", ")", ";", "}", "}"], "docstring": "Bessel function of the second kind, of order 1.\n\n@param x Value.\n@return Y value.", "docstring_tokens": ["Bessel", "function", "of", "the", "second", "kind", "of", "order", "1", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/function/Bessel.java#L222-L244", "partition": "train", "up_fun_num": 6, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1], "package": [], "function": ["public final class Bessel\n", "    public static double J0(double x)\n", "    public static double J(double x)\n", "    public static double J(int n, double x)\n", "    public static double Y0(double x)\n", "    public static double Y(int n, double x)\n", "    public static double I0(double x)\n", "    public static double I(double x)\n", "    public static double I(int n, double x)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2013\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\n// Contains functions from the Cephes Math Library Release 2.8:\n// June, 2000 Copyright 1984, 1987, 1988, 2000 by Stephen L. Moshier\n//\n// Original license is listed below:\n//\n//   Some software in this archive may be from the book _Methods and\n// Programs for Mathematical Functions_ (Prentice-Hall or Simon & Schuster\n// International, 1989) or from the Cephes Mathematical Library, a\n// commercial product. In either event, it is copyrighted by the author.\n// What you see here may be used freely but it comes with no support or\n// guarantee.\n//\n//   The two known misprints in the book are repaired here in the\n// source listings for the gamma function and the incomplete beta\n// integral.\n//\n//\n//   Stephen L. Moshier\n//   moshier@na-net.ornl.gov\n//\n\npackage com.harium.keel.catalano.math.function;\n\n/**\n * Bessel functions.\n * <para> Bessel functions, first defined by the mathematician Daniel Bernoulli and generalized by Friedrich Bessel,\n * are the canonical solutions y(x) of Bessel's differential equation.</para>\n *\n * @author Diego Catalano\n */\npublic final class Bessel\n{\n\n    private Bessel()\n    {\n    }\n\n    /**\n     * Bessel function of order 0.\n     *\n     * @param x Value.\n     * @return J0 value.\n     */\n    public static double J0(double x)\n    {\n        double ax;\n\n        if ((ax = Math.abs(x)) < 8.0)\n        {\n            double y = x * x;\n            double ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7\n                                               + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));\n            double ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718\n                                               + y * (59272.64853 + y * (267.8532712 + y * 1.0))));\n\n            return ans1 / ans2;\n        }\n        else\n        {\n            double z = 8.0 / ax;\n            double y = z * z;\n            double xx = ax - 0.785398164;\n            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\n                                     + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\n            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\n                                                  + y * (-0.6911147651e-5 + y * (0.7621095161e-6\n                                                          - y * 0.934935152e-7)));\n\n            return Math.sqrt(0.636619772 / ax) *\n                   (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);\n        }\n    }\n\n    /**\n     * Bessel function of order 1.\n     *\n     * @param x Value.\n     * @return J value.\n     */\n    public static double J(double x)\n    {\n        double ax;\n        double y;\n        double ans1, ans2;\n\n        if ((ax = Math.abs(x)) < 8.0)\n        {\n            y = x * x;\n            ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1\n                                             + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));\n            ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74\n                                         + y * (99447.43394 + y * (376.9991397 + y * 1.0))));\n            return ans1 / ans2;\n        }\n        else\n        {\n            double z = 8.0 / ax;\n            double xx = ax - 2.356194491;\n            y = z * z;\n\n            ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4\n                                                 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));\n            ans2 = 0.04687499995 + y * (-0.2002690873e-3\n                                        + y * (0.8449199096e-5 + y * (-0.88228987e-6\n                                                + y * 0.105787412e-6)));\n            double ans = Math.sqrt(0.636619772 / ax) *\n                         (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);\n            if (x < 0.0) ans = -ans;\n            return ans;\n        }\n    }\n\n    /**\n     * Bessel function of order n.\n     *\n     * @param n Order.\n     * @param x Value.\n     * @return J value.\n     */\n    public static double J(int n, double x)\n    {\n        int j, m;\n        double ax, bj, bjm, bjp, sum, tox, ans;\n        boolean jsum;\n\n        double ACC = 40.0;\n        double BIGNO = 1.0e+10;\n        double BIGNI = 1.0e-10;\n\n        if (n == 0) return J0(x);\n        if (n == 1) return J(x);\n\n        ax = Math.abs(x);\n        if (ax == 0.0) return 0.0;\n        else if (ax > (double) n)\n        {\n            tox = 2.0 / ax;\n            bjm = J0(ax);\n            bj = J(ax);\n            for (j = 1; j < n; j++)\n            {\n                bjp = j * tox * bj - bjm;\n                bjm = bj;\n                bj = bjp;\n            }\n            ans = bj;\n        }\n        else\n        {\n            tox = 2.0 / ax;\n            m = 2 * ((n + (int) Math.sqrt(ACC * n)) / 2);\n            jsum = false;\n            bjp = ans = sum = 0.0;\n            bj = 1.0;\n            for (j = m; j > 0; j--)\n            {\n                bjm = j * tox * bj - bjp;\n                bjp = bj;\n                bj = bjm;\n                if (Math.abs(bj) > BIGNO)\n                {\n                    bj *= BIGNI;\n                    bjp *= BIGNI;\n                    ans *= BIGNI;\n                    sum *= BIGNI;\n                }\n                if (jsum) sum += bj;\n                jsum = !jsum;\n                if (j == n) ans = bjp;\n            }\n            sum = 2.0 * sum - bj;\n            ans /= sum;\n        }\n\n        return x < 0.0 && n % 2 == 1 ? -ans : ans;\n    }\n\n    /**\n     * Bessel function of the second kind, of order 0.\n     *\n     * @param x Value.\n     * @return Y0 value.\n     */\n    public static double Y0(double x)\n    {\n        if (x < 8.0)\n        {\n            double y = x * x;\n\n            double ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6\n                                               + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));\n            double ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438\n                                               + y * (47447.26470 + y * (226.1030244 + y * 1.0))));\n\n            return (ans1 / ans2) + 0.636619772 * J0(x) * Math.log(x);\n        }\n        else\n        {\n            double z = 8.0 / x;\n            double y = z * z;\n            double xx = x - 0.785398164;\n\n            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\n                                     + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\n            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\n                                                  + y * (-0.6911147651e-5 + y * (0.7621095161e-6\n                                                          + y * (-0.934945152e-7))));\n            return Math.sqrt(0.636619772 / x) *\n                   (Math.sin(xx) * ans1 + z * Math.cos(xx) * ans2);\n        }\n    }\n\n    /**\n     * Bessel function of the second kind, of order 1.\n     *\n     * @param x Value.\n     * @return Y value.\n     */\n\n    /**\n     * Bessel function of the second kind, of order n.\n     *\n     * @param n Order.\n     * @param x Value.\n     * @return Y value.\n     */\n    public static double Y(int n, double x)\n    {\n        double by, bym, byp, tox;\n\n        if (n == 0) return Y0(x);\n        if (n == 1) return Y(x);\n\n        tox = 2.0 / x;\n        by = Y(x);\n        bym = Y0(x);\n        for (int j = 1; j < n; j++)\n        {\n            byp = j * tox * by - bym;\n            bym = by;\n            by = byp;\n        }\n        return by;\n    }\n\n    /**\n     * Bessel function of the first kind, of order 0.\n     *\n     * @param x Value.\n     * @return I0 value.\n     */\n    public static double I0(double x)\n    {\n        double ans;\n        double ax = Math.abs(x);\n\n        if (ax < 3.75)\n        {\n            double y = x / 3.75;\n            y = y * y;\n            ans = 1.0 + y * (3.5156229 + y * (3.0899424 + y * (1.2067492\n                                              + y * (0.2659732 + y * (0.360768e-1 + y * 0.45813e-2)))));\n        }\n        else\n        {\n            double y = 3.75 / ax;\n            ans = (Math.exp(ax) / Math.sqrt(ax)) * (0.39894228 + y * (0.1328592e-1\n                                                    + y * (0.225319e-2 + y * (-0.157565e-2 + y * (0.916281e-2\n                                                            + y * (-0.2057706e-1 + y * (0.2635537e-1 + y * (-0.1647633e-1\n                                                                    + y * 0.392377e-2))))))));\n        }\n\n        return ans;\n    }\n\n    /**\n     * Bessel function of the first kind, of order 1.\n     *\n     * @param x Value.\n     * @return I value.\n     */\n    public static double I(double x)\n    {\n        double ans;\n\n        double ax = Math.abs(x);\n\n        if (ax < 3.75)\n        {\n            double y = x / 3.75;\n            y = y * y;\n            ans = ax * (0.5 + y * (0.87890594 + y * (0.51498869 + y * (0.15084934\n                                   + y * (0.2658733e-1 + y * (0.301532e-2 + y * 0.32411e-3))))));\n        }\n        else\n        {\n            double y = 3.75 / ax;\n            ans = 0.2282967e-1 + y * (-0.2895312e-1 + y * (0.1787654e-1 - y * 0.420059e-2));\n            ans = 0.39894228 + y * (-0.3988024e-1 + y * (-0.362018e-2 + y * (0.163801e-2 + y * (-0.1031555e-1 + y * ans))));\n            ans *= Math.exp(ax) / Math.sqrt(ax);\n        }\n        return x < 0.0 ? -ans : ans;\n    }\n\n    /**\n     * Bessel function of the first kind, of order n.\n     *\n     * @param n Order.\n     * @param x Value.\n     * @return I value.\n     */\n    public static double I(int n, double x)\n    {\n        if (n < 0)\n            throw new IllegalArgumentException(\"the variable n out of range.\");\n        else if (n == 0)\n            return I0(x);\n        else if (n == 1)\n            return I(x);\n\n        if (x == 0.0)\n            return 0.0;\n\n        double ACC = 40.0;\n        double BIGNO = 1.0e+10;\n        double BIGNI = 1.0e-10;\n\n        double tox = 2.0 / Math.abs(x);\n        double bip = 0, ans = 0.0;\n        double bi = 1.0;\n\n        for (int j = 2 * (n + (int) Math.sqrt(ACC * n)); j > 0; j--)\n        {\n            double bim = bip + j * tox * bi;\n            bip = bi;\n            bi = bim;\n\n            if (Math.abs(bi) > BIGNO)\n            {\n                ans *= BIGNI;\n                bi *= BIGNI;\n                bip *= BIGNI;\n            }\n\n            if (j == n)\n                ans = bip;\n        }\n\n        ans *= I0(x) / bi;\n        return x < 0.0 && n % 2 == 1 ? -ans : ans;\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/function/Bessel.java", "func_name": "Bessel.Y", "original_string": "public static double Y(int n, double x) {\r\n        double by, bym, byp, tox;\r\n\r\n        if (n == 0) return Y0(x);\r\n        if (n == 1) return Y(x);\r\n\r\n        tox = 2.0 / x;\r\n        by = Y(x);\r\n        bym = Y0(x);\r\n        for (int j = 1; j < n; j++) {\r\n            byp = j * tox * by - bym;\r\n            bym = by;\r\n            by = byp;\r\n        }\r\n        return by;\r\n    }", "language": "java", "code": "public static double Y(int n, double x) {\r\n        double by, bym, byp, tox;\r\n\r\n        if (n == 0) return Y0(x);\r\n        if (n == 1) return Y(x);\r\n\r\n        tox = 2.0 / x;\r\n        by = Y(x);\r\n        bym = Y0(x);\r\n        for (int j = 1; j < n; j++) {\r\n            byp = j * tox * by - bym;\r\n            bym = by;\r\n            by = byp;\r\n        }\r\n        return by;\r\n    }", "code_tokens": ["public", "static", "double", "Y", "(", "int", "n", ",", "double", "x", ")", "{", "double", "by", ",", "bym", ",", "byp", ",", "tox", ";", "if", "(", "n", "==", "0", ")", "return", "Y0", "(", "x", ")", ";", "if", "(", "n", "==", "1", ")", "return", "Y", "(", "x", ")", ";", "tox", "=", "2.0", "/", "x", ";", "by", "=", "Y", "(", "x", ")", ";", "bym", "=", "Y0", "(", "x", ")", ";", "for", "(", "int", "j", "=", "1", ";", "j", "<", "n", ";", "j", "++", ")", "{", "byp", "=", "j", "*", "tox", "*", "by", "-", "bym", ";", "bym", "=", "by", ";", "by", "=", "byp", ";", "}", "return", "by", ";", "}"], "docstring": "Bessel function of the second kind, of order n.\n\n@param n Order.\n@param x Value.\n@return Y value.", "docstring_tokens": ["Bessel", "function", "of", "the", "second", "kind", "of", "order", "n", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/function/Bessel.java#L253-L268", "partition": "train", "up_fun_num": 7, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1], "package": [], "function": ["public final class Bessel\n", "    public static double J0(double x)\n", "    public static double J(double x)\n", "    public static double J(int n, double x)\n", "    public static double Y0(double x)\n", "    public static double Y(double x)\n", "    public static double I0(double x)\n", "    public static double I(double x)\n", "    public static double I(int n, double x)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2013\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\n// Contains functions from the Cephes Math Library Release 2.8:\n// June, 2000 Copyright 1984, 1987, 1988, 2000 by Stephen L. Moshier\n//\n// Original license is listed below:\n//\n//   Some software in this archive may be from the book _Methods and\n// Programs for Mathematical Functions_ (Prentice-Hall or Simon & Schuster\n// International, 1989) or from the Cephes Mathematical Library, a\n// commercial product. In either event, it is copyrighted by the author.\n// What you see here may be used freely but it comes with no support or\n// guarantee.\n//\n//   The two known misprints in the book are repaired here in the\n// source listings for the gamma function and the incomplete beta\n// integral.\n//\n//\n//   Stephen L. Moshier\n//   moshier@na-net.ornl.gov\n//\n\npackage com.harium.keel.catalano.math.function;\n\n/**\n * Bessel functions.\n * <para> Bessel functions, first defined by the mathematician Daniel Bernoulli and generalized by Friedrich Bessel,\n * are the canonical solutions y(x) of Bessel's differential equation.</para>\n *\n * @author Diego Catalano\n */\npublic final class Bessel\n{\n\n    private Bessel()\n    {\n    }\n\n    /**\n     * Bessel function of order 0.\n     *\n     * @param x Value.\n     * @return J0 value.\n     */\n    public static double J0(double x)\n    {\n        double ax;\n\n        if ((ax = Math.abs(x)) < 8.0)\n        {\n            double y = x * x;\n            double ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7\n                                               + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));\n            double ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718\n                                               + y * (59272.64853 + y * (267.8532712 + y * 1.0))));\n\n            return ans1 / ans2;\n        }\n        else\n        {\n            double z = 8.0 / ax;\n            double y = z * z;\n            double xx = ax - 0.785398164;\n            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\n                                     + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\n            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\n                                                  + y * (-0.6911147651e-5 + y * (0.7621095161e-6\n                                                          - y * 0.934935152e-7)));\n\n            return Math.sqrt(0.636619772 / ax) *\n                   (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);\n        }\n    }\n\n    /**\n     * Bessel function of order 1.\n     *\n     * @param x Value.\n     * @return J value.\n     */\n    public static double J(double x)\n    {\n        double ax;\n        double y;\n        double ans1, ans2;\n\n        if ((ax = Math.abs(x)) < 8.0)\n        {\n            y = x * x;\n            ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1\n                                             + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));\n            ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74\n                                         + y * (99447.43394 + y * (376.9991397 + y * 1.0))));\n            return ans1 / ans2;\n        }\n        else\n        {\n            double z = 8.0 / ax;\n            double xx = ax - 2.356194491;\n            y = z * z;\n\n            ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4\n                                                 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));\n            ans2 = 0.04687499995 + y * (-0.2002690873e-3\n                                        + y * (0.8449199096e-5 + y * (-0.88228987e-6\n                                                + y * 0.105787412e-6)));\n            double ans = Math.sqrt(0.636619772 / ax) *\n                         (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);\n            if (x < 0.0) ans = -ans;\n            return ans;\n        }\n    }\n\n    /**\n     * Bessel function of order n.\n     *\n     * @param n Order.\n     * @param x Value.\n     * @return J value.\n     */\n    public static double J(int n, double x)\n    {\n        int j, m;\n        double ax, bj, bjm, bjp, sum, tox, ans;\n        boolean jsum;\n\n        double ACC = 40.0;\n        double BIGNO = 1.0e+10;\n        double BIGNI = 1.0e-10;\n\n        if (n == 0) return J0(x);\n        if (n == 1) return J(x);\n\n        ax = Math.abs(x);\n        if (ax == 0.0) return 0.0;\n        else if (ax > (double) n)\n        {\n            tox = 2.0 / ax;\n            bjm = J0(ax);\n            bj = J(ax);\n            for (j = 1; j < n; j++)\n            {\n                bjp = j * tox * bj - bjm;\n                bjm = bj;\n                bj = bjp;\n            }\n            ans = bj;\n        }\n        else\n        {\n            tox = 2.0 / ax;\n            m = 2 * ((n + (int) Math.sqrt(ACC * n)) / 2);\n            jsum = false;\n            bjp = ans = sum = 0.0;\n            bj = 1.0;\n            for (j = m; j > 0; j--)\n            {\n                bjm = j * tox * bj - bjp;\n                bjp = bj;\n                bj = bjm;\n                if (Math.abs(bj) > BIGNO)\n                {\n                    bj *= BIGNI;\n                    bjp *= BIGNI;\n                    ans *= BIGNI;\n                    sum *= BIGNI;\n                }\n                if (jsum) sum += bj;\n                jsum = !jsum;\n                if (j == n) ans = bjp;\n            }\n            sum = 2.0 * sum - bj;\n            ans /= sum;\n        }\n\n        return x < 0.0 && n % 2 == 1 ? -ans : ans;\n    }\n\n    /**\n     * Bessel function of the second kind, of order 0.\n     *\n     * @param x Value.\n     * @return Y0 value.\n     */\n    public static double Y0(double x)\n    {\n        if (x < 8.0)\n        {\n            double y = x * x;\n\n            double ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6\n                                               + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));\n            double ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438\n                                               + y * (47447.26470 + y * (226.1030244 + y * 1.0))));\n\n            return (ans1 / ans2) + 0.636619772 * J0(x) * Math.log(x);\n        }\n        else\n        {\n            double z = 8.0 / x;\n            double y = z * z;\n            double xx = x - 0.785398164;\n\n            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\n                                     + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\n            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\n                                                  + y * (-0.6911147651e-5 + y * (0.7621095161e-6\n                                                          + y * (-0.934945152e-7))));\n            return Math.sqrt(0.636619772 / x) *\n                   (Math.sin(xx) * ans1 + z * Math.cos(xx) * ans2);\n        }\n    }\n\n    /**\n     * Bessel function of the second kind, of order 1.\n     *\n     * @param x Value.\n     * @return Y value.\n     */\n    public static double Y(double x)\n    {\n        if (x < 8.0)\n        {\n            double y = x * x;\n            double ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13\n                               + y * (-0.5153438139e11 + y * (0.7349264551e9\n                                       + y * (-0.4237922726e7 + y * 0.8511937935e4)))));\n            double ans2 = 0.2499580570e14 + y * (0.4244419664e12\n                                                 + y * (0.3733650367e10 + y * (0.2245904002e8\n                                                         + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));\n            return (ans1 / ans2) + 0.636619772 * (J(x) * Math.log(x) - 1.0 / x);\n        }\n        else\n        {\n            double z = 8.0 / x;\n            double y = z * z;\n            double xx = x - 2.356194491;\n            double ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4\n                                     + y * (0.2457520174e-5 + y * (-0.240337019e-6))));\n            double ans2 = 0.04687499995 + y * (-0.2002690873e-3\n                                               + y * (0.8449199096e-5 + y * (-0.88228987e-6\n                                                       + y * 0.105787412e-6)));\n            return Math.sqrt(0.636619772 / x) *\n                   (Math.sin(xx) * ans1 + z * Math.cos(xx) * ans2);\n        }\n    }\n\n    /**\n     * Bessel function of the second kind, of order n.\n     *\n     * @param n Order.\n     * @param x Value.\n     * @return Y value.\n     */\n\n    /**\n     * Bessel function of the first kind, of order 0.\n     *\n     * @param x Value.\n     * @return I0 value.\n     */\n    public static double I0(double x)\n    {\n        double ans;\n        double ax = Math.abs(x);\n\n        if (ax < 3.75)\n        {\n            double y = x / 3.75;\n            y = y * y;\n            ans = 1.0 + y * (3.5156229 + y * (3.0899424 + y * (1.2067492\n                                              + y * (0.2659732 + y * (0.360768e-1 + y * 0.45813e-2)))));\n        }\n        else\n        {\n            double y = 3.75 / ax;\n            ans = (Math.exp(ax) / Math.sqrt(ax)) * (0.39894228 + y * (0.1328592e-1\n                                                    + y * (0.225319e-2 + y * (-0.157565e-2 + y * (0.916281e-2\n                                                            + y * (-0.2057706e-1 + y * (0.2635537e-1 + y * (-0.1647633e-1\n                                                                    + y * 0.392377e-2))))))));\n        }\n\n        return ans;\n    }\n\n    /**\n     * Bessel function of the first kind, of order 1.\n     *\n     * @param x Value.\n     * @return I value.\n     */\n    public static double I(double x)\n    {\n        double ans;\n\n        double ax = Math.abs(x);\n\n        if (ax < 3.75)\n        {\n            double y = x / 3.75;\n            y = y * y;\n            ans = ax * (0.5 + y * (0.87890594 + y * (0.51498869 + y * (0.15084934\n                                   + y * (0.2658733e-1 + y * (0.301532e-2 + y * 0.32411e-3))))));\n        }\n        else\n        {\n            double y = 3.75 / ax;\n            ans = 0.2282967e-1 + y * (-0.2895312e-1 + y * (0.1787654e-1 - y * 0.420059e-2));\n            ans = 0.39894228 + y * (-0.3988024e-1 + y * (-0.362018e-2 + y * (0.163801e-2 + y * (-0.1031555e-1 + y * ans))));\n            ans *= Math.exp(ax) / Math.sqrt(ax);\n        }\n        return x < 0.0 ? -ans : ans;\n    }\n\n    /**\n     * Bessel function of the first kind, of order n.\n     *\n     * @param n Order.\n     * @param x Value.\n     * @return I value.\n     */\n    public static double I(int n, double x)\n    {\n        if (n < 0)\n            throw new IllegalArgumentException(\"the variable n out of range.\");\n        else if (n == 0)\n            return I0(x);\n        else if (n == 1)\n            return I(x);\n\n        if (x == 0.0)\n            return 0.0;\n\n        double ACC = 40.0;\n        double BIGNO = 1.0e+10;\n        double BIGNI = 1.0e-10;\n\n        double tox = 2.0 / Math.abs(x);\n        double bip = 0, ans = 0.0;\n        double bi = 1.0;\n\n        for (int j = 2 * (n + (int) Math.sqrt(ACC * n)); j > 0; j--)\n        {\n            double bim = bip + j * tox * bi;\n            bip = bi;\n            bi = bim;\n\n            if (Math.abs(bi) > BIGNO)\n            {\n                ans *= BIGNI;\n                bi *= BIGNI;\n                bip *= BIGNI;\n            }\n\n            if (j == n)\n                ans = bip;\n        }\n\n        ans *= I0(x) / bi;\n        return x < 0.0 && n % 2 == 1 ? -ans : ans;\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/function/Bessel.java", "func_name": "Bessel.I0", "original_string": "public static double I0(double x) {\r\n        double ans;\r\n        double ax = Math.abs(x);\r\n\r\n        if (ax < 3.75) {\r\n            double y = x / 3.75;\r\n            y = y * y;\r\n            ans = 1.0 + y * (3.5156229 + y * (3.0899424 + y * (1.2067492\r\n                    + y * (0.2659732 + y * (0.360768e-1 + y * 0.45813e-2)))));\r\n        } else {\r\n            double y = 3.75 / ax;\r\n            ans = (Math.exp(ax) / Math.sqrt(ax)) * (0.39894228 + y * (0.1328592e-1\r\n                    + y * (0.225319e-2 + y * (-0.157565e-2 + y * (0.916281e-2\r\n                    + y * (-0.2057706e-1 + y * (0.2635537e-1 + y * (-0.1647633e-1\r\n                    + y * 0.392377e-2))))))));\r\n        }\r\n\r\n        return ans;\r\n    }", "language": "java", "code": "public static double I0(double x) {\r\n        double ans;\r\n        double ax = Math.abs(x);\r\n\r\n        if (ax < 3.75) {\r\n            double y = x / 3.75;\r\n            y = y * y;\r\n            ans = 1.0 + y * (3.5156229 + y * (3.0899424 + y * (1.2067492\r\n                    + y * (0.2659732 + y * (0.360768e-1 + y * 0.45813e-2)))));\r\n        } else {\r\n            double y = 3.75 / ax;\r\n            ans = (Math.exp(ax) / Math.sqrt(ax)) * (0.39894228 + y * (0.1328592e-1\r\n                    + y * (0.225319e-2 + y * (-0.157565e-2 + y * (0.916281e-2\r\n                    + y * (-0.2057706e-1 + y * (0.2635537e-1 + y * (-0.1647633e-1\r\n                    + y * 0.392377e-2))))))));\r\n        }\r\n\r\n        return ans;\r\n    }", "code_tokens": ["public", "static", "double", "I0", "(", "double", "x", ")", "{", "double", "ans", ";", "double", "ax", "=", "Math", ".", "abs", "(", "x", ")", ";", "if", "(", "ax", "<", "3.75", ")", "{", "double", "y", "=", "x", "/", "3.75", ";", "y", "=", "y", "*", "y", ";", "ans", "=", "1.0", "+", "y", "*", "(", "3.5156229", "+", "y", "*", "(", "3.0899424", "+", "y", "*", "(", "1.2067492", "+", "y", "*", "(", "0.2659732", "+", "y", "*", "(", "0.360768e-1", "+", "y", "*", "0.45813e-2", ")", ")", ")", ")", ")", ";", "}", "else", "{", "double", "y", "=", "3.75", "/", "ax", ";", "ans", "=", "(", "Math", ".", "exp", "(", "ax", ")", "/", "Math", ".", "sqrt", "(", "ax", ")", ")", "*", "(", "0.39894228", "+", "y", "*", "(", "0.1328592e-1", "+", "y", "*", "(", "0.225319e-2", "+", "y", "*", "(", "-", "0.157565e-2", "+", "y", "*", "(", "0.916281e-2", "+", "y", "*", "(", "-", "0.2057706e-1", "+", "y", "*", "(", "0.2635537e-1", "+", "y", "*", "(", "-", "0.1647633e-1", "+", "y", "*", "0.392377e-2", ")", ")", ")", ")", ")", ")", ")", ")", ";", "}", "return", "ans", ";", "}"], "docstring": "Bessel function of the first kind, of order 0.\n\n@param x Value.\n@return I0 value.", "docstring_tokens": ["Bessel", "function", "of", "the", "first", "kind", "of", "order", "0", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/function/Bessel.java#L276-L294", "partition": "train", "up_fun_num": 8, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1], "package": [], "function": ["public final class Bessel\n", "    public static double J0(double x)\n", "    public static double J(double x)\n", "    public static double J(int n, double x)\n", "    public static double Y0(double x)\n", "    public static double Y(double x)\n", "    public static double Y(int n, double x)\n", "    public static double I(double x)\n", "    public static double I(int n, double x)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2013\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\n// Contains functions from the Cephes Math Library Release 2.8:\n// June, 2000 Copyright 1984, 1987, 1988, 2000 by Stephen L. Moshier\n//\n// Original license is listed below:\n//\n//   Some software in this archive may be from the book _Methods and\n// Programs for Mathematical Functions_ (Prentice-Hall or Simon & Schuster\n// International, 1989) or from the Cephes Mathematical Library, a\n// commercial product. In either event, it is copyrighted by the author.\n// What you see here may be used freely but it comes with no support or\n// guarantee.\n//\n//   The two known misprints in the book are repaired here in the\n// source listings for the gamma function and the incomplete beta\n// integral.\n//\n//\n//   Stephen L. Moshier\n//   moshier@na-net.ornl.gov\n//\n\npackage com.harium.keel.catalano.math.function;\n\n/**\n * Bessel functions.\n * <para> Bessel functions, first defined by the mathematician Daniel Bernoulli and generalized by Friedrich Bessel,\n * are the canonical solutions y(x) of Bessel's differential equation.</para>\n *\n * @author Diego Catalano\n */\npublic final class Bessel\n{\n\n    private Bessel()\n    {\n    }\n\n    /**\n     * Bessel function of order 0.\n     *\n     * @param x Value.\n     * @return J0 value.\n     */\n    public static double J0(double x)\n    {\n        double ax;\n\n        if ((ax = Math.abs(x)) < 8.0)\n        {\n            double y = x * x;\n            double ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7\n                                               + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));\n            double ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718\n                                               + y * (59272.64853 + y * (267.8532712 + y * 1.0))));\n\n            return ans1 / ans2;\n        }\n        else\n        {\n            double z = 8.0 / ax;\n            double y = z * z;\n            double xx = ax - 0.785398164;\n            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\n                                     + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\n            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\n                                                  + y * (-0.6911147651e-5 + y * (0.7621095161e-6\n                                                          - y * 0.934935152e-7)));\n\n            return Math.sqrt(0.636619772 / ax) *\n                   (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);\n        }\n    }\n\n    /**\n     * Bessel function of order 1.\n     *\n     * @param x Value.\n     * @return J value.\n     */\n    public static double J(double x)\n    {\n        double ax;\n        double y;\n        double ans1, ans2;\n\n        if ((ax = Math.abs(x)) < 8.0)\n        {\n            y = x * x;\n            ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1\n                                             + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));\n            ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74\n                                         + y * (99447.43394 + y * (376.9991397 + y * 1.0))));\n            return ans1 / ans2;\n        }\n        else\n        {\n            double z = 8.0 / ax;\n            double xx = ax - 2.356194491;\n            y = z * z;\n\n            ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4\n                                                 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));\n            ans2 = 0.04687499995 + y * (-0.2002690873e-3\n                                        + y * (0.8449199096e-5 + y * (-0.88228987e-6\n                                                + y * 0.105787412e-6)));\n            double ans = Math.sqrt(0.636619772 / ax) *\n                         (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);\n            if (x < 0.0) ans = -ans;\n            return ans;\n        }\n    }\n\n    /**\n     * Bessel function of order n.\n     *\n     * @param n Order.\n     * @param x Value.\n     * @return J value.\n     */\n    public static double J(int n, double x)\n    {\n        int j, m;\n        double ax, bj, bjm, bjp, sum, tox, ans;\n        boolean jsum;\n\n        double ACC = 40.0;\n        double BIGNO = 1.0e+10;\n        double BIGNI = 1.0e-10;\n\n        if (n == 0) return J0(x);\n        if (n == 1) return J(x);\n\n        ax = Math.abs(x);\n        if (ax == 0.0) return 0.0;\n        else if (ax > (double) n)\n        {\n            tox = 2.0 / ax;\n            bjm = J0(ax);\n            bj = J(ax);\n            for (j = 1; j < n; j++)\n            {\n                bjp = j * tox * bj - bjm;\n                bjm = bj;\n                bj = bjp;\n            }\n            ans = bj;\n        }\n        else\n        {\n            tox = 2.0 / ax;\n            m = 2 * ((n + (int) Math.sqrt(ACC * n)) / 2);\n            jsum = false;\n            bjp = ans = sum = 0.0;\n            bj = 1.0;\n            for (j = m; j > 0; j--)\n            {\n                bjm = j * tox * bj - bjp;\n                bjp = bj;\n                bj = bjm;\n                if (Math.abs(bj) > BIGNO)\n                {\n                    bj *= BIGNI;\n                    bjp *= BIGNI;\n                    ans *= BIGNI;\n                    sum *= BIGNI;\n                }\n                if (jsum) sum += bj;\n                jsum = !jsum;\n                if (j == n) ans = bjp;\n            }\n            sum = 2.0 * sum - bj;\n            ans /= sum;\n        }\n\n        return x < 0.0 && n % 2 == 1 ? -ans : ans;\n    }\n\n    /**\n     * Bessel function of the second kind, of order 0.\n     *\n     * @param x Value.\n     * @return Y0 value.\n     */\n    public static double Y0(double x)\n    {\n        if (x < 8.0)\n        {\n            double y = x * x;\n\n            double ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6\n                                               + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));\n            double ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438\n                                               + y * (47447.26470 + y * (226.1030244 + y * 1.0))));\n\n            return (ans1 / ans2) + 0.636619772 * J0(x) * Math.log(x);\n        }\n        else\n        {\n            double z = 8.0 / x;\n            double y = z * z;\n            double xx = x - 0.785398164;\n\n            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\n                                     + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\n            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\n                                                  + y * (-0.6911147651e-5 + y * (0.7621095161e-6\n                                                          + y * (-0.934945152e-7))));\n            return Math.sqrt(0.636619772 / x) *\n                   (Math.sin(xx) * ans1 + z * Math.cos(xx) * ans2);\n        }\n    }\n\n    /**\n     * Bessel function of the second kind, of order 1.\n     *\n     * @param x Value.\n     * @return Y value.\n     */\n    public static double Y(double x)\n    {\n        if (x < 8.0)\n        {\n            double y = x * x;\n            double ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13\n                               + y * (-0.5153438139e11 + y * (0.7349264551e9\n                                       + y * (-0.4237922726e7 + y * 0.8511937935e4)))));\n            double ans2 = 0.2499580570e14 + y * (0.4244419664e12\n                                                 + y * (0.3733650367e10 + y * (0.2245904002e8\n                                                         + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));\n            return (ans1 / ans2) + 0.636619772 * (J(x) * Math.log(x) - 1.0 / x);\n        }\n        else\n        {\n            double z = 8.0 / x;\n            double y = z * z;\n            double xx = x - 2.356194491;\n            double ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4\n                                     + y * (0.2457520174e-5 + y * (-0.240337019e-6))));\n            double ans2 = 0.04687499995 + y * (-0.2002690873e-3\n                                               + y * (0.8449199096e-5 + y * (-0.88228987e-6\n                                                       + y * 0.105787412e-6)));\n            return Math.sqrt(0.636619772 / x) *\n                   (Math.sin(xx) * ans1 + z * Math.cos(xx) * ans2);\n        }\n    }\n\n    /**\n     * Bessel function of the second kind, of order n.\n     *\n     * @param n Order.\n     * @param x Value.\n     * @return Y value.\n     */\n    public static double Y(int n, double x)\n    {\n        double by, bym, byp, tox;\n\n        if (n == 0) return Y0(x);\n        if (n == 1) return Y(x);\n\n        tox = 2.0 / x;\n        by = Y(x);\n        bym = Y0(x);\n        for (int j = 1; j < n; j++)\n        {\n            byp = j * tox * by - bym;\n            bym = by;\n            by = byp;\n        }\n        return by;\n    }\n\n    /**\n     * Bessel function of the first kind, of order 0.\n     *\n     * @param x Value.\n     * @return I0 value.\n     */\n\n    /**\n     * Bessel function of the first kind, of order 1.\n     *\n     * @param x Value.\n     * @return I value.\n     */\n    public static double I(double x)\n    {\n        double ans;\n\n        double ax = Math.abs(x);\n\n        if (ax < 3.75)\n        {\n            double y = x / 3.75;\n            y = y * y;\n            ans = ax * (0.5 + y * (0.87890594 + y * (0.51498869 + y * (0.15084934\n                                   + y * (0.2658733e-1 + y * (0.301532e-2 + y * 0.32411e-3))))));\n        }\n        else\n        {\n            double y = 3.75 / ax;\n            ans = 0.2282967e-1 + y * (-0.2895312e-1 + y * (0.1787654e-1 - y * 0.420059e-2));\n            ans = 0.39894228 + y * (-0.3988024e-1 + y * (-0.362018e-2 + y * (0.163801e-2 + y * (-0.1031555e-1 + y * ans))));\n            ans *= Math.exp(ax) / Math.sqrt(ax);\n        }\n        return x < 0.0 ? -ans : ans;\n    }\n\n    /**\n     * Bessel function of the first kind, of order n.\n     *\n     * @param n Order.\n     * @param x Value.\n     * @return I value.\n     */\n    public static double I(int n, double x)\n    {\n        if (n < 0)\n            throw new IllegalArgumentException(\"the variable n out of range.\");\n        else if (n == 0)\n            return I0(x);\n        else if (n == 1)\n            return I(x);\n\n        if (x == 0.0)\n            return 0.0;\n\n        double ACC = 40.0;\n        double BIGNO = 1.0e+10;\n        double BIGNI = 1.0e-10;\n\n        double tox = 2.0 / Math.abs(x);\n        double bip = 0, ans = 0.0;\n        double bi = 1.0;\n\n        for (int j = 2 * (n + (int) Math.sqrt(ACC * n)); j > 0; j--)\n        {\n            double bim = bip + j * tox * bi;\n            bip = bi;\n            bi = bim;\n\n            if (Math.abs(bi) > BIGNO)\n            {\n                ans *= BIGNI;\n                bi *= BIGNI;\n                bip *= BIGNI;\n            }\n\n            if (j == n)\n                ans = bip;\n        }\n\n        ans *= I0(x) / bi;\n        return x < 0.0 && n % 2 == 1 ? -ans : ans;\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/function/Bessel.java", "func_name": "Bessel.I", "original_string": "public static double I(int n, double x) {\r\n        if (n < 0)\r\n            throw new IllegalArgumentException(\"the variable n out of range.\");\r\n        else if (n == 0)\r\n            return I0(x);\r\n        else if (n == 1)\r\n            return I(x);\r\n\r\n        if (x == 0.0)\r\n            return 0.0;\r\n\r\n        double ACC = 40.0;\r\n        double BIGNO = 1.0e+10;\r\n        double BIGNI = 1.0e-10;\r\n\r\n        double tox = 2.0 / Math.abs(x);\r\n        double bip = 0, ans = 0.0;\r\n        double bi = 1.0;\r\n\r\n        for (int j = 2 * (n + (int) Math.sqrt(ACC * n)); j > 0; j--) {\r\n            double bim = bip + j * tox * bi;\r\n            bip = bi;\r\n            bi = bim;\r\n\r\n            if (Math.abs(bi) > BIGNO) {\r\n                ans *= BIGNI;\r\n                bi *= BIGNI;\r\n                bip *= BIGNI;\r\n            }\r\n\r\n            if (j == n)\r\n                ans = bip;\r\n        }\r\n\r\n        ans *= I0(x) / bi;\r\n        return x < 0.0 && n % 2 == 1 ? -ans : ans;\r\n    }", "language": "java", "code": "public static double I(int n, double x) {\r\n        if (n < 0)\r\n            throw new IllegalArgumentException(\"the variable n out of range.\");\r\n        else if (n == 0)\r\n            return I0(x);\r\n        else if (n == 1)\r\n            return I(x);\r\n\r\n        if (x == 0.0)\r\n            return 0.0;\r\n\r\n        double ACC = 40.0;\r\n        double BIGNO = 1.0e+10;\r\n        double BIGNI = 1.0e-10;\r\n\r\n        double tox = 2.0 / Math.abs(x);\r\n        double bip = 0, ans = 0.0;\r\n        double bi = 1.0;\r\n\r\n        for (int j = 2 * (n + (int) Math.sqrt(ACC * n)); j > 0; j--) {\r\n            double bim = bip + j * tox * bi;\r\n            bip = bi;\r\n            bi = bim;\r\n\r\n            if (Math.abs(bi) > BIGNO) {\r\n                ans *= BIGNI;\r\n                bi *= BIGNI;\r\n                bip *= BIGNI;\r\n            }\r\n\r\n            if (j == n)\r\n                ans = bip;\r\n        }\r\n\r\n        ans *= I0(x) / bi;\r\n        return x < 0.0 && n % 2 == 1 ? -ans : ans;\r\n    }", "code_tokens": ["public", "static", "double", "I", "(", "int", "n", ",", "double", "x", ")", "{", "if", "(", "n", "<", "0", ")", "throw", "new", "IllegalArgumentException", "(", "\"the variable n out of range.\"", ")", ";", "else", "if", "(", "n", "==", "0", ")", "return", "I0", "(", "x", ")", ";", "else", "if", "(", "n", "==", "1", ")", "return", "I", "(", "x", ")", ";", "if", "(", "x", "==", "0.0", ")", "return", "0.0", ";", "double", "ACC", "=", "40.0", ";", "double", "BIGNO", "=", "1.0e+10", ";", "double", "BIGNI", "=", "1.0e-10", ";", "double", "tox", "=", "2.0", "/", "Math", ".", "abs", "(", "x", ")", ";", "double", "bip", "=", "0", ",", "ans", "=", "0.0", ";", "double", "bi", "=", "1.0", ";", "for", "(", "int", "j", "=", "2", "*", "(", "n", "+", "(", "int", ")", "Math", ".", "sqrt", "(", "ACC", "*", "n", ")", ")", ";", "j", ">", "0", ";", "j", "--", ")", "{", "double", "bim", "=", "bip", "+", "j", "*", "tox", "*", "bi", ";", "bip", "=", "bi", ";", "bi", "=", "bim", ";", "if", "(", "Math", ".", "abs", "(", "bi", ")", ">", "BIGNO", ")", "{", "ans", "*=", "BIGNI", ";", "bi", "*=", "BIGNI", ";", "bip", "*=", "BIGNI", ";", "}", "if", "(", "j", "==", "n", ")", "ans", "=", "bip", ";", "}", "ans", "*=", "I0", "(", "x", ")", "/", "bi", ";", "return", "x", "<", "0.0", "&&", "n", "%", "2", "==", "1", "?", "-", "ans", ":", "ans", ";", "}"], "docstring": "Bessel function of the first kind, of order n.\n\n@param n Order.\n@param x Value.\n@return I value.", "docstring_tokens": ["Bessel", "function", "of", "the", "first", "kind", "of", "order", "n", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/function/Bessel.java#L328-L364", "partition": "train", "up_fun_num": 9, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1], "package": [], "function": ["public final class Bessel\n", "    public static double J0(double x)\n", "    public static double J(double x)\n", "    public static double J(int n, double x)\n", "    public static double Y0(double x)\n", "    public static double Y(double x)\n", "    public static double Y(int n, double x)\n", "    public static double I0(double x)\n", "    public static double I(double x)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2013\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\n// Contains functions from the Cephes Math Library Release 2.8:\n// June, 2000 Copyright 1984, 1987, 1988, 2000 by Stephen L. Moshier\n//\n// Original license is listed below:\n//\n//   Some software in this archive may be from the book _Methods and\n// Programs for Mathematical Functions_ (Prentice-Hall or Simon & Schuster\n// International, 1989) or from the Cephes Mathematical Library, a\n// commercial product. In either event, it is copyrighted by the author.\n// What you see here may be used freely but it comes with no support or\n// guarantee.\n//\n//   The two known misprints in the book are repaired here in the\n// source listings for the gamma function and the incomplete beta\n// integral.\n//\n//\n//   Stephen L. Moshier\n//   moshier@na-net.ornl.gov\n//\n\npackage com.harium.keel.catalano.math.function;\n\n/**\n * Bessel functions.\n * <para> Bessel functions, first defined by the mathematician Daniel Bernoulli and generalized by Friedrich Bessel,\n * are the canonical solutions y(x) of Bessel's differential equation.</para>\n *\n * @author Diego Catalano\n */\npublic final class Bessel\n{\n\n    private Bessel()\n    {\n    }\n\n    /**\n     * Bessel function of order 0.\n     *\n     * @param x Value.\n     * @return J0 value.\n     */\n    public static double J0(double x)\n    {\n        double ax;\n\n        if ((ax = Math.abs(x)) < 8.0)\n        {\n            double y = x * x;\n            double ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7\n                                               + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));\n            double ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718\n                                               + y * (59272.64853 + y * (267.8532712 + y * 1.0))));\n\n            return ans1 / ans2;\n        }\n        else\n        {\n            double z = 8.0 / ax;\n            double y = z * z;\n            double xx = ax - 0.785398164;\n            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\n                                     + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\n            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\n                                                  + y * (-0.6911147651e-5 + y * (0.7621095161e-6\n                                                          - y * 0.934935152e-7)));\n\n            return Math.sqrt(0.636619772 / ax) *\n                   (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);\n        }\n    }\n\n    /**\n     * Bessel function of order 1.\n     *\n     * @param x Value.\n     * @return J value.\n     */\n    public static double J(double x)\n    {\n        double ax;\n        double y;\n        double ans1, ans2;\n\n        if ((ax = Math.abs(x)) < 8.0)\n        {\n            y = x * x;\n            ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1\n                                             + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));\n            ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74\n                                         + y * (99447.43394 + y * (376.9991397 + y * 1.0))));\n            return ans1 / ans2;\n        }\n        else\n        {\n            double z = 8.0 / ax;\n            double xx = ax - 2.356194491;\n            y = z * z;\n\n            ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4\n                                                 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));\n            ans2 = 0.04687499995 + y * (-0.2002690873e-3\n                                        + y * (0.8449199096e-5 + y * (-0.88228987e-6\n                                                + y * 0.105787412e-6)));\n            double ans = Math.sqrt(0.636619772 / ax) *\n                         (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);\n            if (x < 0.0) ans = -ans;\n            return ans;\n        }\n    }\n\n    /**\n     * Bessel function of order n.\n     *\n     * @param n Order.\n     * @param x Value.\n     * @return J value.\n     */\n    public static double J(int n, double x)\n    {\n        int j, m;\n        double ax, bj, bjm, bjp, sum, tox, ans;\n        boolean jsum;\n\n        double ACC = 40.0;\n        double BIGNO = 1.0e+10;\n        double BIGNI = 1.0e-10;\n\n        if (n == 0) return J0(x);\n        if (n == 1) return J(x);\n\n        ax = Math.abs(x);\n        if (ax == 0.0) return 0.0;\n        else if (ax > (double) n)\n        {\n            tox = 2.0 / ax;\n            bjm = J0(ax);\n            bj = J(ax);\n            for (j = 1; j < n; j++)\n            {\n                bjp = j * tox * bj - bjm;\n                bjm = bj;\n                bj = bjp;\n            }\n            ans = bj;\n        }\n        else\n        {\n            tox = 2.0 / ax;\n            m = 2 * ((n + (int) Math.sqrt(ACC * n)) / 2);\n            jsum = false;\n            bjp = ans = sum = 0.0;\n            bj = 1.0;\n            for (j = m; j > 0; j--)\n            {\n                bjm = j * tox * bj - bjp;\n                bjp = bj;\n                bj = bjm;\n                if (Math.abs(bj) > BIGNO)\n                {\n                    bj *= BIGNI;\n                    bjp *= BIGNI;\n                    ans *= BIGNI;\n                    sum *= BIGNI;\n                }\n                if (jsum) sum += bj;\n                jsum = !jsum;\n                if (j == n) ans = bjp;\n            }\n            sum = 2.0 * sum - bj;\n            ans /= sum;\n        }\n\n        return x < 0.0 && n % 2 == 1 ? -ans : ans;\n    }\n\n    /**\n     * Bessel function of the second kind, of order 0.\n     *\n     * @param x Value.\n     * @return Y0 value.\n     */\n    public static double Y0(double x)\n    {\n        if (x < 8.0)\n        {\n            double y = x * x;\n\n            double ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6\n                                               + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));\n            double ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438\n                                               + y * (47447.26470 + y * (226.1030244 + y * 1.0))));\n\n            return (ans1 / ans2) + 0.636619772 * J0(x) * Math.log(x);\n        }\n        else\n        {\n            double z = 8.0 / x;\n            double y = z * z;\n            double xx = x - 0.785398164;\n\n            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\n                                     + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\n            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\n                                                  + y * (-0.6911147651e-5 + y * (0.7621095161e-6\n                                                          + y * (-0.934945152e-7))));\n            return Math.sqrt(0.636619772 / x) *\n                   (Math.sin(xx) * ans1 + z * Math.cos(xx) * ans2);\n        }\n    }\n\n    /**\n     * Bessel function of the second kind, of order 1.\n     *\n     * @param x Value.\n     * @return Y value.\n     */\n    public static double Y(double x)\n    {\n        if (x < 8.0)\n        {\n            double y = x * x;\n            double ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13\n                               + y * (-0.5153438139e11 + y * (0.7349264551e9\n                                       + y * (-0.4237922726e7 + y * 0.8511937935e4)))));\n            double ans2 = 0.2499580570e14 + y * (0.4244419664e12\n                                                 + y * (0.3733650367e10 + y * (0.2245904002e8\n                                                         + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));\n            return (ans1 / ans2) + 0.636619772 * (J(x) * Math.log(x) - 1.0 / x);\n        }\n        else\n        {\n            double z = 8.0 / x;\n            double y = z * z;\n            double xx = x - 2.356194491;\n            double ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4\n                                     + y * (0.2457520174e-5 + y * (-0.240337019e-6))));\n            double ans2 = 0.04687499995 + y * (-0.2002690873e-3\n                                               + y * (0.8449199096e-5 + y * (-0.88228987e-6\n                                                       + y * 0.105787412e-6)));\n            return Math.sqrt(0.636619772 / x) *\n                   (Math.sin(xx) * ans1 + z * Math.cos(xx) * ans2);\n        }\n    }\n\n    /**\n     * Bessel function of the second kind, of order n.\n     *\n     * @param n Order.\n     * @param x Value.\n     * @return Y value.\n     */\n    public static double Y(int n, double x)\n    {\n        double by, bym, byp, tox;\n\n        if (n == 0) return Y0(x);\n        if (n == 1) return Y(x);\n\n        tox = 2.0 / x;\n        by = Y(x);\n        bym = Y0(x);\n        for (int j = 1; j < n; j++)\n        {\n            byp = j * tox * by - bym;\n            bym = by;\n            by = byp;\n        }\n        return by;\n    }\n\n    /**\n     * Bessel function of the first kind, of order 0.\n     *\n     * @param x Value.\n     * @return I0 value.\n     */\n    public static double I0(double x)\n    {\n        double ans;\n        double ax = Math.abs(x);\n\n        if (ax < 3.75)\n        {\n            double y = x / 3.75;\n            y = y * y;\n            ans = 1.0 + y * (3.5156229 + y * (3.0899424 + y * (1.2067492\n                                              + y * (0.2659732 + y * (0.360768e-1 + y * 0.45813e-2)))));\n        }\n        else\n        {\n            double y = 3.75 / ax;\n            ans = (Math.exp(ax) / Math.sqrt(ax)) * (0.39894228 + y * (0.1328592e-1\n                                                    + y * (0.225319e-2 + y * (-0.157565e-2 + y * (0.916281e-2\n                                                            + y * (-0.2057706e-1 + y * (0.2635537e-1 + y * (-0.1647633e-1\n                                                                    + y * 0.392377e-2))))))));\n        }\n\n        return ans;\n    }\n\n    /**\n     * Bessel function of the first kind, of order 1.\n     *\n     * @param x Value.\n     * @return I value.\n     */\n    public static double I(double x)\n    {\n        double ans;\n\n        double ax = Math.abs(x);\n\n        if (ax < 3.75)\n        {\n            double y = x / 3.75;\n            y = y * y;\n            ans = ax * (0.5 + y * (0.87890594 + y * (0.51498869 + y * (0.15084934\n                                   + y * (0.2658733e-1 + y * (0.301532e-2 + y * 0.32411e-3))))));\n        }\n        else\n        {\n            double y = 3.75 / ax;\n            ans = 0.2282967e-1 + y * (-0.2895312e-1 + y * (0.1787654e-1 - y * 0.420059e-2));\n            ans = 0.39894228 + y * (-0.3988024e-1 + y * (-0.362018e-2 + y * (0.163801e-2 + y * (-0.1031555e-1 + y * ans))));\n            ans *= Math.exp(ax) / Math.sqrt(ax);\n        }\n        return x < 0.0 ? -ans : ans;\n    }\n\n    /**\n     * Bessel function of the first kind, of order n.\n     *\n     * @param n Order.\n     * @param x Value.\n     * @return I value.\n     */\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/effect/normal/SobelNormalMap.java", "func_name": "SobelNormalMap.apply", "original_string": "@Override\n    public ImageSource apply(ImageSource input) {\n        int w = input.getWidth();\n        int h = input.getHeight();\n\n        MatrixSource output = new MatrixSource(input);\n\n        Vector3 n = new Vector3(0, 0, 1);\n\n        for (int y = 0; y < h; y++) {\n            for (int x = 0; x < w; x++) {\n\n                if (x < border || x == w - border || y < border || y == h - border) {\n                    output.setRGB(x, y, VectorHelper.Z_NORMAL);\n                    continue;\n                }\n\n                float s0 = input.getR(x - 1, y + 1);\n                float s1 = input.getR(x, y + 1);\n                float s2 = input.getR(x + 1, y + 1);\n                float s3 = input.getR(x - 1, y);\n                float s5 = input.getR(x + 1, y);\n                float s6 = input.getR(x - 1, y - 1);\n                float s7 = input.getR(x, y - 1);\n                float s8 = input.getR(x + 1, y - 1);\n\n                float nx = -(s2 - s0 + 2 * (s5 - s3) + s8 - s6);\n                float ny = -(s6 - s0 + 2 * (s7 - s1) + s8 - s2);\n\n                n.set(nx, ny, scale);\n                n.nor();\n\n                int rgb = VectorHelper.vectorToColor(n);\n                output.setRGB(x, y, rgb);\n            }\n        }\n\n        return new MatrixSource(output);\n    }", "language": "java", "code": "@Override\n    public ImageSource apply(ImageSource input) {\n        int w = input.getWidth();\n        int h = input.getHeight();\n\n        MatrixSource output = new MatrixSource(input);\n\n        Vector3 n = new Vector3(0, 0, 1);\n\n        for (int y = 0; y < h; y++) {\n            for (int x = 0; x < w; x++) {\n\n                if (x < border || x == w - border || y < border || y == h - border) {\n                    output.setRGB(x, y, VectorHelper.Z_NORMAL);\n                    continue;\n                }\n\n                float s0 = input.getR(x - 1, y + 1);\n                float s1 = input.getR(x, y + 1);\n                float s2 = input.getR(x + 1, y + 1);\n                float s3 = input.getR(x - 1, y);\n                float s5 = input.getR(x + 1, y);\n                float s6 = input.getR(x - 1, y - 1);\n                float s7 = input.getR(x, y - 1);\n                float s8 = input.getR(x + 1, y - 1);\n\n                float nx = -(s2 - s0 + 2 * (s5 - s3) + s8 - s6);\n                float ny = -(s6 - s0 + 2 * (s7 - s1) + s8 - s2);\n\n                n.set(nx, ny, scale);\n                n.nor();\n\n                int rgb = VectorHelper.vectorToColor(n);\n                output.setRGB(x, y, rgb);\n            }\n        }\n\n        return new MatrixSource(output);\n    }", "code_tokens": ["@", "Override", "public", "ImageSource", "apply", "(", "ImageSource", "input", ")", "{", "int", "w", "=", "input", ".", "getWidth", "(", ")", ";", "int", "h", "=", "input", ".", "getHeight", "(", ")", ";", "MatrixSource", "output", "=", "new", "MatrixSource", "(", "input", ")", ";", "Vector3", "n", "=", "new", "Vector3", "(", "0", ",", "0", ",", "1", ")", ";", "for", "(", "int", "y", "=", "0", ";", "y", "<", "h", ";", "y", "++", ")", "{", "for", "(", "int", "x", "=", "0", ";", "x", "<", "w", ";", "x", "++", ")", "{", "if", "(", "x", "<", "border", "||", "x", "==", "w", "-", "border", "||", "y", "<", "border", "||", "y", "==", "h", "-", "border", ")", "{", "output", ".", "setRGB", "(", "x", ",", "y", ",", "VectorHelper", ".", "Z_NORMAL", ")", ";", "continue", ";", "}", "float", "s0", "=", "input", ".", "getR", "(", "x", "-", "1", ",", "y", "+", "1", ")", ";", "float", "s1", "=", "input", ".", "getR", "(", "x", ",", "y", "+", "1", ")", ";", "float", "s2", "=", "input", ".", "getR", "(", "x", "+", "1", ",", "y", "+", "1", ")", ";", "float", "s3", "=", "input", ".", "getR", "(", "x", "-", "1", ",", "y", ")", ";", "float", "s5", "=", "input", ".", "getR", "(", "x", "+", "1", ",", "y", ")", ";", "float", "s6", "=", "input", ".", "getR", "(", "x", "-", "1", ",", "y", "-", "1", ")", ";", "float", "s7", "=", "input", ".", "getR", "(", "x", ",", "y", "-", "1", ")", ";", "float", "s8", "=", "input", ".", "getR", "(", "x", "+", "1", ",", "y", "-", "1", ")", ";", "float", "nx", "=", "-", "(", "s2", "-", "s0", "+", "2", "*", "(", "s5", "-", "s3", ")", "+", "s8", "-", "s6", ")", ";", "float", "ny", "=", "-", "(", "s6", "-", "s0", "+", "2", "*", "(", "s7", "-", "s1", ")", "+", "s8", "-", "s2", ")", ";", "n", ".", "set", "(", "nx", ",", "ny", ",", "scale", ")", ";", "n", ".", "nor", "(", ")", ";", "int", "rgb", "=", "VectorHelper", ".", "vectorToColor", "(", "n", ")", ";", "output", ".", "setRGB", "(", "x", ",", "y", ",", "rgb", ")", ";", "}", "}", "return", "new", "MatrixSource", "(", "output", ")", ";", "}"], "docstring": "Sobel method to generate bump map from a height map\n\n@param input - A height map\n@return bump map", "docstring_tokens": ["Sobel", "method", "to", "generate", "bump", "map", "from", "a", "height", "map"], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/effect/normal/SobelNormalMap.java#L19-L57", "partition": "train", "up_fun_num": 1, "levels": [0], "package": ["import com.badlogic.gdx.math.Vector3;", "import com.harium.keel.core.helper.VectorHelper;", "import com.harium.keel.core.source.ImageSource;", "import com.harium.keel.core.source.MatrixSource;"], "function": ["public class SobelNormalMap extends NormalMap\n"], "context": "package com.harium.keel.effect.normal;\n\nimport com.badlogic.gdx.math.Vector3;\nimport com.harium.keel.core.helper.VectorHelper;\nimport com.harium.keel.core.source.ImageSource;\nimport com.harium.keel.core.source.MatrixSource;\n\n/**\n * Reference: http://www.alejandrosegovia.net/2014/03/31/bump-map-generation/\n */\npublic class SobelNormalMap extends NormalMap\n{\n\n    /**\n     * Sobel method to generate bump map from a height map\n     *\n     * @param input - A height map\n     * @return bump map\n     */\n\n}"}
{"repo": "hyleung/ratpack-zipkin", "path": "src/main/java/ratpack/zipkin/internal/RatpackCurrentTraceContext.java", "func_name": "RatpackCurrentTraceContext.wrap", "original_string": "@Deprecated\n  public static TraceContextHolder wrap(TraceContext traceContext) {\n    return (traceContext != null) ? new TraceContextHolder(traceContext) : TraceContextHolder.EMPTY;\n  }", "language": "java", "code": "@Deprecated\n  public static TraceContextHolder wrap(TraceContext traceContext) {\n    return (traceContext != null) ? new TraceContextHolder(traceContext) : TraceContextHolder.EMPTY;\n  }", "code_tokens": ["@", "Deprecated", "public", "static", "TraceContextHolder", "wrap", "(", "TraceContext", "traceContext", ")", "{", "return", "(", "traceContext", "!=", "null", ")", "?", "new", "TraceContextHolder", "(", "traceContext", ")", ":", "TraceContextHolder", ".", "EMPTY", ";", "}"], "docstring": "Used by TracedParallelBatch where its used to wrap a TraceContext and puts it in the\nregistry for the forked execution.  This is marked deprecated as we prefer not to\nexpose details of the RatpackCurrentTraceContext implementation.\n\n@param traceContext a trace context.\n@return a holder for the trace context, which can be put into the registry.", "docstring_tokens": ["Used", "by", "TracedParallelBatch", "where", "its", "used", "to", "wrap", "a", "TraceContext", "and", "puts", "it", "in", "the", "registry", "for", "the", "forked", "execution", ".", "This", "is", "marked", "deprecated", "as", "we", "prefer", "not", "to", "expose", "details", "of", "the", "RatpackCurrentTraceContext", "implementation", "."], "sha": "3c9e4b05e3f5fab034c1f7832fffce8a55c311d3", "url": "https://github.com/hyleung/ratpack-zipkin/blob/3c9e4b05e3f5fab034c1f7832fffce8a55c311d3/src/main/java/ratpack/zipkin/internal/RatpackCurrentTraceContext.java#L64-L67", "partition": "train", "up_fun_num": 3, "levels": [0, 1, 1], "package": ["import brave.propagation.CurrentTraceContext;", "import brave.propagation.TraceContext;", "import java.util.function.Supplier;", "import org.slf4j.MDC;", "import ratpack.exec.Execution;", "import ratpack.registry.MutableRegistry;"], "function": ["public final class RatpackCurrentTraceContext extends CurrentTraceContext\n", "    public TraceContext get()\n", "    public Scope newScope(TraceContext current)\n"], "context": "package ratpack.zipkin.internal;\n\nimport brave.propagation.CurrentTraceContext;\nimport brave.propagation.TraceContext;\nimport java.util.function.Supplier;\nimport org.slf4j.MDC;\nimport ratpack.exec.Execution;\nimport ratpack.registry.MutableRegistry;\n\npublic final class RatpackCurrentTraceContext extends CurrentTraceContext\n{\n\n    private static final String TRACE_ID_KEY = \"TraceId\";\n\n    private final Supplier<MutableRegistry> registrySupplier;\n\n    public RatpackCurrentTraceContext(Supplier<MutableRegistry> registrySupplier)\n    {\n        this.registrySupplier = registrySupplier;\n    }\n\n    public RatpackCurrentTraceContext()\n    {\n        this(Execution::current);\n    }\n\n    @Override\n    public TraceContext get()\n    {\n        return registrySupplier.get()\n               .maybeGet(TraceContextHolder.class)\n               .map(h -> h.context)\n               .orElse(null);\n    }\n\n    @Override\n    public Scope newScope(TraceContext current)\n    {\n        final TraceContextHolder previous = registrySupplier.get()\n                                            .maybeGet(TraceContextHolder.class)\n                                            .orElse(TraceContextHolder.EMPTY);\n\n        if (current != null)\n        {\n            registrySupplier.get().add(new TraceContextHolder(current));\n            MDC.put(TRACE_ID_KEY, current.traceIdString());\n        }\n        else\n        {\n            registrySupplier.get().add(TraceContextHolder.EMPTY);\n            MDC.remove(TRACE_ID_KEY);\n        }\n\n        return () ->\n        {\n            registrySupplier.get().add(previous);\n            if (previous.context != null)\n            {\n                MDC.put(TRACE_ID_KEY, previous.context.traceIdString());\n            }\n            else\n            {\n                MDC.remove(TRACE_ID_KEY);\n            }\n        };\n    }\n\n    /**\n     * Used by TracedParallelBatch where its used to wrap a TraceContext and puts it in the\n     * registry for the forked execution.  This is marked deprecated as we prefer not to\n     * expose details of the RatpackCurrentTraceContext implementation.\n     *\n     * @param traceContext a trace context.\n     * @return a holder for the trace context, which can be put into the registry.\n     */\n\n    private static final class TraceContextHolder\n    {\n\n        private static final TraceContextHolder EMPTY = new TraceContextHolder(null);\n\n        private final TraceContext context;\n\n        private TraceContextHolder(final TraceContext context)\n        {\n            this.context = context;\n        }\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/Tools.java", "func_name": "Tools.Sinc", "original_string": "public static double Sinc(double x) {\r\n        return Math.sin(Math.PI * x) / (Math.PI * x);\r\n    }", "language": "java", "code": "public static double Sinc(double x) {\r\n        return Math.sin(Math.PI * x) / (Math.PI * x);\r\n    }", "code_tokens": ["public", "static", "double", "Sinc", "(", "double", "x", ")", "{", "return", "Math", ".", "sin", "(", "Math", ".", "PI", "*", "x", ")", "/", "(", "Math", ".", "PI", "*", "x", ")", ";", "}"], "docstring": "Sinc function.\n\n@param x Value.\n@return Sinc of the value.", "docstring_tokens": ["Sinc", "function", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/Tools.java#L68-L70", "partition": "train", "up_fun_num": 5, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.DoubleRange;", "import com.harium.keel.catalano.core.FloatRange;", "import com.harium.keel.catalano.core.IntRange;", "import com.harium.keel.catalano.math.random.Random;", "import java.util.HashSet;", "import java.util.Iterator;"], "function": ["public final class Tools\n", "    public static Random Random()\n", "    public static void SetupGenerator(int seed)\n", "    public static double Square(double x)\n", "    public static float Angle(float x, float y)\n", "    public static double Angle(double x, double y)\n", "    public static double Clamp(double x, DoubleRange range)\n", "    public static int Clamp(int x, IntRange range)\n", "    public static float Clamp(float x, FloatRange range)\n", "    public static double Clamp(double x, double min, double max)\n", "    public static int Clamp(int x, int min, int max)\n", "    public static float Clamp(float x, float min, float max)\n", "    public static int DigitalRoot(int n)\n", "    public static int GreatestCommonDivisor(int a, int b)\n", "    public static boolean isNumeric(String str)\n", "    public static boolean isPowerOf2(int x)\n", "    public static int Mod(int x, int m)\n", "    public static int NextPowerOf2(int x)\n", "    public static void Permutate(int[] x)\n", "    public static int PreviousPowerOf2(int x)\n", "    public static synchronized double RandomNextDouble()\n", "    public static int Scale(IntRange from, IntRange to, int x)\n", "    public static double Scale(DoubleRange from, DoubleRange to, int x)\n", "    public static double Scale(DoubleRange from, DoubleRange to, double x)\n", "    public static float Scale(FloatRange from, FloatRange to, int x)\n", "    public static double Scale(double fromMin, double fromMax, double toMin, double toMax, double x)\n", "    public static double Sum(double[] data)\n", "    public static int Sum(int[] data)\n", "    public static float Sum(float[] data)\n", "    public static double Log(double a, double b)\n", "    public static double TruncatedPower(double value, double degree)\n", "    public static int[] Unique(int[] values)\n", "    public static double Hypotenuse(double a, double b)\n", "    public static int Log2(int x)\n", "    public static int Pow2(int power)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2013\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math;\n\nimport com.harium.keel.catalano.core.DoubleRange;\nimport com.harium.keel.catalano.core.FloatRange;\nimport com.harium.keel.catalano.core.IntRange;\nimport com.harium.keel.catalano.math.random.Random;\n\nimport java.util.HashSet;\nimport java.util.Iterator;\n\n/**\n * Set of mathematical tools.\n *\n * @author Diego Catalano\n */\npublic final class Tools\n{\n\n    private static Random random = new Random();\n\n    public static Random Random()\n    {\n        return random;\n    }\n\n    public static void SetupGenerator(int seed)\n    {\n        random = new Random(seed);\n    }\n\n    /**\n     * Gets the square of the number.\n     *\n     * @param x Number.\n     * @return x*x;\n     */\n    public static double Square(double x)\n    {\n        return x * x;\n    }\n\n    /**\n     * Sinc function.\n     *\n     * @param x Value.\n     * @return Sinc of the value.\n     */\n\n    /**\n     * Don't let anyone instantiate this class.\n     */\n    private Tools()\n    {\n    }\n\n    /**\n     * Gets the angle formed by the vector [x,y].\n     *\n     * @param x X axis coordinate.\n     * @param y Y axis coordinate.\n     * @return Angle formed by the vector.\n     */\n    public static float Angle(float x, float y)\n    {\n        if (y >= 0)\n        {\n            if (x >= 0)\n                return (float) Math.atan(y / x);\n            return (float) (Math.PI - Math.atan(-y / x));\n        }\n        else\n        {\n            if (x >= 0)\n                return (float) (2 * Math.PI - Math.atan(-y / x));\n            return (float) (Math.PI + Math.atan(y / x));\n        }\n    }\n\n    /**\n     * Gets the angle formed by the vector [x,y].\n     *\n     * @param x X axis coordinate.\n     * @param y Y axis coordinate.\n     * @return Angle formed by the vector.\n     */\n    public static double Angle(double x, double y)\n    {\n        if (y >= 0)\n        {\n            if (x >= 0)\n                return Math.atan(y / x);\n            return (Math.PI - Math.atan(-y / x));\n        }\n        else\n        {\n            if (x >= 0)\n                return (2 * Math.PI - Math.atan(-y / x));\n            return (Math.PI + Math.atan(y / x));\n        }\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x     Value.\n     * @param range Range.\n     * @return Value.\n     */\n    public static double Clamp(double x, DoubleRange range)\n    {\n        return Clamp(x, range.getMin(), range.getMax());\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x     Value.\n     * @param range Range.\n     * @return Value.\n     */\n    public static int Clamp(int x, IntRange range)\n    {\n        return Clamp(x, range.getMin(), range.getMax());\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x     Value.\n     * @param range Range.\n     * @return Value.\n     */\n    public static float Clamp(float x, FloatRange range)\n    {\n        return Clamp(x, range.getMin(), range.getMax());\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x   Value.\n     * @param min Minimum value.\n     * @param max Maximum value.\n     * @return Value.\n     */\n    public static double Clamp(double x, double min, double max)\n    {\n        if (x < min)\n            return min;\n        if (x > max)\n            return max;\n        return x;\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x   Value.\n     * @param min Minimum value.\n     * @param max Maximum value.\n     * @return Value.\n     */\n    public static int Clamp(int x, int min, int max)\n    {\n        if (x < min)\n            return min;\n        if (x > max)\n            return max;\n        return x;\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x   Value.\n     * @param min Minimum value.\n     * @param max Maximum value.\n     * @return Value.\n     */\n    public static float Clamp(float x, float min, float max)\n    {\n        if (x < min)\n            return min;\n        if (x > max)\n            return max;\n        return x;\n    }\n\n    /**\n     * Return the digital root from a number.\n     * Example:\n     * Number: 24365\n     * Digital root: 2+4+3+6+5 = 20 = 2+0 = 2\n     *\n     * @param n Number.\n     * @return Digital root.\n     */\n    public static int DigitalRoot(int n)\n    {\n        return 1 + (n - 1) % 9;\n    }\n\n    /**\n     * Gets the greatest common divisor between two integers.\n     *\n     * @param a First integer.\n     * @param b Second integer.\n     * @return Greatest common divisor.\n     */\n    public static int GreatestCommonDivisor(int a, int b)\n    {\n\n        int x = a - b * (int) Math.floor(a / b);\n        while (x != 0)\n        {\n            a = b;\n            b = x;\n            x = a - b * (int) Math.floor(a / b);\n        }\n        return b;\n    }\n\n    public static boolean isNumeric(String str)\n    {\n        if (str.length() == 0)\n        {\n            return false;\n        }\n        char[] chars = str.toCharArray();\n        int sz = chars.length;\n        boolean hasExp = false;\n        boolean hasDecPoint = false;\n        boolean allowSigns = false;\n        boolean foundDigit = false;\n        // deal with any possible sign up front\n        int start = (chars[0] == '-') ? 1 : 0;\n        if (sz > start + 1)\n        {\n            if (chars[start] == '0' && chars[start + 1] == 'x')\n            {\n                int i = start + 2;\n                if (i == sz)\n                {\n                    return false; // str == \"0x\"\n                }\n                // checking hex (it can't be anything else)\n                for (; i < chars.length; i++)\n                {\n                    if ((chars[i] < '0' || chars[i] > '9')\n                            && (chars[i] < 'a' || chars[i] > 'f')\n                            && (chars[i] < 'A' || chars[i] > 'F'))\n                    {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        sz--; // don't want to loop to the last char, check it afterwords\n        // for type qualifiers\n        int i = start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] = \"1234E\")\n        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit))\n        {\n            if (chars[i] >= '0' && chars[i] <= '9')\n            {\n                foundDigit = true;\n                allowSigns = false;\n\n            }\n            else if (chars[i] == '.')\n            {\n                if (hasDecPoint || hasExp)\n                {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                hasDecPoint = true;\n            }\n            else if (chars[i] == 'e' || chars[i] == 'E')\n            {\n                // we've already taken care of hex.\n                if (hasExp)\n                {\n                    // two E's\n                    return false;\n                }\n                if (!foundDigit)\n                {\n                    return false;\n                }\n                hasExp = true;\n                allowSigns = true;\n            }\n            else if (chars[i] == '+' || chars[i] == '-')\n            {\n                if (!allowSigns)\n                {\n                    return false;\n                }\n                allowSigns = false;\n                foundDigit = false; // we need a digit after the E\n            }\n            else\n            {\n                return false;\n            }\n            i++;\n        }\n        if (i < chars.length)\n        {\n            if (chars[i] >= '0' && chars[i] <= '9')\n            {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] == 'e' || chars[i] == 'E')\n            {\n                // can't have an E at the last byte\n                return false;\n            }\n            if (chars[i] == '.')\n            {\n                if (hasDecPoint || hasExp)\n                {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                    && (chars[i] == 'd'\n                        || chars[i] == 'D'\n                        || chars[i] == 'f'\n                        || chars[i] == 'F'))\n            {\n                return foundDigit;\n            }\n            if (chars[i] == 'l'\n                    || chars[i] == 'L')\n            {\n                // not allowing L with an exponent\n                return foundDigit && !hasExp;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in 'E'\n        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n        return !allowSigns && foundDigit;\n    }\n\n    /**\n     * Checks if the specified integer is power of 2.\n     *\n     * @param x Integer number to check.\n     * @return True: if the specified number is power of 2, otherwise returns false.\n     */\n    public static boolean isPowerOf2(int x)\n    {\n        return (x > 0) ? ((x & (x - 1)) == 0) : false;\n    }\n\n    /**\n     * Gets the proper modulus operation.\n     *\n     * @param x Integer.\n     * @param m Modulo.\n     * @return Modulus.\n     */\n    public static int Mod(int x, int m)\n    {\n        if (m < 0) m = -m;\n        int r = x % m;\n        return r < 0 ? r + m : r;\n    }\n\n    /**\n     * Returns the next power of 2 after the input value x.\n     *\n     * @param x Input value x.\n     * @return Returns the next power of 2 after the input value x.\n     */\n    public static int NextPowerOf2(int x)\n    {\n        --x;\n        x |= x >> 1;\n        x |= x >> 2;\n        x |= x >> 4;\n        x |= x >> 8;\n        x |= x >> 16;\n        return ++x;\n    }\n\n    /**\n     * Generates a permutation of given array. This method is properly synchronized\n     * to allow correct use by more than one thread. However, if many threads\n     * need to generate pseudorandom numbers at a great rate, it may reduce\n     * contention for each thread to have its own pseudorandom-number generator.\n     */\n    public static void Permutate(int[] x)\n    {\n        random.permutate(x);\n    }\n\n    /**\n     * Returns the previous power of 2 after the input value x.\n     *\n     * @param x value x.\n     * @return Returns the previous power of 2 after the input value x.\n     */\n    public static int PreviousPowerOf2(int x)\n    {\n        return NextPowerOf2(x + 1) / 2;\n    }\n\n    /**\n     * Generate a random number in [0, 1). This method is properly synchronized\n     * to allow correct use by more than one thread. However, if many threads\n     * need to generate pseudorandom numbers at a great rate, it may reduce\n     * contention for each thread to have its own pseudorandom-number generator.\n     */\n    public static synchronized double RandomNextDouble()\n    {\n        return random.nextDouble();\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static int Scale(IntRange from, IntRange to, int x)\n    {\n        if (from.length() == 0) return 0;\n        return (int) ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static double Scale(DoubleRange from, DoubleRange to, int x)\n    {\n        if (from.length() == 0) return 0;\n        return ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static double Scale(DoubleRange from, DoubleRange to, double x)\n    {\n        if (from.length() == 0) return 0;\n        return ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static float Scale(FloatRange from, FloatRange to, int x)\n    {\n        if (from.length() == 0) return 0;\n        return (float) ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param fromMin Scale min from.\n     * @param fromMax Scale max from.\n     * @param toMin   Scale min to.\n     * @param toMax   Scale max to.\n     * @param x       Value.\n     * @return Result.\n     */\n    public static double Scale(double fromMin, double fromMax, double toMin, double toMax, double x)\n    {\n        if (fromMax - fromMin == 0) return 0;\n        return (toMax - toMin) * (x - fromMin) / (fromMax - fromMin) + toMin;\n    }\n\n    /**\n     * Sum of the elements.\n     *\n     * @param data Data.\n     * @return Sum(data).\n     */\n    public static double Sum(double[] data)\n    {\n        double sum = 0;\n        for (int i = 0; i < data.length; i++)\n        {\n            sum += data[i];\n        }\n        return sum;\n    }\n\n    /**\n     * Sum of the elements.\n     *\n     * @param data Data.\n     * @return Sum(data).\n     */\n    public static int Sum(int[] data)\n    {\n        int sum = 0;\n        for (int i = 0; i < data.length; i++)\n        {\n            sum += data[i];\n        }\n        return sum;\n    }\n\n    /**\n     * Sum of the elements.\n     *\n     * @param data Data.\n     * @return Sum(data).\n     */\n    public static float Sum(float[] data)\n    {\n        float sum = 0;\n        for (int i = 0; i < data.length; i++)\n        {\n            sum += data[i];\n        }\n        return sum;\n    }\n\n    /**\n     * Calculates the logarithm with base determined.\n     *\n     * @param a Value.\n     * @param b Base.\n     * @return Result.\n     */\n    public static double Log(double a, double b)\n    {\n        return Math.log(a) / Math.log(b);\n    }\n\n    /**\n     * Truncated power function.\n     *\n     * @param value  Value.\n     * @param degree Degree.\n     * @return Result.\n     */\n    public static double TruncatedPower(double value, double degree)\n    {\n        double x = Math.pow(value, degree);\n        return (x > 0) ? x : 0.0;\n    }\n\n    /**\n     * Get unique values form the array.\n     *\n     * @param values Array of values.\n     * @return Unique values.\n     */\n    public static int[] Unique(int[] values)\n    {\n        HashSet<Integer> lst = new HashSet<Integer>();\n        for (int i = 0; i < values.length; i++)\n        {\n            lst.add(values[i]);\n        }\n\n        int[] v = new int[lst.size()];\n        Iterator<Integer> it = lst.iterator();\n        for (int i = 0; i < v.length; i++)\n        {\n            v[i] = it.next();\n        }\n\n        return v;\n    }\n\n    /**\n     * Hypotenuse calculus without overflow/underflow.\n     *\n     * @param a First value.\n     * @param b Second value.\n     * @return The hypotenuse Sqrt(a^2 + b^2).\n     */\n    public static double Hypotenuse(double a, double b)\n    {\n        double r = 0.0;\n        double absA = Math.abs(a);\n        double absB = Math.abs(b);\n\n        if (absA > absB)\n        {\n            r = b / a;\n            r = absA * Math.sqrt(1 + r * r);\n        }\n        else if (b != 0)\n        {\n            r = a / b;\n            r = absB * Math.sqrt(1 + r * r);\n        }\n\n        return r;\n    }\n\n    public static int Log2(int x)\n    {\n        if (x <= 65536)\n        {\n            if (x <= 256)\n            {\n                if (x <= 16)\n                {\n                    if (x <= 4)\n                    {\n                        if (x <= 2)\n                        {\n                            if (x <= 1)\n                                return 0;\n                            return 1;\n                        }\n                        return 2;\n                    }\n                    if (x <= 8)\n                        return 3;\n                    return 4;\n                }\n                if (x <= 64)\n                {\n                    if (x <= 32)\n                        return 5;\n                    return 6;\n                }\n                if (x <= 128)\n                    return 7;\n                return 8;\n            }\n            if (x <= 4096)\n            {\n                if (x <= 1024)\n                {\n                    if (x <= 512)\n                        return 9;\n                    return 10;\n                }\n                if (x <= 2048)\n                    return 11;\n                return 12;\n            }\n            if (x <= 16384)\n            {\n                if (x <= 8192)\n                    return 13;\n                return 14;\n            }\n            if (x <= 32768)\n                return 15;\n            return 16;\n        }\n\n        if (x <= 16777216)\n        {\n            if (x <= 1048576)\n            {\n                if (x <= 262144)\n                {\n                    if (x <= 131072)\n                        return 17;\n                    return 18;\n                }\n                if (x <= 524288)\n                    return 19;\n                return 20;\n            }\n            if (x <= 4194304)\n            {\n                if (x <= 2097152)\n                    return 21;\n                return 22;\n            }\n            if (x <= 8388608)\n                return 23;\n            return 24;\n        }\n        if (x <= 268435456)\n        {\n            if (x <= 67108864)\n            {\n                if (x <= 33554432)\n                    return 25;\n                return 26;\n            }\n            if (x <= 134217728)\n                return 27;\n            return 28;\n        }\n        if (x <= 1073741824)\n        {\n            if (x <= 536870912)\n                return 29;\n            return 30;\n        }\n        return 31;\n    }\n\n    public static int Pow2(int power)\n    {\n        return ((power >= 0) && (power <= 30)) ? (1 << power) : 0;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/Tools.java", "func_name": "Tools.Mod", "original_string": "public static int Mod(int x, int m) {\r\n        if (m < 0) m = -m;\r\n        int r = x % m;\r\n        return r < 0 ? r + m : r;\r\n    }", "language": "java", "code": "public static int Mod(int x, int m) {\r\n        if (m < 0) m = -m;\r\n        int r = x % m;\r\n        return r < 0 ? r + m : r;\r\n    }", "code_tokens": ["public", "static", "int", "Mod", "(", "int", "x", ",", "int", "m", ")", "{", "if", "(", "m", "<", "0", ")", "m", "=", "-", "m", ";", "int", "r", "=", "x", "%", "m", ";", "return", "r", "<", "0", "?", "r", "+", "m", ":", "r", ";", "}"], "docstring": "Gets the proper modulus operation.\n\n@param x Integer.\n@param m Modulo.\n@return Modulus.", "docstring_tokens": ["Gets", "the", "proper", "modulus", "operation", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/Tools.java#L349-L353", "partition": "train", "up_fun_num": 18, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.DoubleRange;", "import com.harium.keel.catalano.core.FloatRange;", "import com.harium.keel.catalano.core.IntRange;", "import com.harium.keel.catalano.math.random.Random;", "import java.util.HashSet;", "import java.util.Iterator;"], "function": ["public final class Tools\n", "    public static Random Random()\n", "    public static void SetupGenerator(int seed)\n", "    public static double Square(double x)\n", "    public static double Sinc(double x)\n", "    public static float Angle(float x, float y)\n", "    public static double Angle(double x, double y)\n", "    public static double Clamp(double x, DoubleRange range)\n", "    public static int Clamp(int x, IntRange range)\n", "    public static float Clamp(float x, FloatRange range)\n", "    public static double Clamp(double x, double min, double max)\n", "    public static int Clamp(int x, int min, int max)\n", "    public static float Clamp(float x, float min, float max)\n", "    public static int DigitalRoot(int n)\n", "    public static int GreatestCommonDivisor(int a, int b)\n", "    public static boolean isNumeric(String str)\n", "    public static boolean isPowerOf2(int x)\n", "    public static int NextPowerOf2(int x)\n", "    public static void Permutate(int[] x)\n", "    public static int PreviousPowerOf2(int x)\n", "    public static synchronized double RandomNextDouble()\n", "    public static int Scale(IntRange from, IntRange to, int x)\n", "    public static double Scale(DoubleRange from, DoubleRange to, int x)\n", "    public static double Scale(DoubleRange from, DoubleRange to, double x)\n", "    public static float Scale(FloatRange from, FloatRange to, int x)\n", "    public static double Scale(double fromMin, double fromMax, double toMin, double toMax, double x)\n", "    public static double Sum(double[] data)\n", "    public static int Sum(int[] data)\n", "    public static float Sum(float[] data)\n", "    public static double Log(double a, double b)\n", "    public static double TruncatedPower(double value, double degree)\n", "    public static int[] Unique(int[] values)\n", "    public static double Hypotenuse(double a, double b)\n", "    public static int Log2(int x)\n", "    public static int Pow2(int power)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2013\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math;\n\nimport com.harium.keel.catalano.core.DoubleRange;\nimport com.harium.keel.catalano.core.FloatRange;\nimport com.harium.keel.catalano.core.IntRange;\nimport com.harium.keel.catalano.math.random.Random;\n\nimport java.util.HashSet;\nimport java.util.Iterator;\n\n/**\n * Set of mathematical tools.\n *\n * @author Diego Catalano\n */\npublic final class Tools\n{\n\n    private static Random random = new Random();\n\n    public static Random Random()\n    {\n        return random;\n    }\n\n    public static void SetupGenerator(int seed)\n    {\n        random = new Random(seed);\n    }\n\n    /**\n     * Gets the square of the number.\n     *\n     * @param x Number.\n     * @return x*x;\n     */\n    public static double Square(double x)\n    {\n        return x * x;\n    }\n\n    /**\n     * Sinc function.\n     *\n     * @param x Value.\n     * @return Sinc of the value.\n     */\n    public static double Sinc(double x)\n    {\n        return Math.sin(Math.PI * x) / (Math.PI * x);\n    }\n\n    /**\n     * Don't let anyone instantiate this class.\n     */\n    private Tools()\n    {\n    }\n\n    /**\n     * Gets the angle formed by the vector [x,y].\n     *\n     * @param x X axis coordinate.\n     * @param y Y axis coordinate.\n     * @return Angle formed by the vector.\n     */\n    public static float Angle(float x, float y)\n    {\n        if (y >= 0)\n        {\n            if (x >= 0)\n                return (float) Math.atan(y / x);\n            return (float) (Math.PI - Math.atan(-y / x));\n        }\n        else\n        {\n            if (x >= 0)\n                return (float) (2 * Math.PI - Math.atan(-y / x));\n            return (float) (Math.PI + Math.atan(y / x));\n        }\n    }\n\n    /**\n     * Gets the angle formed by the vector [x,y].\n     *\n     * @param x X axis coordinate.\n     * @param y Y axis coordinate.\n     * @return Angle formed by the vector.\n     */\n    public static double Angle(double x, double y)\n    {\n        if (y >= 0)\n        {\n            if (x >= 0)\n                return Math.atan(y / x);\n            return (Math.PI - Math.atan(-y / x));\n        }\n        else\n        {\n            if (x >= 0)\n                return (2 * Math.PI - Math.atan(-y / x));\n            return (Math.PI + Math.atan(y / x));\n        }\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x     Value.\n     * @param range Range.\n     * @return Value.\n     */\n    public static double Clamp(double x, DoubleRange range)\n    {\n        return Clamp(x, range.getMin(), range.getMax());\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x     Value.\n     * @param range Range.\n     * @return Value.\n     */\n    public static int Clamp(int x, IntRange range)\n    {\n        return Clamp(x, range.getMin(), range.getMax());\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x     Value.\n     * @param range Range.\n     * @return Value.\n     */\n    public static float Clamp(float x, FloatRange range)\n    {\n        return Clamp(x, range.getMin(), range.getMax());\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x   Value.\n     * @param min Minimum value.\n     * @param max Maximum value.\n     * @return Value.\n     */\n    public static double Clamp(double x, double min, double max)\n    {\n        if (x < min)\n            return min;\n        if (x > max)\n            return max;\n        return x;\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x   Value.\n     * @param min Minimum value.\n     * @param max Maximum value.\n     * @return Value.\n     */\n    public static int Clamp(int x, int min, int max)\n    {\n        if (x < min)\n            return min;\n        if (x > max)\n            return max;\n        return x;\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x   Value.\n     * @param min Minimum value.\n     * @param max Maximum value.\n     * @return Value.\n     */\n    public static float Clamp(float x, float min, float max)\n    {\n        if (x < min)\n            return min;\n        if (x > max)\n            return max;\n        return x;\n    }\n\n    /**\n     * Return the digital root from a number.\n     * Example:\n     * Number: 24365\n     * Digital root: 2+4+3+6+5 = 20 = 2+0 = 2\n     *\n     * @param n Number.\n     * @return Digital root.\n     */\n    public static int DigitalRoot(int n)\n    {\n        return 1 + (n - 1) % 9;\n    }\n\n    /**\n     * Gets the greatest common divisor between two integers.\n     *\n     * @param a First integer.\n     * @param b Second integer.\n     * @return Greatest common divisor.\n     */\n    public static int GreatestCommonDivisor(int a, int b)\n    {\n\n        int x = a - b * (int) Math.floor(a / b);\n        while (x != 0)\n        {\n            a = b;\n            b = x;\n            x = a - b * (int) Math.floor(a / b);\n        }\n        return b;\n    }\n\n    public static boolean isNumeric(String str)\n    {\n        if (str.length() == 0)\n        {\n            return false;\n        }\n        char[] chars = str.toCharArray();\n        int sz = chars.length;\n        boolean hasExp = false;\n        boolean hasDecPoint = false;\n        boolean allowSigns = false;\n        boolean foundDigit = false;\n        // deal with any possible sign up front\n        int start = (chars[0] == '-') ? 1 : 0;\n        if (sz > start + 1)\n        {\n            if (chars[start] == '0' && chars[start + 1] == 'x')\n            {\n                int i = start + 2;\n                if (i == sz)\n                {\n                    return false; // str == \"0x\"\n                }\n                // checking hex (it can't be anything else)\n                for (; i < chars.length; i++)\n                {\n                    if ((chars[i] < '0' || chars[i] > '9')\n                            && (chars[i] < 'a' || chars[i] > 'f')\n                            && (chars[i] < 'A' || chars[i] > 'F'))\n                    {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        sz--; // don't want to loop to the last char, check it afterwords\n        // for type qualifiers\n        int i = start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] = \"1234E\")\n        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit))\n        {\n            if (chars[i] >= '0' && chars[i] <= '9')\n            {\n                foundDigit = true;\n                allowSigns = false;\n\n            }\n            else if (chars[i] == '.')\n            {\n                if (hasDecPoint || hasExp)\n                {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                hasDecPoint = true;\n            }\n            else if (chars[i] == 'e' || chars[i] == 'E')\n            {\n                // we've already taken care of hex.\n                if (hasExp)\n                {\n                    // two E's\n                    return false;\n                }\n                if (!foundDigit)\n                {\n                    return false;\n                }\n                hasExp = true;\n                allowSigns = true;\n            }\n            else if (chars[i] == '+' || chars[i] == '-')\n            {\n                if (!allowSigns)\n                {\n                    return false;\n                }\n                allowSigns = false;\n                foundDigit = false; // we need a digit after the E\n            }\n            else\n            {\n                return false;\n            }\n            i++;\n        }\n        if (i < chars.length)\n        {\n            if (chars[i] >= '0' && chars[i] <= '9')\n            {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] == 'e' || chars[i] == 'E')\n            {\n                // can't have an E at the last byte\n                return false;\n            }\n            if (chars[i] == '.')\n            {\n                if (hasDecPoint || hasExp)\n                {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                    && (chars[i] == 'd'\n                        || chars[i] == 'D'\n                        || chars[i] == 'f'\n                        || chars[i] == 'F'))\n            {\n                return foundDigit;\n            }\n            if (chars[i] == 'l'\n                    || chars[i] == 'L')\n            {\n                // not allowing L with an exponent\n                return foundDigit && !hasExp;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in 'E'\n        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n        return !allowSigns && foundDigit;\n    }\n\n    /**\n     * Checks if the specified integer is power of 2.\n     *\n     * @param x Integer number to check.\n     * @return True: if the specified number is power of 2, otherwise returns false.\n     */\n    public static boolean isPowerOf2(int x)\n    {\n        return (x > 0) ? ((x & (x - 1)) == 0) : false;\n    }\n\n    /**\n     * Gets the proper modulus operation.\n     *\n     * @param x Integer.\n     * @param m Modulo.\n     * @return Modulus.\n     */\n\n    /**\n     * Returns the next power of 2 after the input value x.\n     *\n     * @param x Input value x.\n     * @return Returns the next power of 2 after the input value x.\n     */\n    public static int NextPowerOf2(int x)\n    {\n        --x;\n        x |= x >> 1;\n        x |= x >> 2;\n        x |= x >> 4;\n        x |= x >> 8;\n        x |= x >> 16;\n        return ++x;\n    }\n\n    /**\n     * Generates a permutation of given array. This method is properly synchronized\n     * to allow correct use by more than one thread. However, if many threads\n     * need to generate pseudorandom numbers at a great rate, it may reduce\n     * contention for each thread to have its own pseudorandom-number generator.\n     */\n    public static void Permutate(int[] x)\n    {\n        random.permutate(x);\n    }\n\n    /**\n     * Returns the previous power of 2 after the input value x.\n     *\n     * @param x value x.\n     * @return Returns the previous power of 2 after the input value x.\n     */\n    public static int PreviousPowerOf2(int x)\n    {\n        return NextPowerOf2(x + 1) / 2;\n    }\n\n    /**\n     * Generate a random number in [0, 1). This method is properly synchronized\n     * to allow correct use by more than one thread. However, if many threads\n     * need to generate pseudorandom numbers at a great rate, it may reduce\n     * contention for each thread to have its own pseudorandom-number generator.\n     */\n    public static synchronized double RandomNextDouble()\n    {\n        return random.nextDouble();\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static int Scale(IntRange from, IntRange to, int x)\n    {\n        if (from.length() == 0) return 0;\n        return (int) ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static double Scale(DoubleRange from, DoubleRange to, int x)\n    {\n        if (from.length() == 0) return 0;\n        return ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static double Scale(DoubleRange from, DoubleRange to, double x)\n    {\n        if (from.length() == 0) return 0;\n        return ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static float Scale(FloatRange from, FloatRange to, int x)\n    {\n        if (from.length() == 0) return 0;\n        return (float) ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param fromMin Scale min from.\n     * @param fromMax Scale max from.\n     * @param toMin   Scale min to.\n     * @param toMax   Scale max to.\n     * @param x       Value.\n     * @return Result.\n     */\n    public static double Scale(double fromMin, double fromMax, double toMin, double toMax, double x)\n    {\n        if (fromMax - fromMin == 0) return 0;\n        return (toMax - toMin) * (x - fromMin) / (fromMax - fromMin) + toMin;\n    }\n\n    /**\n     * Sum of the elements.\n     *\n     * @param data Data.\n     * @return Sum(data).\n     */\n    public static double Sum(double[] data)\n    {\n        double sum = 0;\n        for (int i = 0; i < data.length; i++)\n        {\n            sum += data[i];\n        }\n        return sum;\n    }\n\n    /**\n     * Sum of the elements.\n     *\n     * @param data Data.\n     * @return Sum(data).\n     */\n    public static int Sum(int[] data)\n    {\n        int sum = 0;\n        for (int i = 0; i < data.length; i++)\n        {\n            sum += data[i];\n        }\n        return sum;\n    }\n\n    /**\n     * Sum of the elements.\n     *\n     * @param data Data.\n     * @return Sum(data).\n     */\n    public static float Sum(float[] data)\n    {\n        float sum = 0;\n        for (int i = 0; i < data.length; i++)\n        {\n            sum += data[i];\n        }\n        return sum;\n    }\n\n    /**\n     * Calculates the logarithm with base determined.\n     *\n     * @param a Value.\n     * @param b Base.\n     * @return Result.\n     */\n    public static double Log(double a, double b)\n    {\n        return Math.log(a) / Math.log(b);\n    }\n\n    /**\n     * Truncated power function.\n     *\n     * @param value  Value.\n     * @param degree Degree.\n     * @return Result.\n     */\n    public static double TruncatedPower(double value, double degree)\n    {\n        double x = Math.pow(value, degree);\n        return (x > 0) ? x : 0.0;\n    }\n\n    /**\n     * Get unique values form the array.\n     *\n     * @param values Array of values.\n     * @return Unique values.\n     */\n    public static int[] Unique(int[] values)\n    {\n        HashSet<Integer> lst = new HashSet<Integer>();\n        for (int i = 0; i < values.length; i++)\n        {\n            lst.add(values[i]);\n        }\n\n        int[] v = new int[lst.size()];\n        Iterator<Integer> it = lst.iterator();\n        for (int i = 0; i < v.length; i++)\n        {\n            v[i] = it.next();\n        }\n\n        return v;\n    }\n\n    /**\n     * Hypotenuse calculus without overflow/underflow.\n     *\n     * @param a First value.\n     * @param b Second value.\n     * @return The hypotenuse Sqrt(a^2 + b^2).\n     */\n    public static double Hypotenuse(double a, double b)\n    {\n        double r = 0.0;\n        double absA = Math.abs(a);\n        double absB = Math.abs(b);\n\n        if (absA > absB)\n        {\n            r = b / a;\n            r = absA * Math.sqrt(1 + r * r);\n        }\n        else if (b != 0)\n        {\n            r = a / b;\n            r = absB * Math.sqrt(1 + r * r);\n        }\n\n        return r;\n    }\n\n    public static int Log2(int x)\n    {\n        if (x <= 65536)\n        {\n            if (x <= 256)\n            {\n                if (x <= 16)\n                {\n                    if (x <= 4)\n                    {\n                        if (x <= 2)\n                        {\n                            if (x <= 1)\n                                return 0;\n                            return 1;\n                        }\n                        return 2;\n                    }\n                    if (x <= 8)\n                        return 3;\n                    return 4;\n                }\n                if (x <= 64)\n                {\n                    if (x <= 32)\n                        return 5;\n                    return 6;\n                }\n                if (x <= 128)\n                    return 7;\n                return 8;\n            }\n            if (x <= 4096)\n            {\n                if (x <= 1024)\n                {\n                    if (x <= 512)\n                        return 9;\n                    return 10;\n                }\n                if (x <= 2048)\n                    return 11;\n                return 12;\n            }\n            if (x <= 16384)\n            {\n                if (x <= 8192)\n                    return 13;\n                return 14;\n            }\n            if (x <= 32768)\n                return 15;\n            return 16;\n        }\n\n        if (x <= 16777216)\n        {\n            if (x <= 1048576)\n            {\n                if (x <= 262144)\n                {\n                    if (x <= 131072)\n                        return 17;\n                    return 18;\n                }\n                if (x <= 524288)\n                    return 19;\n                return 20;\n            }\n            if (x <= 4194304)\n            {\n                if (x <= 2097152)\n                    return 21;\n                return 22;\n            }\n            if (x <= 8388608)\n                return 23;\n            return 24;\n        }\n        if (x <= 268435456)\n        {\n            if (x <= 67108864)\n            {\n                if (x <= 33554432)\n                    return 25;\n                return 26;\n            }\n            if (x <= 134217728)\n                return 27;\n            return 28;\n        }\n        if (x <= 1073741824)\n        {\n            if (x <= 536870912)\n                return 29;\n            return 30;\n        }\n        return 31;\n    }\n\n    public static int Pow2(int power)\n    {\n        return ((power >= 0) && (power <= 30)) ? (1 << power) : 0;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/Tools.java", "func_name": "Tools.NextPowerOf2", "original_string": "public static int NextPowerOf2(int x) {\r\n        --x;\r\n        x |= x >> 1;\r\n        x |= x >> 2;\r\n        x |= x >> 4;\r\n        x |= x >> 8;\r\n        x |= x >> 16;\r\n        return ++x;\r\n    }", "language": "java", "code": "public static int NextPowerOf2(int x) {\r\n        --x;\r\n        x |= x >> 1;\r\n        x |= x >> 2;\r\n        x |= x >> 4;\r\n        x |= x >> 8;\r\n        x |= x >> 16;\r\n        return ++x;\r\n    }", "code_tokens": ["public", "static", "int", "NextPowerOf2", "(", "int", "x", ")", "{", "--", "x", ";", "x", "|=", "x", ">>", "1", ";", "x", "|=", "x", ">>", "2", ";", "x", "|=", "x", ">>", "4", ";", "x", "|=", "x", ">>", "8", ";", "x", "|=", "x", ">>", "16", ";", "return", "++", "x", ";", "}"], "docstring": "Returns the next power of 2 after the input value x.\n\n@param x Input value x.\n@return Returns the next power of 2 after the input value x.", "docstring_tokens": ["Returns", "the", "next", "power", "of", "2", "after", "the", "input", "value", "x", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/Tools.java#L361-L369", "partition": "train", "up_fun_num": 19, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.DoubleRange;", "import com.harium.keel.catalano.core.FloatRange;", "import com.harium.keel.catalano.core.IntRange;", "import com.harium.keel.catalano.math.random.Random;", "import java.util.HashSet;", "import java.util.Iterator;"], "function": ["public final class Tools\n", "    public static Random Random()\n", "    public static void SetupGenerator(int seed)\n", "    public static double Square(double x)\n", "    public static double Sinc(double x)\n", "    public static float Angle(float x, float y)\n", "    public static double Angle(double x, double y)\n", "    public static double Clamp(double x, DoubleRange range)\n", "    public static int Clamp(int x, IntRange range)\n", "    public static float Clamp(float x, FloatRange range)\n", "    public static double Clamp(double x, double min, double max)\n", "    public static int Clamp(int x, int min, int max)\n", "    public static float Clamp(float x, float min, float max)\n", "    public static int DigitalRoot(int n)\n", "    public static int GreatestCommonDivisor(int a, int b)\n", "    public static boolean isNumeric(String str)\n", "    public static boolean isPowerOf2(int x)\n", "    public static int Mod(int x, int m)\n", "    public static void Permutate(int[] x)\n", "    public static int PreviousPowerOf2(int x)\n", "    public static synchronized double RandomNextDouble()\n", "    public static int Scale(IntRange from, IntRange to, int x)\n", "    public static double Scale(DoubleRange from, DoubleRange to, int x)\n", "    public static double Scale(DoubleRange from, DoubleRange to, double x)\n", "    public static float Scale(FloatRange from, FloatRange to, int x)\n", "    public static double Scale(double fromMin, double fromMax, double toMin, double toMax, double x)\n", "    public static double Sum(double[] data)\n", "    public static int Sum(int[] data)\n", "    public static float Sum(float[] data)\n", "    public static double Log(double a, double b)\n", "    public static double TruncatedPower(double value, double degree)\n", "    public static int[] Unique(int[] values)\n", "    public static double Hypotenuse(double a, double b)\n", "    public static int Log2(int x)\n", "    public static int Pow2(int power)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2013\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math;\n\nimport com.harium.keel.catalano.core.DoubleRange;\nimport com.harium.keel.catalano.core.FloatRange;\nimport com.harium.keel.catalano.core.IntRange;\nimport com.harium.keel.catalano.math.random.Random;\n\nimport java.util.HashSet;\nimport java.util.Iterator;\n\n/**\n * Set of mathematical tools.\n *\n * @author Diego Catalano\n */\npublic final class Tools\n{\n\n    private static Random random = new Random();\n\n    public static Random Random()\n    {\n        return random;\n    }\n\n    public static void SetupGenerator(int seed)\n    {\n        random = new Random(seed);\n    }\n\n    /**\n     * Gets the square of the number.\n     *\n     * @param x Number.\n     * @return x*x;\n     */\n    public static double Square(double x)\n    {\n        return x * x;\n    }\n\n    /**\n     * Sinc function.\n     *\n     * @param x Value.\n     * @return Sinc of the value.\n     */\n    public static double Sinc(double x)\n    {\n        return Math.sin(Math.PI * x) / (Math.PI * x);\n    }\n\n    /**\n     * Don't let anyone instantiate this class.\n     */\n    private Tools()\n    {\n    }\n\n    /**\n     * Gets the angle formed by the vector [x,y].\n     *\n     * @param x X axis coordinate.\n     * @param y Y axis coordinate.\n     * @return Angle formed by the vector.\n     */\n    public static float Angle(float x, float y)\n    {\n        if (y >= 0)\n        {\n            if (x >= 0)\n                return (float) Math.atan(y / x);\n            return (float) (Math.PI - Math.atan(-y / x));\n        }\n        else\n        {\n            if (x >= 0)\n                return (float) (2 * Math.PI - Math.atan(-y / x));\n            return (float) (Math.PI + Math.atan(y / x));\n        }\n    }\n\n    /**\n     * Gets the angle formed by the vector [x,y].\n     *\n     * @param x X axis coordinate.\n     * @param y Y axis coordinate.\n     * @return Angle formed by the vector.\n     */\n    public static double Angle(double x, double y)\n    {\n        if (y >= 0)\n        {\n            if (x >= 0)\n                return Math.atan(y / x);\n            return (Math.PI - Math.atan(-y / x));\n        }\n        else\n        {\n            if (x >= 0)\n                return (2 * Math.PI - Math.atan(-y / x));\n            return (Math.PI + Math.atan(y / x));\n        }\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x     Value.\n     * @param range Range.\n     * @return Value.\n     */\n    public static double Clamp(double x, DoubleRange range)\n    {\n        return Clamp(x, range.getMin(), range.getMax());\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x     Value.\n     * @param range Range.\n     * @return Value.\n     */\n    public static int Clamp(int x, IntRange range)\n    {\n        return Clamp(x, range.getMin(), range.getMax());\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x     Value.\n     * @param range Range.\n     * @return Value.\n     */\n    public static float Clamp(float x, FloatRange range)\n    {\n        return Clamp(x, range.getMin(), range.getMax());\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x   Value.\n     * @param min Minimum value.\n     * @param max Maximum value.\n     * @return Value.\n     */\n    public static double Clamp(double x, double min, double max)\n    {\n        if (x < min)\n            return min;\n        if (x > max)\n            return max;\n        return x;\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x   Value.\n     * @param min Minimum value.\n     * @param max Maximum value.\n     * @return Value.\n     */\n    public static int Clamp(int x, int min, int max)\n    {\n        if (x < min)\n            return min;\n        if (x > max)\n            return max;\n        return x;\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x   Value.\n     * @param min Minimum value.\n     * @param max Maximum value.\n     * @return Value.\n     */\n    public static float Clamp(float x, float min, float max)\n    {\n        if (x < min)\n            return min;\n        if (x > max)\n            return max;\n        return x;\n    }\n\n    /**\n     * Return the digital root from a number.\n     * Example:\n     * Number: 24365\n     * Digital root: 2+4+3+6+5 = 20 = 2+0 = 2\n     *\n     * @param n Number.\n     * @return Digital root.\n     */\n    public static int DigitalRoot(int n)\n    {\n        return 1 + (n - 1) % 9;\n    }\n\n    /**\n     * Gets the greatest common divisor between two integers.\n     *\n     * @param a First integer.\n     * @param b Second integer.\n     * @return Greatest common divisor.\n     */\n    public static int GreatestCommonDivisor(int a, int b)\n    {\n\n        int x = a - b * (int) Math.floor(a / b);\n        while (x != 0)\n        {\n            a = b;\n            b = x;\n            x = a - b * (int) Math.floor(a / b);\n        }\n        return b;\n    }\n\n    public static boolean isNumeric(String str)\n    {\n        if (str.length() == 0)\n        {\n            return false;\n        }\n        char[] chars = str.toCharArray();\n        int sz = chars.length;\n        boolean hasExp = false;\n        boolean hasDecPoint = false;\n        boolean allowSigns = false;\n        boolean foundDigit = false;\n        // deal with any possible sign up front\n        int start = (chars[0] == '-') ? 1 : 0;\n        if (sz > start + 1)\n        {\n            if (chars[start] == '0' && chars[start + 1] == 'x')\n            {\n                int i = start + 2;\n                if (i == sz)\n                {\n                    return false; // str == \"0x\"\n                }\n                // checking hex (it can't be anything else)\n                for (; i < chars.length; i++)\n                {\n                    if ((chars[i] < '0' || chars[i] > '9')\n                            && (chars[i] < 'a' || chars[i] > 'f')\n                            && (chars[i] < 'A' || chars[i] > 'F'))\n                    {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        sz--; // don't want to loop to the last char, check it afterwords\n        // for type qualifiers\n        int i = start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] = \"1234E\")\n        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit))\n        {\n            if (chars[i] >= '0' && chars[i] <= '9')\n            {\n                foundDigit = true;\n                allowSigns = false;\n\n            }\n            else if (chars[i] == '.')\n            {\n                if (hasDecPoint || hasExp)\n                {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                hasDecPoint = true;\n            }\n            else if (chars[i] == 'e' || chars[i] == 'E')\n            {\n                // we've already taken care of hex.\n                if (hasExp)\n                {\n                    // two E's\n                    return false;\n                }\n                if (!foundDigit)\n                {\n                    return false;\n                }\n                hasExp = true;\n                allowSigns = true;\n            }\n            else if (chars[i] == '+' || chars[i] == '-')\n            {\n                if (!allowSigns)\n                {\n                    return false;\n                }\n                allowSigns = false;\n                foundDigit = false; // we need a digit after the E\n            }\n            else\n            {\n                return false;\n            }\n            i++;\n        }\n        if (i < chars.length)\n        {\n            if (chars[i] >= '0' && chars[i] <= '9')\n            {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] == 'e' || chars[i] == 'E')\n            {\n                // can't have an E at the last byte\n                return false;\n            }\n            if (chars[i] == '.')\n            {\n                if (hasDecPoint || hasExp)\n                {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                    && (chars[i] == 'd'\n                        || chars[i] == 'D'\n                        || chars[i] == 'f'\n                        || chars[i] == 'F'))\n            {\n                return foundDigit;\n            }\n            if (chars[i] == 'l'\n                    || chars[i] == 'L')\n            {\n                // not allowing L with an exponent\n                return foundDigit && !hasExp;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in 'E'\n        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n        return !allowSigns && foundDigit;\n    }\n\n    /**\n     * Checks if the specified integer is power of 2.\n     *\n     * @param x Integer number to check.\n     * @return True: if the specified number is power of 2, otherwise returns false.\n     */\n    public static boolean isPowerOf2(int x)\n    {\n        return (x > 0) ? ((x & (x - 1)) == 0) : false;\n    }\n\n    /**\n     * Gets the proper modulus operation.\n     *\n     * @param x Integer.\n     * @param m Modulo.\n     * @return Modulus.\n     */\n    public static int Mod(int x, int m)\n    {\n        if (m < 0) m = -m;\n        int r = x % m;\n        return r < 0 ? r + m : r;\n    }\n\n    /**\n     * Returns the next power of 2 after the input value x.\n     *\n     * @param x Input value x.\n     * @return Returns the next power of 2 after the input value x.\n     */\n\n    /**\n     * Generates a permutation of given array. This method is properly synchronized\n     * to allow correct use by more than one thread. However, if many threads\n     * need to generate pseudorandom numbers at a great rate, it may reduce\n     * contention for each thread to have its own pseudorandom-number generator.\n     */\n    public static void Permutate(int[] x)\n    {\n        random.permutate(x);\n    }\n\n    /**\n     * Returns the previous power of 2 after the input value x.\n     *\n     * @param x value x.\n     * @return Returns the previous power of 2 after the input value x.\n     */\n    public static int PreviousPowerOf2(int x)\n    {\n        return NextPowerOf2(x + 1) / 2;\n    }\n\n    /**\n     * Generate a random number in [0, 1). This method is properly synchronized\n     * to allow correct use by more than one thread. However, if many threads\n     * need to generate pseudorandom numbers at a great rate, it may reduce\n     * contention for each thread to have its own pseudorandom-number generator.\n     */\n    public static synchronized double RandomNextDouble()\n    {\n        return random.nextDouble();\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static int Scale(IntRange from, IntRange to, int x)\n    {\n        if (from.length() == 0) return 0;\n        return (int) ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static double Scale(DoubleRange from, DoubleRange to, int x)\n    {\n        if (from.length() == 0) return 0;\n        return ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static double Scale(DoubleRange from, DoubleRange to, double x)\n    {\n        if (from.length() == 0) return 0;\n        return ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static float Scale(FloatRange from, FloatRange to, int x)\n    {\n        if (from.length() == 0) return 0;\n        return (float) ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param fromMin Scale min from.\n     * @param fromMax Scale max from.\n     * @param toMin   Scale min to.\n     * @param toMax   Scale max to.\n     * @param x       Value.\n     * @return Result.\n     */\n    public static double Scale(double fromMin, double fromMax, double toMin, double toMax, double x)\n    {\n        if (fromMax - fromMin == 0) return 0;\n        return (toMax - toMin) * (x - fromMin) / (fromMax - fromMin) + toMin;\n    }\n\n    /**\n     * Sum of the elements.\n     *\n     * @param data Data.\n     * @return Sum(data).\n     */\n    public static double Sum(double[] data)\n    {\n        double sum = 0;\n        for (int i = 0; i < data.length; i++)\n        {\n            sum += data[i];\n        }\n        return sum;\n    }\n\n    /**\n     * Sum of the elements.\n     *\n     * @param data Data.\n     * @return Sum(data).\n     */\n    public static int Sum(int[] data)\n    {\n        int sum = 0;\n        for (int i = 0; i < data.length; i++)\n        {\n            sum += data[i];\n        }\n        return sum;\n    }\n\n    /**\n     * Sum of the elements.\n     *\n     * @param data Data.\n     * @return Sum(data).\n     */\n    public static float Sum(float[] data)\n    {\n        float sum = 0;\n        for (int i = 0; i < data.length; i++)\n        {\n            sum += data[i];\n        }\n        return sum;\n    }\n\n    /**\n     * Calculates the logarithm with base determined.\n     *\n     * @param a Value.\n     * @param b Base.\n     * @return Result.\n     */\n    public static double Log(double a, double b)\n    {\n        return Math.log(a) / Math.log(b);\n    }\n\n    /**\n     * Truncated power function.\n     *\n     * @param value  Value.\n     * @param degree Degree.\n     * @return Result.\n     */\n    public static double TruncatedPower(double value, double degree)\n    {\n        double x = Math.pow(value, degree);\n        return (x > 0) ? x : 0.0;\n    }\n\n    /**\n     * Get unique values form the array.\n     *\n     * @param values Array of values.\n     * @return Unique values.\n     */\n    public static int[] Unique(int[] values)\n    {\n        HashSet<Integer> lst = new HashSet<Integer>();\n        for (int i = 0; i < values.length; i++)\n        {\n            lst.add(values[i]);\n        }\n\n        int[] v = new int[lst.size()];\n        Iterator<Integer> it = lst.iterator();\n        for (int i = 0; i < v.length; i++)\n        {\n            v[i] = it.next();\n        }\n\n        return v;\n    }\n\n    /**\n     * Hypotenuse calculus without overflow/underflow.\n     *\n     * @param a First value.\n     * @param b Second value.\n     * @return The hypotenuse Sqrt(a^2 + b^2).\n     */\n    public static double Hypotenuse(double a, double b)\n    {\n        double r = 0.0;\n        double absA = Math.abs(a);\n        double absB = Math.abs(b);\n\n        if (absA > absB)\n        {\n            r = b / a;\n            r = absA * Math.sqrt(1 + r * r);\n        }\n        else if (b != 0)\n        {\n            r = a / b;\n            r = absB * Math.sqrt(1 + r * r);\n        }\n\n        return r;\n    }\n\n    public static int Log2(int x)\n    {\n        if (x <= 65536)\n        {\n            if (x <= 256)\n            {\n                if (x <= 16)\n                {\n                    if (x <= 4)\n                    {\n                        if (x <= 2)\n                        {\n                            if (x <= 1)\n                                return 0;\n                            return 1;\n                        }\n                        return 2;\n                    }\n                    if (x <= 8)\n                        return 3;\n                    return 4;\n                }\n                if (x <= 64)\n                {\n                    if (x <= 32)\n                        return 5;\n                    return 6;\n                }\n                if (x <= 128)\n                    return 7;\n                return 8;\n            }\n            if (x <= 4096)\n            {\n                if (x <= 1024)\n                {\n                    if (x <= 512)\n                        return 9;\n                    return 10;\n                }\n                if (x <= 2048)\n                    return 11;\n                return 12;\n            }\n            if (x <= 16384)\n            {\n                if (x <= 8192)\n                    return 13;\n                return 14;\n            }\n            if (x <= 32768)\n                return 15;\n            return 16;\n        }\n\n        if (x <= 16777216)\n        {\n            if (x <= 1048576)\n            {\n                if (x <= 262144)\n                {\n                    if (x <= 131072)\n                        return 17;\n                    return 18;\n                }\n                if (x <= 524288)\n                    return 19;\n                return 20;\n            }\n            if (x <= 4194304)\n            {\n                if (x <= 2097152)\n                    return 21;\n                return 22;\n            }\n            if (x <= 8388608)\n                return 23;\n            return 24;\n        }\n        if (x <= 268435456)\n        {\n            if (x <= 67108864)\n            {\n                if (x <= 33554432)\n                    return 25;\n                return 26;\n            }\n            if (x <= 134217728)\n                return 27;\n            return 28;\n        }\n        if (x <= 1073741824)\n        {\n            if (x <= 536870912)\n                return 29;\n            return 30;\n        }\n        return 31;\n    }\n\n    public static int Pow2(int power)\n    {\n        return ((power >= 0) && (power <= 30)) ? (1 << power) : 0;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/Tools.java", "func_name": "Tools.Sum", "original_string": "public static float Sum(float[] data) {\r\n        float sum = 0;\r\n        for (int i = 0; i < data.length; i++) {\r\n            sum += data[i];\r\n        }\r\n        return sum;\r\n    }", "language": "java", "code": "public static float Sum(float[] data) {\r\n        float sum = 0;\r\n        for (int i = 0; i < data.length; i++) {\r\n            sum += data[i];\r\n        }\r\n        return sum;\r\n    }", "code_tokens": ["public", "static", "float", "Sum", "(", "float", "[", "]", "data", ")", "{", "float", "sum", "=", "0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "data", ".", "length", ";", "i", "++", ")", "{", "sum", "+=", "data", "[", "i", "]", ";", "}", "return", "sum", ";", "}"], "docstring": "Sum of the elements.\n\n@param data Data.\n@return Sum(data).", "docstring_tokens": ["Sum", "of", "the", "elements", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/Tools.java#L502-L508", "partition": "train", "up_fun_num": 30, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.DoubleRange;", "import com.harium.keel.catalano.core.FloatRange;", "import com.harium.keel.catalano.core.IntRange;", "import com.harium.keel.catalano.math.random.Random;", "import java.util.HashSet;", "import java.util.Iterator;"], "function": ["public final class Tools\n", "    public static Random Random()\n", "    public static void SetupGenerator(int seed)\n", "    public static double Square(double x)\n", "    public static double Sinc(double x)\n", "    public static float Angle(float x, float y)\n", "    public static double Angle(double x, double y)\n", "    public static double Clamp(double x, DoubleRange range)\n", "    public static int Clamp(int x, IntRange range)\n", "    public static float Clamp(float x, FloatRange range)\n", "    public static double Clamp(double x, double min, double max)\n", "    public static int Clamp(int x, int min, int max)\n", "    public static float Clamp(float x, float min, float max)\n", "    public static int DigitalRoot(int n)\n", "    public static int GreatestCommonDivisor(int a, int b)\n", "    public static boolean isNumeric(String str)\n", "    public static boolean isPowerOf2(int x)\n", "    public static int Mod(int x, int m)\n", "    public static int NextPowerOf2(int x)\n", "    public static void Permutate(int[] x)\n", "    public static int PreviousPowerOf2(int x)\n", "    public static synchronized double RandomNextDouble()\n", "    public static int Scale(IntRange from, IntRange to, int x)\n", "    public static double Scale(DoubleRange from, DoubleRange to, int x)\n", "    public static double Scale(DoubleRange from, DoubleRange to, double x)\n", "    public static float Scale(FloatRange from, FloatRange to, int x)\n", "    public static double Scale(double fromMin, double fromMax, double toMin, double toMax, double x)\n", "    public static double Sum(double[] data)\n", "    public static int Sum(int[] data)\n", "    public static double Log(double a, double b)\n", "    public static double TruncatedPower(double value, double degree)\n", "    public static int[] Unique(int[] values)\n", "    public static double Hypotenuse(double a, double b)\n", "    public static int Log2(int x)\n", "    public static int Pow2(int power)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2013\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math;\n\nimport com.harium.keel.catalano.core.DoubleRange;\nimport com.harium.keel.catalano.core.FloatRange;\nimport com.harium.keel.catalano.core.IntRange;\nimport com.harium.keel.catalano.math.random.Random;\n\nimport java.util.HashSet;\nimport java.util.Iterator;\n\n/**\n * Set of mathematical tools.\n *\n * @author Diego Catalano\n */\npublic final class Tools\n{\n\n    private static Random random = new Random();\n\n    public static Random Random()\n    {\n        return random;\n    }\n\n    public static void SetupGenerator(int seed)\n    {\n        random = new Random(seed);\n    }\n\n    /**\n     * Gets the square of the number.\n     *\n     * @param x Number.\n     * @return x*x;\n     */\n    public static double Square(double x)\n    {\n        return x * x;\n    }\n\n    /**\n     * Sinc function.\n     *\n     * @param x Value.\n     * @return Sinc of the value.\n     */\n    public static double Sinc(double x)\n    {\n        return Math.sin(Math.PI * x) / (Math.PI * x);\n    }\n\n    /**\n     * Don't let anyone instantiate this class.\n     */\n    private Tools()\n    {\n    }\n\n    /**\n     * Gets the angle formed by the vector [x,y].\n     *\n     * @param x X axis coordinate.\n     * @param y Y axis coordinate.\n     * @return Angle formed by the vector.\n     */\n    public static float Angle(float x, float y)\n    {\n        if (y >= 0)\n        {\n            if (x >= 0)\n                return (float) Math.atan(y / x);\n            return (float) (Math.PI - Math.atan(-y / x));\n        }\n        else\n        {\n            if (x >= 0)\n                return (float) (2 * Math.PI - Math.atan(-y / x));\n            return (float) (Math.PI + Math.atan(y / x));\n        }\n    }\n\n    /**\n     * Gets the angle formed by the vector [x,y].\n     *\n     * @param x X axis coordinate.\n     * @param y Y axis coordinate.\n     * @return Angle formed by the vector.\n     */\n    public static double Angle(double x, double y)\n    {\n        if (y >= 0)\n        {\n            if (x >= 0)\n                return Math.atan(y / x);\n            return (Math.PI - Math.atan(-y / x));\n        }\n        else\n        {\n            if (x >= 0)\n                return (2 * Math.PI - Math.atan(-y / x));\n            return (Math.PI + Math.atan(y / x));\n        }\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x     Value.\n     * @param range Range.\n     * @return Value.\n     */\n    public static double Clamp(double x, DoubleRange range)\n    {\n        return Clamp(x, range.getMin(), range.getMax());\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x     Value.\n     * @param range Range.\n     * @return Value.\n     */\n    public static int Clamp(int x, IntRange range)\n    {\n        return Clamp(x, range.getMin(), range.getMax());\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x     Value.\n     * @param range Range.\n     * @return Value.\n     */\n    public static float Clamp(float x, FloatRange range)\n    {\n        return Clamp(x, range.getMin(), range.getMax());\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x   Value.\n     * @param min Minimum value.\n     * @param max Maximum value.\n     * @return Value.\n     */\n    public static double Clamp(double x, double min, double max)\n    {\n        if (x < min)\n            return min;\n        if (x > max)\n            return max;\n        return x;\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x   Value.\n     * @param min Minimum value.\n     * @param max Maximum value.\n     * @return Value.\n     */\n    public static int Clamp(int x, int min, int max)\n    {\n        if (x < min)\n            return min;\n        if (x > max)\n            return max;\n        return x;\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x   Value.\n     * @param min Minimum value.\n     * @param max Maximum value.\n     * @return Value.\n     */\n    public static float Clamp(float x, float min, float max)\n    {\n        if (x < min)\n            return min;\n        if (x > max)\n            return max;\n        return x;\n    }\n\n    /**\n     * Return the digital root from a number.\n     * Example:\n     * Number: 24365\n     * Digital root: 2+4+3+6+5 = 20 = 2+0 = 2\n     *\n     * @param n Number.\n     * @return Digital root.\n     */\n    public static int DigitalRoot(int n)\n    {\n        return 1 + (n - 1) % 9;\n    }\n\n    /**\n     * Gets the greatest common divisor between two integers.\n     *\n     * @param a First integer.\n     * @param b Second integer.\n     * @return Greatest common divisor.\n     */\n    public static int GreatestCommonDivisor(int a, int b)\n    {\n\n        int x = a - b * (int) Math.floor(a / b);\n        while (x != 0)\n        {\n            a = b;\n            b = x;\n            x = a - b * (int) Math.floor(a / b);\n        }\n        return b;\n    }\n\n    public static boolean isNumeric(String str)\n    {\n        if (str.length() == 0)\n        {\n            return false;\n        }\n        char[] chars = str.toCharArray();\n        int sz = chars.length;\n        boolean hasExp = false;\n        boolean hasDecPoint = false;\n        boolean allowSigns = false;\n        boolean foundDigit = false;\n        // deal with any possible sign up front\n        int start = (chars[0] == '-') ? 1 : 0;\n        if (sz > start + 1)\n        {\n            if (chars[start] == '0' && chars[start + 1] == 'x')\n            {\n                int i = start + 2;\n                if (i == sz)\n                {\n                    return false; // str == \"0x\"\n                }\n                // checking hex (it can't be anything else)\n                for (; i < chars.length; i++)\n                {\n                    if ((chars[i] < '0' || chars[i] > '9')\n                            && (chars[i] < 'a' || chars[i] > 'f')\n                            && (chars[i] < 'A' || chars[i] > 'F'))\n                    {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        sz--; // don't want to loop to the last char, check it afterwords\n        // for type qualifiers\n        int i = start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] = \"1234E\")\n        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit))\n        {\n            if (chars[i] >= '0' && chars[i] <= '9')\n            {\n                foundDigit = true;\n                allowSigns = false;\n\n            }\n            else if (chars[i] == '.')\n            {\n                if (hasDecPoint || hasExp)\n                {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                hasDecPoint = true;\n            }\n            else if (chars[i] == 'e' || chars[i] == 'E')\n            {\n                // we've already taken care of hex.\n                if (hasExp)\n                {\n                    // two E's\n                    return false;\n                }\n                if (!foundDigit)\n                {\n                    return false;\n                }\n                hasExp = true;\n                allowSigns = true;\n            }\n            else if (chars[i] == '+' || chars[i] == '-')\n            {\n                if (!allowSigns)\n                {\n                    return false;\n                }\n                allowSigns = false;\n                foundDigit = false; // we need a digit after the E\n            }\n            else\n            {\n                return false;\n            }\n            i++;\n        }\n        if (i < chars.length)\n        {\n            if (chars[i] >= '0' && chars[i] <= '9')\n            {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] == 'e' || chars[i] == 'E')\n            {\n                // can't have an E at the last byte\n                return false;\n            }\n            if (chars[i] == '.')\n            {\n                if (hasDecPoint || hasExp)\n                {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                    && (chars[i] == 'd'\n                        || chars[i] == 'D'\n                        || chars[i] == 'f'\n                        || chars[i] == 'F'))\n            {\n                return foundDigit;\n            }\n            if (chars[i] == 'l'\n                    || chars[i] == 'L')\n            {\n                // not allowing L with an exponent\n                return foundDigit && !hasExp;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in 'E'\n        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n        return !allowSigns && foundDigit;\n    }\n\n    /**\n     * Checks if the specified integer is power of 2.\n     *\n     * @param x Integer number to check.\n     * @return True: if the specified number is power of 2, otherwise returns false.\n     */\n    public static boolean isPowerOf2(int x)\n    {\n        return (x > 0) ? ((x & (x - 1)) == 0) : false;\n    }\n\n    /**\n     * Gets the proper modulus operation.\n     *\n     * @param x Integer.\n     * @param m Modulo.\n     * @return Modulus.\n     */\n    public static int Mod(int x, int m)\n    {\n        if (m < 0) m = -m;\n        int r = x % m;\n        return r < 0 ? r + m : r;\n    }\n\n    /**\n     * Returns the next power of 2 after the input value x.\n     *\n     * @param x Input value x.\n     * @return Returns the next power of 2 after the input value x.\n     */\n    public static int NextPowerOf2(int x)\n    {\n        --x;\n        x |= x >> 1;\n        x |= x >> 2;\n        x |= x >> 4;\n        x |= x >> 8;\n        x |= x >> 16;\n        return ++x;\n    }\n\n    /**\n     * Generates a permutation of given array. This method is properly synchronized\n     * to allow correct use by more than one thread. However, if many threads\n     * need to generate pseudorandom numbers at a great rate, it may reduce\n     * contention for each thread to have its own pseudorandom-number generator.\n     */\n    public static void Permutate(int[] x)\n    {\n        random.permutate(x);\n    }\n\n    /**\n     * Returns the previous power of 2 after the input value x.\n     *\n     * @param x value x.\n     * @return Returns the previous power of 2 after the input value x.\n     */\n    public static int PreviousPowerOf2(int x)\n    {\n        return NextPowerOf2(x + 1) / 2;\n    }\n\n    /**\n     * Generate a random number in [0, 1). This method is properly synchronized\n     * to allow correct use by more than one thread. However, if many threads\n     * need to generate pseudorandom numbers at a great rate, it may reduce\n     * contention for each thread to have its own pseudorandom-number generator.\n     */\n    public static synchronized double RandomNextDouble()\n    {\n        return random.nextDouble();\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static int Scale(IntRange from, IntRange to, int x)\n    {\n        if (from.length() == 0) return 0;\n        return (int) ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static double Scale(DoubleRange from, DoubleRange to, int x)\n    {\n        if (from.length() == 0) return 0;\n        return ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static double Scale(DoubleRange from, DoubleRange to, double x)\n    {\n        if (from.length() == 0) return 0;\n        return ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static float Scale(FloatRange from, FloatRange to, int x)\n    {\n        if (from.length() == 0) return 0;\n        return (float) ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param fromMin Scale min from.\n     * @param fromMax Scale max from.\n     * @param toMin   Scale min to.\n     * @param toMax   Scale max to.\n     * @param x       Value.\n     * @return Result.\n     */\n    public static double Scale(double fromMin, double fromMax, double toMin, double toMax, double x)\n    {\n        if (fromMax - fromMin == 0) return 0;\n        return (toMax - toMin) * (x - fromMin) / (fromMax - fromMin) + toMin;\n    }\n\n    /**\n     * Sum of the elements.\n     *\n     * @param data Data.\n     * @return Sum(data).\n     */\n    public static double Sum(double[] data)\n    {\n        double sum = 0;\n        for (int i = 0; i < data.length; i++)\n        {\n            sum += data[i];\n        }\n        return sum;\n    }\n\n    /**\n     * Sum of the elements.\n     *\n     * @param data Data.\n     * @return Sum(data).\n     */\n    public static int Sum(int[] data)\n    {\n        int sum = 0;\n        for (int i = 0; i < data.length; i++)\n        {\n            sum += data[i];\n        }\n        return sum;\n    }\n\n    /**\n     * Sum of the elements.\n     *\n     * @param data Data.\n     * @return Sum(data).\n     */\n\n    /**\n     * Calculates the logarithm with base determined.\n     *\n     * @param a Value.\n     * @param b Base.\n     * @return Result.\n     */\n    public static double Log(double a, double b)\n    {\n        return Math.log(a) / Math.log(b);\n    }\n\n    /**\n     * Truncated power function.\n     *\n     * @param value  Value.\n     * @param degree Degree.\n     * @return Result.\n     */\n    public static double TruncatedPower(double value, double degree)\n    {\n        double x = Math.pow(value, degree);\n        return (x > 0) ? x : 0.0;\n    }\n\n    /**\n     * Get unique values form the array.\n     *\n     * @param values Array of values.\n     * @return Unique values.\n     */\n    public static int[] Unique(int[] values)\n    {\n        HashSet<Integer> lst = new HashSet<Integer>();\n        for (int i = 0; i < values.length; i++)\n        {\n            lst.add(values[i]);\n        }\n\n        int[] v = new int[lst.size()];\n        Iterator<Integer> it = lst.iterator();\n        for (int i = 0; i < v.length; i++)\n        {\n            v[i] = it.next();\n        }\n\n        return v;\n    }\n\n    /**\n     * Hypotenuse calculus without overflow/underflow.\n     *\n     * @param a First value.\n     * @param b Second value.\n     * @return The hypotenuse Sqrt(a^2 + b^2).\n     */\n    public static double Hypotenuse(double a, double b)\n    {\n        double r = 0.0;\n        double absA = Math.abs(a);\n        double absB = Math.abs(b);\n\n        if (absA > absB)\n        {\n            r = b / a;\n            r = absA * Math.sqrt(1 + r * r);\n        }\n        else if (b != 0)\n        {\n            r = a / b;\n            r = absB * Math.sqrt(1 + r * r);\n        }\n\n        return r;\n    }\n\n    public static int Log2(int x)\n    {\n        if (x <= 65536)\n        {\n            if (x <= 256)\n            {\n                if (x <= 16)\n                {\n                    if (x <= 4)\n                    {\n                        if (x <= 2)\n                        {\n                            if (x <= 1)\n                                return 0;\n                            return 1;\n                        }\n                        return 2;\n                    }\n                    if (x <= 8)\n                        return 3;\n                    return 4;\n                }\n                if (x <= 64)\n                {\n                    if (x <= 32)\n                        return 5;\n                    return 6;\n                }\n                if (x <= 128)\n                    return 7;\n                return 8;\n            }\n            if (x <= 4096)\n            {\n                if (x <= 1024)\n                {\n                    if (x <= 512)\n                        return 9;\n                    return 10;\n                }\n                if (x <= 2048)\n                    return 11;\n                return 12;\n            }\n            if (x <= 16384)\n            {\n                if (x <= 8192)\n                    return 13;\n                return 14;\n            }\n            if (x <= 32768)\n                return 15;\n            return 16;\n        }\n\n        if (x <= 16777216)\n        {\n            if (x <= 1048576)\n            {\n                if (x <= 262144)\n                {\n                    if (x <= 131072)\n                        return 17;\n                    return 18;\n                }\n                if (x <= 524288)\n                    return 19;\n                return 20;\n            }\n            if (x <= 4194304)\n            {\n                if (x <= 2097152)\n                    return 21;\n                return 22;\n            }\n            if (x <= 8388608)\n                return 23;\n            return 24;\n        }\n        if (x <= 268435456)\n        {\n            if (x <= 67108864)\n            {\n                if (x <= 33554432)\n                    return 25;\n                return 26;\n            }\n            if (x <= 134217728)\n                return 27;\n            return 28;\n        }\n        if (x <= 1073741824)\n        {\n            if (x <= 536870912)\n                return 29;\n            return 30;\n        }\n        return 31;\n    }\n\n    public static int Pow2(int power)\n    {\n        return ((power >= 0) && (power <= 30)) ? (1 << power) : 0;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/Tools.java", "func_name": "Tools.TruncatedPower", "original_string": "public static double TruncatedPower(double value, double degree) {\r\n        double x = Math.pow(value, degree);\r\n        return (x > 0) ? x : 0.0;\r\n    }", "language": "java", "code": "public static double TruncatedPower(double value, double degree) {\r\n        double x = Math.pow(value, degree);\r\n        return (x > 0) ? x : 0.0;\r\n    }", "code_tokens": ["public", "static", "double", "TruncatedPower", "(", "double", "value", ",", "double", "degree", ")", "{", "double", "x", "=", "Math", ".", "pow", "(", "value", ",", "degree", ")", ";", "return", "(", "x", ">", "0", ")", "?", "x", ":", "0.0", ";", "}"], "docstring": "Truncated power function.\n\n@param value  Value.\n@param degree Degree.\n@return Result.", "docstring_tokens": ["Truncated", "power", "function", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/Tools.java#L528-L531", "partition": "train", "up_fun_num": 32, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.DoubleRange;", "import com.harium.keel.catalano.core.FloatRange;", "import com.harium.keel.catalano.core.IntRange;", "import com.harium.keel.catalano.math.random.Random;", "import java.util.HashSet;", "import java.util.Iterator;"], "function": ["public final class Tools\n", "    public static Random Random()\n", "    public static void SetupGenerator(int seed)\n", "    public static double Square(double x)\n", "    public static double Sinc(double x)\n", "    public static float Angle(float x, float y)\n", "    public static double Angle(double x, double y)\n", "    public static double Clamp(double x, DoubleRange range)\n", "    public static int Clamp(int x, IntRange range)\n", "    public static float Clamp(float x, FloatRange range)\n", "    public static double Clamp(double x, double min, double max)\n", "    public static int Clamp(int x, int min, int max)\n", "    public static float Clamp(float x, float min, float max)\n", "    public static int DigitalRoot(int n)\n", "    public static int GreatestCommonDivisor(int a, int b)\n", "    public static boolean isNumeric(String str)\n", "    public static boolean isPowerOf2(int x)\n", "    public static int Mod(int x, int m)\n", "    public static int NextPowerOf2(int x)\n", "    public static void Permutate(int[] x)\n", "    public static int PreviousPowerOf2(int x)\n", "    public static synchronized double RandomNextDouble()\n", "    public static int Scale(IntRange from, IntRange to, int x)\n", "    public static double Scale(DoubleRange from, DoubleRange to, int x)\n", "    public static double Scale(DoubleRange from, DoubleRange to, double x)\n", "    public static float Scale(FloatRange from, FloatRange to, int x)\n", "    public static double Scale(double fromMin, double fromMax, double toMin, double toMax, double x)\n", "    public static double Sum(double[] data)\n", "    public static int Sum(int[] data)\n", "    public static float Sum(float[] data)\n", "    public static double Log(double a, double b)\n", "    public static int[] Unique(int[] values)\n", "    public static double Hypotenuse(double a, double b)\n", "    public static int Log2(int x)\n", "    public static int Pow2(int power)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2013\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math;\n\nimport com.harium.keel.catalano.core.DoubleRange;\nimport com.harium.keel.catalano.core.FloatRange;\nimport com.harium.keel.catalano.core.IntRange;\nimport com.harium.keel.catalano.math.random.Random;\n\nimport java.util.HashSet;\nimport java.util.Iterator;\n\n/**\n * Set of mathematical tools.\n *\n * @author Diego Catalano\n */\npublic final class Tools\n{\n\n    private static Random random = new Random();\n\n    public static Random Random()\n    {\n        return random;\n    }\n\n    public static void SetupGenerator(int seed)\n    {\n        random = new Random(seed);\n    }\n\n    /**\n     * Gets the square of the number.\n     *\n     * @param x Number.\n     * @return x*x;\n     */\n    public static double Square(double x)\n    {\n        return x * x;\n    }\n\n    /**\n     * Sinc function.\n     *\n     * @param x Value.\n     * @return Sinc of the value.\n     */\n    public static double Sinc(double x)\n    {\n        return Math.sin(Math.PI * x) / (Math.PI * x);\n    }\n\n    /**\n     * Don't let anyone instantiate this class.\n     */\n    private Tools()\n    {\n    }\n\n    /**\n     * Gets the angle formed by the vector [x,y].\n     *\n     * @param x X axis coordinate.\n     * @param y Y axis coordinate.\n     * @return Angle formed by the vector.\n     */\n    public static float Angle(float x, float y)\n    {\n        if (y >= 0)\n        {\n            if (x >= 0)\n                return (float) Math.atan(y / x);\n            return (float) (Math.PI - Math.atan(-y / x));\n        }\n        else\n        {\n            if (x >= 0)\n                return (float) (2 * Math.PI - Math.atan(-y / x));\n            return (float) (Math.PI + Math.atan(y / x));\n        }\n    }\n\n    /**\n     * Gets the angle formed by the vector [x,y].\n     *\n     * @param x X axis coordinate.\n     * @param y Y axis coordinate.\n     * @return Angle formed by the vector.\n     */\n    public static double Angle(double x, double y)\n    {\n        if (y >= 0)\n        {\n            if (x >= 0)\n                return Math.atan(y / x);\n            return (Math.PI - Math.atan(-y / x));\n        }\n        else\n        {\n            if (x >= 0)\n                return (2 * Math.PI - Math.atan(-y / x));\n            return (Math.PI + Math.atan(y / x));\n        }\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x     Value.\n     * @param range Range.\n     * @return Value.\n     */\n    public static double Clamp(double x, DoubleRange range)\n    {\n        return Clamp(x, range.getMin(), range.getMax());\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x     Value.\n     * @param range Range.\n     * @return Value.\n     */\n    public static int Clamp(int x, IntRange range)\n    {\n        return Clamp(x, range.getMin(), range.getMax());\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x     Value.\n     * @param range Range.\n     * @return Value.\n     */\n    public static float Clamp(float x, FloatRange range)\n    {\n        return Clamp(x, range.getMin(), range.getMax());\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x   Value.\n     * @param min Minimum value.\n     * @param max Maximum value.\n     * @return Value.\n     */\n    public static double Clamp(double x, double min, double max)\n    {\n        if (x < min)\n            return min;\n        if (x > max)\n            return max;\n        return x;\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x   Value.\n     * @param min Minimum value.\n     * @param max Maximum value.\n     * @return Value.\n     */\n    public static int Clamp(int x, int min, int max)\n    {\n        if (x < min)\n            return min;\n        if (x > max)\n            return max;\n        return x;\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x   Value.\n     * @param min Minimum value.\n     * @param max Maximum value.\n     * @return Value.\n     */\n    public static float Clamp(float x, float min, float max)\n    {\n        if (x < min)\n            return min;\n        if (x > max)\n            return max;\n        return x;\n    }\n\n    /**\n     * Return the digital root from a number.\n     * Example:\n     * Number: 24365\n     * Digital root: 2+4+3+6+5 = 20 = 2+0 = 2\n     *\n     * @param n Number.\n     * @return Digital root.\n     */\n    public static int DigitalRoot(int n)\n    {\n        return 1 + (n - 1) % 9;\n    }\n\n    /**\n     * Gets the greatest common divisor between two integers.\n     *\n     * @param a First integer.\n     * @param b Second integer.\n     * @return Greatest common divisor.\n     */\n    public static int GreatestCommonDivisor(int a, int b)\n    {\n\n        int x = a - b * (int) Math.floor(a / b);\n        while (x != 0)\n        {\n            a = b;\n            b = x;\n            x = a - b * (int) Math.floor(a / b);\n        }\n        return b;\n    }\n\n    public static boolean isNumeric(String str)\n    {\n        if (str.length() == 0)\n        {\n            return false;\n        }\n        char[] chars = str.toCharArray();\n        int sz = chars.length;\n        boolean hasExp = false;\n        boolean hasDecPoint = false;\n        boolean allowSigns = false;\n        boolean foundDigit = false;\n        // deal with any possible sign up front\n        int start = (chars[0] == '-') ? 1 : 0;\n        if (sz > start + 1)\n        {\n            if (chars[start] == '0' && chars[start + 1] == 'x')\n            {\n                int i = start + 2;\n                if (i == sz)\n                {\n                    return false; // str == \"0x\"\n                }\n                // checking hex (it can't be anything else)\n                for (; i < chars.length; i++)\n                {\n                    if ((chars[i] < '0' || chars[i] > '9')\n                            && (chars[i] < 'a' || chars[i] > 'f')\n                            && (chars[i] < 'A' || chars[i] > 'F'))\n                    {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        sz--; // don't want to loop to the last char, check it afterwords\n        // for type qualifiers\n        int i = start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] = \"1234E\")\n        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit))\n        {\n            if (chars[i] >= '0' && chars[i] <= '9')\n            {\n                foundDigit = true;\n                allowSigns = false;\n\n            }\n            else if (chars[i] == '.')\n            {\n                if (hasDecPoint || hasExp)\n                {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                hasDecPoint = true;\n            }\n            else if (chars[i] == 'e' || chars[i] == 'E')\n            {\n                // we've already taken care of hex.\n                if (hasExp)\n                {\n                    // two E's\n                    return false;\n                }\n                if (!foundDigit)\n                {\n                    return false;\n                }\n                hasExp = true;\n                allowSigns = true;\n            }\n            else if (chars[i] == '+' || chars[i] == '-')\n            {\n                if (!allowSigns)\n                {\n                    return false;\n                }\n                allowSigns = false;\n                foundDigit = false; // we need a digit after the E\n            }\n            else\n            {\n                return false;\n            }\n            i++;\n        }\n        if (i < chars.length)\n        {\n            if (chars[i] >= '0' && chars[i] <= '9')\n            {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] == 'e' || chars[i] == 'E')\n            {\n                // can't have an E at the last byte\n                return false;\n            }\n            if (chars[i] == '.')\n            {\n                if (hasDecPoint || hasExp)\n                {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                    && (chars[i] == 'd'\n                        || chars[i] == 'D'\n                        || chars[i] == 'f'\n                        || chars[i] == 'F'))\n            {\n                return foundDigit;\n            }\n            if (chars[i] == 'l'\n                    || chars[i] == 'L')\n            {\n                // not allowing L with an exponent\n                return foundDigit && !hasExp;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in 'E'\n        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n        return !allowSigns && foundDigit;\n    }\n\n    /**\n     * Checks if the specified integer is power of 2.\n     *\n     * @param x Integer number to check.\n     * @return True: if the specified number is power of 2, otherwise returns false.\n     */\n    public static boolean isPowerOf2(int x)\n    {\n        return (x > 0) ? ((x & (x - 1)) == 0) : false;\n    }\n\n    /**\n     * Gets the proper modulus operation.\n     *\n     * @param x Integer.\n     * @param m Modulo.\n     * @return Modulus.\n     */\n    public static int Mod(int x, int m)\n    {\n        if (m < 0) m = -m;\n        int r = x % m;\n        return r < 0 ? r + m : r;\n    }\n\n    /**\n     * Returns the next power of 2 after the input value x.\n     *\n     * @param x Input value x.\n     * @return Returns the next power of 2 after the input value x.\n     */\n    public static int NextPowerOf2(int x)\n    {\n        --x;\n        x |= x >> 1;\n        x |= x >> 2;\n        x |= x >> 4;\n        x |= x >> 8;\n        x |= x >> 16;\n        return ++x;\n    }\n\n    /**\n     * Generates a permutation of given array. This method is properly synchronized\n     * to allow correct use by more than one thread. However, if many threads\n     * need to generate pseudorandom numbers at a great rate, it may reduce\n     * contention for each thread to have its own pseudorandom-number generator.\n     */\n    public static void Permutate(int[] x)\n    {\n        random.permutate(x);\n    }\n\n    /**\n     * Returns the previous power of 2 after the input value x.\n     *\n     * @param x value x.\n     * @return Returns the previous power of 2 after the input value x.\n     */\n    public static int PreviousPowerOf2(int x)\n    {\n        return NextPowerOf2(x + 1) / 2;\n    }\n\n    /**\n     * Generate a random number in [0, 1). This method is properly synchronized\n     * to allow correct use by more than one thread. However, if many threads\n     * need to generate pseudorandom numbers at a great rate, it may reduce\n     * contention for each thread to have its own pseudorandom-number generator.\n     */\n    public static synchronized double RandomNextDouble()\n    {\n        return random.nextDouble();\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static int Scale(IntRange from, IntRange to, int x)\n    {\n        if (from.length() == 0) return 0;\n        return (int) ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static double Scale(DoubleRange from, DoubleRange to, int x)\n    {\n        if (from.length() == 0) return 0;\n        return ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static double Scale(DoubleRange from, DoubleRange to, double x)\n    {\n        if (from.length() == 0) return 0;\n        return ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static float Scale(FloatRange from, FloatRange to, int x)\n    {\n        if (from.length() == 0) return 0;\n        return (float) ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param fromMin Scale min from.\n     * @param fromMax Scale max from.\n     * @param toMin   Scale min to.\n     * @param toMax   Scale max to.\n     * @param x       Value.\n     * @return Result.\n     */\n    public static double Scale(double fromMin, double fromMax, double toMin, double toMax, double x)\n    {\n        if (fromMax - fromMin == 0) return 0;\n        return (toMax - toMin) * (x - fromMin) / (fromMax - fromMin) + toMin;\n    }\n\n    /**\n     * Sum of the elements.\n     *\n     * @param data Data.\n     * @return Sum(data).\n     */\n    public static double Sum(double[] data)\n    {\n        double sum = 0;\n        for (int i = 0; i < data.length; i++)\n        {\n            sum += data[i];\n        }\n        return sum;\n    }\n\n    /**\n     * Sum of the elements.\n     *\n     * @param data Data.\n     * @return Sum(data).\n     */\n    public static int Sum(int[] data)\n    {\n        int sum = 0;\n        for (int i = 0; i < data.length; i++)\n        {\n            sum += data[i];\n        }\n        return sum;\n    }\n\n    /**\n     * Sum of the elements.\n     *\n     * @param data Data.\n     * @return Sum(data).\n     */\n    public static float Sum(float[] data)\n    {\n        float sum = 0;\n        for (int i = 0; i < data.length; i++)\n        {\n            sum += data[i];\n        }\n        return sum;\n    }\n\n    /**\n     * Calculates the logarithm with base determined.\n     *\n     * @param a Value.\n     * @param b Base.\n     * @return Result.\n     */\n    public static double Log(double a, double b)\n    {\n        return Math.log(a) / Math.log(b);\n    }\n\n    /**\n     * Truncated power function.\n     *\n     * @param value  Value.\n     * @param degree Degree.\n     * @return Result.\n     */\n\n    /**\n     * Get unique values form the array.\n     *\n     * @param values Array of values.\n     * @return Unique values.\n     */\n    public static int[] Unique(int[] values)\n    {\n        HashSet<Integer> lst = new HashSet<Integer>();\n        for (int i = 0; i < values.length; i++)\n        {\n            lst.add(values[i]);\n        }\n\n        int[] v = new int[lst.size()];\n        Iterator<Integer> it = lst.iterator();\n        for (int i = 0; i < v.length; i++)\n        {\n            v[i] = it.next();\n        }\n\n        return v;\n    }\n\n    /**\n     * Hypotenuse calculus without overflow/underflow.\n     *\n     * @param a First value.\n     * @param b Second value.\n     * @return The hypotenuse Sqrt(a^2 + b^2).\n     */\n    public static double Hypotenuse(double a, double b)\n    {\n        double r = 0.0;\n        double absA = Math.abs(a);\n        double absB = Math.abs(b);\n\n        if (absA > absB)\n        {\n            r = b / a;\n            r = absA * Math.sqrt(1 + r * r);\n        }\n        else if (b != 0)\n        {\n            r = a / b;\n            r = absB * Math.sqrt(1 + r * r);\n        }\n\n        return r;\n    }\n\n    public static int Log2(int x)\n    {\n        if (x <= 65536)\n        {\n            if (x <= 256)\n            {\n                if (x <= 16)\n                {\n                    if (x <= 4)\n                    {\n                        if (x <= 2)\n                        {\n                            if (x <= 1)\n                                return 0;\n                            return 1;\n                        }\n                        return 2;\n                    }\n                    if (x <= 8)\n                        return 3;\n                    return 4;\n                }\n                if (x <= 64)\n                {\n                    if (x <= 32)\n                        return 5;\n                    return 6;\n                }\n                if (x <= 128)\n                    return 7;\n                return 8;\n            }\n            if (x <= 4096)\n            {\n                if (x <= 1024)\n                {\n                    if (x <= 512)\n                        return 9;\n                    return 10;\n                }\n                if (x <= 2048)\n                    return 11;\n                return 12;\n            }\n            if (x <= 16384)\n            {\n                if (x <= 8192)\n                    return 13;\n                return 14;\n            }\n            if (x <= 32768)\n                return 15;\n            return 16;\n        }\n\n        if (x <= 16777216)\n        {\n            if (x <= 1048576)\n            {\n                if (x <= 262144)\n                {\n                    if (x <= 131072)\n                        return 17;\n                    return 18;\n                }\n                if (x <= 524288)\n                    return 19;\n                return 20;\n            }\n            if (x <= 4194304)\n            {\n                if (x <= 2097152)\n                    return 21;\n                return 22;\n            }\n            if (x <= 8388608)\n                return 23;\n            return 24;\n        }\n        if (x <= 268435456)\n        {\n            if (x <= 67108864)\n            {\n                if (x <= 33554432)\n                    return 25;\n                return 26;\n            }\n            if (x <= 134217728)\n                return 27;\n            return 28;\n        }\n        if (x <= 1073741824)\n        {\n            if (x <= 536870912)\n                return 29;\n            return 30;\n        }\n        return 31;\n    }\n\n    public static int Pow2(int power)\n    {\n        return ((power >= 0) && (power <= 30)) ? (1 << power) : 0;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/Tools.java", "func_name": "Tools.Unique", "original_string": "public static int[] Unique(int[] values) {\r\n        HashSet<Integer> lst = new HashSet<Integer>();\r\n        for (int i = 0; i < values.length; i++) {\r\n            lst.add(values[i]);\r\n        }\r\n\r\n        int[] v = new int[lst.size()];\r\n        Iterator<Integer> it = lst.iterator();\r\n        for (int i = 0; i < v.length; i++) {\r\n            v[i] = it.next();\r\n        }\r\n\r\n        return v;\r\n    }", "language": "java", "code": "public static int[] Unique(int[] values) {\r\n        HashSet<Integer> lst = new HashSet<Integer>();\r\n        for (int i = 0; i < values.length; i++) {\r\n            lst.add(values[i]);\r\n        }\r\n\r\n        int[] v = new int[lst.size()];\r\n        Iterator<Integer> it = lst.iterator();\r\n        for (int i = 0; i < v.length; i++) {\r\n            v[i] = it.next();\r\n        }\r\n\r\n        return v;\r\n    }", "code_tokens": ["public", "static", "int", "[", "]", "Unique", "(", "int", "[", "]", "values", ")", "{", "HashSet", "<", "Integer", ">", "lst", "=", "new", "HashSet", "<", "Integer", ">", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "values", ".", "length", ";", "i", "++", ")", "{", "lst", ".", "add", "(", "values", "[", "i", "]", ")", ";", "}", "int", "[", "]", "v", "=", "new", "int", "[", "lst", ".", "size", "(", ")", "]", ";", "Iterator", "<", "Integer", ">", "it", "=", "lst", ".", "iterator", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "v", ".", "length", ";", "i", "++", ")", "{", "v", "[", "i", "]", "=", "it", ".", "next", "(", ")", ";", "}", "return", "v", ";", "}"], "docstring": "Get unique values form the array.\n\n@param values Array of values.\n@return Unique values.", "docstring_tokens": ["Get", "unique", "values", "form", "the", "array", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/Tools.java#L539-L552", "partition": "train", "up_fun_num": 33, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.DoubleRange;", "import com.harium.keel.catalano.core.FloatRange;", "import com.harium.keel.catalano.core.IntRange;", "import com.harium.keel.catalano.math.random.Random;", "import java.util.HashSet;", "import java.util.Iterator;"], "function": ["public final class Tools\n", "    public static Random Random()\n", "    public static void SetupGenerator(int seed)\n", "    public static double Square(double x)\n", "    public static double Sinc(double x)\n", "    public static float Angle(float x, float y)\n", "    public static double Angle(double x, double y)\n", "    public static double Clamp(double x, DoubleRange range)\n", "    public static int Clamp(int x, IntRange range)\n", "    public static float Clamp(float x, FloatRange range)\n", "    public static double Clamp(double x, double min, double max)\n", "    public static int Clamp(int x, int min, int max)\n", "    public static float Clamp(float x, float min, float max)\n", "    public static int DigitalRoot(int n)\n", "    public static int GreatestCommonDivisor(int a, int b)\n", "    public static boolean isNumeric(String str)\n", "    public static boolean isPowerOf2(int x)\n", "    public static int Mod(int x, int m)\n", "    public static int NextPowerOf2(int x)\n", "    public static void Permutate(int[] x)\n", "    public static int PreviousPowerOf2(int x)\n", "    public static synchronized double RandomNextDouble()\n", "    public static int Scale(IntRange from, IntRange to, int x)\n", "    public static double Scale(DoubleRange from, DoubleRange to, int x)\n", "    public static double Scale(DoubleRange from, DoubleRange to, double x)\n", "    public static float Scale(FloatRange from, FloatRange to, int x)\n", "    public static double Scale(double fromMin, double fromMax, double toMin, double toMax, double x)\n", "    public static double Sum(double[] data)\n", "    public static int Sum(int[] data)\n", "    public static float Sum(float[] data)\n", "    public static double Log(double a, double b)\n", "    public static double TruncatedPower(double value, double degree)\n", "    public static double Hypotenuse(double a, double b)\n", "    public static int Log2(int x)\n", "    public static int Pow2(int power)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2013\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math;\n\nimport com.harium.keel.catalano.core.DoubleRange;\nimport com.harium.keel.catalano.core.FloatRange;\nimport com.harium.keel.catalano.core.IntRange;\nimport com.harium.keel.catalano.math.random.Random;\n\nimport java.util.HashSet;\nimport java.util.Iterator;\n\n/**\n * Set of mathematical tools.\n *\n * @author Diego Catalano\n */\npublic final class Tools\n{\n\n    private static Random random = new Random();\n\n    public static Random Random()\n    {\n        return random;\n    }\n\n    public static void SetupGenerator(int seed)\n    {\n        random = new Random(seed);\n    }\n\n    /**\n     * Gets the square of the number.\n     *\n     * @param x Number.\n     * @return x*x;\n     */\n    public static double Square(double x)\n    {\n        return x * x;\n    }\n\n    /**\n     * Sinc function.\n     *\n     * @param x Value.\n     * @return Sinc of the value.\n     */\n    public static double Sinc(double x)\n    {\n        return Math.sin(Math.PI * x) / (Math.PI * x);\n    }\n\n    /**\n     * Don't let anyone instantiate this class.\n     */\n    private Tools()\n    {\n    }\n\n    /**\n     * Gets the angle formed by the vector [x,y].\n     *\n     * @param x X axis coordinate.\n     * @param y Y axis coordinate.\n     * @return Angle formed by the vector.\n     */\n    public static float Angle(float x, float y)\n    {\n        if (y >= 0)\n        {\n            if (x >= 0)\n                return (float) Math.atan(y / x);\n            return (float) (Math.PI - Math.atan(-y / x));\n        }\n        else\n        {\n            if (x >= 0)\n                return (float) (2 * Math.PI - Math.atan(-y / x));\n            return (float) (Math.PI + Math.atan(y / x));\n        }\n    }\n\n    /**\n     * Gets the angle formed by the vector [x,y].\n     *\n     * @param x X axis coordinate.\n     * @param y Y axis coordinate.\n     * @return Angle formed by the vector.\n     */\n    public static double Angle(double x, double y)\n    {\n        if (y >= 0)\n        {\n            if (x >= 0)\n                return Math.atan(y / x);\n            return (Math.PI - Math.atan(-y / x));\n        }\n        else\n        {\n            if (x >= 0)\n                return (2 * Math.PI - Math.atan(-y / x));\n            return (Math.PI + Math.atan(y / x));\n        }\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x     Value.\n     * @param range Range.\n     * @return Value.\n     */\n    public static double Clamp(double x, DoubleRange range)\n    {\n        return Clamp(x, range.getMin(), range.getMax());\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x     Value.\n     * @param range Range.\n     * @return Value.\n     */\n    public static int Clamp(int x, IntRange range)\n    {\n        return Clamp(x, range.getMin(), range.getMax());\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x     Value.\n     * @param range Range.\n     * @return Value.\n     */\n    public static float Clamp(float x, FloatRange range)\n    {\n        return Clamp(x, range.getMin(), range.getMax());\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x   Value.\n     * @param min Minimum value.\n     * @param max Maximum value.\n     * @return Value.\n     */\n    public static double Clamp(double x, double min, double max)\n    {\n        if (x < min)\n            return min;\n        if (x > max)\n            return max;\n        return x;\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x   Value.\n     * @param min Minimum value.\n     * @param max Maximum value.\n     * @return Value.\n     */\n    public static int Clamp(int x, int min, int max)\n    {\n        if (x < min)\n            return min;\n        if (x > max)\n            return max;\n        return x;\n    }\n\n    /**\n     * Clamp values.\n     *\n     * @param x   Value.\n     * @param min Minimum value.\n     * @param max Maximum value.\n     * @return Value.\n     */\n    public static float Clamp(float x, float min, float max)\n    {\n        if (x < min)\n            return min;\n        if (x > max)\n            return max;\n        return x;\n    }\n\n    /**\n     * Return the digital root from a number.\n     * Example:\n     * Number: 24365\n     * Digital root: 2+4+3+6+5 = 20 = 2+0 = 2\n     *\n     * @param n Number.\n     * @return Digital root.\n     */\n    public static int DigitalRoot(int n)\n    {\n        return 1 + (n - 1) % 9;\n    }\n\n    /**\n     * Gets the greatest common divisor between two integers.\n     *\n     * @param a First integer.\n     * @param b Second integer.\n     * @return Greatest common divisor.\n     */\n    public static int GreatestCommonDivisor(int a, int b)\n    {\n\n        int x = a - b * (int) Math.floor(a / b);\n        while (x != 0)\n        {\n            a = b;\n            b = x;\n            x = a - b * (int) Math.floor(a / b);\n        }\n        return b;\n    }\n\n    public static boolean isNumeric(String str)\n    {\n        if (str.length() == 0)\n        {\n            return false;\n        }\n        char[] chars = str.toCharArray();\n        int sz = chars.length;\n        boolean hasExp = false;\n        boolean hasDecPoint = false;\n        boolean allowSigns = false;\n        boolean foundDigit = false;\n        // deal with any possible sign up front\n        int start = (chars[0] == '-') ? 1 : 0;\n        if (sz > start + 1)\n        {\n            if (chars[start] == '0' && chars[start + 1] == 'x')\n            {\n                int i = start + 2;\n                if (i == sz)\n                {\n                    return false; // str == \"0x\"\n                }\n                // checking hex (it can't be anything else)\n                for (; i < chars.length; i++)\n                {\n                    if ((chars[i] < '0' || chars[i] > '9')\n                            && (chars[i] < 'a' || chars[i] > 'f')\n                            && (chars[i] < 'A' || chars[i] > 'F'))\n                    {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        sz--; // don't want to loop to the last char, check it afterwords\n        // for type qualifiers\n        int i = start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] = \"1234E\")\n        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit))\n        {\n            if (chars[i] >= '0' && chars[i] <= '9')\n            {\n                foundDigit = true;\n                allowSigns = false;\n\n            }\n            else if (chars[i] == '.')\n            {\n                if (hasDecPoint || hasExp)\n                {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                hasDecPoint = true;\n            }\n            else if (chars[i] == 'e' || chars[i] == 'E')\n            {\n                // we've already taken care of hex.\n                if (hasExp)\n                {\n                    // two E's\n                    return false;\n                }\n                if (!foundDigit)\n                {\n                    return false;\n                }\n                hasExp = true;\n                allowSigns = true;\n            }\n            else if (chars[i] == '+' || chars[i] == '-')\n            {\n                if (!allowSigns)\n                {\n                    return false;\n                }\n                allowSigns = false;\n                foundDigit = false; // we need a digit after the E\n            }\n            else\n            {\n                return false;\n            }\n            i++;\n        }\n        if (i < chars.length)\n        {\n            if (chars[i] >= '0' && chars[i] <= '9')\n            {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] == 'e' || chars[i] == 'E')\n            {\n                // can't have an E at the last byte\n                return false;\n            }\n            if (chars[i] == '.')\n            {\n                if (hasDecPoint || hasExp)\n                {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                    && (chars[i] == 'd'\n                        || chars[i] == 'D'\n                        || chars[i] == 'f'\n                        || chars[i] == 'F'))\n            {\n                return foundDigit;\n            }\n            if (chars[i] == 'l'\n                    || chars[i] == 'L')\n            {\n                // not allowing L with an exponent\n                return foundDigit && !hasExp;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in 'E'\n        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n        return !allowSigns && foundDigit;\n    }\n\n    /**\n     * Checks if the specified integer is power of 2.\n     *\n     * @param x Integer number to check.\n     * @return True: if the specified number is power of 2, otherwise returns false.\n     */\n    public static boolean isPowerOf2(int x)\n    {\n        return (x > 0) ? ((x & (x - 1)) == 0) : false;\n    }\n\n    /**\n     * Gets the proper modulus operation.\n     *\n     * @param x Integer.\n     * @param m Modulo.\n     * @return Modulus.\n     */\n    public static int Mod(int x, int m)\n    {\n        if (m < 0) m = -m;\n        int r = x % m;\n        return r < 0 ? r + m : r;\n    }\n\n    /**\n     * Returns the next power of 2 after the input value x.\n     *\n     * @param x Input value x.\n     * @return Returns the next power of 2 after the input value x.\n     */\n    public static int NextPowerOf2(int x)\n    {\n        --x;\n        x |= x >> 1;\n        x |= x >> 2;\n        x |= x >> 4;\n        x |= x >> 8;\n        x |= x >> 16;\n        return ++x;\n    }\n\n    /**\n     * Generates a permutation of given array. This method is properly synchronized\n     * to allow correct use by more than one thread. However, if many threads\n     * need to generate pseudorandom numbers at a great rate, it may reduce\n     * contention for each thread to have its own pseudorandom-number generator.\n     */\n    public static void Permutate(int[] x)\n    {\n        random.permutate(x);\n    }\n\n    /**\n     * Returns the previous power of 2 after the input value x.\n     *\n     * @param x value x.\n     * @return Returns the previous power of 2 after the input value x.\n     */\n    public static int PreviousPowerOf2(int x)\n    {\n        return NextPowerOf2(x + 1) / 2;\n    }\n\n    /**\n     * Generate a random number in [0, 1). This method is properly synchronized\n     * to allow correct use by more than one thread. However, if many threads\n     * need to generate pseudorandom numbers at a great rate, it may reduce\n     * contention for each thread to have its own pseudorandom-number generator.\n     */\n    public static synchronized double RandomNextDouble()\n    {\n        return random.nextDouble();\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static int Scale(IntRange from, IntRange to, int x)\n    {\n        if (from.length() == 0) return 0;\n        return (int) ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static double Scale(DoubleRange from, DoubleRange to, int x)\n    {\n        if (from.length() == 0) return 0;\n        return ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static double Scale(DoubleRange from, DoubleRange to, double x)\n    {\n        if (from.length() == 0) return 0;\n        return ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param from Scale from.\n     * @param to   Scale to.\n     * @param x    Value.\n     * @return Result.\n     */\n    public static float Scale(FloatRange from, FloatRange to, int x)\n    {\n        if (from.length() == 0) return 0;\n        return (float) ((to.length()) * (x - from.getMin()) / from.length() + to.getMin());\n    }\n\n    /**\n     * Converts the value x (which is measured in the scale 'from') to another value measured in the scale 'to'.\n     *\n     * @param fromMin Scale min from.\n     * @param fromMax Scale max from.\n     * @param toMin   Scale min to.\n     * @param toMax   Scale max to.\n     * @param x       Value.\n     * @return Result.\n     */\n    public static double Scale(double fromMin, double fromMax, double toMin, double toMax, double x)\n    {\n        if (fromMax - fromMin == 0) return 0;\n        return (toMax - toMin) * (x - fromMin) / (fromMax - fromMin) + toMin;\n    }\n\n    /**\n     * Sum of the elements.\n     *\n     * @param data Data.\n     * @return Sum(data).\n     */\n    public static double Sum(double[] data)\n    {\n        double sum = 0;\n        for (int i = 0; i < data.length; i++)\n        {\n            sum += data[i];\n        }\n        return sum;\n    }\n\n    /**\n     * Sum of the elements.\n     *\n     * @param data Data.\n     * @return Sum(data).\n     */\n    public static int Sum(int[] data)\n    {\n        int sum = 0;\n        for (int i = 0; i < data.length; i++)\n        {\n            sum += data[i];\n        }\n        return sum;\n    }\n\n    /**\n     * Sum of the elements.\n     *\n     * @param data Data.\n     * @return Sum(data).\n     */\n    public static float Sum(float[] data)\n    {\n        float sum = 0;\n        for (int i = 0; i < data.length; i++)\n        {\n            sum += data[i];\n        }\n        return sum;\n    }\n\n    /**\n     * Calculates the logarithm with base determined.\n     *\n     * @param a Value.\n     * @param b Base.\n     * @return Result.\n     */\n    public static double Log(double a, double b)\n    {\n        return Math.log(a) / Math.log(b);\n    }\n\n    /**\n     * Truncated power function.\n     *\n     * @param value  Value.\n     * @param degree Degree.\n     * @return Result.\n     */\n    public static double TruncatedPower(double value, double degree)\n    {\n        double x = Math.pow(value, degree);\n        return (x > 0) ? x : 0.0;\n    }\n\n    /**\n     * Get unique values form the array.\n     *\n     * @param values Array of values.\n     * @return Unique values.\n     */\n\n    /**\n     * Hypotenuse calculus without overflow/underflow.\n     *\n     * @param a First value.\n     * @param b Second value.\n     * @return The hypotenuse Sqrt(a^2 + b^2).\n     */\n    public static double Hypotenuse(double a, double b)\n    {\n        double r = 0.0;\n        double absA = Math.abs(a);\n        double absB = Math.abs(b);\n\n        if (absA > absB)\n        {\n            r = b / a;\n            r = absA * Math.sqrt(1 + r * r);\n        }\n        else if (b != 0)\n        {\n            r = a / b;\n            r = absB * Math.sqrt(1 + r * r);\n        }\n\n        return r;\n    }\n\n    public static int Log2(int x)\n    {\n        if (x <= 65536)\n        {\n            if (x <= 256)\n            {\n                if (x <= 16)\n                {\n                    if (x <= 4)\n                    {\n                        if (x <= 2)\n                        {\n                            if (x <= 1)\n                                return 0;\n                            return 1;\n                        }\n                        return 2;\n                    }\n                    if (x <= 8)\n                        return 3;\n                    return 4;\n                }\n                if (x <= 64)\n                {\n                    if (x <= 32)\n                        return 5;\n                    return 6;\n                }\n                if (x <= 128)\n                    return 7;\n                return 8;\n            }\n            if (x <= 4096)\n            {\n                if (x <= 1024)\n                {\n                    if (x <= 512)\n                        return 9;\n                    return 10;\n                }\n                if (x <= 2048)\n                    return 11;\n                return 12;\n            }\n            if (x <= 16384)\n            {\n                if (x <= 8192)\n                    return 13;\n                return 14;\n            }\n            if (x <= 32768)\n                return 15;\n            return 16;\n        }\n\n        if (x <= 16777216)\n        {\n            if (x <= 1048576)\n            {\n                if (x <= 262144)\n                {\n                    if (x <= 131072)\n                        return 17;\n                    return 18;\n                }\n                if (x <= 524288)\n                    return 19;\n                return 20;\n            }\n            if (x <= 4194304)\n            {\n                if (x <= 2097152)\n                    return 21;\n                return 22;\n            }\n            if (x <= 8388608)\n                return 23;\n            return 24;\n        }\n        if (x <= 268435456)\n        {\n            if (x <= 67108864)\n            {\n                if (x <= 33554432)\n                    return 25;\n                return 26;\n            }\n            if (x <= 134217728)\n                return 27;\n            return 28;\n        }\n        if (x <= 1073741824)\n        {\n            if (x <= 536870912)\n                return 29;\n            return 30;\n        }\n        return 31;\n    }\n\n    public static int Pow2(int power)\n    {\n        return ((power >= 0) && (power <= 30)) ? (1 << power) : 0;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/effect/AlphaTrimmedMean.java", "func_name": "AlphaTrimmedMean.setT", "original_string": "public void setT(int t) {\r\n        this.t = Math.min((radius * 2 + 1) * (radius * 2 + 1) / 2, Math.max(0, t));\r\n    }", "language": "java", "code": "public void setT(int t) {\r\n        this.t = Math.min((radius * 2 + 1) * (radius * 2 + 1) / 2, Math.max(0, t));\r\n    }", "code_tokens": ["public", "void", "setT", "(", "int", "t", ")", "{", "this", ".", "t", "=", "Math", ".", "min", "(", "(", "radius", "*", "2", "+", "1", ")", "*", "(", "radius", "*", "2", "+", "1", ")", "/", "2", ",", "Math", ".", "max", "(", "0", ",", "t", ")", ")", ";", "}"], "docstring": "Set trimmed value.\n\n@param t Trimmed value.", "docstring_tokens": ["Set", "trimmed", "value", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/effect/AlphaTrimmedMean.java#L60-L62", "partition": "train", "up_fun_num": 3, "levels": [0, 1, 1], "package": ["import com.harium.keel.core.Effect;", "import com.harium.keel.core.helper.ColorHelper;", "import com.harium.keel.core.source.ImageSource;", "import com.harium.keel.core.source.MatrixSource;", "import java.util.Arrays;"], "function": ["public class AlphaTrimmedMean extends RadiusEffect implements Effect\n", "    public int getT()\n", "    public ImageSource apply(ImageSource input)\n"], "context": "// Catalano Imaging Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.effect;\n\nimport com.harium.keel.core.Effect;\nimport com.harium.keel.core.helper.ColorHelper;\nimport com.harium.keel.core.source.ImageSource;\nimport com.harium.keel.core.source.MatrixSource;\n\nimport java.util.Arrays;\n\n/**\n * Alpha Trimmed Mean filter.\n * <p>The alpha trimmed mean filter is normally used to reduce noise in an image, somewhat like the mean and median filter. However, it often does a better job than the mean filter of preserving useful detail in the image.</p>\n * <p>\n * <p><b>Properties:</b>\n * <li>Supported types: Grayscale, RGB.\n * <br><li>Coordinate System: Matrix.</p>\n *\n * @author Diego Catalano\n */\npublic class AlphaTrimmedMean extends RadiusEffect implements Effect\n{\n\n    private int t = 1;\n\n    /**\n     * Get trimmed value.\n     *\n     * @return Trimmed value.\n     */\n    public int getT()\n    {\n        return t;\n    }\n\n    /**\n     * Set trimmed value.\n     *\n     * @param t Trimmed value.\n     */\n\n    /**\n     * Initializes a new instance of the AlphaTrimmedMean class.\n     */\n    public AlphaTrimmedMean()\n    {\n        super();\n    }\n\n    /**\n     * Initializes a new instance of the AlphaTrimmedMean class.\n     *\n     * @param radius Radius.\n     */\n    public AlphaTrimmedMean(int radius)\n    {\n        super(radius);\n    }\n\n    /**\n     * Initializes a new instance of the AlphaTrimmedMean class.\n     *\n     * @param radius Radius.\n     * @param t      Trimmed value.\n     */\n    public AlphaTrimmedMean(int radius, int t)\n    {\n        super(radius);\n        setT(t);\n    }\n\n    @Override\n    public ImageSource apply(ImageSource input)\n    {\n\n        int width = input.getWidth();\n        int height = input.getHeight();\n        int Xline, Yline;\n        int lines = calcLines(radius);\n        int maxArray = lines * lines;\n        int c;\n\n        MatrixSource copy = new MatrixSource(input);\n\n        if (input.isGrayscale())\n        {\n            int[] avgL = new int[maxArray];\n            for (int y = 0; y < height; y++)\n            {\n                for (int x = 0; x < width; x++)\n                {\n                    c = 0;\n                    for (int i = 0; i < lines; i++)\n                    {\n                        Xline = x + (i - radius);\n                        for (int j = 0; j < lines; j++)\n                        {\n                            Yline = y + (j - radius);\n                            if ((Xline >= 0) && (Xline < width) && (Yline >= 0) && (Yline < height))\n                            {\n                                // Gray Value\n                                avgL[c] = copy.getB(Xline, Yline);\n                            }\n                            else\n                            {\n                                // Gray Value\n                                avgL[c] = copy.getB(x, y);\n                            }\n                            c++;\n                        }\n                    }\n\n                    Arrays.sort(avgL);\n\n                    //alpha trimmed mean\n                    double mean = 0;\n                    for (int i = t; i < c - t; i++)\n                    {\n                        mean += avgL[i];\n                    }\n\n                    input.setGray(x, y, (int) (mean / (avgL.length - 2 * t)));\n                }\n            }\n        }\n        else\n        {\n            int[] avgR = new int[maxArray];\n            int[] avgG = new int[maxArray];\n            int[] avgB = new int[maxArray];\n\n            for (int y = 0; y < height; y++)\n            {\n                for (int x = 0; x < width; x++)\n                {\n                    c = 0;\n                    for (int i = 0; i < lines; i++)\n                    {\n                        Xline = x + (i - radius);\n                        for (int j = 0; j < lines; j++)\n                        {\n                            Yline = y + (j - radius);\n                            if ((Xline >= 0) && (Xline < width) && (Yline >= 0) && (Yline < height))\n                            {\n                                avgR[c] = copy.getR(Xline, Yline);\n                                avgG[c] = copy.getG(Xline, Yline);\n                                avgB[c] = copy.getB(Xline, Yline);\n                            }\n                            else\n                            {\n                                avgR[c] = copy.getR(x, y);\n                                avgG[c] = copy.getG(x, y);\n                                avgB[c] = copy.getB(x, y);\n                            }\n                            c++;\n                        }\n                    }\n\n                    Arrays.sort(avgR);\n                    Arrays.sort(avgG);\n                    Arrays.sort(avgB);\n\n                    //alpha trimmed mean\n                    double meanR = 0, meanG = 0, meanB = 0;\n                    for (int i = t; i < c - t; i++)\n                    {\n                        meanR += avgR[i];\n                        meanG += avgG[i];\n                        meanB += avgB[i];\n                    }\n\n                    meanR /= (avgR.length - 2 * t);\n                    meanG /= (avgG.length - 2 * t);\n                    meanB /= (avgB.length - 2 * t);\n\n                    int rgb = ColorHelper.getRGB((int) meanR, (int) meanG, (int) meanB);\n                    input.setRGB(y, x, rgb);\n                }\n            }\n        }\n        return input;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/TaylorSeries.java", "func_name": "TaylorSeries.Sin", "original_string": "public static double Sin(double x, int nTerms) {\r\n        if (nTerms < 2) return x;\r\n        if (nTerms == 2) {\r\n            return x - (x * x * x) / 6D;\r\n        } else {\r\n\r\n            double mult = x * x * x;\r\n            double fact = 6;\r\n            double sign = 1;\r\n            int factS = 5;\r\n            double result = x - mult / fact;\r\n            for (int i = 3; i <= nTerms; i++) {\r\n                mult *= x * x;\r\n                fact *= factS * (factS - 1);\r\n                factS += 2;\r\n                result += sign * (mult / fact);\r\n                sign *= -1;\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }", "language": "java", "code": "public static double Sin(double x, int nTerms) {\r\n        if (nTerms < 2) return x;\r\n        if (nTerms == 2) {\r\n            return x - (x * x * x) / 6D;\r\n        } else {\r\n\r\n            double mult = x * x * x;\r\n            double fact = 6;\r\n            double sign = 1;\r\n            int factS = 5;\r\n            double result = x - mult / fact;\r\n            for (int i = 3; i <= nTerms; i++) {\r\n                mult *= x * x;\r\n                fact *= factS * (factS - 1);\r\n                factS += 2;\r\n                result += sign * (mult / fact);\r\n                sign *= -1;\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }", "code_tokens": ["public", "static", "double", "Sin", "(", "double", "x", ",", "int", "nTerms", ")", "{", "if", "(", "nTerms", "<", "2", ")", "return", "x", ";", "if", "(", "nTerms", "==", "2", ")", "{", "return", "x", "-", "(", "x", "*", "x", "*", "x", ")", "/", "6D", ";", "}", "else", "{", "double", "mult", "=", "x", "*", "x", "*", "x", ";", "double", "fact", "=", "6", ";", "double", "sign", "=", "1", ";", "int", "factS", "=", "5", ";", "double", "result", "=", "x", "-", "mult", "/", "fact", ";", "for", "(", "int", "i", "=", "3", ";", "i", "<=", "nTerms", ";", "i", "++", ")", "{", "mult", "*=", "x", "*", "x", ";", "fact", "*=", "factS", "*", "(", "factS", "-", "1", ")", ";", "factS", "+=", "2", ";", "result", "+=", "sign", "*", "(", "mult", "/", "fact", ")", ";", "sign", "*=", "-", "1", ";", "}", "return", "result", ";", "}", "}"], "docstring": "compute Sin using Taylor Series.\n\n@param x      An angle, in radians.\n@param nTerms Number of terms.\n@return Result.", "docstring_tokens": ["compute", "Sin", "using", "Taylor", "Series", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/TaylorSeries.java#L47-L68", "partition": "train", "up_fun_num": 2, "levels": [0, 1, 1, 1, 1], "package": [], "function": ["public final class TaylorSeries\n", "    public static double Cos(double x, int nTerms)\n", "    public static double Sinh(double x, int nTerms)\n", "    public static double Cosh(double x, int nTerms)\n", "    public static double Exp(double x, int nTerms)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2013\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math;\n\n/**\n * compute functions using Taylor series expansion.\n *\n * @author Diego Catalano\n */\npublic final class TaylorSeries\n{\n\n    /**\n     * Don't let anyone initialize this class.\n     */\n    private TaylorSeries()\n    {\n    }\n\n    /**\n     * compute Sin using Taylor Series.\n     *\n     * @param x      An angle, in radians.\n     * @param nTerms Number of terms.\n     * @return Result.\n     */\n\n    /**\n     * compute Cos using Taylor Series.\n     *\n     * @param x      An angle, in radians.\n     * @param nTerms Number of terms.\n     * @return Result.\n     */\n    public static double Cos(double x, int nTerms)\n    {\n        if (nTerms < 2) return 1;\n        if (nTerms == 2)\n        {\n            return 1 - (x * x) / 2D;\n        }\n        else\n        {\n\n            double mult = x * x;\n            double fact = 2;\n            double sign = 1;\n            int factS = 4;\n            double result = 1 - mult / fact;\n            for (int i = 3; i <= nTerms; i++)\n            {\n                mult *= x * x;\n                fact *= factS * (factS - 1);\n                factS += 2;\n                result += sign * (mult / fact);\n                sign *= -1;\n            }\n\n            return result;\n        }\n    }\n\n    /**\n     * compute Sinh using Taylor Series.\n     *\n     * @param x      An angle, in radians.\n     * @param nTerms Number of terms.\n     * @return Result.\n     */\n    public static double Sinh(double x, int nTerms)\n    {\n        if (nTerms < 2) return x;\n        if (nTerms == 2)\n        {\n            return x + (x * x * x) / 6D;\n        }\n        else\n        {\n\n            double mult = x * x * x;\n            double fact = 6;\n            int factS = 5;\n            double result = x + mult / fact;\n            for (int i = 3; i <= nTerms; i++)\n            {\n                mult *= x * x;\n                fact *= factS * (factS - 1);\n                factS += 2;\n                result += mult / fact;\n            }\n\n            return result;\n        }\n    }\n\n    /**\n     * compute Cosh using Taylor Series.\n     *\n     * @param x      An angle, in radians.\n     * @param nTerms Number of terms.\n     * @return Result.\n     */\n    public static double Cosh(double x, int nTerms)\n    {\n        if (nTerms < 2) return x;\n        if (nTerms == 2)\n        {\n            return 1 + (x * x) / 2D;\n        }\n        else\n        {\n\n            double mult = x * x;\n            double fact = 2;\n            int factS = 4;\n            double result = 1 + mult / fact;\n            for (int i = 3; i <= nTerms; i++)\n            {\n                mult *= x * x;\n                fact *= factS * (factS - 1);\n                factS += 2;\n                result += mult / fact;\n            }\n\n            return result;\n        }\n    }\n\n    /**\n     * compute Exp using Taylor Series.\n     *\n     * @param x      An angle, in radians.\n     * @param nTerms Number of terms.\n     * @return Result.\n     */\n    public static double Exp(double x, int nTerms)\n    {\n        if (nTerms < 2) return 1 + x;\n        if (nTerms == 2)\n        {\n            return 1 + x + (x * x) / 2;\n        }\n        else\n        {\n\n            double mult = x * x;\n            double fact = 2;\n            double result = 1 + x + mult / fact;\n            for (int i = 3; i <= nTerms; i++)\n            {\n                mult *= x;\n                fact *= i;\n                result += mult / fact;\n            }\n\n            return result;\n        }\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/TaylorSeries.java", "func_name": "TaylorSeries.Sinh", "original_string": "public static double Sinh(double x, int nTerms) {\r\n        if (nTerms < 2) return x;\r\n        if (nTerms == 2) {\r\n            return x + (x * x * x) / 6D;\r\n        } else {\r\n\r\n            double mult = x * x * x;\r\n            double fact = 6;\r\n            int factS = 5;\r\n            double result = x + mult / fact;\r\n            for (int i = 3; i <= nTerms; i++) {\r\n                mult *= x * x;\r\n                fact *= factS * (factS - 1);\r\n                factS += 2;\r\n                result += mult / fact;\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }", "language": "java", "code": "public static double Sinh(double x, int nTerms) {\r\n        if (nTerms < 2) return x;\r\n        if (nTerms == 2) {\r\n            return x + (x * x * x) / 6D;\r\n        } else {\r\n\r\n            double mult = x * x * x;\r\n            double fact = 6;\r\n            int factS = 5;\r\n            double result = x + mult / fact;\r\n            for (int i = 3; i <= nTerms; i++) {\r\n                mult *= x * x;\r\n                fact *= factS * (factS - 1);\r\n                factS += 2;\r\n                result += mult / fact;\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }", "code_tokens": ["public", "static", "double", "Sinh", "(", "double", "x", ",", "int", "nTerms", ")", "{", "if", "(", "nTerms", "<", "2", ")", "return", "x", ";", "if", "(", "nTerms", "==", "2", ")", "{", "return", "x", "+", "(", "x", "*", "x", "*", "x", ")", "/", "6D", ";", "}", "else", "{", "double", "mult", "=", "x", "*", "x", "*", "x", ";", "double", "fact", "=", "6", ";", "int", "factS", "=", "5", ";", "double", "result", "=", "x", "+", "mult", "/", "fact", ";", "for", "(", "int", "i", "=", "3", ";", "i", "<=", "nTerms", ";", "i", "++", ")", "{", "mult", "*=", "x", "*", "x", ";", "fact", "*=", "factS", "*", "(", "factS", "-", "1", ")", ";", "factS", "+=", "2", ";", "result", "+=", "mult", "/", "fact", ";", "}", "return", "result", ";", "}", "}"], "docstring": "compute Sinh using Taylor Series.\n\n@param x      An angle, in radians.\n@param nTerms Number of terms.\n@return Result.", "docstring_tokens": ["compute", "Sinh", "using", "Taylor", "Series", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/TaylorSeries.java#L107-L126", "partition": "train", "up_fun_num": 4, "levels": [0, 1, 1, 1, 1], "package": [], "function": ["public final class TaylorSeries\n", "    public static double Sin(double x, int nTerms)\n", "    public static double Cos(double x, int nTerms)\n", "    public static double Cosh(double x, int nTerms)\n", "    public static double Exp(double x, int nTerms)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2013\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math;\n\n/**\n * compute functions using Taylor series expansion.\n *\n * @author Diego Catalano\n */\npublic final class TaylorSeries\n{\n\n    /**\n     * Don't let anyone initialize this class.\n     */\n    private TaylorSeries()\n    {\n    }\n\n    /**\n     * compute Sin using Taylor Series.\n     *\n     * @param x      An angle, in radians.\n     * @param nTerms Number of terms.\n     * @return Result.\n     */\n    public static double Sin(double x, int nTerms)\n    {\n        if (nTerms < 2) return x;\n        if (nTerms == 2)\n        {\n            return x - (x * x * x) / 6D;\n        }\n        else\n        {\n\n            double mult = x * x * x;\n            double fact = 6;\n            double sign = 1;\n            int factS = 5;\n            double result = x - mult / fact;\n            for (int i = 3; i <= nTerms; i++)\n            {\n                mult *= x * x;\n                fact *= factS * (factS - 1);\n                factS += 2;\n                result += sign * (mult / fact);\n                sign *= -1;\n            }\n\n            return result;\n        }\n    }\n\n    /**\n     * compute Cos using Taylor Series.\n     *\n     * @param x      An angle, in radians.\n     * @param nTerms Number of terms.\n     * @return Result.\n     */\n    public static double Cos(double x, int nTerms)\n    {\n        if (nTerms < 2) return 1;\n        if (nTerms == 2)\n        {\n            return 1 - (x * x) / 2D;\n        }\n        else\n        {\n\n            double mult = x * x;\n            double fact = 2;\n            double sign = 1;\n            int factS = 4;\n            double result = 1 - mult / fact;\n            for (int i = 3; i <= nTerms; i++)\n            {\n                mult *= x * x;\n                fact *= factS * (factS - 1);\n                factS += 2;\n                result += sign * (mult / fact);\n                sign *= -1;\n            }\n\n            return result;\n        }\n    }\n\n    /**\n     * compute Sinh using Taylor Series.\n     *\n     * @param x      An angle, in radians.\n     * @param nTerms Number of terms.\n     * @return Result.\n     */\n\n    /**\n     * compute Cosh using Taylor Series.\n     *\n     * @param x      An angle, in radians.\n     * @param nTerms Number of terms.\n     * @return Result.\n     */\n    public static double Cosh(double x, int nTerms)\n    {\n        if (nTerms < 2) return x;\n        if (nTerms == 2)\n        {\n            return 1 + (x * x) / 2D;\n        }\n        else\n        {\n\n            double mult = x * x;\n            double fact = 2;\n            int factS = 4;\n            double result = 1 + mult / fact;\n            for (int i = 3; i <= nTerms; i++)\n            {\n                mult *= x * x;\n                fact *= factS * (factS - 1);\n                factS += 2;\n                result += mult / fact;\n            }\n\n            return result;\n        }\n    }\n\n    /**\n     * compute Exp using Taylor Series.\n     *\n     * @param x      An angle, in radians.\n     * @param nTerms Number of terms.\n     * @return Result.\n     */\n    public static double Exp(double x, int nTerms)\n    {\n        if (nTerms < 2) return 1 + x;\n        if (nTerms == 2)\n        {\n            return 1 + x + (x * x) / 2;\n        }\n        else\n        {\n\n            double mult = x * x;\n            double fact = 2;\n            double result = 1 + x + mult / fact;\n            for (int i = 3; i <= nTerms; i++)\n            {\n                mult *= x;\n                fact *= i;\n                result += mult / fact;\n            }\n\n            return result;\n        }\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/TaylorSeries.java", "func_name": "TaylorSeries.Cosh", "original_string": "public static double Cosh(double x, int nTerms) {\r\n        if (nTerms < 2) return x;\r\n        if (nTerms == 2) {\r\n            return 1 + (x * x) / 2D;\r\n        } else {\r\n\r\n            double mult = x * x;\r\n            double fact = 2;\r\n            int factS = 4;\r\n            double result = 1 + mult / fact;\r\n            for (int i = 3; i <= nTerms; i++) {\r\n                mult *= x * x;\r\n                fact *= factS * (factS - 1);\r\n                factS += 2;\r\n                result += mult / fact;\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }", "language": "java", "code": "public static double Cosh(double x, int nTerms) {\r\n        if (nTerms < 2) return x;\r\n        if (nTerms == 2) {\r\n            return 1 + (x * x) / 2D;\r\n        } else {\r\n\r\n            double mult = x * x;\r\n            double fact = 2;\r\n            int factS = 4;\r\n            double result = 1 + mult / fact;\r\n            for (int i = 3; i <= nTerms; i++) {\r\n                mult *= x * x;\r\n                fact *= factS * (factS - 1);\r\n                factS += 2;\r\n                result += mult / fact;\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }", "code_tokens": ["public", "static", "double", "Cosh", "(", "double", "x", ",", "int", "nTerms", ")", "{", "if", "(", "nTerms", "<", "2", ")", "return", "x", ";", "if", "(", "nTerms", "==", "2", ")", "{", "return", "1", "+", "(", "x", "*", "x", ")", "/", "2D", ";", "}", "else", "{", "double", "mult", "=", "x", "*", "x", ";", "double", "fact", "=", "2", ";", "int", "factS", "=", "4", ";", "double", "result", "=", "1", "+", "mult", "/", "fact", ";", "for", "(", "int", "i", "=", "3", ";", "i", "<=", "nTerms", ";", "i", "++", ")", "{", "mult", "*=", "x", "*", "x", ";", "fact", "*=", "factS", "*", "(", "factS", "-", "1", ")", ";", "factS", "+=", "2", ";", "result", "+=", "mult", "/", "fact", ";", "}", "return", "result", ";", "}", "}"], "docstring": "compute Cosh using Taylor Series.\n\n@param x      An angle, in radians.\n@param nTerms Number of terms.\n@return Result.", "docstring_tokens": ["compute", "Cosh", "using", "Taylor", "Series", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/TaylorSeries.java#L135-L154", "partition": "train", "up_fun_num": 5, "levels": [0, 1, 1, 1, 1], "package": [], "function": ["public final class TaylorSeries\n", "    public static double Sin(double x, int nTerms)\n", "    public static double Cos(double x, int nTerms)\n", "    public static double Sinh(double x, int nTerms)\n", "    public static double Exp(double x, int nTerms)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2013\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math;\n\n/**\n * compute functions using Taylor series expansion.\n *\n * @author Diego Catalano\n */\npublic final class TaylorSeries\n{\n\n    /**\n     * Don't let anyone initialize this class.\n     */\n    private TaylorSeries()\n    {\n    }\n\n    /**\n     * compute Sin using Taylor Series.\n     *\n     * @param x      An angle, in radians.\n     * @param nTerms Number of terms.\n     * @return Result.\n     */\n    public static double Sin(double x, int nTerms)\n    {\n        if (nTerms < 2) return x;\n        if (nTerms == 2)\n        {\n            return x - (x * x * x) / 6D;\n        }\n        else\n        {\n\n            double mult = x * x * x;\n            double fact = 6;\n            double sign = 1;\n            int factS = 5;\n            double result = x - mult / fact;\n            for (int i = 3; i <= nTerms; i++)\n            {\n                mult *= x * x;\n                fact *= factS * (factS - 1);\n                factS += 2;\n                result += sign * (mult / fact);\n                sign *= -1;\n            }\n\n            return result;\n        }\n    }\n\n    /**\n     * compute Cos using Taylor Series.\n     *\n     * @param x      An angle, in radians.\n     * @param nTerms Number of terms.\n     * @return Result.\n     */\n    public static double Cos(double x, int nTerms)\n    {\n        if (nTerms < 2) return 1;\n        if (nTerms == 2)\n        {\n            return 1 - (x * x) / 2D;\n        }\n        else\n        {\n\n            double mult = x * x;\n            double fact = 2;\n            double sign = 1;\n            int factS = 4;\n            double result = 1 - mult / fact;\n            for (int i = 3; i <= nTerms; i++)\n            {\n                mult *= x * x;\n                fact *= factS * (factS - 1);\n                factS += 2;\n                result += sign * (mult / fact);\n                sign *= -1;\n            }\n\n            return result;\n        }\n    }\n\n    /**\n     * compute Sinh using Taylor Series.\n     *\n     * @param x      An angle, in radians.\n     * @param nTerms Number of terms.\n     * @return Result.\n     */\n    public static double Sinh(double x, int nTerms)\n    {\n        if (nTerms < 2) return x;\n        if (nTerms == 2)\n        {\n            return x + (x * x * x) / 6D;\n        }\n        else\n        {\n\n            double mult = x * x * x;\n            double fact = 6;\n            int factS = 5;\n            double result = x + mult / fact;\n            for (int i = 3; i <= nTerms; i++)\n            {\n                mult *= x * x;\n                fact *= factS * (factS - 1);\n                factS += 2;\n                result += mult / fact;\n            }\n\n            return result;\n        }\n    }\n\n    /**\n     * compute Cosh using Taylor Series.\n     *\n     * @param x      An angle, in radians.\n     * @param nTerms Number of terms.\n     * @return Result.\n     */\n\n    /**\n     * compute Exp using Taylor Series.\n     *\n     * @param x      An angle, in radians.\n     * @param nTerms Number of terms.\n     * @return Result.\n     */\n    public static double Exp(double x, int nTerms)\n    {\n        if (nTerms < 2) return 1 + x;\n        if (nTerms == 2)\n        {\n            return 1 + x + (x * x) / 2;\n        }\n        else\n        {\n\n            double mult = x * x;\n            double fact = 2;\n            double result = 1 + x + mult / fact;\n            for (int i = 3; i <= nTerms; i++)\n            {\n                mult *= x;\n                fact *= i;\n                result += mult / fact;\n            }\n\n            return result;\n        }\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/TaylorSeries.java", "func_name": "TaylorSeries.Exp", "original_string": "public static double Exp(double x, int nTerms) {\r\n        if (nTerms < 2) return 1 + x;\r\n        if (nTerms == 2) {\r\n            return 1 + x + (x * x) / 2;\r\n        } else {\r\n\r\n            double mult = x * x;\r\n            double fact = 2;\r\n            double result = 1 + x + mult / fact;\r\n            for (int i = 3; i <= nTerms; i++) {\r\n                mult *= x;\r\n                fact *= i;\r\n                result += mult / fact;\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }", "language": "java", "code": "public static double Exp(double x, int nTerms) {\r\n        if (nTerms < 2) return 1 + x;\r\n        if (nTerms == 2) {\r\n            return 1 + x + (x * x) / 2;\r\n        } else {\r\n\r\n            double mult = x * x;\r\n            double fact = 2;\r\n            double result = 1 + x + mult / fact;\r\n            for (int i = 3; i <= nTerms; i++) {\r\n                mult *= x;\r\n                fact *= i;\r\n                result += mult / fact;\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }", "code_tokens": ["public", "static", "double", "Exp", "(", "double", "x", ",", "int", "nTerms", ")", "{", "if", "(", "nTerms", "<", "2", ")", "return", "1", "+", "x", ";", "if", "(", "nTerms", "==", "2", ")", "{", "return", "1", "+", "x", "+", "(", "x", "*", "x", ")", "/", "2", ";", "}", "else", "{", "double", "mult", "=", "x", "*", "x", ";", "double", "fact", "=", "2", ";", "double", "result", "=", "1", "+", "x", "+", "mult", "/", "fact", ";", "for", "(", "int", "i", "=", "3", ";", "i", "<=", "nTerms", ";", "i", "++", ")", "{", "mult", "*=", "x", ";", "fact", "*=", "i", ";", "result", "+=", "mult", "/", "fact", ";", "}", "return", "result", ";", "}", "}"], "docstring": "compute Exp using Taylor Series.\n\n@param x      An angle, in radians.\n@param nTerms Number of terms.\n@return Result.", "docstring_tokens": ["compute", "Exp", "using", "Taylor", "Series", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/TaylorSeries.java#L163-L180", "partition": "train", "up_fun_num": 5, "levels": [0, 1, 1, 1, 1], "package": [], "function": ["public final class TaylorSeries\n", "    public static double Sin(double x, int nTerms)\n", "    public static double Cos(double x, int nTerms)\n", "    public static double Sinh(double x, int nTerms)\n", "    public static double Cosh(double x, int nTerms)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2013\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math;\n\n/**\n * compute functions using Taylor series expansion.\n *\n * @author Diego Catalano\n */\npublic final class TaylorSeries\n{\n\n    /**\n     * Don't let anyone initialize this class.\n     */\n    private TaylorSeries()\n    {\n    }\n\n    /**\n     * compute Sin using Taylor Series.\n     *\n     * @param x      An angle, in radians.\n     * @param nTerms Number of terms.\n     * @return Result.\n     */\n    public static double Sin(double x, int nTerms)\n    {\n        if (nTerms < 2) return x;\n        if (nTerms == 2)\n        {\n            return x - (x * x * x) / 6D;\n        }\n        else\n        {\n\n            double mult = x * x * x;\n            double fact = 6;\n            double sign = 1;\n            int factS = 5;\n            double result = x - mult / fact;\n            for (int i = 3; i <= nTerms; i++)\n            {\n                mult *= x * x;\n                fact *= factS * (factS - 1);\n                factS += 2;\n                result += sign * (mult / fact);\n                sign *= -1;\n            }\n\n            return result;\n        }\n    }\n\n    /**\n     * compute Cos using Taylor Series.\n     *\n     * @param x      An angle, in radians.\n     * @param nTerms Number of terms.\n     * @return Result.\n     */\n    public static double Cos(double x, int nTerms)\n    {\n        if (nTerms < 2) return 1;\n        if (nTerms == 2)\n        {\n            return 1 - (x * x) / 2D;\n        }\n        else\n        {\n\n            double mult = x * x;\n            double fact = 2;\n            double sign = 1;\n            int factS = 4;\n            double result = 1 - mult / fact;\n            for (int i = 3; i <= nTerms; i++)\n            {\n                mult *= x * x;\n                fact *= factS * (factS - 1);\n                factS += 2;\n                result += sign * (mult / fact);\n                sign *= -1;\n            }\n\n            return result;\n        }\n    }\n\n    /**\n     * compute Sinh using Taylor Series.\n     *\n     * @param x      An angle, in radians.\n     * @param nTerms Number of terms.\n     * @return Result.\n     */\n    public static double Sinh(double x, int nTerms)\n    {\n        if (nTerms < 2) return x;\n        if (nTerms == 2)\n        {\n            return x + (x * x * x) / 6D;\n        }\n        else\n        {\n\n            double mult = x * x * x;\n            double fact = 6;\n            int factS = 5;\n            double result = x + mult / fact;\n            for (int i = 3; i <= nTerms; i++)\n            {\n                mult *= x * x;\n                fact *= factS * (factS - 1);\n                factS += 2;\n                result += mult / fact;\n            }\n\n            return result;\n        }\n    }\n\n    /**\n     * compute Cosh using Taylor Series.\n     *\n     * @param x      An angle, in radians.\n     * @param nTerms Number of terms.\n     * @return Result.\n     */\n    public static double Cosh(double x, int nTerms)\n    {\n        if (nTerms < 2) return x;\n        if (nTerms == 2)\n        {\n            return 1 + (x * x) / 2D;\n        }\n        else\n        {\n\n            double mult = x * x;\n            double fact = 2;\n            int factS = 4;\n            double result = 1 + mult / fact;\n            for (int i = 3; i <= nTerms; i++)\n            {\n                mult *= x * x;\n                fact *= factS * (factS - 1);\n                factS += 2;\n                result += mult / fact;\n            }\n\n            return result;\n        }\n    }\n\n    /**\n     * compute Exp using Taylor Series.\n     *\n     * @param x      An angle, in radians.\n     * @param nTerms Number of terms.\n     * @return Result.\n     */\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/decomposition/LUDecomposition.java", "func_name": "LUDecomposition.getU", "original_string": "public double[][] getU() {\n        double[][] X = new double[n][n];\n        double[][] U = X;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i <= j) {\n                    U[i][j] = LU[i][j];\n                } else {\n                    U[i][j] = 0.0;\n                }\n            }\n        }\n        return X;\n    }", "language": "java", "code": "public double[][] getU() {\n        double[][] X = new double[n][n];\n        double[][] U = X;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i <= j) {\n                    U[i][j] = LU[i][j];\n                } else {\n                    U[i][j] = 0.0;\n                }\n            }\n        }\n        return X;\n    }", "code_tokens": ["public", "double", "[", "]", "[", "]", "getU", "(", ")", "{", "double", "[", "]", "[", "]", "X", "=", "new", "double", "[", "n", "]", "[", "n", "]", ";", "double", "[", "]", "[", "]", "U", "=", "X", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "n", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "0", ";", "j", "<", "n", ";", "j", "++", ")", "{", "if", "(", "i", "<=", "j", ")", "{", "U", "[", "i", "]", "[", "j", "]", "=", "LU", "[", "i", "]", "[", "j", "]", ";", "}", "else", "{", "U", "[", "i", "]", "[", "j", "]", "=", "0.0", ";", "}", "}", "}", "return", "X", ";", "}"], "docstring": "Get the Upper triangular factor.\n\n@return U.", "docstring_tokens": ["Get", "the", "Upper", "triangular", "factor", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/decomposition/LUDecomposition.java#L194-L207", "partition": "train", "up_fun_num": 5, "levels": [0, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.math.Matrix;"], "function": ["public class LUDecomposition implements java.io.Serializable\n", "    public boolean isNonsingular()\n", "    public double[][] inverse()\n", "    public double[][] getL()\n", "    public int[] getPivot()\n", "    public double[] getDoublePivot()\n", "    public double determinant()\n", "    public double[][] solve(double[][] B)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Original work copyright ? JAMA: A Java Matrix Package\n// http://math.nist.gov/javanumerics/jama/\n//\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.decomposition;\n\nimport com.harium.keel.catalano.math.Matrix;\n\n/**\n * LU Decomposition.\n * <p>\n * For an m-by-n matrix A with m >= n, the LU decomposition is an m-by-n\n * unit lower triangular matrix L, an n-by-n upper triangular matrix U,\n * and a permutation vector piv of length m so that A(piv,:) = L*U.\n * If m < n, then L is m-by-m and U is m-by-n.\n * <p>\n * The LU decompostion with pivoting always exists, even if the matrix is\n * singular, so the constructor will never fail.  The primary use of the\n * LU decomposition is in the solution of square systems of simultaneous\n * linear equations.  This will fail if isNonsingular() returns false.\n */\n\npublic class LUDecomposition implements java.io.Serializable\n{\n\n    /**\n     * Array for internal storage of decomposition.\n     *\n     * @serial internal array storage.\n     */\n    private double[][] LU;\n\n    /**\n     * Row and column dimensions, and pivot sign.\n     *\n     * @serial column dimension.\n     * @serial row dimension.\n     * @serial pivot sign.\n     */\n    private int m, n, pivsign;\n\n    /**\n     * Internal storage of pivot vector.\n     *\n     * @serial pivot vector.\n     */\n    private int[] piv;\n\n    /**\n     * Initializes a new instance of the LUDecomposition class.\n     *\n     * @param matrix Matrix.\n     */\n    public LUDecomposition(double[][] matrix)\n    {\n\n        // Use a \"left-looking\", dot-product, Crout/Doolittle algorithm.\n\n        LU = Matrix.Copy(matrix);\n        m = matrix.length;\n        n = matrix[0].length;\n        piv = new int[m];\n\n        for (int i = 0; i < m; i++)\n            piv[i] = i;\n\n        pivsign = 1;\n        double[] LUrowi;\n        double[] LUcolj = new double[m];\n\n        // Outer loop.\n        for (int j = 0; j < n; j++)\n        {\n\n            // Make a copy of the j-th column to localize references.\n\n            for (int i = 0; i < m; i++)\n            {\n                LUcolj[i] = LU[i][j];\n            }\n\n            // Apply previous transformations.\n\n            for (int i = 0; i < m; i++)\n            {\n                LUrowi = LU[i];\n\n                // Most of the time is spent in the following dot product.\n\n                int kmax = Math.min(i, j);\n                double s = 0.0;\n                for (int k = 0; k < kmax; k++)\n                {\n                    s += LUrowi[k] * LUcolj[k];\n                }\n\n                LUrowi[j] = LUcolj[i] -= s;\n            }\n\n            // Find pivot and exchange if necessary.\n\n            int p = j;\n            for (int i = j + 1; i < m; i++)\n            {\n                if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p]))\n                {\n                    p = i;\n                }\n            }\n            if (p != j)\n            {\n                for (int k = 0; k < n; k++)\n                {\n                    double t = LU[p][k];\n                    LU[p][k] = LU[j][k];\n                    LU[j][k] = t;\n                }\n                int k = piv[p];\n                piv[p] = piv[j];\n                piv[j] = k;\n                pivsign = -pivsign;\n            }\n\n            // compute multipliers.\n\n            if (j < m && LU[j][j] != 0.0)\n            {\n                for (int i = j + 1; i < m; i++)\n                {\n                    LU[i][j] /= LU[j][j];\n                }\n            }\n        }\n    }\n\n    /**\n     * Check if the matrix is non singular.\n     *\n     * @return True if U, and hence A, is nonsingular.\n     */\n    public boolean isNonsingular()\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (LU[j][j] == 0)\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * Matrix inverse or pseudoinverse.\n     *\n     * @return Matrix inverse.\n     */\n    public double[][] inverse()\n    {\n        return solve(Matrix.Identity(m, m));\n    }\n\n    /**\n     * Get the Lower triangular factor.\n     *\n     * @return L.\n     */\n    public double[][] getL()\n    {\n        double[][] X = new double[m][n];\n        double[][] L = X;\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                if (i > j)\n                {\n                    L[i][j] = LU[i][j];\n                }\n                else if (i == j)\n                {\n                    L[i][j] = 1.0;\n                }\n                else\n                {\n                    L[i][j] = 0.0;\n                }\n            }\n        }\n        return X;\n    }\n\n    /**\n     * Get the Upper triangular factor.\n     *\n     * @return U.\n     */\n\n    /**\n     * Get the pivot permutation vector.\n     *\n     * @return Pivot.\n     */\n    public int[] getPivot()\n    {\n        int[] p = new int[m];\n        for (int i = 0; i < m; i++)\n        {\n            p[i] = piv[i];\n        }\n        return p;\n    }\n\n    /** Return pivot permutation vector as a one-dimensional double array\n     @return (double) piv\n     */\n\n    /**\n     * Get the pivot permutation vector as double type.\n     *\n     * @return Pivot.\n     */\n    public double[] getDoublePivot()\n    {\n        double[] vals = new double[m];\n        for (int i = 0; i < m; i++)\n        {\n            vals[i] = (double) piv[i];\n        }\n        return vals;\n    }\n\n    /**\n     * Calculate the determinant.\n     *\n     * @return Determinant.\n     */\n    public double determinant()\n    {\n        if (m != n)\n        {\n            throw new IllegalArgumentException(\"Matrix must be square.\");\n        }\n        double d = (double) pivsign;\n        for (int j = 0; j < n; j++)\n        {\n            d *= LU[j][j];\n        }\n        return d;\n    }\n\n    /**\n     * Solve A*X = B\n     *\n     * @param B A Matrix with as many rows as A and any number of columns.\n     * @return X so that L*U*X = B(piv,:)\n     * @throws IllegalArgumentException Matrix row dimensions must agree.\n     * @throws RuntimeException         Matrix is singular.\n     */\n    public double[][] solve(double[][] B)\n    {\n        if (B.length != m)\n        {\n            throw new IllegalArgumentException(\"Matrix row dimensions must agree.\");\n        }\n        if (!this.isNonsingular())\n        {\n            throw new RuntimeException(\"Matrix is singular.\");\n        }\n\n        // Copy right hand side with pivoting\n        int nx = B[0].length;\n        double[][] X = Matrix.Submatrix(B, piv, 0, nx - 1);\n\n        // Solve L*Y = B(piv,:)\n        for (int k = 0; k < n; k++)\n        {\n            for (int i = k + 1; i < n; i++)\n            {\n                for (int j = 0; j < nx; j++)\n                {\n                    X[i][j] -= X[k][j] * LU[i][k];\n                }\n            }\n        }\n        // Solve U*X = Y;\n        for (int k = n - 1; k >= 0; k--)\n        {\n            for (int j = 0; j < nx; j++)\n            {\n                X[k][j] /= LU[k][k];\n            }\n            for (int i = 0; i < k; i++)\n            {\n                for (int j = 0; j < nx; j++)\n                {\n                    X[i][j] -= X[k][j] * LU[i][k];\n                }\n            }\n        }\n        return X;\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/decomposition/LUDecomposition.java", "func_name": "LUDecomposition.determinant", "original_string": "public double determinant() {\n        if (m != n) {\n            throw new IllegalArgumentException(\"Matrix must be square.\");\n        }\n        double d = (double) pivsign;\n        for (int j = 0; j < n; j++) {\n            d *= LU[j][j];\n        }\n        return d;\n    }", "language": "java", "code": "public double determinant() {\n        if (m != n) {\n            throw new IllegalArgumentException(\"Matrix must be square.\");\n        }\n        double d = (double) pivsign;\n        for (int j = 0; j < n; j++) {\n            d *= LU[j][j];\n        }\n        return d;\n    }", "code_tokens": ["public", "double", "determinant", "(", ")", "{", "if", "(", "m", "!=", "n", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"Matrix must be square.\"", ")", ";", "}", "double", "d", "=", "(", "double", ")", "pivsign", ";", "for", "(", "int", "j", "=", "0", ";", "j", "<", "n", ";", "j", "++", ")", "{", "d", "*=", "LU", "[", "j", "]", "[", "j", "]", ";", "}", "return", "d", ";", "}"], "docstring": "Calculate the determinant.\n\n@return Determinant.", "docstring_tokens": ["Calculate", "the", "determinant", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/decomposition/LUDecomposition.java#L244-L253", "partition": "train", "up_fun_num": 8, "levels": [0, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.math.Matrix;"], "function": ["public class LUDecomposition implements java.io.Serializable\n", "    public boolean isNonsingular()\n", "    public double[][] inverse()\n", "    public double[][] getL()\n", "    public double[][] getU()\n", "    public int[] getPivot()\n", "    public double[] getDoublePivot()\n", "    public double[][] solve(double[][] B)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Original work copyright ? JAMA: A Java Matrix Package\n// http://math.nist.gov/javanumerics/jama/\n//\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.decomposition;\n\nimport com.harium.keel.catalano.math.Matrix;\n\n/**\n * LU Decomposition.\n * <p>\n * For an m-by-n matrix A with m >= n, the LU decomposition is an m-by-n\n * unit lower triangular matrix L, an n-by-n upper triangular matrix U,\n * and a permutation vector piv of length m so that A(piv,:) = L*U.\n * If m < n, then L is m-by-m and U is m-by-n.\n * <p>\n * The LU decompostion with pivoting always exists, even if the matrix is\n * singular, so the constructor will never fail.  The primary use of the\n * LU decomposition is in the solution of square systems of simultaneous\n * linear equations.  This will fail if isNonsingular() returns false.\n */\n\npublic class LUDecomposition implements java.io.Serializable\n{\n\n    /**\n     * Array for internal storage of decomposition.\n     *\n     * @serial internal array storage.\n     */\n    private double[][] LU;\n\n    /**\n     * Row and column dimensions, and pivot sign.\n     *\n     * @serial column dimension.\n     * @serial row dimension.\n     * @serial pivot sign.\n     */\n    private int m, n, pivsign;\n\n    /**\n     * Internal storage of pivot vector.\n     *\n     * @serial pivot vector.\n     */\n    private int[] piv;\n\n    /**\n     * Initializes a new instance of the LUDecomposition class.\n     *\n     * @param matrix Matrix.\n     */\n    public LUDecomposition(double[][] matrix)\n    {\n\n        // Use a \"left-looking\", dot-product, Crout/Doolittle algorithm.\n\n        LU = Matrix.Copy(matrix);\n        m = matrix.length;\n        n = matrix[0].length;\n        piv = new int[m];\n\n        for (int i = 0; i < m; i++)\n            piv[i] = i;\n\n        pivsign = 1;\n        double[] LUrowi;\n        double[] LUcolj = new double[m];\n\n        // Outer loop.\n        for (int j = 0; j < n; j++)\n        {\n\n            // Make a copy of the j-th column to localize references.\n\n            for (int i = 0; i < m; i++)\n            {\n                LUcolj[i] = LU[i][j];\n            }\n\n            // Apply previous transformations.\n\n            for (int i = 0; i < m; i++)\n            {\n                LUrowi = LU[i];\n\n                // Most of the time is spent in the following dot product.\n\n                int kmax = Math.min(i, j);\n                double s = 0.0;\n                for (int k = 0; k < kmax; k++)\n                {\n                    s += LUrowi[k] * LUcolj[k];\n                }\n\n                LUrowi[j] = LUcolj[i] -= s;\n            }\n\n            // Find pivot and exchange if necessary.\n\n            int p = j;\n            for (int i = j + 1; i < m; i++)\n            {\n                if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p]))\n                {\n                    p = i;\n                }\n            }\n            if (p != j)\n            {\n                for (int k = 0; k < n; k++)\n                {\n                    double t = LU[p][k];\n                    LU[p][k] = LU[j][k];\n                    LU[j][k] = t;\n                }\n                int k = piv[p];\n                piv[p] = piv[j];\n                piv[j] = k;\n                pivsign = -pivsign;\n            }\n\n            // compute multipliers.\n\n            if (j < m && LU[j][j] != 0.0)\n            {\n                for (int i = j + 1; i < m; i++)\n                {\n                    LU[i][j] /= LU[j][j];\n                }\n            }\n        }\n    }\n\n    /**\n     * Check if the matrix is non singular.\n     *\n     * @return True if U, and hence A, is nonsingular.\n     */\n    public boolean isNonsingular()\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (LU[j][j] == 0)\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * Matrix inverse or pseudoinverse.\n     *\n     * @return Matrix inverse.\n     */\n    public double[][] inverse()\n    {\n        return solve(Matrix.Identity(m, m));\n    }\n\n    /**\n     * Get the Lower triangular factor.\n     *\n     * @return L.\n     */\n    public double[][] getL()\n    {\n        double[][] X = new double[m][n];\n        double[][] L = X;\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                if (i > j)\n                {\n                    L[i][j] = LU[i][j];\n                }\n                else if (i == j)\n                {\n                    L[i][j] = 1.0;\n                }\n                else\n                {\n                    L[i][j] = 0.0;\n                }\n            }\n        }\n        return X;\n    }\n\n    /**\n     * Get the Upper triangular factor.\n     *\n     * @return U.\n     */\n    public double[][] getU()\n    {\n        double[][] X = new double[n][n];\n        double[][] U = X;\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                if (i <= j)\n                {\n                    U[i][j] = LU[i][j];\n                }\n                else\n                {\n                    U[i][j] = 0.0;\n                }\n            }\n        }\n        return X;\n    }\n\n    /**\n     * Get the pivot permutation vector.\n     *\n     * @return Pivot.\n     */\n    public int[] getPivot()\n    {\n        int[] p = new int[m];\n        for (int i = 0; i < m; i++)\n        {\n            p[i] = piv[i];\n        }\n        return p;\n    }\n\n    /** Return pivot permutation vector as a one-dimensional double array\n     @return (double) piv\n     */\n\n    /**\n     * Get the pivot permutation vector as double type.\n     *\n     * @return Pivot.\n     */\n    public double[] getDoublePivot()\n    {\n        double[] vals = new double[m];\n        for (int i = 0; i < m; i++)\n        {\n            vals[i] = (double) piv[i];\n        }\n        return vals;\n    }\n\n    /**\n     * Calculate the determinant.\n     *\n     * @return Determinant.\n     */\n\n    /**\n     * Solve A*X = B\n     *\n     * @param B A Matrix with as many rows as A and any number of columns.\n     * @return X so that L*U*X = B(piv,:)\n     * @throws IllegalArgumentException Matrix row dimensions must agree.\n     * @throws RuntimeException         Matrix is singular.\n     */\n    public double[][] solve(double[][] B)\n    {\n        if (B.length != m)\n        {\n            throw new IllegalArgumentException(\"Matrix row dimensions must agree.\");\n        }\n        if (!this.isNonsingular())\n        {\n            throw new RuntimeException(\"Matrix is singular.\");\n        }\n\n        // Copy right hand side with pivoting\n        int nx = B[0].length;\n        double[][] X = Matrix.Submatrix(B, piv, 0, nx - 1);\n\n        // Solve L*Y = B(piv,:)\n        for (int k = 0; k < n; k++)\n        {\n            for (int i = k + 1; i < n; i++)\n            {\n                for (int j = 0; j < nx; j++)\n                {\n                    X[i][j] -= X[k][j] * LU[i][k];\n                }\n            }\n        }\n        // Solve U*X = Y;\n        for (int k = n - 1; k >= 0; k--)\n        {\n            for (int j = 0; j < nx; j++)\n            {\n                X[k][j] /= LU[k][k];\n            }\n            for (int i = 0; i < k; i++)\n            {\n                for (int j = 0; j < nx; j++)\n                {\n                    X[i][j] -= X[k][j] * LU[i][k];\n                }\n            }\n        }\n        return X;\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/ComplexNumber.java", "func_name": "ComplexNumber.Add", "original_string": "public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2) {\r\n        return new ComplexNumber(z1.real + z2.real, z1.imaginary + z2.imaginary);\r\n    }", "language": "java", "code": "public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2) {\r\n        return new ComplexNumber(z1.real + z2.real, z1.imaginary + z2.imaginary);\r\n    }", "code_tokens": ["public", "static", "ComplexNumber", "Add", "(", "ComplexNumber", "z1", ",", "ComplexNumber", "z2", ")", "{", "return", "new", "ComplexNumber", "(", "z1", ".", "real", "+", "z2", ".", "real", ",", "z1", ".", "imaginary", "+", "z2", ".", "imaginary", ")", ";", "}"], "docstring": "Adds two complex numbers.\n\n@param z1 Complex Number.\n@param z2 Complex Number.\n@return Returns new ComplexNumber instance containing the sum of specified complex numbers.", "docstring_tokens": ["Adds", "two", "complex", "numbers", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/ComplexNumber.java#L241-L243", "partition": "train", "up_fun_num": 15, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": [], "function": ["public class ComplexNumber\n", "    public double getMagnitude()\n", "    public double getSquaredMagnitude()\n", "    public double getPhase()\n", "    public static double[] getReal(ComplexNumber[] cn)\n", "    public static double[] getImaginary(ComplexNumber[] cn)\n", "    public static double[][] getReal(ComplexNumber[][] cn)\n", "    public static double[][] getImaginary(ComplexNumber[][] cn)\n", "    public static void Swap(ComplexNumber z1)\n", "    public static void Swap(ComplexNumber[] z)\n", "    public static void Swap(ComplexNumber[][] z)\n", "    public static double Abs(ComplexNumber z)\n", "    public static double[] Abs(ComplexNumber[] z)\n", "    public static double[][] Abs(ComplexNumber[][] z)\n", "    public static ComplexNumber Add(ComplexNumber z1, double scalar)\n", "    public void Add(double scalar)\n", "    public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Subtract(ComplexNumber z1, double scalar)\n", "    public void Subtract(double scalar)\n", "    public static double Magnitude(ComplexNumber z)\n", "    public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Multiply(ComplexNumber z1, double scalar)\n", "    public void Multiply(double scalar)\n", "    public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2)\n", "    public void Divide(ComplexNumber z1)\n", "    public static ComplexNumber Divide(ComplexNumber z1, double scalar)\n", "    public void Divide(double scalar)\n", "    public static ComplexNumber Pow(ComplexNumber z1, double n)\n", "    public void Pow(double n)\n", "    public static ComplexNumber Log(ComplexNumber z1)\n", "    public static ComplexNumber Exp(ComplexNumber z1)\n", "    public static ComplexNumber Sin(ComplexNumber z1)\n", "    public static ComplexNumber Cos(ComplexNumber z1)\n", "    public static ComplexNumber Tan(ComplexNumber z1)\n", "    public void Conjugate()\n", "    public static ComplexNumber Conjugate(ComplexNumber z1)\n", "    public String toString()\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2005-2009\n// andrew.kirillov@aforgenet.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math;\n\n/**\n * Complex Number.\n *\n * @author Diego Catalano\n */\npublic class ComplexNumber\n{\n\n    /**\n     * Real.\n     */\n    public double real = 0;\n    /**\n     * Imaginary.\n     */\n    public double imaginary = 0;\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     */\n    public ComplexNumber()\n    {\n        this(0, 0);\n    }\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     *\n     * @param real      Real.\n     * @param imaginary Imaginary.\n     */\n    public ComplexNumber(double real, double imaginary)\n    {\n        this.real = real;\n        this.imaginary = imaginary;\n    }\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     *\n     * @param z1 Complex Number.\n     */\n    public ComplexNumber(ComplexNumber z1)\n    {\n        this.real = z1.real;\n        this.imaginary = z1.imaginary;\n    }\n\n    /**\n     * Get Magnitude value of the complex number.\n     *\n     * @return Magnitude.\n     */\n    public double getMagnitude()\n    {\n        return Math.sqrt(real * real + imaginary * imaginary);\n    }\n\n    /**\n     * Get Squared magnitude value of the complex number.\n     *\n     * @return squared magnitude.\n     */\n    public double getSquaredMagnitude()\n    {\n        return real * real + imaginary * imaginary;\n    }\n\n    /**\n     * Get Phase value of the complex number.\n     *\n     * @return Phase value.\n     */\n    public double getPhase()\n    {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Get real part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Real part.\n     */\n    public static double[] getReal(ComplexNumber[] cn)\n    {\n        double[] n = new double[cn.length];\n        for (int i = 0; i < n.length; i++)\n        {\n            n[i] = cn[i].real;\n        }\n        return n;\n    }\n\n    /**\n     * Get imaginary part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Imaginary part.\n     */\n    public static double[] getImaginary(ComplexNumber[] cn)\n    {\n        double[] n = new double[cn.length];\n        for (int i = 0; i < n.length; i++)\n        {\n            n[i] = cn[i].imaginary;\n        }\n        return n;\n    }\n\n    /**\n     * Get real part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Real part.\n     */\n    public static double[][] getReal(ComplexNumber[][] cn)\n    {\n        double[][] n = new double[cn.length][cn[0].length];\n        for (int i = 0; i < n.length; i++)\n        {\n            for (int j = 0; j < n[0].length; j++)\n            {\n                n[i][j] = cn[i][j].real;\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Get imaginary part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Imaginary part.\n     */\n    public static double[][] getImaginary(ComplexNumber[][] cn)\n    {\n        double[][] n = new double[cn.length][cn[0].length];\n        for (int i = 0; i < n.length; i++)\n        {\n            for (int j = 0; j < n[0].length; j++)\n            {\n                n[i][j] = cn[i][j].imaginary;\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z1 Complex number.\n     */\n    public static void Swap(ComplexNumber z1)\n    {\n        double t = z1.real;\n        z1.real = z1.imaginary;\n        z1.imaginary = t;\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z Complex number.\n     */\n    public static void Swap(ComplexNumber[] z)\n    {\n        for (int i = 0; i < z.length; i++)\n        {\n            z[i] = new ComplexNumber(z[i].imaginary, z[i].real);\n        }\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z Complex number.\n     */\n    public static void Swap(ComplexNumber[][] z)\n    {\n        for (int i = 0; i < z.length; i++)\n        {\n            for (int j = 0; j < z[0].length; j++)\n            {\n                z[i][j] = new ComplexNumber(z[i][j].imaginary, z[i][j].real);\n            }\n        }\n    }\n\n    /**\n     * Absolute value of complex number.\n     * Same result like magnitude.\n     *\n     * @param z Complex Number.\n     * @return Absolute number.\n     */\n    public static double Abs(ComplexNumber z)\n    {\n        return Magnitude(z);\n    }\n\n    /**\n     * Absolute value of complex number.\n     *\n     * @param z Complex Numbers.\n     * @return Absolute number.\n     */\n    public static double[] Abs(ComplexNumber[] z)\n    {\n        double[] values = new double[z.length];\n        for (int i = 0; i < values.length; i++)\n        {\n            values[i] = z[i].getMagnitude();\n        }\n        return values;\n    }\n\n    /**\n     * Absolute value of complex number.\n     *\n     * @param z Complex numbers.\n     * @return Absolute number.\n     */\n    public static double[][] Abs(ComplexNumber[][] z)\n    {\n        double[][] values = new double[z.length][z[0].length];\n        for (int i = 0; i < values.length; i++)\n        {\n            for (int j = 0; j < values[0].length; j++)\n            {\n                values[i][j] = z[i][j].getMagnitude();\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Adds two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the sum of specified complex numbers.\n     */\n\n    /**\n     * Adds the complex number with a scalar value.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the add of specified complex number with scalar value.\n     */\n    public static ComplexNumber Add(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real + scalar, z1.imaginary);\n    }\n\n    /**\n     * Adds scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Add(double scalar)\n    {\n        this.real += scalar;\n    }\n\n    /**\n     * Subtract two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the subtract of specified complex numbers.\n     */\n    public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2)\n    {\n        return new ComplexNumber(z1.real - z2.real, z1.imaginary - z2.imaginary);\n    }\n\n    /**\n     * Subtract a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the subtract of specified complex number with a scalar value.\n     */\n    public static ComplexNumber Subtract(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real - scalar, z1.imaginary);\n    }\n\n    /**\n     * Subtracts scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Subtract(double scalar)\n    {\n        this.real -= scalar;\n    }\n\n    /**\n     * Magnitude of complex number.\n     *\n     * @param z Complex number.\n     * @return Magnitude of complex number.\n     */\n    public static double Magnitude(ComplexNumber z)\n    {\n        return Math.sqrt(z.real * z.real + z.imaginary * z.imaginary);\n    }\n\n    /**\n     * Multiply two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the multiply of specified complex numbers.\n     */\n    public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2)\n    {\n        double z1R = z1.real, z1I = z1.imaginary;\n        double z2R = z2.real, z2I = z2.imaginary;\n\n        return new ComplexNumber(z1R * z2R - z1I * z2I, z1R * z2I + z1I * z2R);\n    }\n\n    /**\n     * Multiply scalar value to a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the multiply of specified complex number with the scalar value.\n     */\n    public static ComplexNumber Multiply(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real * scalar, z1.imaginary * scalar);\n    }\n\n    /**\n     * Multiplys scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Multiply(double scalar)\n    {\n        this.real *= scalar;\n        this.imaginary *= scalar;\n    }\n\n    /**\n     * Divide two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the divide of specified complex numbers.\n     */\n    public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2)\n    {\n\n        ComplexNumber conj = ComplexNumber.Conjugate(z2);\n\n        double a = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\n        double b = z1.real * conj.imaginary + (z1.imaginary * conj.real);\n\n        double c = z2.real * conj.real + ((z2.imaginary * conj.imaginary) * -1);\n\n        return new ComplexNumber(a / c, b / c);\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param z1 Complex Number.\n     */\n    public void Divide(ComplexNumber z1)\n    {\n        ComplexNumber conj = ComplexNumber.Conjugate(z1);\n\n        double a = this.real * conj.real + ((this.imaginary * conj.imaginary) * -1);\n        double b = this.real * conj.imaginary + (this.imaginary * conj.real);\n\n        double c = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\n\n        this.real = a / c;\n        this.imaginary = b / c;\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the divide of specified complex number with the scalar value.\n     */\n    public static ComplexNumber Divide(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real / scalar, z1.imaginary / scalar);\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Divide(double scalar)\n    {\n\n        if (scalar == 0)\n        {\n            try\n            {\n                throw new ArithmeticException(\"Can not divide by zero.\");\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n            }\n        }\n\n        this.real /= scalar;\n        this.imaginary /= scalar;\n    }\n\n    /**\n     * Calculate power of a complex number.\n     *\n     * @param z1 Complex Number.\n     * @param n  Power.\n     * @return Returns a new complex number containing the power of a specified number.\n     */\n    public static ComplexNumber Pow(ComplexNumber z1, double n)\n    {\n\n        double norm = Math.pow(z1.getMagnitude(), n);\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(z1.imaginary / z1.real)));\n\n        double common = n * angle;\n\n        double r = norm * Math.cos(Math.toRadians(common));\n        double i = norm * Math.sin(Math.toRadians(common));\n\n        return new ComplexNumber(r, i);\n\n    }\n\n    /**\n     * Calculate power of a complex number.\n     *\n     * @param n Power.\n     */\n    public void Pow(double n)\n    {\n        double norm = Math.pow(getMagnitude(), n);\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(this.imaginary / this.real)));\n\n        double common = n * angle;\n\n        this.real = norm * Math.cos(Math.toRadians(common));\n        this.imaginary = norm * Math.sin(Math.toRadians(common));\n    }\n\n    /**\n     * Calculates natural (base <b>e</b>) logarithm of a complex number.\n     *\n     * @param z1 Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the natural logarithm of the specified complex number.\n     */\n    public static ComplexNumber Log(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if ((z1.real > 0.0) && (z1.imaginary == 0.0))\n        {\n            result.real = Math.log(z1.real);\n            result.imaginary = 0.0;\n        }\n        else if (z1.real == 0.0)\n        {\n            if (z1.imaginary > 0.0)\n            {\n                result.real = Math.log(z1.imaginary);\n                result.imaginary = Math.PI / 2.0;\n            }\n            else\n            {\n                result.real = Math.log(-(z1.imaginary));\n                result.imaginary = -Math.PI / 2.0;\n            }\n        }\n        else\n        {\n            result.real = Math.log(z1.getMagnitude());\n            result.imaginary = Math.atan2(z1.imaginary, z1.real);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates exponent (e raised to the specified power) of a complex number.\n     *\n     * @param z1 A Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the exponent of the specified complex number.\n     */\n    public static ComplexNumber Exp(ComplexNumber z1)\n    {\n        ComplexNumber x, y;\n        x = new ComplexNumber(Math.exp(z1.real), 0.0);\n        y = new ComplexNumber(Math.cos(z1.imaginary), Math.sin(z1.imaginary));\n\n        return Multiply(x, y);\n    }\n\n    /**\n     * Calculates Sine value of the complex number.\n     *\n     * @param z1 A Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the Sine value of the specified complex number.\n     */\n    public static ComplexNumber Sin(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.sin(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            result.real = Math.sin(z1.real) * Math.cosh(z1.imaginary);\n            result.imaginary = Math.cos(z1.real) * Math.sinh(z1.imaginary);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates Cosine value of the complex number.\n     *\n     * @param z1 A ComplexNumber instance.\n     * @return Returns new ComplexNumber instance containing the Cosine value of the specified complex number.\n     */\n    public static ComplexNumber Cos(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.cos(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            result.real = Math.cos(z1.real) * Math.cosh(z1.imaginary);\n            result.imaginary = -Math.sin(z1.real) * Math.sinh(z1.imaginary);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates Tangent value of the complex number.\n     *\n     * @param z1 A ComplexNumber instance.\n     * @return Returns new ComplexNumber instance containing the Tangent value of the specified complex number.\n     */\n    public static ComplexNumber Tan(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.tan(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            double real2 = 2 * z1.real;\n            double imag2 = 2 * z1.imaginary;\n            double denom = Math.cos(real2) + Math.cosh(real2);\n\n            result.real = Math.sin(real2) / denom;\n            result.imaginary = Math.sinh(imag2) / denom;\n        }\n\n        return result;\n    }\n\n    /**\n     * Conjugate this complex number.\n     */\n    public void Conjugate()\n    {\n        this.imaginary *= -1;\n    }\n\n    /**\n     * Conjugate a complex number.\n     *\n     * @param z1 Complex number.\n     * @return Returns new ComplexNumber instance containing the conjugate of the specified complex number.\n     */\n    public static ComplexNumber Conjugate(ComplexNumber z1)\n    {\n        return new ComplexNumber(z1.real, z1.imaginary * -1);\n    }\n\n    @Override\n    public String toString()\n    {\n        if (this.imaginary >= 0)\n            return this.real + \" +\" + this.imaginary + \"i\";\n        return this.real + \" \" + this.imaginary + \"i\";\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/ComplexNumber.java", "func_name": "ComplexNumber.Add", "original_string": "public static ComplexNumber Add(ComplexNumber z1, double scalar) {\r\n        return new ComplexNumber(z1.real + scalar, z1.imaginary);\r\n    }", "language": "java", "code": "public static ComplexNumber Add(ComplexNumber z1, double scalar) {\r\n        return new ComplexNumber(z1.real + scalar, z1.imaginary);\r\n    }", "code_tokens": ["public", "static", "ComplexNumber", "Add", "(", "ComplexNumber", "z1", ",", "double", "scalar", ")", "{", "return", "new", "ComplexNumber", "(", "z1", ".", "real", "+", "scalar", ",", "z1", ".", "imaginary", ")", ";", "}"], "docstring": "Adds the complex number with a scalar value.\n\n@param z1     Complex Number.\n@param scalar Scalar value.\n@return Returns new ComplexNumber instance containing the add of specified complex number with scalar value.", "docstring_tokens": ["Adds", "the", "complex", "number", "with", "a", "scalar", "value", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/ComplexNumber.java#L252-L254", "partition": "train", "up_fun_num": 16, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": [], "function": ["public class ComplexNumber\n", "    public double getMagnitude()\n", "    public double getSquaredMagnitude()\n", "    public double getPhase()\n", "    public static double[] getReal(ComplexNumber[] cn)\n", "    public static double[] getImaginary(ComplexNumber[] cn)\n", "    public static double[][] getReal(ComplexNumber[][] cn)\n", "    public static double[][] getImaginary(ComplexNumber[][] cn)\n", "    public static void Swap(ComplexNumber z1)\n", "    public static void Swap(ComplexNumber[] z)\n", "    public static void Swap(ComplexNumber[][] z)\n", "    public static double Abs(ComplexNumber z)\n", "    public static double[] Abs(ComplexNumber[] z)\n", "    public static double[][] Abs(ComplexNumber[][] z)\n", "    public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2)\n", "    public void Add(double scalar)\n", "    public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Subtract(ComplexNumber z1, double scalar)\n", "    public void Subtract(double scalar)\n", "    public static double Magnitude(ComplexNumber z)\n", "    public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Multiply(ComplexNumber z1, double scalar)\n", "    public void Multiply(double scalar)\n", "    public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2)\n", "    public void Divide(ComplexNumber z1)\n", "    public static ComplexNumber Divide(ComplexNumber z1, double scalar)\n", "    public void Divide(double scalar)\n", "    public static ComplexNumber Pow(ComplexNumber z1, double n)\n", "    public void Pow(double n)\n", "    public static ComplexNumber Log(ComplexNumber z1)\n", "    public static ComplexNumber Exp(ComplexNumber z1)\n", "    public static ComplexNumber Sin(ComplexNumber z1)\n", "    public static ComplexNumber Cos(ComplexNumber z1)\n", "    public static ComplexNumber Tan(ComplexNumber z1)\n", "    public void Conjugate()\n", "    public static ComplexNumber Conjugate(ComplexNumber z1)\n", "    public String toString()\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2005-2009\n// andrew.kirillov@aforgenet.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math;\n\n/**\n * Complex Number.\n *\n * @author Diego Catalano\n */\npublic class ComplexNumber\n{\n\n    /**\n     * Real.\n     */\n    public double real = 0;\n    /**\n     * Imaginary.\n     */\n    public double imaginary = 0;\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     */\n    public ComplexNumber()\n    {\n        this(0, 0);\n    }\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     *\n     * @param real      Real.\n     * @param imaginary Imaginary.\n     */\n    public ComplexNumber(double real, double imaginary)\n    {\n        this.real = real;\n        this.imaginary = imaginary;\n    }\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     *\n     * @param z1 Complex Number.\n     */\n    public ComplexNumber(ComplexNumber z1)\n    {\n        this.real = z1.real;\n        this.imaginary = z1.imaginary;\n    }\n\n    /**\n     * Get Magnitude value of the complex number.\n     *\n     * @return Magnitude.\n     */\n    public double getMagnitude()\n    {\n        return Math.sqrt(real * real + imaginary * imaginary);\n    }\n\n    /**\n     * Get Squared magnitude value of the complex number.\n     *\n     * @return squared magnitude.\n     */\n    public double getSquaredMagnitude()\n    {\n        return real * real + imaginary * imaginary;\n    }\n\n    /**\n     * Get Phase value of the complex number.\n     *\n     * @return Phase value.\n     */\n    public double getPhase()\n    {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Get real part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Real part.\n     */\n    public static double[] getReal(ComplexNumber[] cn)\n    {\n        double[] n = new double[cn.length];\n        for (int i = 0; i < n.length; i++)\n        {\n            n[i] = cn[i].real;\n        }\n        return n;\n    }\n\n    /**\n     * Get imaginary part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Imaginary part.\n     */\n    public static double[] getImaginary(ComplexNumber[] cn)\n    {\n        double[] n = new double[cn.length];\n        for (int i = 0; i < n.length; i++)\n        {\n            n[i] = cn[i].imaginary;\n        }\n        return n;\n    }\n\n    /**\n     * Get real part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Real part.\n     */\n    public static double[][] getReal(ComplexNumber[][] cn)\n    {\n        double[][] n = new double[cn.length][cn[0].length];\n        for (int i = 0; i < n.length; i++)\n        {\n            for (int j = 0; j < n[0].length; j++)\n            {\n                n[i][j] = cn[i][j].real;\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Get imaginary part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Imaginary part.\n     */\n    public static double[][] getImaginary(ComplexNumber[][] cn)\n    {\n        double[][] n = new double[cn.length][cn[0].length];\n        for (int i = 0; i < n.length; i++)\n        {\n            for (int j = 0; j < n[0].length; j++)\n            {\n                n[i][j] = cn[i][j].imaginary;\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z1 Complex number.\n     */\n    public static void Swap(ComplexNumber z1)\n    {\n        double t = z1.real;\n        z1.real = z1.imaginary;\n        z1.imaginary = t;\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z Complex number.\n     */\n    public static void Swap(ComplexNumber[] z)\n    {\n        for (int i = 0; i < z.length; i++)\n        {\n            z[i] = new ComplexNumber(z[i].imaginary, z[i].real);\n        }\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z Complex number.\n     */\n    public static void Swap(ComplexNumber[][] z)\n    {\n        for (int i = 0; i < z.length; i++)\n        {\n            for (int j = 0; j < z[0].length; j++)\n            {\n                z[i][j] = new ComplexNumber(z[i][j].imaginary, z[i][j].real);\n            }\n        }\n    }\n\n    /**\n     * Absolute value of complex number.\n     * Same result like magnitude.\n     *\n     * @param z Complex Number.\n     * @return Absolute number.\n     */\n    public static double Abs(ComplexNumber z)\n    {\n        return Magnitude(z);\n    }\n\n    /**\n     * Absolute value of complex number.\n     *\n     * @param z Complex Numbers.\n     * @return Absolute number.\n     */\n    public static double[] Abs(ComplexNumber[] z)\n    {\n        double[] values = new double[z.length];\n        for (int i = 0; i < values.length; i++)\n        {\n            values[i] = z[i].getMagnitude();\n        }\n        return values;\n    }\n\n    /**\n     * Absolute value of complex number.\n     *\n     * @param z Complex numbers.\n     * @return Absolute number.\n     */\n    public static double[][] Abs(ComplexNumber[][] z)\n    {\n        double[][] values = new double[z.length][z[0].length];\n        for (int i = 0; i < values.length; i++)\n        {\n            for (int j = 0; j < values[0].length; j++)\n            {\n                values[i][j] = z[i][j].getMagnitude();\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Adds two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the sum of specified complex numbers.\n     */\n    public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2)\n    {\n        return new ComplexNumber(z1.real + z2.real, z1.imaginary + z2.imaginary);\n    }\n\n    /**\n     * Adds the complex number with a scalar value.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the add of specified complex number with scalar value.\n     */\n\n    /**\n     * Adds scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Add(double scalar)\n    {\n        this.real += scalar;\n    }\n\n    /**\n     * Subtract two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the subtract of specified complex numbers.\n     */\n    public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2)\n    {\n        return new ComplexNumber(z1.real - z2.real, z1.imaginary - z2.imaginary);\n    }\n\n    /**\n     * Subtract a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the subtract of specified complex number with a scalar value.\n     */\n    public static ComplexNumber Subtract(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real - scalar, z1.imaginary);\n    }\n\n    /**\n     * Subtracts scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Subtract(double scalar)\n    {\n        this.real -= scalar;\n    }\n\n    /**\n     * Magnitude of complex number.\n     *\n     * @param z Complex number.\n     * @return Magnitude of complex number.\n     */\n    public static double Magnitude(ComplexNumber z)\n    {\n        return Math.sqrt(z.real * z.real + z.imaginary * z.imaginary);\n    }\n\n    /**\n     * Multiply two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the multiply of specified complex numbers.\n     */\n    public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2)\n    {\n        double z1R = z1.real, z1I = z1.imaginary;\n        double z2R = z2.real, z2I = z2.imaginary;\n\n        return new ComplexNumber(z1R * z2R - z1I * z2I, z1R * z2I + z1I * z2R);\n    }\n\n    /**\n     * Multiply scalar value to a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the multiply of specified complex number with the scalar value.\n     */\n    public static ComplexNumber Multiply(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real * scalar, z1.imaginary * scalar);\n    }\n\n    /**\n     * Multiplys scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Multiply(double scalar)\n    {\n        this.real *= scalar;\n        this.imaginary *= scalar;\n    }\n\n    /**\n     * Divide two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the divide of specified complex numbers.\n     */\n    public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2)\n    {\n\n        ComplexNumber conj = ComplexNumber.Conjugate(z2);\n\n        double a = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\n        double b = z1.real * conj.imaginary + (z1.imaginary * conj.real);\n\n        double c = z2.real * conj.real + ((z2.imaginary * conj.imaginary) * -1);\n\n        return new ComplexNumber(a / c, b / c);\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param z1 Complex Number.\n     */\n    public void Divide(ComplexNumber z1)\n    {\n        ComplexNumber conj = ComplexNumber.Conjugate(z1);\n\n        double a = this.real * conj.real + ((this.imaginary * conj.imaginary) * -1);\n        double b = this.real * conj.imaginary + (this.imaginary * conj.real);\n\n        double c = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\n\n        this.real = a / c;\n        this.imaginary = b / c;\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the divide of specified complex number with the scalar value.\n     */\n    public static ComplexNumber Divide(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real / scalar, z1.imaginary / scalar);\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Divide(double scalar)\n    {\n\n        if (scalar == 0)\n        {\n            try\n            {\n                throw new ArithmeticException(\"Can not divide by zero.\");\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n            }\n        }\n\n        this.real /= scalar;\n        this.imaginary /= scalar;\n    }\n\n    /**\n     * Calculate power of a complex number.\n     *\n     * @param z1 Complex Number.\n     * @param n  Power.\n     * @return Returns a new complex number containing the power of a specified number.\n     */\n    public static ComplexNumber Pow(ComplexNumber z1, double n)\n    {\n\n        double norm = Math.pow(z1.getMagnitude(), n);\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(z1.imaginary / z1.real)));\n\n        double common = n * angle;\n\n        double r = norm * Math.cos(Math.toRadians(common));\n        double i = norm * Math.sin(Math.toRadians(common));\n\n        return new ComplexNumber(r, i);\n\n    }\n\n    /**\n     * Calculate power of a complex number.\n     *\n     * @param n Power.\n     */\n    public void Pow(double n)\n    {\n        double norm = Math.pow(getMagnitude(), n);\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(this.imaginary / this.real)));\n\n        double common = n * angle;\n\n        this.real = norm * Math.cos(Math.toRadians(common));\n        this.imaginary = norm * Math.sin(Math.toRadians(common));\n    }\n\n    /**\n     * Calculates natural (base <b>e</b>) logarithm of a complex number.\n     *\n     * @param z1 Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the natural logarithm of the specified complex number.\n     */\n    public static ComplexNumber Log(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if ((z1.real > 0.0) && (z1.imaginary == 0.0))\n        {\n            result.real = Math.log(z1.real);\n            result.imaginary = 0.0;\n        }\n        else if (z1.real == 0.0)\n        {\n            if (z1.imaginary > 0.0)\n            {\n                result.real = Math.log(z1.imaginary);\n                result.imaginary = Math.PI / 2.0;\n            }\n            else\n            {\n                result.real = Math.log(-(z1.imaginary));\n                result.imaginary = -Math.PI / 2.0;\n            }\n        }\n        else\n        {\n            result.real = Math.log(z1.getMagnitude());\n            result.imaginary = Math.atan2(z1.imaginary, z1.real);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates exponent (e raised to the specified power) of a complex number.\n     *\n     * @param z1 A Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the exponent of the specified complex number.\n     */\n    public static ComplexNumber Exp(ComplexNumber z1)\n    {\n        ComplexNumber x, y;\n        x = new ComplexNumber(Math.exp(z1.real), 0.0);\n        y = new ComplexNumber(Math.cos(z1.imaginary), Math.sin(z1.imaginary));\n\n        return Multiply(x, y);\n    }\n\n    /**\n     * Calculates Sine value of the complex number.\n     *\n     * @param z1 A Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the Sine value of the specified complex number.\n     */\n    public static ComplexNumber Sin(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.sin(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            result.real = Math.sin(z1.real) * Math.cosh(z1.imaginary);\n            result.imaginary = Math.cos(z1.real) * Math.sinh(z1.imaginary);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates Cosine value of the complex number.\n     *\n     * @param z1 A ComplexNumber instance.\n     * @return Returns new ComplexNumber instance containing the Cosine value of the specified complex number.\n     */\n    public static ComplexNumber Cos(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.cos(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            result.real = Math.cos(z1.real) * Math.cosh(z1.imaginary);\n            result.imaginary = -Math.sin(z1.real) * Math.sinh(z1.imaginary);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates Tangent value of the complex number.\n     *\n     * @param z1 A ComplexNumber instance.\n     * @return Returns new ComplexNumber instance containing the Tangent value of the specified complex number.\n     */\n    public static ComplexNumber Tan(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.tan(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            double real2 = 2 * z1.real;\n            double imag2 = 2 * z1.imaginary;\n            double denom = Math.cos(real2) + Math.cosh(real2);\n\n            result.real = Math.sin(real2) / denom;\n            result.imaginary = Math.sinh(imag2) / denom;\n        }\n\n        return result;\n    }\n\n    /**\n     * Conjugate this complex number.\n     */\n    public void Conjugate()\n    {\n        this.imaginary *= -1;\n    }\n\n    /**\n     * Conjugate a complex number.\n     *\n     * @param z1 Complex number.\n     * @return Returns new ComplexNumber instance containing the conjugate of the specified complex number.\n     */\n    public static ComplexNumber Conjugate(ComplexNumber z1)\n    {\n        return new ComplexNumber(z1.real, z1.imaginary * -1);\n    }\n\n    @Override\n    public String toString()\n    {\n        if (this.imaginary >= 0)\n            return this.real + \" +\" + this.imaginary + \"i\";\n        return this.real + \" \" + this.imaginary + \"i\";\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/ComplexNumber.java", "func_name": "ComplexNumber.Subtract", "original_string": "public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2) {\r\n        return new ComplexNumber(z1.real - z2.real, z1.imaginary - z2.imaginary);\r\n    }", "language": "java", "code": "public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2) {\r\n        return new ComplexNumber(z1.real - z2.real, z1.imaginary - z2.imaginary);\r\n    }", "code_tokens": ["public", "static", "ComplexNumber", "Subtract", "(", "ComplexNumber", "z1", ",", "ComplexNumber", "z2", ")", "{", "return", "new", "ComplexNumber", "(", "z1", ".", "real", "-", "z2", ".", "real", ",", "z1", ".", "imaginary", "-", "z2", ".", "imaginary", ")", ";", "}"], "docstring": "Subtract two complex numbers.\n\n@param z1 Complex Number.\n@param z2 Complex Number.\n@return Returns new ComplexNumber instance containing the subtract of specified complex numbers.", "docstring_tokens": ["Subtract", "two", "complex", "numbers", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/ComplexNumber.java#L272-L274", "partition": "train", "up_fun_num": 18, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": [], "function": ["public class ComplexNumber\n", "    public double getMagnitude()\n", "    public double getSquaredMagnitude()\n", "    public double getPhase()\n", "    public static double[] getReal(ComplexNumber[] cn)\n", "    public static double[] getImaginary(ComplexNumber[] cn)\n", "    public static double[][] getReal(ComplexNumber[][] cn)\n", "    public static double[][] getImaginary(ComplexNumber[][] cn)\n", "    public static void Swap(ComplexNumber z1)\n", "    public static void Swap(ComplexNumber[] z)\n", "    public static void Swap(ComplexNumber[][] z)\n", "    public static double Abs(ComplexNumber z)\n", "    public static double[] Abs(ComplexNumber[] z)\n", "    public static double[][] Abs(ComplexNumber[][] z)\n", "    public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Add(ComplexNumber z1, double scalar)\n", "    public void Add(double scalar)\n", "    public static ComplexNumber Subtract(ComplexNumber z1, double scalar)\n", "    public void Subtract(double scalar)\n", "    public static double Magnitude(ComplexNumber z)\n", "    public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Multiply(ComplexNumber z1, double scalar)\n", "    public void Multiply(double scalar)\n", "    public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2)\n", "    public void Divide(ComplexNumber z1)\n", "    public static ComplexNumber Divide(ComplexNumber z1, double scalar)\n", "    public void Divide(double scalar)\n", "    public static ComplexNumber Pow(ComplexNumber z1, double n)\n", "    public void Pow(double n)\n", "    public static ComplexNumber Log(ComplexNumber z1)\n", "    public static ComplexNumber Exp(ComplexNumber z1)\n", "    public static ComplexNumber Sin(ComplexNumber z1)\n", "    public static ComplexNumber Cos(ComplexNumber z1)\n", "    public static ComplexNumber Tan(ComplexNumber z1)\n", "    public void Conjugate()\n", "    public static ComplexNumber Conjugate(ComplexNumber z1)\n", "    public String toString()\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2005-2009\n// andrew.kirillov@aforgenet.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math;\n\n/**\n * Complex Number.\n *\n * @author Diego Catalano\n */\npublic class ComplexNumber\n{\n\n    /**\n     * Real.\n     */\n    public double real = 0;\n    /**\n     * Imaginary.\n     */\n    public double imaginary = 0;\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     */\n    public ComplexNumber()\n    {\n        this(0, 0);\n    }\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     *\n     * @param real      Real.\n     * @param imaginary Imaginary.\n     */\n    public ComplexNumber(double real, double imaginary)\n    {\n        this.real = real;\n        this.imaginary = imaginary;\n    }\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     *\n     * @param z1 Complex Number.\n     */\n    public ComplexNumber(ComplexNumber z1)\n    {\n        this.real = z1.real;\n        this.imaginary = z1.imaginary;\n    }\n\n    /**\n     * Get Magnitude value of the complex number.\n     *\n     * @return Magnitude.\n     */\n    public double getMagnitude()\n    {\n        return Math.sqrt(real * real + imaginary * imaginary);\n    }\n\n    /**\n     * Get Squared magnitude value of the complex number.\n     *\n     * @return squared magnitude.\n     */\n    public double getSquaredMagnitude()\n    {\n        return real * real + imaginary * imaginary;\n    }\n\n    /**\n     * Get Phase value of the complex number.\n     *\n     * @return Phase value.\n     */\n    public double getPhase()\n    {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Get real part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Real part.\n     */\n    public static double[] getReal(ComplexNumber[] cn)\n    {\n        double[] n = new double[cn.length];\n        for (int i = 0; i < n.length; i++)\n        {\n            n[i] = cn[i].real;\n        }\n        return n;\n    }\n\n    /**\n     * Get imaginary part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Imaginary part.\n     */\n    public static double[] getImaginary(ComplexNumber[] cn)\n    {\n        double[] n = new double[cn.length];\n        for (int i = 0; i < n.length; i++)\n        {\n            n[i] = cn[i].imaginary;\n        }\n        return n;\n    }\n\n    /**\n     * Get real part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Real part.\n     */\n    public static double[][] getReal(ComplexNumber[][] cn)\n    {\n        double[][] n = new double[cn.length][cn[0].length];\n        for (int i = 0; i < n.length; i++)\n        {\n            for (int j = 0; j < n[0].length; j++)\n            {\n                n[i][j] = cn[i][j].real;\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Get imaginary part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Imaginary part.\n     */\n    public static double[][] getImaginary(ComplexNumber[][] cn)\n    {\n        double[][] n = new double[cn.length][cn[0].length];\n        for (int i = 0; i < n.length; i++)\n        {\n            for (int j = 0; j < n[0].length; j++)\n            {\n                n[i][j] = cn[i][j].imaginary;\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z1 Complex number.\n     */\n    public static void Swap(ComplexNumber z1)\n    {\n        double t = z1.real;\n        z1.real = z1.imaginary;\n        z1.imaginary = t;\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z Complex number.\n     */\n    public static void Swap(ComplexNumber[] z)\n    {\n        for (int i = 0; i < z.length; i++)\n        {\n            z[i] = new ComplexNumber(z[i].imaginary, z[i].real);\n        }\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z Complex number.\n     */\n    public static void Swap(ComplexNumber[][] z)\n    {\n        for (int i = 0; i < z.length; i++)\n        {\n            for (int j = 0; j < z[0].length; j++)\n            {\n                z[i][j] = new ComplexNumber(z[i][j].imaginary, z[i][j].real);\n            }\n        }\n    }\n\n    /**\n     * Absolute value of complex number.\n     * Same result like magnitude.\n     *\n     * @param z Complex Number.\n     * @return Absolute number.\n     */\n    public static double Abs(ComplexNumber z)\n    {\n        return Magnitude(z);\n    }\n\n    /**\n     * Absolute value of complex number.\n     *\n     * @param z Complex Numbers.\n     * @return Absolute number.\n     */\n    public static double[] Abs(ComplexNumber[] z)\n    {\n        double[] values = new double[z.length];\n        for (int i = 0; i < values.length; i++)\n        {\n            values[i] = z[i].getMagnitude();\n        }\n        return values;\n    }\n\n    /**\n     * Absolute value of complex number.\n     *\n     * @param z Complex numbers.\n     * @return Absolute number.\n     */\n    public static double[][] Abs(ComplexNumber[][] z)\n    {\n        double[][] values = new double[z.length][z[0].length];\n        for (int i = 0; i < values.length; i++)\n        {\n            for (int j = 0; j < values[0].length; j++)\n            {\n                values[i][j] = z[i][j].getMagnitude();\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Adds two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the sum of specified complex numbers.\n     */\n    public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2)\n    {\n        return new ComplexNumber(z1.real + z2.real, z1.imaginary + z2.imaginary);\n    }\n\n    /**\n     * Adds the complex number with a scalar value.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the add of specified complex number with scalar value.\n     */\n    public static ComplexNumber Add(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real + scalar, z1.imaginary);\n    }\n\n    /**\n     * Adds scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Add(double scalar)\n    {\n        this.real += scalar;\n    }\n\n    /**\n     * Subtract two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the subtract of specified complex numbers.\n     */\n\n    /**\n     * Subtract a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the subtract of specified complex number with a scalar value.\n     */\n    public static ComplexNumber Subtract(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real - scalar, z1.imaginary);\n    }\n\n    /**\n     * Subtracts scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Subtract(double scalar)\n    {\n        this.real -= scalar;\n    }\n\n    /**\n     * Magnitude of complex number.\n     *\n     * @param z Complex number.\n     * @return Magnitude of complex number.\n     */\n    public static double Magnitude(ComplexNumber z)\n    {\n        return Math.sqrt(z.real * z.real + z.imaginary * z.imaginary);\n    }\n\n    /**\n     * Multiply two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the multiply of specified complex numbers.\n     */\n    public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2)\n    {\n        double z1R = z1.real, z1I = z1.imaginary;\n        double z2R = z2.real, z2I = z2.imaginary;\n\n        return new ComplexNumber(z1R * z2R - z1I * z2I, z1R * z2I + z1I * z2R);\n    }\n\n    /**\n     * Multiply scalar value to a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the multiply of specified complex number with the scalar value.\n     */\n    public static ComplexNumber Multiply(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real * scalar, z1.imaginary * scalar);\n    }\n\n    /**\n     * Multiplys scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Multiply(double scalar)\n    {\n        this.real *= scalar;\n        this.imaginary *= scalar;\n    }\n\n    /**\n     * Divide two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the divide of specified complex numbers.\n     */\n    public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2)\n    {\n\n        ComplexNumber conj = ComplexNumber.Conjugate(z2);\n\n        double a = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\n        double b = z1.real * conj.imaginary + (z1.imaginary * conj.real);\n\n        double c = z2.real * conj.real + ((z2.imaginary * conj.imaginary) * -1);\n\n        return new ComplexNumber(a / c, b / c);\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param z1 Complex Number.\n     */\n    public void Divide(ComplexNumber z1)\n    {\n        ComplexNumber conj = ComplexNumber.Conjugate(z1);\n\n        double a = this.real * conj.real + ((this.imaginary * conj.imaginary) * -1);\n        double b = this.real * conj.imaginary + (this.imaginary * conj.real);\n\n        double c = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\n\n        this.real = a / c;\n        this.imaginary = b / c;\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the divide of specified complex number with the scalar value.\n     */\n    public static ComplexNumber Divide(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real / scalar, z1.imaginary / scalar);\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Divide(double scalar)\n    {\n\n        if (scalar == 0)\n        {\n            try\n            {\n                throw new ArithmeticException(\"Can not divide by zero.\");\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n            }\n        }\n\n        this.real /= scalar;\n        this.imaginary /= scalar;\n    }\n\n    /**\n     * Calculate power of a complex number.\n     *\n     * @param z1 Complex Number.\n     * @param n  Power.\n     * @return Returns a new complex number containing the power of a specified number.\n     */\n    public static ComplexNumber Pow(ComplexNumber z1, double n)\n    {\n\n        double norm = Math.pow(z1.getMagnitude(), n);\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(z1.imaginary / z1.real)));\n\n        double common = n * angle;\n\n        double r = norm * Math.cos(Math.toRadians(common));\n        double i = norm * Math.sin(Math.toRadians(common));\n\n        return new ComplexNumber(r, i);\n\n    }\n\n    /**\n     * Calculate power of a complex number.\n     *\n     * @param n Power.\n     */\n    public void Pow(double n)\n    {\n        double norm = Math.pow(getMagnitude(), n);\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(this.imaginary / this.real)));\n\n        double common = n * angle;\n\n        this.real = norm * Math.cos(Math.toRadians(common));\n        this.imaginary = norm * Math.sin(Math.toRadians(common));\n    }\n\n    /**\n     * Calculates natural (base <b>e</b>) logarithm of a complex number.\n     *\n     * @param z1 Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the natural logarithm of the specified complex number.\n     */\n    public static ComplexNumber Log(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if ((z1.real > 0.0) && (z1.imaginary == 0.0))\n        {\n            result.real = Math.log(z1.real);\n            result.imaginary = 0.0;\n        }\n        else if (z1.real == 0.0)\n        {\n            if (z1.imaginary > 0.0)\n            {\n                result.real = Math.log(z1.imaginary);\n                result.imaginary = Math.PI / 2.0;\n            }\n            else\n            {\n                result.real = Math.log(-(z1.imaginary));\n                result.imaginary = -Math.PI / 2.0;\n            }\n        }\n        else\n        {\n            result.real = Math.log(z1.getMagnitude());\n            result.imaginary = Math.atan2(z1.imaginary, z1.real);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates exponent (e raised to the specified power) of a complex number.\n     *\n     * @param z1 A Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the exponent of the specified complex number.\n     */\n    public static ComplexNumber Exp(ComplexNumber z1)\n    {\n        ComplexNumber x, y;\n        x = new ComplexNumber(Math.exp(z1.real), 0.0);\n        y = new ComplexNumber(Math.cos(z1.imaginary), Math.sin(z1.imaginary));\n\n        return Multiply(x, y);\n    }\n\n    /**\n     * Calculates Sine value of the complex number.\n     *\n     * @param z1 A Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the Sine value of the specified complex number.\n     */\n    public static ComplexNumber Sin(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.sin(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            result.real = Math.sin(z1.real) * Math.cosh(z1.imaginary);\n            result.imaginary = Math.cos(z1.real) * Math.sinh(z1.imaginary);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates Cosine value of the complex number.\n     *\n     * @param z1 A ComplexNumber instance.\n     * @return Returns new ComplexNumber instance containing the Cosine value of the specified complex number.\n     */\n    public static ComplexNumber Cos(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.cos(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            result.real = Math.cos(z1.real) * Math.cosh(z1.imaginary);\n            result.imaginary = -Math.sin(z1.real) * Math.sinh(z1.imaginary);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates Tangent value of the complex number.\n     *\n     * @param z1 A ComplexNumber instance.\n     * @return Returns new ComplexNumber instance containing the Tangent value of the specified complex number.\n     */\n    public static ComplexNumber Tan(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.tan(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            double real2 = 2 * z1.real;\n            double imag2 = 2 * z1.imaginary;\n            double denom = Math.cos(real2) + Math.cosh(real2);\n\n            result.real = Math.sin(real2) / denom;\n            result.imaginary = Math.sinh(imag2) / denom;\n        }\n\n        return result;\n    }\n\n    /**\n     * Conjugate this complex number.\n     */\n    public void Conjugate()\n    {\n        this.imaginary *= -1;\n    }\n\n    /**\n     * Conjugate a complex number.\n     *\n     * @param z1 Complex number.\n     * @return Returns new ComplexNumber instance containing the conjugate of the specified complex number.\n     */\n    public static ComplexNumber Conjugate(ComplexNumber z1)\n    {\n        return new ComplexNumber(z1.real, z1.imaginary * -1);\n    }\n\n    @Override\n    public String toString()\n    {\n        if (this.imaginary >= 0)\n            return this.real + \" +\" + this.imaginary + \"i\";\n        return this.real + \" \" + this.imaginary + \"i\";\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/ComplexNumber.java", "func_name": "ComplexNumber.Subtract", "original_string": "public static ComplexNumber Subtract(ComplexNumber z1, double scalar) {\r\n        return new ComplexNumber(z1.real - scalar, z1.imaginary);\r\n    }", "language": "java", "code": "public static ComplexNumber Subtract(ComplexNumber z1, double scalar) {\r\n        return new ComplexNumber(z1.real - scalar, z1.imaginary);\r\n    }", "code_tokens": ["public", "static", "ComplexNumber", "Subtract", "(", "ComplexNumber", "z1", ",", "double", "scalar", ")", "{", "return", "new", "ComplexNumber", "(", "z1", ".", "real", "-", "scalar", ",", "z1", ".", "imaginary", ")", ";", "}"], "docstring": "Subtract a complex number.\n\n@param z1     Complex Number.\n@param scalar Scalar value.\n@return Returns new ComplexNumber instance containing the subtract of specified complex number with a scalar value.", "docstring_tokens": ["Subtract", "a", "complex", "number", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/ComplexNumber.java#L283-L285", "partition": "train", "up_fun_num": 19, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": [], "function": ["public class ComplexNumber\n", "    public double getMagnitude()\n", "    public double getSquaredMagnitude()\n", "    public double getPhase()\n", "    public static double[] getReal(ComplexNumber[] cn)\n", "    public static double[] getImaginary(ComplexNumber[] cn)\n", "    public static double[][] getReal(ComplexNumber[][] cn)\n", "    public static double[][] getImaginary(ComplexNumber[][] cn)\n", "    public static void Swap(ComplexNumber z1)\n", "    public static void Swap(ComplexNumber[] z)\n", "    public static void Swap(ComplexNumber[][] z)\n", "    public static double Abs(ComplexNumber z)\n", "    public static double[] Abs(ComplexNumber[] z)\n", "    public static double[][] Abs(ComplexNumber[][] z)\n", "    public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Add(ComplexNumber z1, double scalar)\n", "    public void Add(double scalar)\n", "    public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2)\n", "    public void Subtract(double scalar)\n", "    public static double Magnitude(ComplexNumber z)\n", "    public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Multiply(ComplexNumber z1, double scalar)\n", "    public void Multiply(double scalar)\n", "    public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2)\n", "    public void Divide(ComplexNumber z1)\n", "    public static ComplexNumber Divide(ComplexNumber z1, double scalar)\n", "    public void Divide(double scalar)\n", "    public static ComplexNumber Pow(ComplexNumber z1, double n)\n", "    public void Pow(double n)\n", "    public static ComplexNumber Log(ComplexNumber z1)\n", "    public static ComplexNumber Exp(ComplexNumber z1)\n", "    public static ComplexNumber Sin(ComplexNumber z1)\n", "    public static ComplexNumber Cos(ComplexNumber z1)\n", "    public static ComplexNumber Tan(ComplexNumber z1)\n", "    public void Conjugate()\n", "    public static ComplexNumber Conjugate(ComplexNumber z1)\n", "    public String toString()\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2005-2009\n// andrew.kirillov@aforgenet.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math;\n\n/**\n * Complex Number.\n *\n * @author Diego Catalano\n */\npublic class ComplexNumber\n{\n\n    /**\n     * Real.\n     */\n    public double real = 0;\n    /**\n     * Imaginary.\n     */\n    public double imaginary = 0;\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     */\n    public ComplexNumber()\n    {\n        this(0, 0);\n    }\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     *\n     * @param real      Real.\n     * @param imaginary Imaginary.\n     */\n    public ComplexNumber(double real, double imaginary)\n    {\n        this.real = real;\n        this.imaginary = imaginary;\n    }\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     *\n     * @param z1 Complex Number.\n     */\n    public ComplexNumber(ComplexNumber z1)\n    {\n        this.real = z1.real;\n        this.imaginary = z1.imaginary;\n    }\n\n    /**\n     * Get Magnitude value of the complex number.\n     *\n     * @return Magnitude.\n     */\n    public double getMagnitude()\n    {\n        return Math.sqrt(real * real + imaginary * imaginary);\n    }\n\n    /**\n     * Get Squared magnitude value of the complex number.\n     *\n     * @return squared magnitude.\n     */\n    public double getSquaredMagnitude()\n    {\n        return real * real + imaginary * imaginary;\n    }\n\n    /**\n     * Get Phase value of the complex number.\n     *\n     * @return Phase value.\n     */\n    public double getPhase()\n    {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Get real part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Real part.\n     */\n    public static double[] getReal(ComplexNumber[] cn)\n    {\n        double[] n = new double[cn.length];\n        for (int i = 0; i < n.length; i++)\n        {\n            n[i] = cn[i].real;\n        }\n        return n;\n    }\n\n    /**\n     * Get imaginary part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Imaginary part.\n     */\n    public static double[] getImaginary(ComplexNumber[] cn)\n    {\n        double[] n = new double[cn.length];\n        for (int i = 0; i < n.length; i++)\n        {\n            n[i] = cn[i].imaginary;\n        }\n        return n;\n    }\n\n    /**\n     * Get real part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Real part.\n     */\n    public static double[][] getReal(ComplexNumber[][] cn)\n    {\n        double[][] n = new double[cn.length][cn[0].length];\n        for (int i = 0; i < n.length; i++)\n        {\n            for (int j = 0; j < n[0].length; j++)\n            {\n                n[i][j] = cn[i][j].real;\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Get imaginary part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Imaginary part.\n     */\n    public static double[][] getImaginary(ComplexNumber[][] cn)\n    {\n        double[][] n = new double[cn.length][cn[0].length];\n        for (int i = 0; i < n.length; i++)\n        {\n            for (int j = 0; j < n[0].length; j++)\n            {\n                n[i][j] = cn[i][j].imaginary;\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z1 Complex number.\n     */\n    public static void Swap(ComplexNumber z1)\n    {\n        double t = z1.real;\n        z1.real = z1.imaginary;\n        z1.imaginary = t;\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z Complex number.\n     */\n    public static void Swap(ComplexNumber[] z)\n    {\n        for (int i = 0; i < z.length; i++)\n        {\n            z[i] = new ComplexNumber(z[i].imaginary, z[i].real);\n        }\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z Complex number.\n     */\n    public static void Swap(ComplexNumber[][] z)\n    {\n        for (int i = 0; i < z.length; i++)\n        {\n            for (int j = 0; j < z[0].length; j++)\n            {\n                z[i][j] = new ComplexNumber(z[i][j].imaginary, z[i][j].real);\n            }\n        }\n    }\n\n    /**\n     * Absolute value of complex number.\n     * Same result like magnitude.\n     *\n     * @param z Complex Number.\n     * @return Absolute number.\n     */\n    public static double Abs(ComplexNumber z)\n    {\n        return Magnitude(z);\n    }\n\n    /**\n     * Absolute value of complex number.\n     *\n     * @param z Complex Numbers.\n     * @return Absolute number.\n     */\n    public static double[] Abs(ComplexNumber[] z)\n    {\n        double[] values = new double[z.length];\n        for (int i = 0; i < values.length; i++)\n        {\n            values[i] = z[i].getMagnitude();\n        }\n        return values;\n    }\n\n    /**\n     * Absolute value of complex number.\n     *\n     * @param z Complex numbers.\n     * @return Absolute number.\n     */\n    public static double[][] Abs(ComplexNumber[][] z)\n    {\n        double[][] values = new double[z.length][z[0].length];\n        for (int i = 0; i < values.length; i++)\n        {\n            for (int j = 0; j < values[0].length; j++)\n            {\n                values[i][j] = z[i][j].getMagnitude();\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Adds two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the sum of specified complex numbers.\n     */\n    public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2)\n    {\n        return new ComplexNumber(z1.real + z2.real, z1.imaginary + z2.imaginary);\n    }\n\n    /**\n     * Adds the complex number with a scalar value.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the add of specified complex number with scalar value.\n     */\n    public static ComplexNumber Add(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real + scalar, z1.imaginary);\n    }\n\n    /**\n     * Adds scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Add(double scalar)\n    {\n        this.real += scalar;\n    }\n\n    /**\n     * Subtract two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the subtract of specified complex numbers.\n     */\n    public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2)\n    {\n        return new ComplexNumber(z1.real - z2.real, z1.imaginary - z2.imaginary);\n    }\n\n    /**\n     * Subtract a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the subtract of specified complex number with a scalar value.\n     */\n\n    /**\n     * Subtracts scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Subtract(double scalar)\n    {\n        this.real -= scalar;\n    }\n\n    /**\n     * Magnitude of complex number.\n     *\n     * @param z Complex number.\n     * @return Magnitude of complex number.\n     */\n    public static double Magnitude(ComplexNumber z)\n    {\n        return Math.sqrt(z.real * z.real + z.imaginary * z.imaginary);\n    }\n\n    /**\n     * Multiply two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the multiply of specified complex numbers.\n     */\n    public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2)\n    {\n        double z1R = z1.real, z1I = z1.imaginary;\n        double z2R = z2.real, z2I = z2.imaginary;\n\n        return new ComplexNumber(z1R * z2R - z1I * z2I, z1R * z2I + z1I * z2R);\n    }\n\n    /**\n     * Multiply scalar value to a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the multiply of specified complex number with the scalar value.\n     */\n    public static ComplexNumber Multiply(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real * scalar, z1.imaginary * scalar);\n    }\n\n    /**\n     * Multiplys scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Multiply(double scalar)\n    {\n        this.real *= scalar;\n        this.imaginary *= scalar;\n    }\n\n    /**\n     * Divide two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the divide of specified complex numbers.\n     */\n    public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2)\n    {\n\n        ComplexNumber conj = ComplexNumber.Conjugate(z2);\n\n        double a = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\n        double b = z1.real * conj.imaginary + (z1.imaginary * conj.real);\n\n        double c = z2.real * conj.real + ((z2.imaginary * conj.imaginary) * -1);\n\n        return new ComplexNumber(a / c, b / c);\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param z1 Complex Number.\n     */\n    public void Divide(ComplexNumber z1)\n    {\n        ComplexNumber conj = ComplexNumber.Conjugate(z1);\n\n        double a = this.real * conj.real + ((this.imaginary * conj.imaginary) * -1);\n        double b = this.real * conj.imaginary + (this.imaginary * conj.real);\n\n        double c = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\n\n        this.real = a / c;\n        this.imaginary = b / c;\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the divide of specified complex number with the scalar value.\n     */\n    public static ComplexNumber Divide(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real / scalar, z1.imaginary / scalar);\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Divide(double scalar)\n    {\n\n        if (scalar == 0)\n        {\n            try\n            {\n                throw new ArithmeticException(\"Can not divide by zero.\");\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n            }\n        }\n\n        this.real /= scalar;\n        this.imaginary /= scalar;\n    }\n\n    /**\n     * Calculate power of a complex number.\n     *\n     * @param z1 Complex Number.\n     * @param n  Power.\n     * @return Returns a new complex number containing the power of a specified number.\n     */\n    public static ComplexNumber Pow(ComplexNumber z1, double n)\n    {\n\n        double norm = Math.pow(z1.getMagnitude(), n);\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(z1.imaginary / z1.real)));\n\n        double common = n * angle;\n\n        double r = norm * Math.cos(Math.toRadians(common));\n        double i = norm * Math.sin(Math.toRadians(common));\n\n        return new ComplexNumber(r, i);\n\n    }\n\n    /**\n     * Calculate power of a complex number.\n     *\n     * @param n Power.\n     */\n    public void Pow(double n)\n    {\n        double norm = Math.pow(getMagnitude(), n);\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(this.imaginary / this.real)));\n\n        double common = n * angle;\n\n        this.real = norm * Math.cos(Math.toRadians(common));\n        this.imaginary = norm * Math.sin(Math.toRadians(common));\n    }\n\n    /**\n     * Calculates natural (base <b>e</b>) logarithm of a complex number.\n     *\n     * @param z1 Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the natural logarithm of the specified complex number.\n     */\n    public static ComplexNumber Log(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if ((z1.real > 0.0) && (z1.imaginary == 0.0))\n        {\n            result.real = Math.log(z1.real);\n            result.imaginary = 0.0;\n        }\n        else if (z1.real == 0.0)\n        {\n            if (z1.imaginary > 0.0)\n            {\n                result.real = Math.log(z1.imaginary);\n                result.imaginary = Math.PI / 2.0;\n            }\n            else\n            {\n                result.real = Math.log(-(z1.imaginary));\n                result.imaginary = -Math.PI / 2.0;\n            }\n        }\n        else\n        {\n            result.real = Math.log(z1.getMagnitude());\n            result.imaginary = Math.atan2(z1.imaginary, z1.real);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates exponent (e raised to the specified power) of a complex number.\n     *\n     * @param z1 A Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the exponent of the specified complex number.\n     */\n    public static ComplexNumber Exp(ComplexNumber z1)\n    {\n        ComplexNumber x, y;\n        x = new ComplexNumber(Math.exp(z1.real), 0.0);\n        y = new ComplexNumber(Math.cos(z1.imaginary), Math.sin(z1.imaginary));\n\n        return Multiply(x, y);\n    }\n\n    /**\n     * Calculates Sine value of the complex number.\n     *\n     * @param z1 A Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the Sine value of the specified complex number.\n     */\n    public static ComplexNumber Sin(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.sin(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            result.real = Math.sin(z1.real) * Math.cosh(z1.imaginary);\n            result.imaginary = Math.cos(z1.real) * Math.sinh(z1.imaginary);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates Cosine value of the complex number.\n     *\n     * @param z1 A ComplexNumber instance.\n     * @return Returns new ComplexNumber instance containing the Cosine value of the specified complex number.\n     */\n    public static ComplexNumber Cos(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.cos(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            result.real = Math.cos(z1.real) * Math.cosh(z1.imaginary);\n            result.imaginary = -Math.sin(z1.real) * Math.sinh(z1.imaginary);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates Tangent value of the complex number.\n     *\n     * @param z1 A ComplexNumber instance.\n     * @return Returns new ComplexNumber instance containing the Tangent value of the specified complex number.\n     */\n    public static ComplexNumber Tan(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.tan(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            double real2 = 2 * z1.real;\n            double imag2 = 2 * z1.imaginary;\n            double denom = Math.cos(real2) + Math.cosh(real2);\n\n            result.real = Math.sin(real2) / denom;\n            result.imaginary = Math.sinh(imag2) / denom;\n        }\n\n        return result;\n    }\n\n    /**\n     * Conjugate this complex number.\n     */\n    public void Conjugate()\n    {\n        this.imaginary *= -1;\n    }\n\n    /**\n     * Conjugate a complex number.\n     *\n     * @param z1 Complex number.\n     * @return Returns new ComplexNumber instance containing the conjugate of the specified complex number.\n     */\n    public static ComplexNumber Conjugate(ComplexNumber z1)\n    {\n        return new ComplexNumber(z1.real, z1.imaginary * -1);\n    }\n\n    @Override\n    public String toString()\n    {\n        if (this.imaginary >= 0)\n            return this.real + \" +\" + this.imaginary + \"i\";\n        return this.real + \" \" + this.imaginary + \"i\";\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/ComplexNumber.java", "func_name": "ComplexNumber.Magnitude", "original_string": "public static double Magnitude(ComplexNumber z) {\r\n        return Math.sqrt(z.real * z.real + z.imaginary * z.imaginary);\r\n    }", "language": "java", "code": "public static double Magnitude(ComplexNumber z) {\r\n        return Math.sqrt(z.real * z.real + z.imaginary * z.imaginary);\r\n    }", "code_tokens": ["public", "static", "double", "Magnitude", "(", "ComplexNumber", "z", ")", "{", "return", "Math", ".", "sqrt", "(", "z", ".", "real", "*", "z", ".", "real", "+", "z", ".", "imaginary", "*", "z", ".", "imaginary", ")", ";", "}"], "docstring": "Magnitude of complex number.\n\n@param z Complex number.\n@return Magnitude of complex number.", "docstring_tokens": ["Magnitude", "of", "complex", "number", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/ComplexNumber.java#L302-L304", "partition": "train", "up_fun_num": 21, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": [], "function": ["public class ComplexNumber\n", "    public double getMagnitude()\n", "    public double getSquaredMagnitude()\n", "    public double getPhase()\n", "    public static double[] getReal(ComplexNumber[] cn)\n", "    public static double[] getImaginary(ComplexNumber[] cn)\n", "    public static double[][] getReal(ComplexNumber[][] cn)\n", "    public static double[][] getImaginary(ComplexNumber[][] cn)\n", "    public static void Swap(ComplexNumber z1)\n", "    public static void Swap(ComplexNumber[] z)\n", "    public static void Swap(ComplexNumber[][] z)\n", "    public static double Abs(ComplexNumber z)\n", "    public static double[] Abs(ComplexNumber[] z)\n", "    public static double[][] Abs(ComplexNumber[][] z)\n", "    public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Add(ComplexNumber z1, double scalar)\n", "    public void Add(double scalar)\n", "    public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Subtract(ComplexNumber z1, double scalar)\n", "    public void Subtract(double scalar)\n", "    public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Multiply(ComplexNumber z1, double scalar)\n", "    public void Multiply(double scalar)\n", "    public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2)\n", "    public void Divide(ComplexNumber z1)\n", "    public static ComplexNumber Divide(ComplexNumber z1, double scalar)\n", "    public void Divide(double scalar)\n", "    public static ComplexNumber Pow(ComplexNumber z1, double n)\n", "    public void Pow(double n)\n", "    public static ComplexNumber Log(ComplexNumber z1)\n", "    public static ComplexNumber Exp(ComplexNumber z1)\n", "    public static ComplexNumber Sin(ComplexNumber z1)\n", "    public static ComplexNumber Cos(ComplexNumber z1)\n", "    public static ComplexNumber Tan(ComplexNumber z1)\n", "    public void Conjugate()\n", "    public static ComplexNumber Conjugate(ComplexNumber z1)\n", "    public String toString()\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2005-2009\n// andrew.kirillov@aforgenet.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math;\n\n/**\n * Complex Number.\n *\n * @author Diego Catalano\n */\npublic class ComplexNumber\n{\n\n    /**\n     * Real.\n     */\n    public double real = 0;\n    /**\n     * Imaginary.\n     */\n    public double imaginary = 0;\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     */\n    public ComplexNumber()\n    {\n        this(0, 0);\n    }\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     *\n     * @param real      Real.\n     * @param imaginary Imaginary.\n     */\n    public ComplexNumber(double real, double imaginary)\n    {\n        this.real = real;\n        this.imaginary = imaginary;\n    }\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     *\n     * @param z1 Complex Number.\n     */\n    public ComplexNumber(ComplexNumber z1)\n    {\n        this.real = z1.real;\n        this.imaginary = z1.imaginary;\n    }\n\n    /**\n     * Get Magnitude value of the complex number.\n     *\n     * @return Magnitude.\n     */\n    public double getMagnitude()\n    {\n        return Math.sqrt(real * real + imaginary * imaginary);\n    }\n\n    /**\n     * Get Squared magnitude value of the complex number.\n     *\n     * @return squared magnitude.\n     */\n    public double getSquaredMagnitude()\n    {\n        return real * real + imaginary * imaginary;\n    }\n\n    /**\n     * Get Phase value of the complex number.\n     *\n     * @return Phase value.\n     */\n    public double getPhase()\n    {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Get real part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Real part.\n     */\n    public static double[] getReal(ComplexNumber[] cn)\n    {\n        double[] n = new double[cn.length];\n        for (int i = 0; i < n.length; i++)\n        {\n            n[i] = cn[i].real;\n        }\n        return n;\n    }\n\n    /**\n     * Get imaginary part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Imaginary part.\n     */\n    public static double[] getImaginary(ComplexNumber[] cn)\n    {\n        double[] n = new double[cn.length];\n        for (int i = 0; i < n.length; i++)\n        {\n            n[i] = cn[i].imaginary;\n        }\n        return n;\n    }\n\n    /**\n     * Get real part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Real part.\n     */\n    public static double[][] getReal(ComplexNumber[][] cn)\n    {\n        double[][] n = new double[cn.length][cn[0].length];\n        for (int i = 0; i < n.length; i++)\n        {\n            for (int j = 0; j < n[0].length; j++)\n            {\n                n[i][j] = cn[i][j].real;\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Get imaginary part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Imaginary part.\n     */\n    public static double[][] getImaginary(ComplexNumber[][] cn)\n    {\n        double[][] n = new double[cn.length][cn[0].length];\n        for (int i = 0; i < n.length; i++)\n        {\n            for (int j = 0; j < n[0].length; j++)\n            {\n                n[i][j] = cn[i][j].imaginary;\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z1 Complex number.\n     */\n    public static void Swap(ComplexNumber z1)\n    {\n        double t = z1.real;\n        z1.real = z1.imaginary;\n        z1.imaginary = t;\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z Complex number.\n     */\n    public static void Swap(ComplexNumber[] z)\n    {\n        for (int i = 0; i < z.length; i++)\n        {\n            z[i] = new ComplexNumber(z[i].imaginary, z[i].real);\n        }\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z Complex number.\n     */\n    public static void Swap(ComplexNumber[][] z)\n    {\n        for (int i = 0; i < z.length; i++)\n        {\n            for (int j = 0; j < z[0].length; j++)\n            {\n                z[i][j] = new ComplexNumber(z[i][j].imaginary, z[i][j].real);\n            }\n        }\n    }\n\n    /**\n     * Absolute value of complex number.\n     * Same result like magnitude.\n     *\n     * @param z Complex Number.\n     * @return Absolute number.\n     */\n    public static double Abs(ComplexNumber z)\n    {\n        return Magnitude(z);\n    }\n\n    /**\n     * Absolute value of complex number.\n     *\n     * @param z Complex Numbers.\n     * @return Absolute number.\n     */\n    public static double[] Abs(ComplexNumber[] z)\n    {\n        double[] values = new double[z.length];\n        for (int i = 0; i < values.length; i++)\n        {\n            values[i] = z[i].getMagnitude();\n        }\n        return values;\n    }\n\n    /**\n     * Absolute value of complex number.\n     *\n     * @param z Complex numbers.\n     * @return Absolute number.\n     */\n    public static double[][] Abs(ComplexNumber[][] z)\n    {\n        double[][] values = new double[z.length][z[0].length];\n        for (int i = 0; i < values.length; i++)\n        {\n            for (int j = 0; j < values[0].length; j++)\n            {\n                values[i][j] = z[i][j].getMagnitude();\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Adds two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the sum of specified complex numbers.\n     */\n    public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2)\n    {\n        return new ComplexNumber(z1.real + z2.real, z1.imaginary + z2.imaginary);\n    }\n\n    /**\n     * Adds the complex number with a scalar value.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the add of specified complex number with scalar value.\n     */\n    public static ComplexNumber Add(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real + scalar, z1.imaginary);\n    }\n\n    /**\n     * Adds scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Add(double scalar)\n    {\n        this.real += scalar;\n    }\n\n    /**\n     * Subtract two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the subtract of specified complex numbers.\n     */\n    public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2)\n    {\n        return new ComplexNumber(z1.real - z2.real, z1.imaginary - z2.imaginary);\n    }\n\n    /**\n     * Subtract a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the subtract of specified complex number with a scalar value.\n     */\n    public static ComplexNumber Subtract(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real - scalar, z1.imaginary);\n    }\n\n    /**\n     * Subtracts scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Subtract(double scalar)\n    {\n        this.real -= scalar;\n    }\n\n    /**\n     * Magnitude of complex number.\n     *\n     * @param z Complex number.\n     * @return Magnitude of complex number.\n     */\n\n    /**\n     * Multiply two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the multiply of specified complex numbers.\n     */\n    public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2)\n    {\n        double z1R = z1.real, z1I = z1.imaginary;\n        double z2R = z2.real, z2I = z2.imaginary;\n\n        return new ComplexNumber(z1R * z2R - z1I * z2I, z1R * z2I + z1I * z2R);\n    }\n\n    /**\n     * Multiply scalar value to a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the multiply of specified complex number with the scalar value.\n     */\n    public static ComplexNumber Multiply(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real * scalar, z1.imaginary * scalar);\n    }\n\n    /**\n     * Multiplys scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Multiply(double scalar)\n    {\n        this.real *= scalar;\n        this.imaginary *= scalar;\n    }\n\n    /**\n     * Divide two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the divide of specified complex numbers.\n     */\n    public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2)\n    {\n\n        ComplexNumber conj = ComplexNumber.Conjugate(z2);\n\n        double a = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\n        double b = z1.real * conj.imaginary + (z1.imaginary * conj.real);\n\n        double c = z2.real * conj.real + ((z2.imaginary * conj.imaginary) * -1);\n\n        return new ComplexNumber(a / c, b / c);\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param z1 Complex Number.\n     */\n    public void Divide(ComplexNumber z1)\n    {\n        ComplexNumber conj = ComplexNumber.Conjugate(z1);\n\n        double a = this.real * conj.real + ((this.imaginary * conj.imaginary) * -1);\n        double b = this.real * conj.imaginary + (this.imaginary * conj.real);\n\n        double c = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\n\n        this.real = a / c;\n        this.imaginary = b / c;\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the divide of specified complex number with the scalar value.\n     */\n    public static ComplexNumber Divide(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real / scalar, z1.imaginary / scalar);\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Divide(double scalar)\n    {\n\n        if (scalar == 0)\n        {\n            try\n            {\n                throw new ArithmeticException(\"Can not divide by zero.\");\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n            }\n        }\n\n        this.real /= scalar;\n        this.imaginary /= scalar;\n    }\n\n    /**\n     * Calculate power of a complex number.\n     *\n     * @param z1 Complex Number.\n     * @param n  Power.\n     * @return Returns a new complex number containing the power of a specified number.\n     */\n    public static ComplexNumber Pow(ComplexNumber z1, double n)\n    {\n\n        double norm = Math.pow(z1.getMagnitude(), n);\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(z1.imaginary / z1.real)));\n\n        double common = n * angle;\n\n        double r = norm * Math.cos(Math.toRadians(common));\n        double i = norm * Math.sin(Math.toRadians(common));\n\n        return new ComplexNumber(r, i);\n\n    }\n\n    /**\n     * Calculate power of a complex number.\n     *\n     * @param n Power.\n     */\n    public void Pow(double n)\n    {\n        double norm = Math.pow(getMagnitude(), n);\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(this.imaginary / this.real)));\n\n        double common = n * angle;\n\n        this.real = norm * Math.cos(Math.toRadians(common));\n        this.imaginary = norm * Math.sin(Math.toRadians(common));\n    }\n\n    /**\n     * Calculates natural (base <b>e</b>) logarithm of a complex number.\n     *\n     * @param z1 Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the natural logarithm of the specified complex number.\n     */\n    public static ComplexNumber Log(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if ((z1.real > 0.0) && (z1.imaginary == 0.0))\n        {\n            result.real = Math.log(z1.real);\n            result.imaginary = 0.0;\n        }\n        else if (z1.real == 0.0)\n        {\n            if (z1.imaginary > 0.0)\n            {\n                result.real = Math.log(z1.imaginary);\n                result.imaginary = Math.PI / 2.0;\n            }\n            else\n            {\n                result.real = Math.log(-(z1.imaginary));\n                result.imaginary = -Math.PI / 2.0;\n            }\n        }\n        else\n        {\n            result.real = Math.log(z1.getMagnitude());\n            result.imaginary = Math.atan2(z1.imaginary, z1.real);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates exponent (e raised to the specified power) of a complex number.\n     *\n     * @param z1 A Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the exponent of the specified complex number.\n     */\n    public static ComplexNumber Exp(ComplexNumber z1)\n    {\n        ComplexNumber x, y;\n        x = new ComplexNumber(Math.exp(z1.real), 0.0);\n        y = new ComplexNumber(Math.cos(z1.imaginary), Math.sin(z1.imaginary));\n\n        return Multiply(x, y);\n    }\n\n    /**\n     * Calculates Sine value of the complex number.\n     *\n     * @param z1 A Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the Sine value of the specified complex number.\n     */\n    public static ComplexNumber Sin(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.sin(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            result.real = Math.sin(z1.real) * Math.cosh(z1.imaginary);\n            result.imaginary = Math.cos(z1.real) * Math.sinh(z1.imaginary);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates Cosine value of the complex number.\n     *\n     * @param z1 A ComplexNumber instance.\n     * @return Returns new ComplexNumber instance containing the Cosine value of the specified complex number.\n     */\n    public static ComplexNumber Cos(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.cos(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            result.real = Math.cos(z1.real) * Math.cosh(z1.imaginary);\n            result.imaginary = -Math.sin(z1.real) * Math.sinh(z1.imaginary);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates Tangent value of the complex number.\n     *\n     * @param z1 A ComplexNumber instance.\n     * @return Returns new ComplexNumber instance containing the Tangent value of the specified complex number.\n     */\n    public static ComplexNumber Tan(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.tan(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            double real2 = 2 * z1.real;\n            double imag2 = 2 * z1.imaginary;\n            double denom = Math.cos(real2) + Math.cosh(real2);\n\n            result.real = Math.sin(real2) / denom;\n            result.imaginary = Math.sinh(imag2) / denom;\n        }\n\n        return result;\n    }\n\n    /**\n     * Conjugate this complex number.\n     */\n    public void Conjugate()\n    {\n        this.imaginary *= -1;\n    }\n\n    /**\n     * Conjugate a complex number.\n     *\n     * @param z1 Complex number.\n     * @return Returns new ComplexNumber instance containing the conjugate of the specified complex number.\n     */\n    public static ComplexNumber Conjugate(ComplexNumber z1)\n    {\n        return new ComplexNumber(z1.real, z1.imaginary * -1);\n    }\n\n    @Override\n    public String toString()\n    {\n        if (this.imaginary >= 0)\n            return this.real + \" +\" + this.imaginary + \"i\";\n        return this.real + \" \" + this.imaginary + \"i\";\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/ComplexNumber.java", "func_name": "ComplexNumber.Multiply", "original_string": "public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2) {\r\n        double z1R = z1.real, z1I = z1.imaginary;\r\n        double z2R = z2.real, z2I = z2.imaginary;\r\n\r\n        return new ComplexNumber(z1R * z2R - z1I * z2I, z1R * z2I + z1I * z2R);\r\n    }", "language": "java", "code": "public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2) {\r\n        double z1R = z1.real, z1I = z1.imaginary;\r\n        double z2R = z2.real, z2I = z2.imaginary;\r\n\r\n        return new ComplexNumber(z1R * z2R - z1I * z2I, z1R * z2I + z1I * z2R);\r\n    }", "code_tokens": ["public", "static", "ComplexNumber", "Multiply", "(", "ComplexNumber", "z1", ",", "ComplexNumber", "z2", ")", "{", "double", "z1R", "=", "z1", ".", "real", ",", "z1I", "=", "z1", ".", "imaginary", ";", "double", "z2R", "=", "z2", ".", "real", ",", "z2I", "=", "z2", ".", "imaginary", ";", "return", "new", "ComplexNumber", "(", "z1R", "*", "z2R", "-", "z1I", "*", "z2I", ",", "z1R", "*", "z2I", "+", "z1I", "*", "z2R", ")", ";", "}"], "docstring": "Multiply two complex numbers.\n\n@param z1 Complex Number.\n@param z2 Complex Number.\n@return Returns new ComplexNumber instance containing the multiply of specified complex numbers.", "docstring_tokens": ["Multiply", "two", "complex", "numbers", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/ComplexNumber.java#L313-L318", "partition": "train", "up_fun_num": 22, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": [], "function": ["public class ComplexNumber\n", "    public double getMagnitude()\n", "    public double getSquaredMagnitude()\n", "    public double getPhase()\n", "    public static double[] getReal(ComplexNumber[] cn)\n", "    public static double[] getImaginary(ComplexNumber[] cn)\n", "    public static double[][] getReal(ComplexNumber[][] cn)\n", "    public static double[][] getImaginary(ComplexNumber[][] cn)\n", "    public static void Swap(ComplexNumber z1)\n", "    public static void Swap(ComplexNumber[] z)\n", "    public static void Swap(ComplexNumber[][] z)\n", "    public static double Abs(ComplexNumber z)\n", "    public static double[] Abs(ComplexNumber[] z)\n", "    public static double[][] Abs(ComplexNumber[][] z)\n", "    public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Add(ComplexNumber z1, double scalar)\n", "    public void Add(double scalar)\n", "    public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Subtract(ComplexNumber z1, double scalar)\n", "    public void Subtract(double scalar)\n", "    public static double Magnitude(ComplexNumber z)\n", "    public static ComplexNumber Multiply(ComplexNumber z1, double scalar)\n", "    public void Multiply(double scalar)\n", "    public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2)\n", "    public void Divide(ComplexNumber z1)\n", "    public static ComplexNumber Divide(ComplexNumber z1, double scalar)\n", "    public void Divide(double scalar)\n", "    public static ComplexNumber Pow(ComplexNumber z1, double n)\n", "    public void Pow(double n)\n", "    public static ComplexNumber Log(ComplexNumber z1)\n", "    public static ComplexNumber Exp(ComplexNumber z1)\n", "    public static ComplexNumber Sin(ComplexNumber z1)\n", "    public static ComplexNumber Cos(ComplexNumber z1)\n", "    public static ComplexNumber Tan(ComplexNumber z1)\n", "    public void Conjugate()\n", "    public static ComplexNumber Conjugate(ComplexNumber z1)\n", "    public String toString()\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2005-2009\n// andrew.kirillov@aforgenet.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math;\n\n/**\n * Complex Number.\n *\n * @author Diego Catalano\n */\npublic class ComplexNumber\n{\n\n    /**\n     * Real.\n     */\n    public double real = 0;\n    /**\n     * Imaginary.\n     */\n    public double imaginary = 0;\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     */\n    public ComplexNumber()\n    {\n        this(0, 0);\n    }\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     *\n     * @param real      Real.\n     * @param imaginary Imaginary.\n     */\n    public ComplexNumber(double real, double imaginary)\n    {\n        this.real = real;\n        this.imaginary = imaginary;\n    }\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     *\n     * @param z1 Complex Number.\n     */\n    public ComplexNumber(ComplexNumber z1)\n    {\n        this.real = z1.real;\n        this.imaginary = z1.imaginary;\n    }\n\n    /**\n     * Get Magnitude value of the complex number.\n     *\n     * @return Magnitude.\n     */\n    public double getMagnitude()\n    {\n        return Math.sqrt(real * real + imaginary * imaginary);\n    }\n\n    /**\n     * Get Squared magnitude value of the complex number.\n     *\n     * @return squared magnitude.\n     */\n    public double getSquaredMagnitude()\n    {\n        return real * real + imaginary * imaginary;\n    }\n\n    /**\n     * Get Phase value of the complex number.\n     *\n     * @return Phase value.\n     */\n    public double getPhase()\n    {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Get real part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Real part.\n     */\n    public static double[] getReal(ComplexNumber[] cn)\n    {\n        double[] n = new double[cn.length];\n        for (int i = 0; i < n.length; i++)\n        {\n            n[i] = cn[i].real;\n        }\n        return n;\n    }\n\n    /**\n     * Get imaginary part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Imaginary part.\n     */\n    public static double[] getImaginary(ComplexNumber[] cn)\n    {\n        double[] n = new double[cn.length];\n        for (int i = 0; i < n.length; i++)\n        {\n            n[i] = cn[i].imaginary;\n        }\n        return n;\n    }\n\n    /**\n     * Get real part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Real part.\n     */\n    public static double[][] getReal(ComplexNumber[][] cn)\n    {\n        double[][] n = new double[cn.length][cn[0].length];\n        for (int i = 0; i < n.length; i++)\n        {\n            for (int j = 0; j < n[0].length; j++)\n            {\n                n[i][j] = cn[i][j].real;\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Get imaginary part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Imaginary part.\n     */\n    public static double[][] getImaginary(ComplexNumber[][] cn)\n    {\n        double[][] n = new double[cn.length][cn[0].length];\n        for (int i = 0; i < n.length; i++)\n        {\n            for (int j = 0; j < n[0].length; j++)\n            {\n                n[i][j] = cn[i][j].imaginary;\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z1 Complex number.\n     */\n    public static void Swap(ComplexNumber z1)\n    {\n        double t = z1.real;\n        z1.real = z1.imaginary;\n        z1.imaginary = t;\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z Complex number.\n     */\n    public static void Swap(ComplexNumber[] z)\n    {\n        for (int i = 0; i < z.length; i++)\n        {\n            z[i] = new ComplexNumber(z[i].imaginary, z[i].real);\n        }\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z Complex number.\n     */\n    public static void Swap(ComplexNumber[][] z)\n    {\n        for (int i = 0; i < z.length; i++)\n        {\n            for (int j = 0; j < z[0].length; j++)\n            {\n                z[i][j] = new ComplexNumber(z[i][j].imaginary, z[i][j].real);\n            }\n        }\n    }\n\n    /**\n     * Absolute value of complex number.\n     * Same result like magnitude.\n     *\n     * @param z Complex Number.\n     * @return Absolute number.\n     */\n    public static double Abs(ComplexNumber z)\n    {\n        return Magnitude(z);\n    }\n\n    /**\n     * Absolute value of complex number.\n     *\n     * @param z Complex Numbers.\n     * @return Absolute number.\n     */\n    public static double[] Abs(ComplexNumber[] z)\n    {\n        double[] values = new double[z.length];\n        for (int i = 0; i < values.length; i++)\n        {\n            values[i] = z[i].getMagnitude();\n        }\n        return values;\n    }\n\n    /**\n     * Absolute value of complex number.\n     *\n     * @param z Complex numbers.\n     * @return Absolute number.\n     */\n    public static double[][] Abs(ComplexNumber[][] z)\n    {\n        double[][] values = new double[z.length][z[0].length];\n        for (int i = 0; i < values.length; i++)\n        {\n            for (int j = 0; j < values[0].length; j++)\n            {\n                values[i][j] = z[i][j].getMagnitude();\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Adds two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the sum of specified complex numbers.\n     */\n    public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2)\n    {\n        return new ComplexNumber(z1.real + z2.real, z1.imaginary + z2.imaginary);\n    }\n\n    /**\n     * Adds the complex number with a scalar value.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the add of specified complex number with scalar value.\n     */\n    public static ComplexNumber Add(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real + scalar, z1.imaginary);\n    }\n\n    /**\n     * Adds scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Add(double scalar)\n    {\n        this.real += scalar;\n    }\n\n    /**\n     * Subtract two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the subtract of specified complex numbers.\n     */\n    public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2)\n    {\n        return new ComplexNumber(z1.real - z2.real, z1.imaginary - z2.imaginary);\n    }\n\n    /**\n     * Subtract a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the subtract of specified complex number with a scalar value.\n     */\n    public static ComplexNumber Subtract(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real - scalar, z1.imaginary);\n    }\n\n    /**\n     * Subtracts scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Subtract(double scalar)\n    {\n        this.real -= scalar;\n    }\n\n    /**\n     * Magnitude of complex number.\n     *\n     * @param z Complex number.\n     * @return Magnitude of complex number.\n     */\n    public static double Magnitude(ComplexNumber z)\n    {\n        return Math.sqrt(z.real * z.real + z.imaginary * z.imaginary);\n    }\n\n    /**\n     * Multiply two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the multiply of specified complex numbers.\n     */\n\n    /**\n     * Multiply scalar value to a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the multiply of specified complex number with the scalar value.\n     */\n    public static ComplexNumber Multiply(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real * scalar, z1.imaginary * scalar);\n    }\n\n    /**\n     * Multiplys scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Multiply(double scalar)\n    {\n        this.real *= scalar;\n        this.imaginary *= scalar;\n    }\n\n    /**\n     * Divide two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the divide of specified complex numbers.\n     */\n    public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2)\n    {\n\n        ComplexNumber conj = ComplexNumber.Conjugate(z2);\n\n        double a = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\n        double b = z1.real * conj.imaginary + (z1.imaginary * conj.real);\n\n        double c = z2.real * conj.real + ((z2.imaginary * conj.imaginary) * -1);\n\n        return new ComplexNumber(a / c, b / c);\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param z1 Complex Number.\n     */\n    public void Divide(ComplexNumber z1)\n    {\n        ComplexNumber conj = ComplexNumber.Conjugate(z1);\n\n        double a = this.real * conj.real + ((this.imaginary * conj.imaginary) * -1);\n        double b = this.real * conj.imaginary + (this.imaginary * conj.real);\n\n        double c = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\n\n        this.real = a / c;\n        this.imaginary = b / c;\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the divide of specified complex number with the scalar value.\n     */\n    public static ComplexNumber Divide(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real / scalar, z1.imaginary / scalar);\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Divide(double scalar)\n    {\n\n        if (scalar == 0)\n        {\n            try\n            {\n                throw new ArithmeticException(\"Can not divide by zero.\");\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n            }\n        }\n\n        this.real /= scalar;\n        this.imaginary /= scalar;\n    }\n\n    /**\n     * Calculate power of a complex number.\n     *\n     * @param z1 Complex Number.\n     * @param n  Power.\n     * @return Returns a new complex number containing the power of a specified number.\n     */\n    public static ComplexNumber Pow(ComplexNumber z1, double n)\n    {\n\n        double norm = Math.pow(z1.getMagnitude(), n);\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(z1.imaginary / z1.real)));\n\n        double common = n * angle;\n\n        double r = norm * Math.cos(Math.toRadians(common));\n        double i = norm * Math.sin(Math.toRadians(common));\n\n        return new ComplexNumber(r, i);\n\n    }\n\n    /**\n     * Calculate power of a complex number.\n     *\n     * @param n Power.\n     */\n    public void Pow(double n)\n    {\n        double norm = Math.pow(getMagnitude(), n);\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(this.imaginary / this.real)));\n\n        double common = n * angle;\n\n        this.real = norm * Math.cos(Math.toRadians(common));\n        this.imaginary = norm * Math.sin(Math.toRadians(common));\n    }\n\n    /**\n     * Calculates natural (base <b>e</b>) logarithm of a complex number.\n     *\n     * @param z1 Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the natural logarithm of the specified complex number.\n     */\n    public static ComplexNumber Log(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if ((z1.real > 0.0) && (z1.imaginary == 0.0))\n        {\n            result.real = Math.log(z1.real);\n            result.imaginary = 0.0;\n        }\n        else if (z1.real == 0.0)\n        {\n            if (z1.imaginary > 0.0)\n            {\n                result.real = Math.log(z1.imaginary);\n                result.imaginary = Math.PI / 2.0;\n            }\n            else\n            {\n                result.real = Math.log(-(z1.imaginary));\n                result.imaginary = -Math.PI / 2.0;\n            }\n        }\n        else\n        {\n            result.real = Math.log(z1.getMagnitude());\n            result.imaginary = Math.atan2(z1.imaginary, z1.real);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates exponent (e raised to the specified power) of a complex number.\n     *\n     * @param z1 A Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the exponent of the specified complex number.\n     */\n    public static ComplexNumber Exp(ComplexNumber z1)\n    {\n        ComplexNumber x, y;\n        x = new ComplexNumber(Math.exp(z1.real), 0.0);\n        y = new ComplexNumber(Math.cos(z1.imaginary), Math.sin(z1.imaginary));\n\n        return Multiply(x, y);\n    }\n\n    /**\n     * Calculates Sine value of the complex number.\n     *\n     * @param z1 A Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the Sine value of the specified complex number.\n     */\n    public static ComplexNumber Sin(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.sin(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            result.real = Math.sin(z1.real) * Math.cosh(z1.imaginary);\n            result.imaginary = Math.cos(z1.real) * Math.sinh(z1.imaginary);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates Cosine value of the complex number.\n     *\n     * @param z1 A ComplexNumber instance.\n     * @return Returns new ComplexNumber instance containing the Cosine value of the specified complex number.\n     */\n    public static ComplexNumber Cos(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.cos(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            result.real = Math.cos(z1.real) * Math.cosh(z1.imaginary);\n            result.imaginary = -Math.sin(z1.real) * Math.sinh(z1.imaginary);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates Tangent value of the complex number.\n     *\n     * @param z1 A ComplexNumber instance.\n     * @return Returns new ComplexNumber instance containing the Tangent value of the specified complex number.\n     */\n    public static ComplexNumber Tan(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.tan(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            double real2 = 2 * z1.real;\n            double imag2 = 2 * z1.imaginary;\n            double denom = Math.cos(real2) + Math.cosh(real2);\n\n            result.real = Math.sin(real2) / denom;\n            result.imaginary = Math.sinh(imag2) / denom;\n        }\n\n        return result;\n    }\n\n    /**\n     * Conjugate this complex number.\n     */\n    public void Conjugate()\n    {\n        this.imaginary *= -1;\n    }\n\n    /**\n     * Conjugate a complex number.\n     *\n     * @param z1 Complex number.\n     * @return Returns new ComplexNumber instance containing the conjugate of the specified complex number.\n     */\n    public static ComplexNumber Conjugate(ComplexNumber z1)\n    {\n        return new ComplexNumber(z1.real, z1.imaginary * -1);\n    }\n\n    @Override\n    public String toString()\n    {\n        if (this.imaginary >= 0)\n            return this.real + \" +\" + this.imaginary + \"i\";\n        return this.real + \" \" + this.imaginary + \"i\";\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/ComplexNumber.java", "func_name": "ComplexNumber.Multiply", "original_string": "public static ComplexNumber Multiply(ComplexNumber z1, double scalar) {\r\n        return new ComplexNumber(z1.real * scalar, z1.imaginary * scalar);\r\n    }", "language": "java", "code": "public static ComplexNumber Multiply(ComplexNumber z1, double scalar) {\r\n        return new ComplexNumber(z1.real * scalar, z1.imaginary * scalar);\r\n    }", "code_tokens": ["public", "static", "ComplexNumber", "Multiply", "(", "ComplexNumber", "z1", ",", "double", "scalar", ")", "{", "return", "new", "ComplexNumber", "(", "z1", ".", "real", "*", "scalar", ",", "z1", ".", "imaginary", "*", "scalar", ")", ";", "}"], "docstring": "Multiply scalar value to a complex number.\n\n@param z1     Complex Number.\n@param scalar Scalar value.\n@return Returns new ComplexNumber instance containing the multiply of specified complex number with the scalar value.", "docstring_tokens": ["Multiply", "scalar", "value", "to", "a", "complex", "number", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/ComplexNumber.java#L327-L329", "partition": "train", "up_fun_num": 23, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": [], "function": ["public class ComplexNumber\n", "    public double getMagnitude()\n", "    public double getSquaredMagnitude()\n", "    public double getPhase()\n", "    public static double[] getReal(ComplexNumber[] cn)\n", "    public static double[] getImaginary(ComplexNumber[] cn)\n", "    public static double[][] getReal(ComplexNumber[][] cn)\n", "    public static double[][] getImaginary(ComplexNumber[][] cn)\n", "    public static void Swap(ComplexNumber z1)\n", "    public static void Swap(ComplexNumber[] z)\n", "    public static void Swap(ComplexNumber[][] z)\n", "    public static double Abs(ComplexNumber z)\n", "    public static double[] Abs(ComplexNumber[] z)\n", "    public static double[][] Abs(ComplexNumber[][] z)\n", "    public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Add(ComplexNumber z1, double scalar)\n", "    public void Add(double scalar)\n", "    public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Subtract(ComplexNumber z1, double scalar)\n", "    public void Subtract(double scalar)\n", "    public static double Magnitude(ComplexNumber z)\n", "    public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2)\n", "    public void Multiply(double scalar)\n", "    public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2)\n", "    public void Divide(ComplexNumber z1)\n", "    public static ComplexNumber Divide(ComplexNumber z1, double scalar)\n", "    public void Divide(double scalar)\n", "    public static ComplexNumber Pow(ComplexNumber z1, double n)\n", "    public void Pow(double n)\n", "    public static ComplexNumber Log(ComplexNumber z1)\n", "    public static ComplexNumber Exp(ComplexNumber z1)\n", "    public static ComplexNumber Sin(ComplexNumber z1)\n", "    public static ComplexNumber Cos(ComplexNumber z1)\n", "    public static ComplexNumber Tan(ComplexNumber z1)\n", "    public void Conjugate()\n", "    public static ComplexNumber Conjugate(ComplexNumber z1)\n", "    public String toString()\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2005-2009\n// andrew.kirillov@aforgenet.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math;\n\n/**\n * Complex Number.\n *\n * @author Diego Catalano\n */\npublic class ComplexNumber\n{\n\n    /**\n     * Real.\n     */\n    public double real = 0;\n    /**\n     * Imaginary.\n     */\n    public double imaginary = 0;\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     */\n    public ComplexNumber()\n    {\n        this(0, 0);\n    }\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     *\n     * @param real      Real.\n     * @param imaginary Imaginary.\n     */\n    public ComplexNumber(double real, double imaginary)\n    {\n        this.real = real;\n        this.imaginary = imaginary;\n    }\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     *\n     * @param z1 Complex Number.\n     */\n    public ComplexNumber(ComplexNumber z1)\n    {\n        this.real = z1.real;\n        this.imaginary = z1.imaginary;\n    }\n\n    /**\n     * Get Magnitude value of the complex number.\n     *\n     * @return Magnitude.\n     */\n    public double getMagnitude()\n    {\n        return Math.sqrt(real * real + imaginary * imaginary);\n    }\n\n    /**\n     * Get Squared magnitude value of the complex number.\n     *\n     * @return squared magnitude.\n     */\n    public double getSquaredMagnitude()\n    {\n        return real * real + imaginary * imaginary;\n    }\n\n    /**\n     * Get Phase value of the complex number.\n     *\n     * @return Phase value.\n     */\n    public double getPhase()\n    {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Get real part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Real part.\n     */\n    public static double[] getReal(ComplexNumber[] cn)\n    {\n        double[] n = new double[cn.length];\n        for (int i = 0; i < n.length; i++)\n        {\n            n[i] = cn[i].real;\n        }\n        return n;\n    }\n\n    /**\n     * Get imaginary part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Imaginary part.\n     */\n    public static double[] getImaginary(ComplexNumber[] cn)\n    {\n        double[] n = new double[cn.length];\n        for (int i = 0; i < n.length; i++)\n        {\n            n[i] = cn[i].imaginary;\n        }\n        return n;\n    }\n\n    /**\n     * Get real part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Real part.\n     */\n    public static double[][] getReal(ComplexNumber[][] cn)\n    {\n        double[][] n = new double[cn.length][cn[0].length];\n        for (int i = 0; i < n.length; i++)\n        {\n            for (int j = 0; j < n[0].length; j++)\n            {\n                n[i][j] = cn[i][j].real;\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Get imaginary part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Imaginary part.\n     */\n    public static double[][] getImaginary(ComplexNumber[][] cn)\n    {\n        double[][] n = new double[cn.length][cn[0].length];\n        for (int i = 0; i < n.length; i++)\n        {\n            for (int j = 0; j < n[0].length; j++)\n            {\n                n[i][j] = cn[i][j].imaginary;\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z1 Complex number.\n     */\n    public static void Swap(ComplexNumber z1)\n    {\n        double t = z1.real;\n        z1.real = z1.imaginary;\n        z1.imaginary = t;\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z Complex number.\n     */\n    public static void Swap(ComplexNumber[] z)\n    {\n        for (int i = 0; i < z.length; i++)\n        {\n            z[i] = new ComplexNumber(z[i].imaginary, z[i].real);\n        }\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z Complex number.\n     */\n    public static void Swap(ComplexNumber[][] z)\n    {\n        for (int i = 0; i < z.length; i++)\n        {\n            for (int j = 0; j < z[0].length; j++)\n            {\n                z[i][j] = new ComplexNumber(z[i][j].imaginary, z[i][j].real);\n            }\n        }\n    }\n\n    /**\n     * Absolute value of complex number.\n     * Same result like magnitude.\n     *\n     * @param z Complex Number.\n     * @return Absolute number.\n     */\n    public static double Abs(ComplexNumber z)\n    {\n        return Magnitude(z);\n    }\n\n    /**\n     * Absolute value of complex number.\n     *\n     * @param z Complex Numbers.\n     * @return Absolute number.\n     */\n    public static double[] Abs(ComplexNumber[] z)\n    {\n        double[] values = new double[z.length];\n        for (int i = 0; i < values.length; i++)\n        {\n            values[i] = z[i].getMagnitude();\n        }\n        return values;\n    }\n\n    /**\n     * Absolute value of complex number.\n     *\n     * @param z Complex numbers.\n     * @return Absolute number.\n     */\n    public static double[][] Abs(ComplexNumber[][] z)\n    {\n        double[][] values = new double[z.length][z[0].length];\n        for (int i = 0; i < values.length; i++)\n        {\n            for (int j = 0; j < values[0].length; j++)\n            {\n                values[i][j] = z[i][j].getMagnitude();\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Adds two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the sum of specified complex numbers.\n     */\n    public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2)\n    {\n        return new ComplexNumber(z1.real + z2.real, z1.imaginary + z2.imaginary);\n    }\n\n    /**\n     * Adds the complex number with a scalar value.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the add of specified complex number with scalar value.\n     */\n    public static ComplexNumber Add(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real + scalar, z1.imaginary);\n    }\n\n    /**\n     * Adds scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Add(double scalar)\n    {\n        this.real += scalar;\n    }\n\n    /**\n     * Subtract two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the subtract of specified complex numbers.\n     */\n    public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2)\n    {\n        return new ComplexNumber(z1.real - z2.real, z1.imaginary - z2.imaginary);\n    }\n\n    /**\n     * Subtract a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the subtract of specified complex number with a scalar value.\n     */\n    public static ComplexNumber Subtract(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real - scalar, z1.imaginary);\n    }\n\n    /**\n     * Subtracts scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Subtract(double scalar)\n    {\n        this.real -= scalar;\n    }\n\n    /**\n     * Magnitude of complex number.\n     *\n     * @param z Complex number.\n     * @return Magnitude of complex number.\n     */\n    public static double Magnitude(ComplexNumber z)\n    {\n        return Math.sqrt(z.real * z.real + z.imaginary * z.imaginary);\n    }\n\n    /**\n     * Multiply two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the multiply of specified complex numbers.\n     */\n    public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2)\n    {\n        double z1R = z1.real, z1I = z1.imaginary;\n        double z2R = z2.real, z2I = z2.imaginary;\n\n        return new ComplexNumber(z1R * z2R - z1I * z2I, z1R * z2I + z1I * z2R);\n    }\n\n    /**\n     * Multiply scalar value to a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the multiply of specified complex number with the scalar value.\n     */\n\n    /**\n     * Multiplys scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Multiply(double scalar)\n    {\n        this.real *= scalar;\n        this.imaginary *= scalar;\n    }\n\n    /**\n     * Divide two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the divide of specified complex numbers.\n     */\n    public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2)\n    {\n\n        ComplexNumber conj = ComplexNumber.Conjugate(z2);\n\n        double a = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\n        double b = z1.real * conj.imaginary + (z1.imaginary * conj.real);\n\n        double c = z2.real * conj.real + ((z2.imaginary * conj.imaginary) * -1);\n\n        return new ComplexNumber(a / c, b / c);\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param z1 Complex Number.\n     */\n    public void Divide(ComplexNumber z1)\n    {\n        ComplexNumber conj = ComplexNumber.Conjugate(z1);\n\n        double a = this.real * conj.real + ((this.imaginary * conj.imaginary) * -1);\n        double b = this.real * conj.imaginary + (this.imaginary * conj.real);\n\n        double c = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\n\n        this.real = a / c;\n        this.imaginary = b / c;\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the divide of specified complex number with the scalar value.\n     */\n    public static ComplexNumber Divide(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real / scalar, z1.imaginary / scalar);\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Divide(double scalar)\n    {\n\n        if (scalar == 0)\n        {\n            try\n            {\n                throw new ArithmeticException(\"Can not divide by zero.\");\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n            }\n        }\n\n        this.real /= scalar;\n        this.imaginary /= scalar;\n    }\n\n    /**\n     * Calculate power of a complex number.\n     *\n     * @param z1 Complex Number.\n     * @param n  Power.\n     * @return Returns a new complex number containing the power of a specified number.\n     */\n    public static ComplexNumber Pow(ComplexNumber z1, double n)\n    {\n\n        double norm = Math.pow(z1.getMagnitude(), n);\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(z1.imaginary / z1.real)));\n\n        double common = n * angle;\n\n        double r = norm * Math.cos(Math.toRadians(common));\n        double i = norm * Math.sin(Math.toRadians(common));\n\n        return new ComplexNumber(r, i);\n\n    }\n\n    /**\n     * Calculate power of a complex number.\n     *\n     * @param n Power.\n     */\n    public void Pow(double n)\n    {\n        double norm = Math.pow(getMagnitude(), n);\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(this.imaginary / this.real)));\n\n        double common = n * angle;\n\n        this.real = norm * Math.cos(Math.toRadians(common));\n        this.imaginary = norm * Math.sin(Math.toRadians(common));\n    }\n\n    /**\n     * Calculates natural (base <b>e</b>) logarithm of a complex number.\n     *\n     * @param z1 Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the natural logarithm of the specified complex number.\n     */\n    public static ComplexNumber Log(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if ((z1.real > 0.0) && (z1.imaginary == 0.0))\n        {\n            result.real = Math.log(z1.real);\n            result.imaginary = 0.0;\n        }\n        else if (z1.real == 0.0)\n        {\n            if (z1.imaginary > 0.0)\n            {\n                result.real = Math.log(z1.imaginary);\n                result.imaginary = Math.PI / 2.0;\n            }\n            else\n            {\n                result.real = Math.log(-(z1.imaginary));\n                result.imaginary = -Math.PI / 2.0;\n            }\n        }\n        else\n        {\n            result.real = Math.log(z1.getMagnitude());\n            result.imaginary = Math.atan2(z1.imaginary, z1.real);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates exponent (e raised to the specified power) of a complex number.\n     *\n     * @param z1 A Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the exponent of the specified complex number.\n     */\n    public static ComplexNumber Exp(ComplexNumber z1)\n    {\n        ComplexNumber x, y;\n        x = new ComplexNumber(Math.exp(z1.real), 0.0);\n        y = new ComplexNumber(Math.cos(z1.imaginary), Math.sin(z1.imaginary));\n\n        return Multiply(x, y);\n    }\n\n    /**\n     * Calculates Sine value of the complex number.\n     *\n     * @param z1 A Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the Sine value of the specified complex number.\n     */\n    public static ComplexNumber Sin(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.sin(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            result.real = Math.sin(z1.real) * Math.cosh(z1.imaginary);\n            result.imaginary = Math.cos(z1.real) * Math.sinh(z1.imaginary);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates Cosine value of the complex number.\n     *\n     * @param z1 A ComplexNumber instance.\n     * @return Returns new ComplexNumber instance containing the Cosine value of the specified complex number.\n     */\n    public static ComplexNumber Cos(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.cos(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            result.real = Math.cos(z1.real) * Math.cosh(z1.imaginary);\n            result.imaginary = -Math.sin(z1.real) * Math.sinh(z1.imaginary);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates Tangent value of the complex number.\n     *\n     * @param z1 A ComplexNumber instance.\n     * @return Returns new ComplexNumber instance containing the Tangent value of the specified complex number.\n     */\n    public static ComplexNumber Tan(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.tan(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            double real2 = 2 * z1.real;\n            double imag2 = 2 * z1.imaginary;\n            double denom = Math.cos(real2) + Math.cosh(real2);\n\n            result.real = Math.sin(real2) / denom;\n            result.imaginary = Math.sinh(imag2) / denom;\n        }\n\n        return result;\n    }\n\n    /**\n     * Conjugate this complex number.\n     */\n    public void Conjugate()\n    {\n        this.imaginary *= -1;\n    }\n\n    /**\n     * Conjugate a complex number.\n     *\n     * @param z1 Complex number.\n     * @return Returns new ComplexNumber instance containing the conjugate of the specified complex number.\n     */\n    public static ComplexNumber Conjugate(ComplexNumber z1)\n    {\n        return new ComplexNumber(z1.real, z1.imaginary * -1);\n    }\n\n    @Override\n    public String toString()\n    {\n        if (this.imaginary >= 0)\n            return this.real + \" +\" + this.imaginary + \"i\";\n        return this.real + \" \" + this.imaginary + \"i\";\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/ComplexNumber.java", "func_name": "ComplexNumber.Divide", "original_string": "public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2) {\r\n\r\n        ComplexNumber conj = ComplexNumber.Conjugate(z2);\r\n\r\n        double a = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\r\n        double b = z1.real * conj.imaginary + (z1.imaginary * conj.real);\r\n\r\n        double c = z2.real * conj.real + ((z2.imaginary * conj.imaginary) * -1);\r\n\r\n        return new ComplexNumber(a / c, b / c);\r\n    }", "language": "java", "code": "public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2) {\r\n\r\n        ComplexNumber conj = ComplexNumber.Conjugate(z2);\r\n\r\n        double a = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\r\n        double b = z1.real * conj.imaginary + (z1.imaginary * conj.real);\r\n\r\n        double c = z2.real * conj.real + ((z2.imaginary * conj.imaginary) * -1);\r\n\r\n        return new ComplexNumber(a / c, b / c);\r\n    }", "code_tokens": ["public", "static", "ComplexNumber", "Divide", "(", "ComplexNumber", "z1", ",", "ComplexNumber", "z2", ")", "{", "ComplexNumber", "conj", "=", "ComplexNumber", ".", "Conjugate", "(", "z2", ")", ";", "double", "a", "=", "z1", ".", "real", "*", "conj", ".", "real", "+", "(", "(", "z1", ".", "imaginary", "*", "conj", ".", "imaginary", ")", "*", "-", "1", ")", ";", "double", "b", "=", "z1", ".", "real", "*", "conj", ".", "imaginary", "+", "(", "z1", ".", "imaginary", "*", "conj", ".", "real", ")", ";", "double", "c", "=", "z2", ".", "real", "*", "conj", ".", "real", "+", "(", "(", "z2", ".", "imaginary", "*", "conj", ".", "imaginary", ")", "*", "-", "1", ")", ";", "return", "new", "ComplexNumber", "(", "a", "/", "c", ",", "b", "/", "c", ")", ";", "}"], "docstring": "Divide two complex numbers.\n\n@param z1 Complex Number.\n@param z2 Complex Number.\n@return Returns new ComplexNumber instance containing the divide of specified complex numbers.", "docstring_tokens": ["Divide", "two", "complex", "numbers", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/ComplexNumber.java#L348-L358", "partition": "train", "up_fun_num": 25, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": [], "function": ["public class ComplexNumber\n", "    public double getMagnitude()\n", "    public double getSquaredMagnitude()\n", "    public double getPhase()\n", "    public static double[] getReal(ComplexNumber[] cn)\n", "    public static double[] getImaginary(ComplexNumber[] cn)\n", "    public static double[][] getReal(ComplexNumber[][] cn)\n", "    public static double[][] getImaginary(ComplexNumber[][] cn)\n", "    public static void Swap(ComplexNumber z1)\n", "    public static void Swap(ComplexNumber[] z)\n", "    public static void Swap(ComplexNumber[][] z)\n", "    public static double Abs(ComplexNumber z)\n", "    public static double[] Abs(ComplexNumber[] z)\n", "    public static double[][] Abs(ComplexNumber[][] z)\n", "    public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Add(ComplexNumber z1, double scalar)\n", "    public void Add(double scalar)\n", "    public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Subtract(ComplexNumber z1, double scalar)\n", "    public void Subtract(double scalar)\n", "    public static double Magnitude(ComplexNumber z)\n", "    public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Multiply(ComplexNumber z1, double scalar)\n", "    public void Multiply(double scalar)\n", "    public void Divide(ComplexNumber z1)\n", "    public static ComplexNumber Divide(ComplexNumber z1, double scalar)\n", "    public void Divide(double scalar)\n", "    public static ComplexNumber Pow(ComplexNumber z1, double n)\n", "    public void Pow(double n)\n", "    public static ComplexNumber Log(ComplexNumber z1)\n", "    public static ComplexNumber Exp(ComplexNumber z1)\n", "    public static ComplexNumber Sin(ComplexNumber z1)\n", "    public static ComplexNumber Cos(ComplexNumber z1)\n", "    public static ComplexNumber Tan(ComplexNumber z1)\n", "    public void Conjugate()\n", "    public static ComplexNumber Conjugate(ComplexNumber z1)\n", "    public String toString()\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2005-2009\n// andrew.kirillov@aforgenet.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math;\n\n/**\n * Complex Number.\n *\n * @author Diego Catalano\n */\npublic class ComplexNumber\n{\n\n    /**\n     * Real.\n     */\n    public double real = 0;\n    /**\n     * Imaginary.\n     */\n    public double imaginary = 0;\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     */\n    public ComplexNumber()\n    {\n        this(0, 0);\n    }\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     *\n     * @param real      Real.\n     * @param imaginary Imaginary.\n     */\n    public ComplexNumber(double real, double imaginary)\n    {\n        this.real = real;\n        this.imaginary = imaginary;\n    }\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     *\n     * @param z1 Complex Number.\n     */\n    public ComplexNumber(ComplexNumber z1)\n    {\n        this.real = z1.real;\n        this.imaginary = z1.imaginary;\n    }\n\n    /**\n     * Get Magnitude value of the complex number.\n     *\n     * @return Magnitude.\n     */\n    public double getMagnitude()\n    {\n        return Math.sqrt(real * real + imaginary * imaginary);\n    }\n\n    /**\n     * Get Squared magnitude value of the complex number.\n     *\n     * @return squared magnitude.\n     */\n    public double getSquaredMagnitude()\n    {\n        return real * real + imaginary * imaginary;\n    }\n\n    /**\n     * Get Phase value of the complex number.\n     *\n     * @return Phase value.\n     */\n    public double getPhase()\n    {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Get real part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Real part.\n     */\n    public static double[] getReal(ComplexNumber[] cn)\n    {\n        double[] n = new double[cn.length];\n        for (int i = 0; i < n.length; i++)\n        {\n            n[i] = cn[i].real;\n        }\n        return n;\n    }\n\n    /**\n     * Get imaginary part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Imaginary part.\n     */\n    public static double[] getImaginary(ComplexNumber[] cn)\n    {\n        double[] n = new double[cn.length];\n        for (int i = 0; i < n.length; i++)\n        {\n            n[i] = cn[i].imaginary;\n        }\n        return n;\n    }\n\n    /**\n     * Get real part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Real part.\n     */\n    public static double[][] getReal(ComplexNumber[][] cn)\n    {\n        double[][] n = new double[cn.length][cn[0].length];\n        for (int i = 0; i < n.length; i++)\n        {\n            for (int j = 0; j < n[0].length; j++)\n            {\n                n[i][j] = cn[i][j].real;\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Get imaginary part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Imaginary part.\n     */\n    public static double[][] getImaginary(ComplexNumber[][] cn)\n    {\n        double[][] n = new double[cn.length][cn[0].length];\n        for (int i = 0; i < n.length; i++)\n        {\n            for (int j = 0; j < n[0].length; j++)\n            {\n                n[i][j] = cn[i][j].imaginary;\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z1 Complex number.\n     */\n    public static void Swap(ComplexNumber z1)\n    {\n        double t = z1.real;\n        z1.real = z1.imaginary;\n        z1.imaginary = t;\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z Complex number.\n     */\n    public static void Swap(ComplexNumber[] z)\n    {\n        for (int i = 0; i < z.length; i++)\n        {\n            z[i] = new ComplexNumber(z[i].imaginary, z[i].real);\n        }\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z Complex number.\n     */\n    public static void Swap(ComplexNumber[][] z)\n    {\n        for (int i = 0; i < z.length; i++)\n        {\n            for (int j = 0; j < z[0].length; j++)\n            {\n                z[i][j] = new ComplexNumber(z[i][j].imaginary, z[i][j].real);\n            }\n        }\n    }\n\n    /**\n     * Absolute value of complex number.\n     * Same result like magnitude.\n     *\n     * @param z Complex Number.\n     * @return Absolute number.\n     */\n    public static double Abs(ComplexNumber z)\n    {\n        return Magnitude(z);\n    }\n\n    /**\n     * Absolute value of complex number.\n     *\n     * @param z Complex Numbers.\n     * @return Absolute number.\n     */\n    public static double[] Abs(ComplexNumber[] z)\n    {\n        double[] values = new double[z.length];\n        for (int i = 0; i < values.length; i++)\n        {\n            values[i] = z[i].getMagnitude();\n        }\n        return values;\n    }\n\n    /**\n     * Absolute value of complex number.\n     *\n     * @param z Complex numbers.\n     * @return Absolute number.\n     */\n    public static double[][] Abs(ComplexNumber[][] z)\n    {\n        double[][] values = new double[z.length][z[0].length];\n        for (int i = 0; i < values.length; i++)\n        {\n            for (int j = 0; j < values[0].length; j++)\n            {\n                values[i][j] = z[i][j].getMagnitude();\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Adds two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the sum of specified complex numbers.\n     */\n    public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2)\n    {\n        return new ComplexNumber(z1.real + z2.real, z1.imaginary + z2.imaginary);\n    }\n\n    /**\n     * Adds the complex number with a scalar value.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the add of specified complex number with scalar value.\n     */\n    public static ComplexNumber Add(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real + scalar, z1.imaginary);\n    }\n\n    /**\n     * Adds scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Add(double scalar)\n    {\n        this.real += scalar;\n    }\n\n    /**\n     * Subtract two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the subtract of specified complex numbers.\n     */\n    public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2)\n    {\n        return new ComplexNumber(z1.real - z2.real, z1.imaginary - z2.imaginary);\n    }\n\n    /**\n     * Subtract a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the subtract of specified complex number with a scalar value.\n     */\n    public static ComplexNumber Subtract(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real - scalar, z1.imaginary);\n    }\n\n    /**\n     * Subtracts scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Subtract(double scalar)\n    {\n        this.real -= scalar;\n    }\n\n    /**\n     * Magnitude of complex number.\n     *\n     * @param z Complex number.\n     * @return Magnitude of complex number.\n     */\n    public static double Magnitude(ComplexNumber z)\n    {\n        return Math.sqrt(z.real * z.real + z.imaginary * z.imaginary);\n    }\n\n    /**\n     * Multiply two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the multiply of specified complex numbers.\n     */\n    public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2)\n    {\n        double z1R = z1.real, z1I = z1.imaginary;\n        double z2R = z2.real, z2I = z2.imaginary;\n\n        return new ComplexNumber(z1R * z2R - z1I * z2I, z1R * z2I + z1I * z2R);\n    }\n\n    /**\n     * Multiply scalar value to a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the multiply of specified complex number with the scalar value.\n     */\n    public static ComplexNumber Multiply(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real * scalar, z1.imaginary * scalar);\n    }\n\n    /**\n     * Multiplys scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Multiply(double scalar)\n    {\n        this.real *= scalar;\n        this.imaginary *= scalar;\n    }\n\n    /**\n     * Divide two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the divide of specified complex numbers.\n     */\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param z1 Complex Number.\n     */\n    public void Divide(ComplexNumber z1)\n    {\n        ComplexNumber conj = ComplexNumber.Conjugate(z1);\n\n        double a = this.real * conj.real + ((this.imaginary * conj.imaginary) * -1);\n        double b = this.real * conj.imaginary + (this.imaginary * conj.real);\n\n        double c = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\n\n        this.real = a / c;\n        this.imaginary = b / c;\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the divide of specified complex number with the scalar value.\n     */\n    public static ComplexNumber Divide(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real / scalar, z1.imaginary / scalar);\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Divide(double scalar)\n    {\n\n        if (scalar == 0)\n        {\n            try\n            {\n                throw new ArithmeticException(\"Can not divide by zero.\");\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n            }\n        }\n\n        this.real /= scalar;\n        this.imaginary /= scalar;\n    }\n\n    /**\n     * Calculate power of a complex number.\n     *\n     * @param z1 Complex Number.\n     * @param n  Power.\n     * @return Returns a new complex number containing the power of a specified number.\n     */\n    public static ComplexNumber Pow(ComplexNumber z1, double n)\n    {\n\n        double norm = Math.pow(z1.getMagnitude(), n);\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(z1.imaginary / z1.real)));\n\n        double common = n * angle;\n\n        double r = norm * Math.cos(Math.toRadians(common));\n        double i = norm * Math.sin(Math.toRadians(common));\n\n        return new ComplexNumber(r, i);\n\n    }\n\n    /**\n     * Calculate power of a complex number.\n     *\n     * @param n Power.\n     */\n    public void Pow(double n)\n    {\n        double norm = Math.pow(getMagnitude(), n);\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(this.imaginary / this.real)));\n\n        double common = n * angle;\n\n        this.real = norm * Math.cos(Math.toRadians(common));\n        this.imaginary = norm * Math.sin(Math.toRadians(common));\n    }\n\n    /**\n     * Calculates natural (base <b>e</b>) logarithm of a complex number.\n     *\n     * @param z1 Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the natural logarithm of the specified complex number.\n     */\n    public static ComplexNumber Log(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if ((z1.real > 0.0) && (z1.imaginary == 0.0))\n        {\n            result.real = Math.log(z1.real);\n            result.imaginary = 0.0;\n        }\n        else if (z1.real == 0.0)\n        {\n            if (z1.imaginary > 0.0)\n            {\n                result.real = Math.log(z1.imaginary);\n                result.imaginary = Math.PI / 2.0;\n            }\n            else\n            {\n                result.real = Math.log(-(z1.imaginary));\n                result.imaginary = -Math.PI / 2.0;\n            }\n        }\n        else\n        {\n            result.real = Math.log(z1.getMagnitude());\n            result.imaginary = Math.atan2(z1.imaginary, z1.real);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates exponent (e raised to the specified power) of a complex number.\n     *\n     * @param z1 A Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the exponent of the specified complex number.\n     */\n    public static ComplexNumber Exp(ComplexNumber z1)\n    {\n        ComplexNumber x, y;\n        x = new ComplexNumber(Math.exp(z1.real), 0.0);\n        y = new ComplexNumber(Math.cos(z1.imaginary), Math.sin(z1.imaginary));\n\n        return Multiply(x, y);\n    }\n\n    /**\n     * Calculates Sine value of the complex number.\n     *\n     * @param z1 A Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the Sine value of the specified complex number.\n     */\n    public static ComplexNumber Sin(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.sin(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            result.real = Math.sin(z1.real) * Math.cosh(z1.imaginary);\n            result.imaginary = Math.cos(z1.real) * Math.sinh(z1.imaginary);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates Cosine value of the complex number.\n     *\n     * @param z1 A ComplexNumber instance.\n     * @return Returns new ComplexNumber instance containing the Cosine value of the specified complex number.\n     */\n    public static ComplexNumber Cos(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.cos(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            result.real = Math.cos(z1.real) * Math.cosh(z1.imaginary);\n            result.imaginary = -Math.sin(z1.real) * Math.sinh(z1.imaginary);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates Tangent value of the complex number.\n     *\n     * @param z1 A ComplexNumber instance.\n     * @return Returns new ComplexNumber instance containing the Tangent value of the specified complex number.\n     */\n    public static ComplexNumber Tan(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.tan(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            double real2 = 2 * z1.real;\n            double imag2 = 2 * z1.imaginary;\n            double denom = Math.cos(real2) + Math.cosh(real2);\n\n            result.real = Math.sin(real2) / denom;\n            result.imaginary = Math.sinh(imag2) / denom;\n        }\n\n        return result;\n    }\n\n    /**\n     * Conjugate this complex number.\n     */\n    public void Conjugate()\n    {\n        this.imaginary *= -1;\n    }\n\n    /**\n     * Conjugate a complex number.\n     *\n     * @param z1 Complex number.\n     * @return Returns new ComplexNumber instance containing the conjugate of the specified complex number.\n     */\n    public static ComplexNumber Conjugate(ComplexNumber z1)\n    {\n        return new ComplexNumber(z1.real, z1.imaginary * -1);\n    }\n\n    @Override\n    public String toString()\n    {\n        if (this.imaginary >= 0)\n            return this.real + \" +\" + this.imaginary + \"i\";\n        return this.real + \" \" + this.imaginary + \"i\";\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/ComplexNumber.java", "func_name": "ComplexNumber.Pow", "original_string": "public static ComplexNumber Pow(ComplexNumber z1, double n) {\r\n\r\n        double norm = Math.pow(z1.getMagnitude(), n);\r\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(z1.imaginary / z1.real)));\r\n\r\n        double common = n * angle;\r\n\r\n        double r = norm * Math.cos(Math.toRadians(common));\r\n        double i = norm * Math.sin(Math.toRadians(common));\r\n\r\n        return new ComplexNumber(r, i);\r\n\r\n    }", "language": "java", "code": "public static ComplexNumber Pow(ComplexNumber z1, double n) {\r\n\r\n        double norm = Math.pow(z1.getMagnitude(), n);\r\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(z1.imaginary / z1.real)));\r\n\r\n        double common = n * angle;\r\n\r\n        double r = norm * Math.cos(Math.toRadians(common));\r\n        double i = norm * Math.sin(Math.toRadians(common));\r\n\r\n        return new ComplexNumber(r, i);\r\n\r\n    }", "code_tokens": ["public", "static", "ComplexNumber", "Pow", "(", "ComplexNumber", "z1", ",", "double", "n", ")", "{", "double", "norm", "=", "Math", ".", "pow", "(", "z1", ".", "getMagnitude", "(", ")", ",", "n", ")", ";", "double", "angle", "=", "360", "-", "Math", ".", "abs", "(", "Math", ".", "toDegrees", "(", "Math", ".", "atan", "(", "z1", ".", "imaginary", "/", "z1", ".", "real", ")", ")", ")", ";", "double", "common", "=", "n", "*", "angle", ";", "double", "r", "=", "norm", "*", "Math", ".", "cos", "(", "Math", ".", "toRadians", "(", "common", ")", ")", ";", "double", "i", "=", "norm", "*", "Math", ".", "sin", "(", "Math", ".", "toRadians", "(", "common", ")", ")", ";", "return", "new", "ComplexNumber", "(", "r", ",", "i", ")", ";", "}"], "docstring": "Calculate power of a complex number.\n\n@param z1 Complex Number.\n@param n  Power.\n@return Returns a new complex number containing the power of a specified number.", "docstring_tokens": ["Calculate", "power", "of", "a", "complex", "number", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/ComplexNumber.java#L414-L426", "partition": "train", "up_fun_num": 29, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": [], "function": ["public class ComplexNumber\n", "    public double getMagnitude()\n", "    public double getSquaredMagnitude()\n", "    public double getPhase()\n", "    public static double[] getReal(ComplexNumber[] cn)\n", "    public static double[] getImaginary(ComplexNumber[] cn)\n", "    public static double[][] getReal(ComplexNumber[][] cn)\n", "    public static double[][] getImaginary(ComplexNumber[][] cn)\n", "    public static void Swap(ComplexNumber z1)\n", "    public static void Swap(ComplexNumber[] z)\n", "    public static void Swap(ComplexNumber[][] z)\n", "    public static double Abs(ComplexNumber z)\n", "    public static double[] Abs(ComplexNumber[] z)\n", "    public static double[][] Abs(ComplexNumber[][] z)\n", "    public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Add(ComplexNumber z1, double scalar)\n", "    public void Add(double scalar)\n", "    public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Subtract(ComplexNumber z1, double scalar)\n", "    public void Subtract(double scalar)\n", "    public static double Magnitude(ComplexNumber z)\n", "    public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Multiply(ComplexNumber z1, double scalar)\n", "    public void Multiply(double scalar)\n", "    public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2)\n", "    public void Divide(ComplexNumber z1)\n", "    public static ComplexNumber Divide(ComplexNumber z1, double scalar)\n", "    public void Divide(double scalar)\n", "    public void Pow(double n)\n", "    public static ComplexNumber Log(ComplexNumber z1)\n", "    public static ComplexNumber Exp(ComplexNumber z1)\n", "    public static ComplexNumber Sin(ComplexNumber z1)\n", "    public static ComplexNumber Cos(ComplexNumber z1)\n", "    public static ComplexNumber Tan(ComplexNumber z1)\n", "    public void Conjugate()\n", "    public static ComplexNumber Conjugate(ComplexNumber z1)\n", "    public String toString()\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2005-2009\n// andrew.kirillov@aforgenet.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math;\n\n/**\n * Complex Number.\n *\n * @author Diego Catalano\n */\npublic class ComplexNumber\n{\n\n    /**\n     * Real.\n     */\n    public double real = 0;\n    /**\n     * Imaginary.\n     */\n    public double imaginary = 0;\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     */\n    public ComplexNumber()\n    {\n        this(0, 0);\n    }\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     *\n     * @param real      Real.\n     * @param imaginary Imaginary.\n     */\n    public ComplexNumber(double real, double imaginary)\n    {\n        this.real = real;\n        this.imaginary = imaginary;\n    }\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     *\n     * @param z1 Complex Number.\n     */\n    public ComplexNumber(ComplexNumber z1)\n    {\n        this.real = z1.real;\n        this.imaginary = z1.imaginary;\n    }\n\n    /**\n     * Get Magnitude value of the complex number.\n     *\n     * @return Magnitude.\n     */\n    public double getMagnitude()\n    {\n        return Math.sqrt(real * real + imaginary * imaginary);\n    }\n\n    /**\n     * Get Squared magnitude value of the complex number.\n     *\n     * @return squared magnitude.\n     */\n    public double getSquaredMagnitude()\n    {\n        return real * real + imaginary * imaginary;\n    }\n\n    /**\n     * Get Phase value of the complex number.\n     *\n     * @return Phase value.\n     */\n    public double getPhase()\n    {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Get real part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Real part.\n     */\n    public static double[] getReal(ComplexNumber[] cn)\n    {\n        double[] n = new double[cn.length];\n        for (int i = 0; i < n.length; i++)\n        {\n            n[i] = cn[i].real;\n        }\n        return n;\n    }\n\n    /**\n     * Get imaginary part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Imaginary part.\n     */\n    public static double[] getImaginary(ComplexNumber[] cn)\n    {\n        double[] n = new double[cn.length];\n        for (int i = 0; i < n.length; i++)\n        {\n            n[i] = cn[i].imaginary;\n        }\n        return n;\n    }\n\n    /**\n     * Get real part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Real part.\n     */\n    public static double[][] getReal(ComplexNumber[][] cn)\n    {\n        double[][] n = new double[cn.length][cn[0].length];\n        for (int i = 0; i < n.length; i++)\n        {\n            for (int j = 0; j < n[0].length; j++)\n            {\n                n[i][j] = cn[i][j].real;\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Get imaginary part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Imaginary part.\n     */\n    public static double[][] getImaginary(ComplexNumber[][] cn)\n    {\n        double[][] n = new double[cn.length][cn[0].length];\n        for (int i = 0; i < n.length; i++)\n        {\n            for (int j = 0; j < n[0].length; j++)\n            {\n                n[i][j] = cn[i][j].imaginary;\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z1 Complex number.\n     */\n    public static void Swap(ComplexNumber z1)\n    {\n        double t = z1.real;\n        z1.real = z1.imaginary;\n        z1.imaginary = t;\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z Complex number.\n     */\n    public static void Swap(ComplexNumber[] z)\n    {\n        for (int i = 0; i < z.length; i++)\n        {\n            z[i] = new ComplexNumber(z[i].imaginary, z[i].real);\n        }\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z Complex number.\n     */\n    public static void Swap(ComplexNumber[][] z)\n    {\n        for (int i = 0; i < z.length; i++)\n        {\n            for (int j = 0; j < z[0].length; j++)\n            {\n                z[i][j] = new ComplexNumber(z[i][j].imaginary, z[i][j].real);\n            }\n        }\n    }\n\n    /**\n     * Absolute value of complex number.\n     * Same result like magnitude.\n     *\n     * @param z Complex Number.\n     * @return Absolute number.\n     */\n    public static double Abs(ComplexNumber z)\n    {\n        return Magnitude(z);\n    }\n\n    /**\n     * Absolute value of complex number.\n     *\n     * @param z Complex Numbers.\n     * @return Absolute number.\n     */\n    public static double[] Abs(ComplexNumber[] z)\n    {\n        double[] values = new double[z.length];\n        for (int i = 0; i < values.length; i++)\n        {\n            values[i] = z[i].getMagnitude();\n        }\n        return values;\n    }\n\n    /**\n     * Absolute value of complex number.\n     *\n     * @param z Complex numbers.\n     * @return Absolute number.\n     */\n    public static double[][] Abs(ComplexNumber[][] z)\n    {\n        double[][] values = new double[z.length][z[0].length];\n        for (int i = 0; i < values.length; i++)\n        {\n            for (int j = 0; j < values[0].length; j++)\n            {\n                values[i][j] = z[i][j].getMagnitude();\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Adds two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the sum of specified complex numbers.\n     */\n    public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2)\n    {\n        return new ComplexNumber(z1.real + z2.real, z1.imaginary + z2.imaginary);\n    }\n\n    /**\n     * Adds the complex number with a scalar value.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the add of specified complex number with scalar value.\n     */\n    public static ComplexNumber Add(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real + scalar, z1.imaginary);\n    }\n\n    /**\n     * Adds scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Add(double scalar)\n    {\n        this.real += scalar;\n    }\n\n    /**\n     * Subtract two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the subtract of specified complex numbers.\n     */\n    public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2)\n    {\n        return new ComplexNumber(z1.real - z2.real, z1.imaginary - z2.imaginary);\n    }\n\n    /**\n     * Subtract a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the subtract of specified complex number with a scalar value.\n     */\n    public static ComplexNumber Subtract(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real - scalar, z1.imaginary);\n    }\n\n    /**\n     * Subtracts scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Subtract(double scalar)\n    {\n        this.real -= scalar;\n    }\n\n    /**\n     * Magnitude of complex number.\n     *\n     * @param z Complex number.\n     * @return Magnitude of complex number.\n     */\n    public static double Magnitude(ComplexNumber z)\n    {\n        return Math.sqrt(z.real * z.real + z.imaginary * z.imaginary);\n    }\n\n    /**\n     * Multiply two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the multiply of specified complex numbers.\n     */\n    public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2)\n    {\n        double z1R = z1.real, z1I = z1.imaginary;\n        double z2R = z2.real, z2I = z2.imaginary;\n\n        return new ComplexNumber(z1R * z2R - z1I * z2I, z1R * z2I + z1I * z2R);\n    }\n\n    /**\n     * Multiply scalar value to a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the multiply of specified complex number with the scalar value.\n     */\n    public static ComplexNumber Multiply(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real * scalar, z1.imaginary * scalar);\n    }\n\n    /**\n     * Multiplys scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Multiply(double scalar)\n    {\n        this.real *= scalar;\n        this.imaginary *= scalar;\n    }\n\n    /**\n     * Divide two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the divide of specified complex numbers.\n     */\n    public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2)\n    {\n\n        ComplexNumber conj = ComplexNumber.Conjugate(z2);\n\n        double a = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\n        double b = z1.real * conj.imaginary + (z1.imaginary * conj.real);\n\n        double c = z2.real * conj.real + ((z2.imaginary * conj.imaginary) * -1);\n\n        return new ComplexNumber(a / c, b / c);\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param z1 Complex Number.\n     */\n    public void Divide(ComplexNumber z1)\n    {\n        ComplexNumber conj = ComplexNumber.Conjugate(z1);\n\n        double a = this.real * conj.real + ((this.imaginary * conj.imaginary) * -1);\n        double b = this.real * conj.imaginary + (this.imaginary * conj.real);\n\n        double c = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\n\n        this.real = a / c;\n        this.imaginary = b / c;\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the divide of specified complex number with the scalar value.\n     */\n    public static ComplexNumber Divide(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real / scalar, z1.imaginary / scalar);\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Divide(double scalar)\n    {\n\n        if (scalar == 0)\n        {\n            try\n            {\n                throw new ArithmeticException(\"Can not divide by zero.\");\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n            }\n        }\n\n        this.real /= scalar;\n        this.imaginary /= scalar;\n    }\n\n    /**\n     * Calculate power of a complex number.\n     *\n     * @param z1 Complex Number.\n     * @param n  Power.\n     * @return Returns a new complex number containing the power of a specified number.\n     */\n\n    /**\n     * Calculate power of a complex number.\n     *\n     * @param n Power.\n     */\n    public void Pow(double n)\n    {\n        double norm = Math.pow(getMagnitude(), n);\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(this.imaginary / this.real)));\n\n        double common = n * angle;\n\n        this.real = norm * Math.cos(Math.toRadians(common));\n        this.imaginary = norm * Math.sin(Math.toRadians(common));\n    }\n\n    /**\n     * Calculates natural (base <b>e</b>) logarithm of a complex number.\n     *\n     * @param z1 Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the natural logarithm of the specified complex number.\n     */\n    public static ComplexNumber Log(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if ((z1.real > 0.0) && (z1.imaginary == 0.0))\n        {\n            result.real = Math.log(z1.real);\n            result.imaginary = 0.0;\n        }\n        else if (z1.real == 0.0)\n        {\n            if (z1.imaginary > 0.0)\n            {\n                result.real = Math.log(z1.imaginary);\n                result.imaginary = Math.PI / 2.0;\n            }\n            else\n            {\n                result.real = Math.log(-(z1.imaginary));\n                result.imaginary = -Math.PI / 2.0;\n            }\n        }\n        else\n        {\n            result.real = Math.log(z1.getMagnitude());\n            result.imaginary = Math.atan2(z1.imaginary, z1.real);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates exponent (e raised to the specified power) of a complex number.\n     *\n     * @param z1 A Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the exponent of the specified complex number.\n     */\n    public static ComplexNumber Exp(ComplexNumber z1)\n    {\n        ComplexNumber x, y;\n        x = new ComplexNumber(Math.exp(z1.real), 0.0);\n        y = new ComplexNumber(Math.cos(z1.imaginary), Math.sin(z1.imaginary));\n\n        return Multiply(x, y);\n    }\n\n    /**\n     * Calculates Sine value of the complex number.\n     *\n     * @param z1 A Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the Sine value of the specified complex number.\n     */\n    public static ComplexNumber Sin(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.sin(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            result.real = Math.sin(z1.real) * Math.cosh(z1.imaginary);\n            result.imaginary = Math.cos(z1.real) * Math.sinh(z1.imaginary);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates Cosine value of the complex number.\n     *\n     * @param z1 A ComplexNumber instance.\n     * @return Returns new ComplexNumber instance containing the Cosine value of the specified complex number.\n     */\n    public static ComplexNumber Cos(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.cos(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            result.real = Math.cos(z1.real) * Math.cosh(z1.imaginary);\n            result.imaginary = -Math.sin(z1.real) * Math.sinh(z1.imaginary);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates Tangent value of the complex number.\n     *\n     * @param z1 A ComplexNumber instance.\n     * @return Returns new ComplexNumber instance containing the Tangent value of the specified complex number.\n     */\n    public static ComplexNumber Tan(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.tan(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            double real2 = 2 * z1.real;\n            double imag2 = 2 * z1.imaginary;\n            double denom = Math.cos(real2) + Math.cosh(real2);\n\n            result.real = Math.sin(real2) / denom;\n            result.imaginary = Math.sinh(imag2) / denom;\n        }\n\n        return result;\n    }\n\n    /**\n     * Conjugate this complex number.\n     */\n    public void Conjugate()\n    {\n        this.imaginary *= -1;\n    }\n\n    /**\n     * Conjugate a complex number.\n     *\n     * @param z1 Complex number.\n     * @return Returns new ComplexNumber instance containing the conjugate of the specified complex number.\n     */\n    public static ComplexNumber Conjugate(ComplexNumber z1)\n    {\n        return new ComplexNumber(z1.real, z1.imaginary * -1);\n    }\n\n    @Override\n    public String toString()\n    {\n        if (this.imaginary >= 0)\n            return this.real + \" +\" + this.imaginary + \"i\";\n        return this.real + \" \" + this.imaginary + \"i\";\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/ComplexNumber.java", "func_name": "ComplexNumber.Sin", "original_string": "public static ComplexNumber Sin(ComplexNumber z1) {\r\n        ComplexNumber result = new ComplexNumber();\r\n\r\n        if (z1.imaginary == 0.0) {\r\n            result.real = Math.sin(z1.real);\r\n            result.imaginary = 0.0;\r\n        } else {\r\n            result.real = Math.sin(z1.real) * Math.cosh(z1.imaginary);\r\n            result.imaginary = Math.cos(z1.real) * Math.sinh(z1.imaginary);\r\n        }\r\n\r\n        return result;\r\n    }", "language": "java", "code": "public static ComplexNumber Sin(ComplexNumber z1) {\r\n        ComplexNumber result = new ComplexNumber();\r\n\r\n        if (z1.imaginary == 0.0) {\r\n            result.real = Math.sin(z1.real);\r\n            result.imaginary = 0.0;\r\n        } else {\r\n            result.real = Math.sin(z1.real) * Math.cosh(z1.imaginary);\r\n            result.imaginary = Math.cos(z1.real) * Math.sinh(z1.imaginary);\r\n        }\r\n\r\n        return result;\r\n    }", "code_tokens": ["public", "static", "ComplexNumber", "Sin", "(", "ComplexNumber", "z1", ")", "{", "ComplexNumber", "result", "=", "new", "ComplexNumber", "(", ")", ";", "if", "(", "z1", ".", "imaginary", "==", "0.0", ")", "{", "result", ".", "real", "=", "Math", ".", "sin", "(", "z1", ".", "real", ")", ";", "result", ".", "imaginary", "=", "0.0", ";", "}", "else", "{", "result", ".", "real", "=", "Math", ".", "sin", "(", "z1", ".", "real", ")", "*", "Math", ".", "cosh", "(", "z1", ".", "imaginary", ")", ";", "result", ".", "imaginary", "=", "Math", ".", "cos", "(", "z1", ".", "real", ")", "*", "Math", ".", "sinh", "(", "z1", ".", "imaginary", ")", ";", "}", "return", "result", ";", "}"], "docstring": "Calculates Sine value of the complex number.\n\n@param z1 A Complex Number instance.\n@return Returns new ComplexNumber instance containing the Sine value of the specified complex number.", "docstring_tokens": ["Calculates", "Sine", "value", "of", "the", "complex", "number", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/ComplexNumber.java#L491-L503", "partition": "train", "up_fun_num": 33, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": [], "function": ["public class ComplexNumber\n", "    public double getMagnitude()\n", "    public double getSquaredMagnitude()\n", "    public double getPhase()\n", "    public static double[] getReal(ComplexNumber[] cn)\n", "    public static double[] getImaginary(ComplexNumber[] cn)\n", "    public static double[][] getReal(ComplexNumber[][] cn)\n", "    public static double[][] getImaginary(ComplexNumber[][] cn)\n", "    public static void Swap(ComplexNumber z1)\n", "    public static void Swap(ComplexNumber[] z)\n", "    public static void Swap(ComplexNumber[][] z)\n", "    public static double Abs(ComplexNumber z)\n", "    public static double[] Abs(ComplexNumber[] z)\n", "    public static double[][] Abs(ComplexNumber[][] z)\n", "    public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Add(ComplexNumber z1, double scalar)\n", "    public void Add(double scalar)\n", "    public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Subtract(ComplexNumber z1, double scalar)\n", "    public void Subtract(double scalar)\n", "    public static double Magnitude(ComplexNumber z)\n", "    public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Multiply(ComplexNumber z1, double scalar)\n", "    public void Multiply(double scalar)\n", "    public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2)\n", "    public void Divide(ComplexNumber z1)\n", "    public static ComplexNumber Divide(ComplexNumber z1, double scalar)\n", "    public void Divide(double scalar)\n", "    public static ComplexNumber Pow(ComplexNumber z1, double n)\n", "    public void Pow(double n)\n", "    public static ComplexNumber Log(ComplexNumber z1)\n", "    public static ComplexNumber Exp(ComplexNumber z1)\n", "    public static ComplexNumber Cos(ComplexNumber z1)\n", "    public static ComplexNumber Tan(ComplexNumber z1)\n", "    public void Conjugate()\n", "    public static ComplexNumber Conjugate(ComplexNumber z1)\n", "    public String toString()\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2005-2009\n// andrew.kirillov@aforgenet.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math;\n\n/**\n * Complex Number.\n *\n * @author Diego Catalano\n */\npublic class ComplexNumber\n{\n\n    /**\n     * Real.\n     */\n    public double real = 0;\n    /**\n     * Imaginary.\n     */\n    public double imaginary = 0;\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     */\n    public ComplexNumber()\n    {\n        this(0, 0);\n    }\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     *\n     * @param real      Real.\n     * @param imaginary Imaginary.\n     */\n    public ComplexNumber(double real, double imaginary)\n    {\n        this.real = real;\n        this.imaginary = imaginary;\n    }\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     *\n     * @param z1 Complex Number.\n     */\n    public ComplexNumber(ComplexNumber z1)\n    {\n        this.real = z1.real;\n        this.imaginary = z1.imaginary;\n    }\n\n    /**\n     * Get Magnitude value of the complex number.\n     *\n     * @return Magnitude.\n     */\n    public double getMagnitude()\n    {\n        return Math.sqrt(real * real + imaginary * imaginary);\n    }\n\n    /**\n     * Get Squared magnitude value of the complex number.\n     *\n     * @return squared magnitude.\n     */\n    public double getSquaredMagnitude()\n    {\n        return real * real + imaginary * imaginary;\n    }\n\n    /**\n     * Get Phase value of the complex number.\n     *\n     * @return Phase value.\n     */\n    public double getPhase()\n    {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Get real part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Real part.\n     */\n    public static double[] getReal(ComplexNumber[] cn)\n    {\n        double[] n = new double[cn.length];\n        for (int i = 0; i < n.length; i++)\n        {\n            n[i] = cn[i].real;\n        }\n        return n;\n    }\n\n    /**\n     * Get imaginary part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Imaginary part.\n     */\n    public static double[] getImaginary(ComplexNumber[] cn)\n    {\n        double[] n = new double[cn.length];\n        for (int i = 0; i < n.length; i++)\n        {\n            n[i] = cn[i].imaginary;\n        }\n        return n;\n    }\n\n    /**\n     * Get real part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Real part.\n     */\n    public static double[][] getReal(ComplexNumber[][] cn)\n    {\n        double[][] n = new double[cn.length][cn[0].length];\n        for (int i = 0; i < n.length; i++)\n        {\n            for (int j = 0; j < n[0].length; j++)\n            {\n                n[i][j] = cn[i][j].real;\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Get imaginary part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Imaginary part.\n     */\n    public static double[][] getImaginary(ComplexNumber[][] cn)\n    {\n        double[][] n = new double[cn.length][cn[0].length];\n        for (int i = 0; i < n.length; i++)\n        {\n            for (int j = 0; j < n[0].length; j++)\n            {\n                n[i][j] = cn[i][j].imaginary;\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z1 Complex number.\n     */\n    public static void Swap(ComplexNumber z1)\n    {\n        double t = z1.real;\n        z1.real = z1.imaginary;\n        z1.imaginary = t;\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z Complex number.\n     */\n    public static void Swap(ComplexNumber[] z)\n    {\n        for (int i = 0; i < z.length; i++)\n        {\n            z[i] = new ComplexNumber(z[i].imaginary, z[i].real);\n        }\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z Complex number.\n     */\n    public static void Swap(ComplexNumber[][] z)\n    {\n        for (int i = 0; i < z.length; i++)\n        {\n            for (int j = 0; j < z[0].length; j++)\n            {\n                z[i][j] = new ComplexNumber(z[i][j].imaginary, z[i][j].real);\n            }\n        }\n    }\n\n    /**\n     * Absolute value of complex number.\n     * Same result like magnitude.\n     *\n     * @param z Complex Number.\n     * @return Absolute number.\n     */\n    public static double Abs(ComplexNumber z)\n    {\n        return Magnitude(z);\n    }\n\n    /**\n     * Absolute value of complex number.\n     *\n     * @param z Complex Numbers.\n     * @return Absolute number.\n     */\n    public static double[] Abs(ComplexNumber[] z)\n    {\n        double[] values = new double[z.length];\n        for (int i = 0; i < values.length; i++)\n        {\n            values[i] = z[i].getMagnitude();\n        }\n        return values;\n    }\n\n    /**\n     * Absolute value of complex number.\n     *\n     * @param z Complex numbers.\n     * @return Absolute number.\n     */\n    public static double[][] Abs(ComplexNumber[][] z)\n    {\n        double[][] values = new double[z.length][z[0].length];\n        for (int i = 0; i < values.length; i++)\n        {\n            for (int j = 0; j < values[0].length; j++)\n            {\n                values[i][j] = z[i][j].getMagnitude();\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Adds two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the sum of specified complex numbers.\n     */\n    public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2)\n    {\n        return new ComplexNumber(z1.real + z2.real, z1.imaginary + z2.imaginary);\n    }\n\n    /**\n     * Adds the complex number with a scalar value.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the add of specified complex number with scalar value.\n     */\n    public static ComplexNumber Add(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real + scalar, z1.imaginary);\n    }\n\n    /**\n     * Adds scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Add(double scalar)\n    {\n        this.real += scalar;\n    }\n\n    /**\n     * Subtract two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the subtract of specified complex numbers.\n     */\n    public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2)\n    {\n        return new ComplexNumber(z1.real - z2.real, z1.imaginary - z2.imaginary);\n    }\n\n    /**\n     * Subtract a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the subtract of specified complex number with a scalar value.\n     */\n    public static ComplexNumber Subtract(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real - scalar, z1.imaginary);\n    }\n\n    /**\n     * Subtracts scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Subtract(double scalar)\n    {\n        this.real -= scalar;\n    }\n\n    /**\n     * Magnitude of complex number.\n     *\n     * @param z Complex number.\n     * @return Magnitude of complex number.\n     */\n    public static double Magnitude(ComplexNumber z)\n    {\n        return Math.sqrt(z.real * z.real + z.imaginary * z.imaginary);\n    }\n\n    /**\n     * Multiply two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the multiply of specified complex numbers.\n     */\n    public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2)\n    {\n        double z1R = z1.real, z1I = z1.imaginary;\n        double z2R = z2.real, z2I = z2.imaginary;\n\n        return new ComplexNumber(z1R * z2R - z1I * z2I, z1R * z2I + z1I * z2R);\n    }\n\n    /**\n     * Multiply scalar value to a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the multiply of specified complex number with the scalar value.\n     */\n    public static ComplexNumber Multiply(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real * scalar, z1.imaginary * scalar);\n    }\n\n    /**\n     * Multiplys scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Multiply(double scalar)\n    {\n        this.real *= scalar;\n        this.imaginary *= scalar;\n    }\n\n    /**\n     * Divide two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the divide of specified complex numbers.\n     */\n    public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2)\n    {\n\n        ComplexNumber conj = ComplexNumber.Conjugate(z2);\n\n        double a = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\n        double b = z1.real * conj.imaginary + (z1.imaginary * conj.real);\n\n        double c = z2.real * conj.real + ((z2.imaginary * conj.imaginary) * -1);\n\n        return new ComplexNumber(a / c, b / c);\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param z1 Complex Number.\n     */\n    public void Divide(ComplexNumber z1)\n    {\n        ComplexNumber conj = ComplexNumber.Conjugate(z1);\n\n        double a = this.real * conj.real + ((this.imaginary * conj.imaginary) * -1);\n        double b = this.real * conj.imaginary + (this.imaginary * conj.real);\n\n        double c = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\n\n        this.real = a / c;\n        this.imaginary = b / c;\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the divide of specified complex number with the scalar value.\n     */\n    public static ComplexNumber Divide(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real / scalar, z1.imaginary / scalar);\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Divide(double scalar)\n    {\n\n        if (scalar == 0)\n        {\n            try\n            {\n                throw new ArithmeticException(\"Can not divide by zero.\");\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n            }\n        }\n\n        this.real /= scalar;\n        this.imaginary /= scalar;\n    }\n\n    /**\n     * Calculate power of a complex number.\n     *\n     * @param z1 Complex Number.\n     * @param n  Power.\n     * @return Returns a new complex number containing the power of a specified number.\n     */\n    public static ComplexNumber Pow(ComplexNumber z1, double n)\n    {\n\n        double norm = Math.pow(z1.getMagnitude(), n);\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(z1.imaginary / z1.real)));\n\n        double common = n * angle;\n\n        double r = norm * Math.cos(Math.toRadians(common));\n        double i = norm * Math.sin(Math.toRadians(common));\n\n        return new ComplexNumber(r, i);\n\n    }\n\n    /**\n     * Calculate power of a complex number.\n     *\n     * @param n Power.\n     */\n    public void Pow(double n)\n    {\n        double norm = Math.pow(getMagnitude(), n);\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(this.imaginary / this.real)));\n\n        double common = n * angle;\n\n        this.real = norm * Math.cos(Math.toRadians(common));\n        this.imaginary = norm * Math.sin(Math.toRadians(common));\n    }\n\n    /**\n     * Calculates natural (base <b>e</b>) logarithm of a complex number.\n     *\n     * @param z1 Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the natural logarithm of the specified complex number.\n     */\n    public static ComplexNumber Log(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if ((z1.real > 0.0) && (z1.imaginary == 0.0))\n        {\n            result.real = Math.log(z1.real);\n            result.imaginary = 0.0;\n        }\n        else if (z1.real == 0.0)\n        {\n            if (z1.imaginary > 0.0)\n            {\n                result.real = Math.log(z1.imaginary);\n                result.imaginary = Math.PI / 2.0;\n            }\n            else\n            {\n                result.real = Math.log(-(z1.imaginary));\n                result.imaginary = -Math.PI / 2.0;\n            }\n        }\n        else\n        {\n            result.real = Math.log(z1.getMagnitude());\n            result.imaginary = Math.atan2(z1.imaginary, z1.real);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates exponent (e raised to the specified power) of a complex number.\n     *\n     * @param z1 A Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the exponent of the specified complex number.\n     */\n    public static ComplexNumber Exp(ComplexNumber z1)\n    {\n        ComplexNumber x, y;\n        x = new ComplexNumber(Math.exp(z1.real), 0.0);\n        y = new ComplexNumber(Math.cos(z1.imaginary), Math.sin(z1.imaginary));\n\n        return Multiply(x, y);\n    }\n\n    /**\n     * Calculates Sine value of the complex number.\n     *\n     * @param z1 A Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the Sine value of the specified complex number.\n     */\n\n    /**\n     * Calculates Cosine value of the complex number.\n     *\n     * @param z1 A ComplexNumber instance.\n     * @return Returns new ComplexNumber instance containing the Cosine value of the specified complex number.\n     */\n    public static ComplexNumber Cos(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.cos(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            result.real = Math.cos(z1.real) * Math.cosh(z1.imaginary);\n            result.imaginary = -Math.sin(z1.real) * Math.sinh(z1.imaginary);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates Tangent value of the complex number.\n     *\n     * @param z1 A ComplexNumber instance.\n     * @return Returns new ComplexNumber instance containing the Tangent value of the specified complex number.\n     */\n    public static ComplexNumber Tan(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.tan(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            double real2 = 2 * z1.real;\n            double imag2 = 2 * z1.imaginary;\n            double denom = Math.cos(real2) + Math.cosh(real2);\n\n            result.real = Math.sin(real2) / denom;\n            result.imaginary = Math.sinh(imag2) / denom;\n        }\n\n        return result;\n    }\n\n    /**\n     * Conjugate this complex number.\n     */\n    public void Conjugate()\n    {\n        this.imaginary *= -1;\n    }\n\n    /**\n     * Conjugate a complex number.\n     *\n     * @param z1 Complex number.\n     * @return Returns new ComplexNumber instance containing the conjugate of the specified complex number.\n     */\n    public static ComplexNumber Conjugate(ComplexNumber z1)\n    {\n        return new ComplexNumber(z1.real, z1.imaginary * -1);\n    }\n\n    @Override\n    public String toString()\n    {\n        if (this.imaginary >= 0)\n            return this.real + \" +\" + this.imaginary + \"i\";\n        return this.real + \" \" + this.imaginary + \"i\";\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/ComplexNumber.java", "func_name": "ComplexNumber.Tan", "original_string": "public static ComplexNumber Tan(ComplexNumber z1) {\r\n        ComplexNumber result = new ComplexNumber();\r\n\r\n        if (z1.imaginary == 0.0) {\r\n            result.real = Math.tan(z1.real);\r\n            result.imaginary = 0.0;\r\n        } else {\r\n            double real2 = 2 * z1.real;\r\n            double imag2 = 2 * z1.imaginary;\r\n            double denom = Math.cos(real2) + Math.cosh(real2);\r\n\r\n            result.real = Math.sin(real2) / denom;\r\n            result.imaginary = Math.sinh(imag2) / denom;\r\n        }\r\n\r\n        return result;\r\n    }", "language": "java", "code": "public static ComplexNumber Tan(ComplexNumber z1) {\r\n        ComplexNumber result = new ComplexNumber();\r\n\r\n        if (z1.imaginary == 0.0) {\r\n            result.real = Math.tan(z1.real);\r\n            result.imaginary = 0.0;\r\n        } else {\r\n            double real2 = 2 * z1.real;\r\n            double imag2 = 2 * z1.imaginary;\r\n            double denom = Math.cos(real2) + Math.cosh(real2);\r\n\r\n            result.real = Math.sin(real2) / denom;\r\n            result.imaginary = Math.sinh(imag2) / denom;\r\n        }\r\n\r\n        return result;\r\n    }", "code_tokens": ["public", "static", "ComplexNumber", "Tan", "(", "ComplexNumber", "z1", ")", "{", "ComplexNumber", "result", "=", "new", "ComplexNumber", "(", ")", ";", "if", "(", "z1", ".", "imaginary", "==", "0.0", ")", "{", "result", ".", "real", "=", "Math", ".", "tan", "(", "z1", ".", "real", ")", ";", "result", ".", "imaginary", "=", "0.0", ";", "}", "else", "{", "double", "real2", "=", "2", "*", "z1", ".", "real", ";", "double", "imag2", "=", "2", "*", "z1", ".", "imaginary", ";", "double", "denom", "=", "Math", ".", "cos", "(", "real2", ")", "+", "Math", ".", "cosh", "(", "real2", ")", ";", "result", ".", "real", "=", "Math", ".", "sin", "(", "real2", ")", "/", "denom", ";", "result", ".", "imaginary", "=", "Math", ".", "sinh", "(", "imag2", ")", "/", "denom", ";", "}", "return", "result", ";", "}"], "docstring": "Calculates Tangent value of the complex number.\n\n@param z1 A ComplexNumber instance.\n@return Returns new ComplexNumber instance containing the Tangent value of the specified complex number.", "docstring_tokens": ["Calculates", "Tangent", "value", "of", "the", "complex", "number", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/ComplexNumber.java#L531-L547", "partition": "train", "up_fun_num": 35, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": [], "function": ["public class ComplexNumber\n", "    public double getMagnitude()\n", "    public double getSquaredMagnitude()\n", "    public double getPhase()\n", "    public static double[] getReal(ComplexNumber[] cn)\n", "    public static double[] getImaginary(ComplexNumber[] cn)\n", "    public static double[][] getReal(ComplexNumber[][] cn)\n", "    public static double[][] getImaginary(ComplexNumber[][] cn)\n", "    public static void Swap(ComplexNumber z1)\n", "    public static void Swap(ComplexNumber[] z)\n", "    public static void Swap(ComplexNumber[][] z)\n", "    public static double Abs(ComplexNumber z)\n", "    public static double[] Abs(ComplexNumber[] z)\n", "    public static double[][] Abs(ComplexNumber[][] z)\n", "    public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Add(ComplexNumber z1, double scalar)\n", "    public void Add(double scalar)\n", "    public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Subtract(ComplexNumber z1, double scalar)\n", "    public void Subtract(double scalar)\n", "    public static double Magnitude(ComplexNumber z)\n", "    public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2)\n", "    public static ComplexNumber Multiply(ComplexNumber z1, double scalar)\n", "    public void Multiply(double scalar)\n", "    public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2)\n", "    public void Divide(ComplexNumber z1)\n", "    public static ComplexNumber Divide(ComplexNumber z1, double scalar)\n", "    public void Divide(double scalar)\n", "    public static ComplexNumber Pow(ComplexNumber z1, double n)\n", "    public void Pow(double n)\n", "    public static ComplexNumber Log(ComplexNumber z1)\n", "    public static ComplexNumber Exp(ComplexNumber z1)\n", "    public static ComplexNumber Sin(ComplexNumber z1)\n", "    public static ComplexNumber Cos(ComplexNumber z1)\n", "    public void Conjugate()\n", "    public static ComplexNumber Conjugate(ComplexNumber z1)\n", "    public String toString()\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2005-2009\n// andrew.kirillov@aforgenet.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math;\n\n/**\n * Complex Number.\n *\n * @author Diego Catalano\n */\npublic class ComplexNumber\n{\n\n    /**\n     * Real.\n     */\n    public double real = 0;\n    /**\n     * Imaginary.\n     */\n    public double imaginary = 0;\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     */\n    public ComplexNumber()\n    {\n        this(0, 0);\n    }\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     *\n     * @param real      Real.\n     * @param imaginary Imaginary.\n     */\n    public ComplexNumber(double real, double imaginary)\n    {\n        this.real = real;\n        this.imaginary = imaginary;\n    }\n\n    /**\n     * Initializes a new instance of the ComplexNumber class.\n     *\n     * @param z1 Complex Number.\n     */\n    public ComplexNumber(ComplexNumber z1)\n    {\n        this.real = z1.real;\n        this.imaginary = z1.imaginary;\n    }\n\n    /**\n     * Get Magnitude value of the complex number.\n     *\n     * @return Magnitude.\n     */\n    public double getMagnitude()\n    {\n        return Math.sqrt(real * real + imaginary * imaginary);\n    }\n\n    /**\n     * Get Squared magnitude value of the complex number.\n     *\n     * @return squared magnitude.\n     */\n    public double getSquaredMagnitude()\n    {\n        return real * real + imaginary * imaginary;\n    }\n\n    /**\n     * Get Phase value of the complex number.\n     *\n     * @return Phase value.\n     */\n    public double getPhase()\n    {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Get real part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Real part.\n     */\n    public static double[] getReal(ComplexNumber[] cn)\n    {\n        double[] n = new double[cn.length];\n        for (int i = 0; i < n.length; i++)\n        {\n            n[i] = cn[i].real;\n        }\n        return n;\n    }\n\n    /**\n     * Get imaginary part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Imaginary part.\n     */\n    public static double[] getImaginary(ComplexNumber[] cn)\n    {\n        double[] n = new double[cn.length];\n        for (int i = 0; i < n.length; i++)\n        {\n            n[i] = cn[i].imaginary;\n        }\n        return n;\n    }\n\n    /**\n     * Get real part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Real part.\n     */\n    public static double[][] getReal(ComplexNumber[][] cn)\n    {\n        double[][] n = new double[cn.length][cn[0].length];\n        for (int i = 0; i < n.length; i++)\n        {\n            for (int j = 0; j < n[0].length; j++)\n            {\n                n[i][j] = cn[i][j].real;\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Get imaginary part from the complex numbers.\n     *\n     * @param cn Complex numbers.\n     * @return Imaginary part.\n     */\n    public static double[][] getImaginary(ComplexNumber[][] cn)\n    {\n        double[][] n = new double[cn.length][cn[0].length];\n        for (int i = 0; i < n.length; i++)\n        {\n            for (int j = 0; j < n[0].length; j++)\n            {\n                n[i][j] = cn[i][j].imaginary;\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z1 Complex number.\n     */\n    public static void Swap(ComplexNumber z1)\n    {\n        double t = z1.real;\n        z1.real = z1.imaginary;\n        z1.imaginary = t;\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z Complex number.\n     */\n    public static void Swap(ComplexNumber[] z)\n    {\n        for (int i = 0; i < z.length; i++)\n        {\n            z[i] = new ComplexNumber(z[i].imaginary, z[i].real);\n        }\n    }\n\n    /**\n     * Swap values between real and imaginary.\n     *\n     * @param z Complex number.\n     */\n    public static void Swap(ComplexNumber[][] z)\n    {\n        for (int i = 0; i < z.length; i++)\n        {\n            for (int j = 0; j < z[0].length; j++)\n            {\n                z[i][j] = new ComplexNumber(z[i][j].imaginary, z[i][j].real);\n            }\n        }\n    }\n\n    /**\n     * Absolute value of complex number.\n     * Same result like magnitude.\n     *\n     * @param z Complex Number.\n     * @return Absolute number.\n     */\n    public static double Abs(ComplexNumber z)\n    {\n        return Magnitude(z);\n    }\n\n    /**\n     * Absolute value of complex number.\n     *\n     * @param z Complex Numbers.\n     * @return Absolute number.\n     */\n    public static double[] Abs(ComplexNumber[] z)\n    {\n        double[] values = new double[z.length];\n        for (int i = 0; i < values.length; i++)\n        {\n            values[i] = z[i].getMagnitude();\n        }\n        return values;\n    }\n\n    /**\n     * Absolute value of complex number.\n     *\n     * @param z Complex numbers.\n     * @return Absolute number.\n     */\n    public static double[][] Abs(ComplexNumber[][] z)\n    {\n        double[][] values = new double[z.length][z[0].length];\n        for (int i = 0; i < values.length; i++)\n        {\n            for (int j = 0; j < values[0].length; j++)\n            {\n                values[i][j] = z[i][j].getMagnitude();\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Adds two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the sum of specified complex numbers.\n     */\n    public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2)\n    {\n        return new ComplexNumber(z1.real + z2.real, z1.imaginary + z2.imaginary);\n    }\n\n    /**\n     * Adds the complex number with a scalar value.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the add of specified complex number with scalar value.\n     */\n    public static ComplexNumber Add(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real + scalar, z1.imaginary);\n    }\n\n    /**\n     * Adds scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Add(double scalar)\n    {\n        this.real += scalar;\n    }\n\n    /**\n     * Subtract two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the subtract of specified complex numbers.\n     */\n    public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2)\n    {\n        return new ComplexNumber(z1.real - z2.real, z1.imaginary - z2.imaginary);\n    }\n\n    /**\n     * Subtract a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the subtract of specified complex number with a scalar value.\n     */\n    public static ComplexNumber Subtract(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real - scalar, z1.imaginary);\n    }\n\n    /**\n     * Subtracts scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Subtract(double scalar)\n    {\n        this.real -= scalar;\n    }\n\n    /**\n     * Magnitude of complex number.\n     *\n     * @param z Complex number.\n     * @return Magnitude of complex number.\n     */\n    public static double Magnitude(ComplexNumber z)\n    {\n        return Math.sqrt(z.real * z.real + z.imaginary * z.imaginary);\n    }\n\n    /**\n     * Multiply two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the multiply of specified complex numbers.\n     */\n    public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2)\n    {\n        double z1R = z1.real, z1I = z1.imaginary;\n        double z2R = z2.real, z2I = z2.imaginary;\n\n        return new ComplexNumber(z1R * z2R - z1I * z2I, z1R * z2I + z1I * z2R);\n    }\n\n    /**\n     * Multiply scalar value to a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the multiply of specified complex number with the scalar value.\n     */\n    public static ComplexNumber Multiply(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real * scalar, z1.imaginary * scalar);\n    }\n\n    /**\n     * Multiplys scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Multiply(double scalar)\n    {\n        this.real *= scalar;\n        this.imaginary *= scalar;\n    }\n\n    /**\n     * Divide two complex numbers.\n     *\n     * @param z1 Complex Number.\n     * @param z2 Complex Number.\n     * @return Returns new ComplexNumber instance containing the divide of specified complex numbers.\n     */\n    public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2)\n    {\n\n        ComplexNumber conj = ComplexNumber.Conjugate(z2);\n\n        double a = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\n        double b = z1.real * conj.imaginary + (z1.imaginary * conj.real);\n\n        double c = z2.real * conj.real + ((z2.imaginary * conj.imaginary) * -1);\n\n        return new ComplexNumber(a / c, b / c);\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param z1 Complex Number.\n     */\n    public void Divide(ComplexNumber z1)\n    {\n        ComplexNumber conj = ComplexNumber.Conjugate(z1);\n\n        double a = this.real * conj.real + ((this.imaginary * conj.imaginary) * -1);\n        double b = this.real * conj.imaginary + (this.imaginary * conj.real);\n\n        double c = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\n\n        this.real = a / c;\n        this.imaginary = b / c;\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param z1     Complex Number.\n     * @param scalar Scalar value.\n     * @return Returns new ComplexNumber instance containing the divide of specified complex number with the scalar value.\n     */\n    public static ComplexNumber Divide(ComplexNumber z1, double scalar)\n    {\n        return new ComplexNumber(z1.real / scalar, z1.imaginary / scalar);\n    }\n\n    /**\n     * Divides scalar value to a complex number.\n     *\n     * @param scalar Scalar value.\n     */\n    public void Divide(double scalar)\n    {\n\n        if (scalar == 0)\n        {\n            try\n            {\n                throw new ArithmeticException(\"Can not divide by zero.\");\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n            }\n        }\n\n        this.real /= scalar;\n        this.imaginary /= scalar;\n    }\n\n    /**\n     * Calculate power of a complex number.\n     *\n     * @param z1 Complex Number.\n     * @param n  Power.\n     * @return Returns a new complex number containing the power of a specified number.\n     */\n    public static ComplexNumber Pow(ComplexNumber z1, double n)\n    {\n\n        double norm = Math.pow(z1.getMagnitude(), n);\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(z1.imaginary / z1.real)));\n\n        double common = n * angle;\n\n        double r = norm * Math.cos(Math.toRadians(common));\n        double i = norm * Math.sin(Math.toRadians(common));\n\n        return new ComplexNumber(r, i);\n\n    }\n\n    /**\n     * Calculate power of a complex number.\n     *\n     * @param n Power.\n     */\n    public void Pow(double n)\n    {\n        double norm = Math.pow(getMagnitude(), n);\n        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(this.imaginary / this.real)));\n\n        double common = n * angle;\n\n        this.real = norm * Math.cos(Math.toRadians(common));\n        this.imaginary = norm * Math.sin(Math.toRadians(common));\n    }\n\n    /**\n     * Calculates natural (base <b>e</b>) logarithm of a complex number.\n     *\n     * @param z1 Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the natural logarithm of the specified complex number.\n     */\n    public static ComplexNumber Log(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if ((z1.real > 0.0) && (z1.imaginary == 0.0))\n        {\n            result.real = Math.log(z1.real);\n            result.imaginary = 0.0;\n        }\n        else if (z1.real == 0.0)\n        {\n            if (z1.imaginary > 0.0)\n            {\n                result.real = Math.log(z1.imaginary);\n                result.imaginary = Math.PI / 2.0;\n            }\n            else\n            {\n                result.real = Math.log(-(z1.imaginary));\n                result.imaginary = -Math.PI / 2.0;\n            }\n        }\n        else\n        {\n            result.real = Math.log(z1.getMagnitude());\n            result.imaginary = Math.atan2(z1.imaginary, z1.real);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates exponent (e raised to the specified power) of a complex number.\n     *\n     * @param z1 A Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the exponent of the specified complex number.\n     */\n    public static ComplexNumber Exp(ComplexNumber z1)\n    {\n        ComplexNumber x, y;\n        x = new ComplexNumber(Math.exp(z1.real), 0.0);\n        y = new ComplexNumber(Math.cos(z1.imaginary), Math.sin(z1.imaginary));\n\n        return Multiply(x, y);\n    }\n\n    /**\n     * Calculates Sine value of the complex number.\n     *\n     * @param z1 A Complex Number instance.\n     * @return Returns new ComplexNumber instance containing the Sine value of the specified complex number.\n     */\n    public static ComplexNumber Sin(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.sin(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            result.real = Math.sin(z1.real) * Math.cosh(z1.imaginary);\n            result.imaginary = Math.cos(z1.real) * Math.sinh(z1.imaginary);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates Cosine value of the complex number.\n     *\n     * @param z1 A ComplexNumber instance.\n     * @return Returns new ComplexNumber instance containing the Cosine value of the specified complex number.\n     */\n    public static ComplexNumber Cos(ComplexNumber z1)\n    {\n        ComplexNumber result = new ComplexNumber();\n\n        if (z1.imaginary == 0.0)\n        {\n            result.real = Math.cos(z1.real);\n            result.imaginary = 0.0;\n        }\n        else\n        {\n            result.real = Math.cos(z1.real) * Math.cosh(z1.imaginary);\n            result.imaginary = -Math.sin(z1.real) * Math.sinh(z1.imaginary);\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates Tangent value of the complex number.\n     *\n     * @param z1 A ComplexNumber instance.\n     * @return Returns new ComplexNumber instance containing the Tangent value of the specified complex number.\n     */\n\n    /**\n     * Conjugate this complex number.\n     */\n    public void Conjugate()\n    {\n        this.imaginary *= -1;\n    }\n\n    /**\n     * Conjugate a complex number.\n     *\n     * @param z1 Complex number.\n     * @return Returns new ComplexNumber instance containing the conjugate of the specified complex number.\n     */\n    public static ComplexNumber Conjugate(ComplexNumber z1)\n    {\n        return new ComplexNumber(z1.real, z1.imaginary * -1);\n    }\n\n    @Override\n    public String toString()\n    {\n        if (this.imaginary >= 0)\n            return this.real + \" +\" + this.imaginary + \"i\";\n        return this.real + \" \" + this.imaginary + \"i\";\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/random/UniversalGenerator.java", "func_name": "UniversalGenerator.srand", "original_string": "private void srand(int ijkl) {\n        u = new double[97];\n\n        int ij = ijkl / 30082;\n        int kl = ijkl % 30082;\n\n        // Handle the seed range errors\n        // First random number seed must be between 0 and 31328\n        // Second seed must have a value between 0 and 30081\n        if (ij < 0 || ij > 31328 || kl < 0 || kl > 30081) {\n            ij = ij % 31329;\n            kl = kl % 30082;\n        }\n\n        int i = ((ij / 177) % 177) + 2;\n        int j = (ij % 177) + 2;\n        int k = ((kl / 169) % 178) + 1;\n        int l = kl % 169;\n\n        int m;\n        double s, t;\n        for (int ii = 0; ii < 97; ii++) {\n            s = 0.0;\n            t = 0.5;\n            for (int jj = 0; jj < 24; jj++) {\n                m = (((i * j) % 179) * k) % 179;\n                i = j;\n                j = k;\n                k = m;\n                l = (53 * l + 1) % 169;\n                if (((l * m) % 64) >= 32) {\n                    s += t;\n                }\n                t *= 0.5;\n            }\n            u[ii] = s;\n        }\n\n        c = 362436.0 / 16777216.0;\n        cd = 7654321.0 / 16777216.0;\n        cm = 16777213.0 / 16777216.0;\n        i97 = 96;\n        j97 = 32;\n    }", "language": "java", "code": "private void srand(int ijkl) {\n        u = new double[97];\n\n        int ij = ijkl / 30082;\n        int kl = ijkl % 30082;\n\n        // Handle the seed range errors\n        // First random number seed must be between 0 and 31328\n        // Second seed must have a value between 0 and 30081\n        if (ij < 0 || ij > 31328 || kl < 0 || kl > 30081) {\n            ij = ij % 31329;\n            kl = kl % 30082;\n        }\n\n        int i = ((ij / 177) % 177) + 2;\n        int j = (ij % 177) + 2;\n        int k = ((kl / 169) % 178) + 1;\n        int l = kl % 169;\n\n        int m;\n        double s, t;\n        for (int ii = 0; ii < 97; ii++) {\n            s = 0.0;\n            t = 0.5;\n            for (int jj = 0; jj < 24; jj++) {\n                m = (((i * j) % 179) * k) % 179;\n                i = j;\n                j = k;\n                k = m;\n                l = (53 * l + 1) % 169;\n                if (((l * m) % 64) >= 32) {\n                    s += t;\n                }\n                t *= 0.5;\n            }\n            u[ii] = s;\n        }\n\n        c = 362436.0 / 16777216.0;\n        cd = 7654321.0 / 16777216.0;\n        cm = 16777213.0 / 16777216.0;\n        i97 = 96;\n        j97 = 32;\n    }", "code_tokens": ["private", "void", "srand", "(", "int", "ijkl", ")", "{", "u", "=", "new", "double", "[", "97", "]", ";", "int", "ij", "=", "ijkl", "/", "30082", ";", "int", "kl", "=", "ijkl", "%", "30082", ";", "// Handle the seed range errors", "// First random number seed must be between 0 and 31328", "// Second seed must have a value between 0 and 30081", "if", "(", "ij", "<", "0", "||", "ij", ">", "31328", "||", "kl", "<", "0", "||", "kl", ">", "30081", ")", "{", "ij", "=", "ij", "%", "31329", ";", "kl", "=", "kl", "%", "30082", ";", "}", "int", "i", "=", "(", "(", "ij", "/", "177", ")", "%", "177", ")", "+", "2", ";", "int", "j", "=", "(", "ij", "%", "177", ")", "+", "2", ";", "int", "k", "=", "(", "(", "kl", "/", "169", ")", "%", "178", ")", "+", "1", ";", "int", "l", "=", "kl", "%", "169", ";", "int", "m", ";", "double", "s", ",", "t", ";", "for", "(", "int", "ii", "=", "0", ";", "ii", "<", "97", ";", "ii", "++", ")", "{", "s", "=", "0.0", ";", "t", "=", "0.5", ";", "for", "(", "int", "jj", "=", "0", ";", "jj", "<", "24", ";", "jj", "++", ")", "{", "m", "=", "(", "(", "(", "i", "*", "j", ")", "%", "179", ")", "*", "k", ")", "%", "179", ";", "i", "=", "j", ";", "j", "=", "k", ";", "k", "=", "m", ";", "l", "=", "(", "53", "*", "l", "+", "1", ")", "%", "169", ";", "if", "(", "(", "(", "l", "*", "m", ")", "%", "64", ")", ">=", "32", ")", "{", "s", "+=", "t", ";", "}", "t", "*=", "0.5", ";", "}", "u", "[", "ii", "]", "=", "s", ";", "}", "c", "=", "362436.0", "/", "16777216.0", ";", "cd", "=", "7654321.0", "/", "16777216.0", ";", "cm", "=", "16777213.0", "/", "16777216.0", ";", "i97", "=", "96", ";", "j97", "=", "32", ";", "}"], "docstring": "Initialize the random generator with a seed.", "docstring_tokens": ["Initialize", "the", "random", "generator", "with", "a", "seed", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/random/UniversalGenerator.java#L85-L128", "partition": "train", "up_fun_num": 3, "levels": [0, 1, 1, 1, 1, 1, 1, 1], "package": [], "function": ["public class UniversalGenerator implements IRandomNumberGenerator\n", "    public void setSeed(long seed)\n", "    public double nextDouble()\n", "    public void nextDoubles(double[] d)\n", "    public int nextBits(int numbits)\n", "    public int nextInt()\n", "    public int nextInt(int n)\n", "    public long nextLong()\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright 2015 Diego Catalano\n// diego.catalano at live.com\n//\n// Copyright 2015 Haifeng Li\n// haifeng.hli at gmail.com\n//\n// Based on Smile (Statistical Machine Intelligence & Learning Engine)\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage com.harium.keel.catalano.math.random;\n\n/**\n * The so called \"Universal Generator\" based on multiplicative congruential\n * method, which originally appeared in \"Toward a Universal Random Number\n * Generator\" by Marsaglia, Zaman and Tsang. It was later modified by F. James\n * in \"A Review of Pseudo-random Number Generators\". It passes ALL of the tests\n * for random number generators and has a period of 2<sup>144</sup>. It is\n * completely portable (gives bit identical results on all machines with at\n * least 24-bit mantissas in the floating point representation).\n *\n * @author Haifeng Li\n */\npublic class UniversalGenerator implements IRandomNumberGenerator\n{\n\n    /**\n     * Default seed.  <CODE>DEFAULT_RANDOM_SEED=54217137</CODE>\n     */\n    private static final int DEFAULT_RANDOM_SEED = 54217137;\n    /**\n     * The 46,009,220nd prime number,\n     * The largest prime less than 9*10<SUP>8</SUP>.  Used as a modulus\n     * because this version of <TT>random()</TT> needs a seed between 0\n     * and 9*10<SUP>8</SUP> and <CODE>BIG_PRIME</CODE> isn't commensurate\n     * with any regular period.\n     * <CODE>BIG_PRIME = 899999963</CODE>\n     */\n    private static final int BIG_PRIME = 899999963;\n    private double c, cd, cm, u[];\n    private int i97, j97;\n\n    @Override\n    public void setSeed(long seed)\n    {\n        srand(Math.abs((int) (seed % BIG_PRIME)));\n    }\n\n    /**\n     * Initialize Random with default seed.\n     */\n    public UniversalGenerator()\n    {\n        srand(DEFAULT_RANDOM_SEED);\n    }\n\n    /**\n     * Initialize Random with a specified integer seed\n     */\n    public UniversalGenerator(int seed)\n    {\n        srand(Math.abs(seed % BIG_PRIME));\n    }\n\n    /**\n     * Initialize Random with a specified long seed\n     */\n    public UniversalGenerator(long seed)\n    {\n        setSeed(seed);\n    }\n\n    /**\n     * Initialize the random generator with a seed.\n     */\n\n    @Override\n    public double nextDouble()\n    {\n        double uni;\n\n        uni = u[i97] - u[j97];\n        if (uni < 0.0)\n        {\n            uni += 1.0;\n        }\n\n        u[i97] = uni;\n        if (--i97 < 0)\n        {\n            i97 = 96;\n        }\n\n        if (--j97 < 0)\n        {\n            j97 = 96;\n        }\n\n        c -= cd;\n        if (c < 0.0)\n        {\n            c += cm;\n        }\n\n        uni -= c;\n        if (uni < 0.0)\n        {\n            uni++;\n        }\n\n        return uni;\n    }\n\n    @Override\n    public void nextDoubles(double[] d)\n    {\n        int n = d.length;\n\n        double uni;\n\n        for (int i = 0; i < n; i++)\n        {\n            uni = u[i97] - u[j97];\n            if (uni < 0.0)\n            {\n                uni += 1.0;\n            }\n            u[i97] = uni;\n            if (--i97 < 0)\n            {\n                i97 = 96;\n            }\n            if (--j97 < 0)\n            {\n                j97 = 96;\n            }\n            c -= cd;\n            if (c < 0.0)\n            {\n                c += cm;\n            }\n            uni -= c;\n            if (uni < 0.0)\n            {\n                uni += 1.0;\n            }\n            d[i] = uni;\n        }\n    }\n\n    @Override\n    public int nextBits(int numbits)\n    {\n        return nextInt() >>> (32 - numbits);\n    }\n\n    @Override\n    public int nextInt()\n    {\n        return (int) Math.floor(Integer.MAX_VALUE * (2 * nextDouble() - 1.0));\n    }\n\n    @Override\n    public int nextInt(int n)\n    {\n        if (n <= 0)\n        {\n            throw new IllegalArgumentException(\"n must be positive\");\n        }\n\n        // n is a power of 2\n        if ((n & -n) == n)\n        {\n            return (int) ((n * (long) nextBits(31)) >> 31);\n        }\n\n        int bits, val;\n        do\n        {\n            bits = nextBits(31);\n            val = bits % n;\n        }\n        while (bits - val + (n - 1) < 0);\n\n        return val;\n    }\n\n    @Override\n    public long nextLong()\n    {\n        return (long) Math.floor(Long.MAX_VALUE * (2 * nextDouble() - 1.0));\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/core/IntPoint.java", "func_name": "IntPoint.DistanceTo", "original_string": "public float DistanceTo(IntPoint anotherPoint) {\r\n        float dx = this.x - anotherPoint.x;\r\n        float dy = this.y - anotherPoint.y;\r\n\r\n        return (float) Math.sqrt(dx * dx + dy * dy);\r\n    }", "language": "java", "code": "public float DistanceTo(IntPoint anotherPoint) {\r\n        float dx = this.x - anotherPoint.x;\r\n        float dy = this.y - anotherPoint.y;\r\n\r\n        return (float) Math.sqrt(dx * dx + dy * dy);\r\n    }", "code_tokens": ["public", "float", "DistanceTo", "(", "IntPoint", "anotherPoint", ")", "{", "float", "dx", "=", "this", ".", "x", "-", "anotherPoint", ".", "x", ";", "float", "dy", "=", "this", ".", "y", "-", "anotherPoint", ".", "y", ";", "return", "(", "float", ")", "Math", ".", "sqrt", "(", "dx", "*", "dx", "+", "dy", "*", "dy", ")", ";", "}"], "docstring": "Calculate Euclidean distance between two points.\n\n@param anotherPoint Point to calculate distance to.\n@return Euclidean distance between this point and anotherPoint points.", "docstring_tokens": ["Calculate", "Euclidean", "distance", "between", "two", "points", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/core/IntPoint.java#L260-L265", "partition": "train", "up_fun_num": 15, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": [], "function": ["public class IntPoint\n", "    public void setXY(int x, int y)\n", "    public void Add(IntPoint point)\n", "    public static IntPoint Add(IntPoint point1, IntPoint point2)\n", "    public void Add(int value)\n", "    public void Subtract(IntPoint point)\n", "    public static IntPoint Subtract(IntPoint point1, IntPoint point2)\n", "    public void Subtract(int value)\n", "    public void Multiply(IntPoint point)\n", "    public static IntPoint Multiply(IntPoint point1, IntPoint point2)\n", "    public void Multiply(int value)\n", "    public void Divide(IntPoint point)\n", "    public static IntPoint Divide(IntPoint point1, IntPoint point2)\n", "    public void Divide(int value)\n", "    public FloatPoint toFloatPoint()\n", "    public DoublePoint toDoublePoint()\n", "    public void Swap()\n", "    public boolean equals(Object obj)\n", "    public int hashCode()\n", "    public String toString()\n"], "context": "// Catalano Core Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2007-2008\n// andrew.kirillov at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.core;\n\n/**\n * Class for representing a pair of coordinates of integer type.\n *\n * @author Diego Catalano\n */\npublic class IntPoint\n{\n\n    /**\n     * X axis coordinate.\n     */\n    /**\n     * Y axis coordinate.\n     */\n    public int x, y;\n\n    /**\n     * Initializes a new instance of the IntPoint class.\n     */\n    public IntPoint()\n    {\n    }\n\n    /**\n     * Initializes a new instance of the IntPoint class.\n     *\n     * @param point IntPoint.\n     */\n    public IntPoint(IntPoint point)\n    {\n        this.x = point.x;\n        this.y = point.y;\n    }\n\n    /**\n     * Initializes a new instance of the IntPoint class.\n     *\n     * @param x X axis coordinate.\n     * @param y Y axis coordinate.\n     */\n    public IntPoint(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Initializes a new instance of the IntPoint class.\n     *\n     * @param x X axis coordinate.\n     * @param y Y axis coordinate.\n     */\n    public IntPoint(float x, float y)\n    {\n        this.x = (int) x;\n        this.y = (int) y;\n    }\n\n    /**\n     * Initializes a new instance of the IntPoint class.\n     *\n     * @param x X axis coordinate.\n     * @param y Y axis coordinate.\n     */\n    public IntPoint(double x, double y)\n    {\n        this.x = (int) x;\n        this.y = (int) y;\n    }\n\n    /**\n     * Initializes a new instance of the IntPoint class.\n     *\n     * @param point FloatPoint.\n     */\n    public IntPoint(FloatPoint point)\n    {\n        this.x = (int) point.x;\n        this.y = (int) point.y;\n    }\n\n    /**\n     * Initializes a new instance of the IntPoint class.\n     *\n     * @param point DoublePoint.\n     */\n    public IntPoint(DoublePoint point)\n    {\n        this.x = (int) point.x;\n        this.y = (int) point.y;\n    }\n\n    /**\n     * Sets X and Y axis coordinates.\n     *\n     * @param x X axis coordinate.\n     * @param y Y axis coordinate.\n     */\n    public void setXY(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Adds values of two points.\n     *\n     * @param point IntPoint.\n     */\n    public void Add(IntPoint point)\n    {\n        this.x += point.x;\n        this.y += point.y;\n    }\n\n    /**\n     * Adds values of two points.\n     *\n     * @param point1 IntPoint.\n     * @param point2 IntPoint.\n     * @return IntPoint that contains X and Y axis coordinate.\n     */\n    public static IntPoint Add(IntPoint point1, IntPoint point2)\n    {\n        IntPoint result = new IntPoint(point1);\n        result.Add(point2);\n        return result;\n    }\n\n    /**\n     * Adds values of two points.\n     *\n     * @param value Value.\n     */\n    public void Add(int value)\n    {\n        this.x += value;\n        this.y += value;\n    }\n\n    /**\n     * Subtract values of two points.\n     *\n     * @param point IntPoint.\n     */\n    public void Subtract(IntPoint point)\n    {\n        this.x -= point.x;\n        this.y -= point.y;\n    }\n\n    /**\n     * Subtract values of two points.\n     *\n     * @param point1 IntPoint.\n     * @param point2 IntPoint.\n     * @return IntPoint that contains X and Y axis coordinate.\n     */\n    public static IntPoint Subtract(IntPoint point1, IntPoint point2)\n    {\n        IntPoint result = new IntPoint(point1);\n        result.Subtract(point2);\n        return result;\n    }\n\n    /**\n     * Subtract values of two points.\n     *\n     * @param value\n     */\n    public void Subtract(int value)\n    {\n        this.x -= value;\n        this.y -= value;\n    }\n\n    /**\n     * Multiply values of two points.\n     *\n     * @param point IntPoint.\n     */\n    public void Multiply(IntPoint point)\n    {\n        this.x *= point.x;\n        this.y *= point.y;\n    }\n\n    /**\n     * Multiply values of two points.\n     *\n     * @param point1 IntPoint.\n     * @param point2 IntPoint.\n     * @return IntPoint that contains X and Y axis coordinate.\n     */\n    public static IntPoint Multiply(IntPoint point1, IntPoint point2)\n    {\n        IntPoint result = new IntPoint(point1);\n        result.Multiply(point2);\n        return result;\n    }\n\n    /**\n     * Multiply values of two points.\n     *\n     * @param value Value.\n     */\n    public void Multiply(int value)\n    {\n        this.x *= value;\n        this.y *= value;\n    }\n\n    /**\n     * Divides values of two points.\n     *\n     * @param point IntPoint.\n     */\n    public void Divide(IntPoint point)\n    {\n        this.x /= point.x;\n        this.y /= point.y;\n    }\n\n    /**\n     * Divides values of two points.\n     *\n     * @param point1 IntPoint.\n     * @param point2 IntPoint.\n     * @return IntPoint that contains X and Y axis coordinate.\n     */\n    public static IntPoint Divide(IntPoint point1, IntPoint point2)\n    {\n        IntPoint result = new IntPoint(point1);\n        result.Divide(point2);\n        return result;\n    }\n\n    /**\n     * Divides values of two points.\n     *\n     * @param value Value.\n     */\n    public void Divide(int value)\n    {\n        this.x /= value;\n        this.y /= value;\n    }\n\n    /**\n     * Calculate Euclidean distance between two points.\n     *\n     * @param anotherPoint Point to calculate distance to.\n     * @return Euclidean distance between this point and anotherPoint points.\n     */\n\n    /**\n     * Convert IntPoint to FloatPoint.\n     *\n     * @return FloatPoint.\n     */\n    public FloatPoint toFloatPoint()\n    {\n        return new FloatPoint(this.x, this.y);\n    }\n\n    /**\n     * Convert IntPoint to DoublePoint.\n     *\n     * @return DoublePoint.\n     */\n    public DoublePoint toDoublePoint()\n    {\n        return new DoublePoint(this.x, this.y);\n    }\n\n    /**\n     * Swap values between the coordinates.\n     */\n    public void Swap()\n    {\n        int temp = x;\n        x = y;\n        y = temp;\n    }\n\n    @Override\n    public boolean equals(Object obj)\n    {\n        if (obj.getClass().isAssignableFrom(IntPoint.class))\n        {\n            IntPoint point = (IntPoint) obj;\n            if ((this.x == point.x) && (this.y == point.y))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        int hash = 3;\n        hash = 67 * hash + this.x;\n        hash = 67 * hash + this.y;\n        return hash;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"X: \" + this.x + \" Y: \" + this.y;\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/statistics/HistogramStatistics.java", "func_name": "HistogramStatistics.Entropy", "original_string": "public static double Entropy( int[] values ){\n        int     n = values.length;\n        int     total = 0;\n        double  entropy = 0;\n        double  p;\n\n        // calculate total amount of hits\n        for ( int i = 0; i < n; i++ )\n        {\n            total += values[i];\n        }\n\n        if ( total != 0 )\n        {\n            // for all values\n            for ( int i = 0; i < n; i++ )\n            {\n                // get item's probability\n                p = (double) values[i] / total;\n                // calculate entropy\n                if ( p != 0 )\n                    entropy += ( -p * (Math.log10(p)/Math.log10(2)) );\n            }\n        }\n        return entropy;\n    }", "language": "java", "code": "public static double Entropy( int[] values ){\n        int     n = values.length;\n        int     total = 0;\n        double  entropy = 0;\n        double  p;\n\n        // calculate total amount of hits\n        for ( int i = 0; i < n; i++ )\n        {\n            total += values[i];\n        }\n\n        if ( total != 0 )\n        {\n            // for all values\n            for ( int i = 0; i < n; i++ )\n            {\n                // get item's probability\n                p = (double) values[i] / total;\n                // calculate entropy\n                if ( p != 0 )\n                    entropy += ( -p * (Math.log10(p)/Math.log10(2)) );\n            }\n        }\n        return entropy;\n    }", "code_tokens": ["public", "static", "double", "Entropy", "(", "int", "[", "]", "values", ")", "{", "int", "n", "=", "values", ".", "length", ";", "int", "total", "=", "0", ";", "double", "entropy", "=", "0", ";", "double", "p", ";", "// calculate total amount of hits", "for", "(", "int", "i", "=", "0", ";", "i", "<", "n", ";", "i", "++", ")", "{", "total", "+=", "values", "[", "i", "]", ";", "}", "if", "(", "total", "!=", "0", ")", "{", "// for all values", "for", "(", "int", "i", "=", "0", ";", "i", "<", "n", ";", "i", "++", ")", "{", "// get item's probability", "p", "=", "(", "double", ")", "values", "[", "i", "]", "/", "total", ";", "// calculate entropy", "if", "(", "p", "!=", "0", ")", "entropy", "+=", "(", "-", "p", "*", "(", "Math", ".", "log10", "(", "p", ")", "/", "Math", ".", "log10", "(", "2", ")", ")", ")", ";", "}", "}", "return", "entropy", ";", "}"], "docstring": "Calculate entropy value.\n@param values Values.\n@return Returns entropy value of the specified histogram array.", "docstring_tokens": ["Calculate", "entropy", "value", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/statistics/HistogramStatistics.java#L46-L71", "partition": "train", "up_fun_num": 2, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.IntRange;"], "function": ["public final class HistogramStatistics\n", "    public static IntRange GetRange( int[] values, double percent )\n", "    public static double Kurtosis(int[] values)\n", "    public static double Kurtosis(int[] values, double mean, double stdDeviation)\n", "    public static double Mean( int[] values )\n", "    public static int Median( int[] values )\n", "    public static int Mode( int[] values )\n", "    public static double Skewness(int[] values)\n", "    public static double Skewness(int[] values, double mean, double stdDeviation)\n", "    public static double StdDev( int[] values )\n", "    public static double StdDev( int[] values, double mean )\n"], "context": "// Catalano Imaging Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2007-2008\n// andrew.kirillov at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.statistics;\n\n\nimport com.harium.keel.catalano.core.IntRange;\n\n/**\n * Set of histogram statistics functions.\n * @author Diego Catalano\n */\npublic final class HistogramStatistics\n{\n\n    /**\n     * Don't let anyone instantiate this class.\n     */\n    private HistogramStatistics() {}\n\n    /**\n     * Calculate entropy value.\n     * @param values Values.\n     * @return Returns entropy value of the specified histogram array.\n     */\n\n    /**\n     * Get range around median containing specified percentage of values.\n     * @param values Values.\n     * @param percent Values percentage around median.\n     * @return Returns the range which containes specifies percentage of values.\n     */\n    public static IntRange GetRange( int[] values, double percent )\n    {\n        int total = 0, n = values.length;\n\n        // for all values\n        for ( int i = 0; i < n; i++ )\n        {\n            // accumalate total\n            total += values[i];\n        }\n\n        int min, max, hits;\n        int h = (int) ( total * ( percent + ( 1 - percent ) / 2 ) );\n\n        // get range min value\n        for ( min = 0, hits = total; min < n; min++ )\n        {\n            hits -= values[min];\n            if ( hits < h )\n                break;\n        }\n        // get range max value\n        for ( max = n - 1, hits = total; max >= 0; max-- )\n        {\n            hits -= values[max];\n            if ( hits < h )\n                break;\n        }\n        return new IntRange( min, max );\n    }\n\n    /**\n     * Calculate Kurtosis value.\n     * @param values Values.\n     * @return Returns kurtosis value of the specified histogram array.\n     */\n    public static double Kurtosis(int[] values)\n    {\n        double mean = Mean(values);\n        double std = StdDev(values, mean);\n        return Kurtosis(values, mean, std);\n    }\n\n    /**\n     * Calculate Kurtosis value.\n     * @param values Values.\n     * @param mean Specified mean.\n     * @param stdDeviation Specified standard deviation.\n     * @return Returns kurtosis value of the specified histogram array.\n     */\n    public static double Kurtosis(int[] values, double mean, double stdDeviation)\n    {\n        double n = 0;\n        for (int i = 0; i < values.length; i++)\n            n += values[i];\n\n        double part1 = n * (n + 1);\n        part1 /= ((n - 1) * (n - 2) * (n - 3));\n\n        double part2 = 0;\n        for (int i = 0; i < values.length; i++)\n        {\n            part2 += Math.pow((i - mean) / stdDeviation, 4) * values[i];\n        }\n\n        double part3 = 3 * Math.pow((n - 1), 2);\n        part3 /= (n - 2) * (n - 3);\n\n        return part1 * part2 - part3;\n    }\n\n    /**\n     * Calculate Mean value.\n     * @param values Values.\n     * @return Mean.\n     */\n    public static double Mean( int[] values )\n    {\n        int     hits;\n        long    total = 0;\n        double  mean = 0;\n\n        // for all values\n        for ( int i = 0, n = values.length; i < n; i++ )\n        {\n            hits = values[i];\n            // accumulate mean\n            mean += i * hits;\n            // accumalate total\n            total += hits;\n        }\n        return ( total == 0 ) ? 0 : mean / total;\n    }\n\n    /**\n      * Calculate Median value.\n      * @param values Values.\n      * @return Median.\n      */\n    public static int Median( int[] values )\n    {\n        int total = 0, n = values.length;\n\n        // for all values\n        for ( int i = 0; i < n; i++ )\n        {\n            // accumalate total\n            total += values[i];\n        }\n\n        int halfTotal = total / 2;\n        int median = 0, v = 0;\n\n        // find median value\n        for ( ; median < n; median++ )\n        {\n            v += values[median];\n            if ( v >= halfTotal )\n                break;\n        }\n\n        return median;\n    }\n\n    /**\n     * Calculate Mode value.\n     * @param values Values.\n     * @return Returns mode value of the histogram array.\n     */\n    public static int Mode( int[] values )\n    {\n        int mode = 0, curMax = 0;\n\n        for ( int i = 0, length = values.length; i < length; i++ )\n        {\n            if ( values[i] > curMax )\n            {\n                curMax = values[i];\n                mode = i;\n            }\n        }\n        return mode;\n    }\n\n    /**\n     * Calculate Skewness value.\n     * @param values Values.\n     * @return Returns skewness value of the specified histogram array.\n     */\n    public static double Skewness(int[] values)\n    {\n        double mean = Mean(values);\n        double std = StdDev(values, mean);\n        return Skewness(values, mean, std);\n    }\n\n    /**\n     * Calculate Skewness value.\n     * @param values Values.\n     * @param mean Specified mean.\n     * @param stdDeviation Specified standard deviation.\n     * @return Returns skewness value of the specified histogram array.\n     */\n    public static double Skewness(int[] values, double mean, double stdDeviation)\n    {\n        double n = 0;\n        for (int i = 0; i < values.length; i++)\n            n += values[i];\n\n        double part1 = n / (n - 1) * (n - 2);\n\n        double part2 = 0;\n        for (int i = 0; i < values.length; i++)\n        {\n            part2 += Math.pow((i - mean) / stdDeviation, 3) * values[i];\n        }\n\n        return part1 * part2;\n    }\n\n    /**\n     * Calculate standart deviation.\n     * @param values Values.\n     * @return Standart deviation.\n     */\n    public static double StdDev( int[] values )\n    {\n        return StdDev( values, Mean( values ) );\n    }\n\n    /**\n     * Calculate standart deviation.\n     * @param values Values.\n     * @param mean Mean.\n     * @return Standart deviation.\n     */\n    public static double StdDev( int[] values, double mean )\n    {\n        double  stddev = 0;\n        double  diff;\n        int     hits;\n        int     total = 0;\n\n        // for all values\n        for ( int i = 0, n = values.length; i < n; i++ )\n        {\n            hits = values[i];\n            diff = (double) i - mean;\n            // accumulate std.dev.\n            stddev += diff * diff * hits;\n            // accumalate total\n            total += hits;\n        }\n\n        return ( total == 0 ) ? 0 : Math.sqrt( stddev / (total - 1) );\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/statistics/HistogramStatistics.java", "func_name": "HistogramStatistics.GetRange", "original_string": "public static IntRange GetRange( int[] values, double percent ){\n        int total = 0, n = values.length;\n\n        // for all values\n        for ( int i = 0; i < n; i++ )\n        {\n            // accumalate total\n            total += values[i];\n        }\n\n        int min, max, hits;\n        int h = (int) ( total * ( percent + ( 1 - percent ) / 2 ) );\n\n        // get range min value\n        for ( min = 0, hits = total; min < n; min++ )\n        {\n            hits -= values[min];\n            if ( hits < h )\n                break;\n        }\n        // get range max value\n        for ( max = n - 1, hits = total; max >= 0; max-- )\n        {\n            hits -= values[max];\n            if ( hits < h )\n                break;\n        }\n        return new IntRange( min, max );\n    }", "language": "java", "code": "public static IntRange GetRange( int[] values, double percent ){\n        int total = 0, n = values.length;\n\n        // for all values\n        for ( int i = 0; i < n; i++ )\n        {\n            // accumalate total\n            total += values[i];\n        }\n\n        int min, max, hits;\n        int h = (int) ( total * ( percent + ( 1 - percent ) / 2 ) );\n\n        // get range min value\n        for ( min = 0, hits = total; min < n; min++ )\n        {\n            hits -= values[min];\n            if ( hits < h )\n                break;\n        }\n        // get range max value\n        for ( max = n - 1, hits = total; max >= 0; max-- )\n        {\n            hits -= values[max];\n            if ( hits < h )\n                break;\n        }\n        return new IntRange( min, max );\n    }", "code_tokens": ["public", "static", "IntRange", "GetRange", "(", "int", "[", "]", "values", ",", "double", "percent", ")", "{", "int", "total", "=", "0", ",", "n", "=", "values", ".", "length", ";", "// for all values", "for", "(", "int", "i", "=", "0", ";", "i", "<", "n", ";", "i", "++", ")", "{", "// accumalate total", "total", "+=", "values", "[", "i", "]", ";", "}", "int", "min", ",", "max", ",", "hits", ";", "int", "h", "=", "(", "int", ")", "(", "total", "*", "(", "percent", "+", "(", "1", "-", "percent", ")", "/", "2", ")", ")", ";", "// get range min value", "for", "(", "min", "=", "0", ",", "hits", "=", "total", ";", "min", "<", "n", ";", "min", "++", ")", "{", "hits", "-=", "values", "[", "min", "]", ";", "if", "(", "hits", "<", "h", ")", "break", ";", "}", "// get range max value", "for", "(", "max", "=", "n", "-", "1", ",", "hits", "=", "total", ";", "max", ">=", "0", ";", "max", "--", ")", "{", "hits", "-=", "values", "[", "max", "]", ";", "if", "(", "hits", "<", "h", ")", "break", ";", "}", "return", "new", "IntRange", "(", "min", ",", "max", ")", ";", "}"], "docstring": "Get range around median containing specified percentage of values.\n@param values Values.\n@param percent Values percentage around median.\n@return Returns the range which containes specifies percentage of values.", "docstring_tokens": ["Get", "range", "around", "median", "containing", "specified", "percentage", "of", "values", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/statistics/HistogramStatistics.java#L79-L107", "partition": "train", "up_fun_num": 3, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.IntRange;"], "function": ["public final class HistogramStatistics\n", "    public static double Entropy( int[] values )\n", "    public static double Kurtosis(int[] values)\n", "    public static double Kurtosis(int[] values, double mean, double stdDeviation)\n", "    public static double Mean( int[] values )\n", "    public static int Median( int[] values )\n", "    public static int Mode( int[] values )\n", "    public static double Skewness(int[] values)\n", "    public static double Skewness(int[] values, double mean, double stdDeviation)\n", "    public static double StdDev( int[] values )\n", "    public static double StdDev( int[] values, double mean )\n"], "context": "// Catalano Imaging Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2007-2008\n// andrew.kirillov at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.statistics;\n\n\nimport com.harium.keel.catalano.core.IntRange;\n\n/**\n * Set of histogram statistics functions.\n * @author Diego Catalano\n */\npublic final class HistogramStatistics\n{\n\n    /**\n     * Don't let anyone instantiate this class.\n     */\n    private HistogramStatistics() {}\n\n    /**\n     * Calculate entropy value.\n     * @param values Values.\n     * @return Returns entropy value of the specified histogram array.\n     */\n    public static double Entropy( int[] values )\n    {\n        int     n = values.length;\n        int     total = 0;\n        double  entropy = 0;\n        double  p;\n\n        // calculate total amount of hits\n        for ( int i = 0; i < n; i++ )\n        {\n            total += values[i];\n        }\n\n        if ( total != 0 )\n        {\n            // for all values\n            for ( int i = 0; i < n; i++ )\n            {\n                // get item's probability\n                p = (double) values[i] / total;\n                // calculate entropy\n                if ( p != 0 )\n                    entropy += ( -p * (Math.log10(p) / Math.log10(2)) );\n            }\n        }\n        return entropy;\n    }\n\n    /**\n     * Get range around median containing specified percentage of values.\n     * @param values Values.\n     * @param percent Values percentage around median.\n     * @return Returns the range which containes specifies percentage of values.\n     */\n\n    /**\n     * Calculate Kurtosis value.\n     * @param values Values.\n     * @return Returns kurtosis value of the specified histogram array.\n     */\n    public static double Kurtosis(int[] values)\n    {\n        double mean = Mean(values);\n        double std = StdDev(values, mean);\n        return Kurtosis(values, mean, std);\n    }\n\n    /**\n     * Calculate Kurtosis value.\n     * @param values Values.\n     * @param mean Specified mean.\n     * @param stdDeviation Specified standard deviation.\n     * @return Returns kurtosis value of the specified histogram array.\n     */\n    public static double Kurtosis(int[] values, double mean, double stdDeviation)\n    {\n        double n = 0;\n        for (int i = 0; i < values.length; i++)\n            n += values[i];\n\n        double part1 = n * (n + 1);\n        part1 /= ((n - 1) * (n - 2) * (n - 3));\n\n        double part2 = 0;\n        for (int i = 0; i < values.length; i++)\n        {\n            part2 += Math.pow((i - mean) / stdDeviation, 4) * values[i];\n        }\n\n        double part3 = 3 * Math.pow((n - 1), 2);\n        part3 /= (n - 2) * (n - 3);\n\n        return part1 * part2 - part3;\n    }\n\n    /**\n     * Calculate Mean value.\n     * @param values Values.\n     * @return Mean.\n     */\n    public static double Mean( int[] values )\n    {\n        int     hits;\n        long    total = 0;\n        double  mean = 0;\n\n        // for all values\n        for ( int i = 0, n = values.length; i < n; i++ )\n        {\n            hits = values[i];\n            // accumulate mean\n            mean += i * hits;\n            // accumalate total\n            total += hits;\n        }\n        return ( total == 0 ) ? 0 : mean / total;\n    }\n\n    /**\n      * Calculate Median value.\n      * @param values Values.\n      * @return Median.\n      */\n    public static int Median( int[] values )\n    {\n        int total = 0, n = values.length;\n\n        // for all values\n        for ( int i = 0; i < n; i++ )\n        {\n            // accumalate total\n            total += values[i];\n        }\n\n        int halfTotal = total / 2;\n        int median = 0, v = 0;\n\n        // find median value\n        for ( ; median < n; median++ )\n        {\n            v += values[median];\n            if ( v >= halfTotal )\n                break;\n        }\n\n        return median;\n    }\n\n    /**\n     * Calculate Mode value.\n     * @param values Values.\n     * @return Returns mode value of the histogram array.\n     */\n    public static int Mode( int[] values )\n    {\n        int mode = 0, curMax = 0;\n\n        for ( int i = 0, length = values.length; i < length; i++ )\n        {\n            if ( values[i] > curMax )\n            {\n                curMax = values[i];\n                mode = i;\n            }\n        }\n        return mode;\n    }\n\n    /**\n     * Calculate Skewness value.\n     * @param values Values.\n     * @return Returns skewness value of the specified histogram array.\n     */\n    public static double Skewness(int[] values)\n    {\n        double mean = Mean(values);\n        double std = StdDev(values, mean);\n        return Skewness(values, mean, std);\n    }\n\n    /**\n     * Calculate Skewness value.\n     * @param values Values.\n     * @param mean Specified mean.\n     * @param stdDeviation Specified standard deviation.\n     * @return Returns skewness value of the specified histogram array.\n     */\n    public static double Skewness(int[] values, double mean, double stdDeviation)\n    {\n        double n = 0;\n        for (int i = 0; i < values.length; i++)\n            n += values[i];\n\n        double part1 = n / (n - 1) * (n - 2);\n\n        double part2 = 0;\n        for (int i = 0; i < values.length; i++)\n        {\n            part2 += Math.pow((i - mean) / stdDeviation, 3) * values[i];\n        }\n\n        return part1 * part2;\n    }\n\n    /**\n     * Calculate standart deviation.\n     * @param values Values.\n     * @return Standart deviation.\n     */\n    public static double StdDev( int[] values )\n    {\n        return StdDev( values, Mean( values ) );\n    }\n\n    /**\n     * Calculate standart deviation.\n     * @param values Values.\n     * @param mean Mean.\n     * @return Standart deviation.\n     */\n    public static double StdDev( int[] values, double mean )\n    {\n        double  stddev = 0;\n        double  diff;\n        int     hits;\n        int     total = 0;\n\n        // for all values\n        for ( int i = 0, n = values.length; i < n; i++ )\n        {\n            hits = values[i];\n            diff = (double) i - mean;\n            // accumulate std.dev.\n            stddev += diff * diff * hits;\n            // accumalate total\n            total += hits;\n        }\n\n        return ( total == 0 ) ? 0 : Math.sqrt( stddev / (total - 1) );\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/statistics/HistogramStatistics.java", "func_name": "HistogramStatistics.Median", "original_string": "public static int Median( int[] values ){\n        int total = 0, n = values.length;\n\n        // for all values\n        for ( int i = 0; i < n; i++ )\n        {\n            // accumalate total\n            total += values[i];\n        }\n\n        int halfTotal = total / 2;\n        int median = 0, v = 0;\n\n        // find median value\n        for ( ; median < n; median++ )\n        {\n            v += values[median];\n            if ( v >= halfTotal )\n                break;\n        }\n\n        return median;\n    }", "language": "java", "code": "public static int Median( int[] values ){\n        int total = 0, n = values.length;\n\n        // for all values\n        for ( int i = 0; i < n; i++ )\n        {\n            // accumalate total\n            total += values[i];\n        }\n\n        int halfTotal = total / 2;\n        int median = 0, v = 0;\n\n        // find median value\n        for ( ; median < n; median++ )\n        {\n            v += values[median];\n            if ( v >= halfTotal )\n                break;\n        }\n\n        return median;\n    }", "code_tokens": ["public", "static", "int", "Median", "(", "int", "[", "]", "values", ")", "{", "int", "total", "=", "0", ",", "n", "=", "values", ".", "length", ";", "// for all values", "for", "(", "int", "i", "=", "0", ";", "i", "<", "n", ";", "i", "++", ")", "{", "// accumalate total", "total", "+=", "values", "[", "i", "]", ";", "}", "int", "halfTotal", "=", "total", "/", "2", ";", "int", "median", "=", "0", ",", "v", "=", "0", ";", "// find median value", "for", "(", ";", "median", "<", "n", ";", "median", "++", ")", "{", "v", "+=", "values", "[", "median", "]", ";", "if", "(", "v", ">=", "halfTotal", ")", "break", ";", "}", "return", "median", ";", "}"], "docstring": "Calculate Median value.\n@param values Values.\n@return Median.", "docstring_tokens": ["Calculate", "Median", "value", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/statistics/HistogramStatistics.java#L172-L194", "partition": "train", "up_fun_num": 7, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.IntRange;"], "function": ["public final class HistogramStatistics\n", "    public static double Entropy( int[] values )\n", "    public static IntRange GetRange( int[] values, double percent )\n", "    public static double Kurtosis(int[] values)\n", "    public static double Kurtosis(int[] values, double mean, double stdDeviation)\n", "    public static double Mean( int[] values )\n", "    public static int Mode( int[] values )\n", "    public static double Skewness(int[] values)\n", "    public static double Skewness(int[] values, double mean, double stdDeviation)\n", "    public static double StdDev( int[] values )\n", "    public static double StdDev( int[] values, double mean )\n"], "context": "// Catalano Imaging Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2007-2008\n// andrew.kirillov at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.statistics;\n\n\nimport com.harium.keel.catalano.core.IntRange;\n\n/**\n * Set of histogram statistics functions.\n * @author Diego Catalano\n */\npublic final class HistogramStatistics\n{\n\n    /**\n     * Don't let anyone instantiate this class.\n     */\n    private HistogramStatistics() {}\n\n    /**\n     * Calculate entropy value.\n     * @param values Values.\n     * @return Returns entropy value of the specified histogram array.\n     */\n    public static double Entropy( int[] values )\n    {\n        int     n = values.length;\n        int     total = 0;\n        double  entropy = 0;\n        double  p;\n\n        // calculate total amount of hits\n        for ( int i = 0; i < n; i++ )\n        {\n            total += values[i];\n        }\n\n        if ( total != 0 )\n        {\n            // for all values\n            for ( int i = 0; i < n; i++ )\n            {\n                // get item's probability\n                p = (double) values[i] / total;\n                // calculate entropy\n                if ( p != 0 )\n                    entropy += ( -p * (Math.log10(p) / Math.log10(2)) );\n            }\n        }\n        return entropy;\n    }\n\n    /**\n     * Get range around median containing specified percentage of values.\n     * @param values Values.\n     * @param percent Values percentage around median.\n     * @return Returns the range which containes specifies percentage of values.\n     */\n    public static IntRange GetRange( int[] values, double percent )\n    {\n        int total = 0, n = values.length;\n\n        // for all values\n        for ( int i = 0; i < n; i++ )\n        {\n            // accumalate total\n            total += values[i];\n        }\n\n        int min, max, hits;\n        int h = (int) ( total * ( percent + ( 1 - percent ) / 2 ) );\n\n        // get range min value\n        for ( min = 0, hits = total; min < n; min++ )\n        {\n            hits -= values[min];\n            if ( hits < h )\n                break;\n        }\n        // get range max value\n        for ( max = n - 1, hits = total; max >= 0; max-- )\n        {\n            hits -= values[max];\n            if ( hits < h )\n                break;\n        }\n        return new IntRange( min, max );\n    }\n\n    /**\n     * Calculate Kurtosis value.\n     * @param values Values.\n     * @return Returns kurtosis value of the specified histogram array.\n     */\n    public static double Kurtosis(int[] values)\n    {\n        double mean = Mean(values);\n        double std = StdDev(values, mean);\n        return Kurtosis(values, mean, std);\n    }\n\n    /**\n     * Calculate Kurtosis value.\n     * @param values Values.\n     * @param mean Specified mean.\n     * @param stdDeviation Specified standard deviation.\n     * @return Returns kurtosis value of the specified histogram array.\n     */\n    public static double Kurtosis(int[] values, double mean, double stdDeviation)\n    {\n        double n = 0;\n        for (int i = 0; i < values.length; i++)\n            n += values[i];\n\n        double part1 = n * (n + 1);\n        part1 /= ((n - 1) * (n - 2) * (n - 3));\n\n        double part2 = 0;\n        for (int i = 0; i < values.length; i++)\n        {\n            part2 += Math.pow((i - mean) / stdDeviation, 4) * values[i];\n        }\n\n        double part3 = 3 * Math.pow((n - 1), 2);\n        part3 /= (n - 2) * (n - 3);\n\n        return part1 * part2 - part3;\n    }\n\n    /**\n     * Calculate Mean value.\n     * @param values Values.\n     * @return Mean.\n     */\n    public static double Mean( int[] values )\n    {\n        int     hits;\n        long    total = 0;\n        double  mean = 0;\n\n        // for all values\n        for ( int i = 0, n = values.length; i < n; i++ )\n        {\n            hits = values[i];\n            // accumulate mean\n            mean += i * hits;\n            // accumalate total\n            total += hits;\n        }\n        return ( total == 0 ) ? 0 : mean / total;\n    }\n\n    /**\n      * Calculate Median value.\n      * @param values Values.\n      * @return Median.\n      */\n\n    /**\n     * Calculate Mode value.\n     * @param values Values.\n     * @return Returns mode value of the histogram array.\n     */\n    public static int Mode( int[] values )\n    {\n        int mode = 0, curMax = 0;\n\n        for ( int i = 0, length = values.length; i < length; i++ )\n        {\n            if ( values[i] > curMax )\n            {\n                curMax = values[i];\n                mode = i;\n            }\n        }\n        return mode;\n    }\n\n    /**\n     * Calculate Skewness value.\n     * @param values Values.\n     * @return Returns skewness value of the specified histogram array.\n     */\n    public static double Skewness(int[] values)\n    {\n        double mean = Mean(values);\n        double std = StdDev(values, mean);\n        return Skewness(values, mean, std);\n    }\n\n    /**\n     * Calculate Skewness value.\n     * @param values Values.\n     * @param mean Specified mean.\n     * @param stdDeviation Specified standard deviation.\n     * @return Returns skewness value of the specified histogram array.\n     */\n    public static double Skewness(int[] values, double mean, double stdDeviation)\n    {\n        double n = 0;\n        for (int i = 0; i < values.length; i++)\n            n += values[i];\n\n        double part1 = n / (n - 1) * (n - 2);\n\n        double part2 = 0;\n        for (int i = 0; i < values.length; i++)\n        {\n            part2 += Math.pow((i - mean) / stdDeviation, 3) * values[i];\n        }\n\n        return part1 * part2;\n    }\n\n    /**\n     * Calculate standart deviation.\n     * @param values Values.\n     * @return Standart deviation.\n     */\n    public static double StdDev( int[] values )\n    {\n        return StdDev( values, Mean( values ) );\n    }\n\n    /**\n     * Calculate standart deviation.\n     * @param values Values.\n     * @param mean Mean.\n     * @return Standart deviation.\n     */\n    public static double StdDev( int[] values, double mean )\n    {\n        double  stddev = 0;\n        double  diff;\n        int     hits;\n        int     total = 0;\n\n        // for all values\n        for ( int i = 0, n = values.length; i < n; i++ )\n        {\n            hits = values[i];\n            diff = (double) i - mean;\n            // accumulate std.dev.\n            stddev += diff * diff * hits;\n            // accumalate total\n            total += hits;\n        }\n\n        return ( total == 0 ) ? 0 : Math.sqrt( stddev / (total - 1) );\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/statistics/HistogramStatistics.java", "func_name": "HistogramStatistics.Mode", "original_string": "public static int Mode( int[] values ){\n        int mode = 0, curMax = 0;\n\n        for ( int i = 0, length = values.length; i < length; i++ )\n        {\n            if ( values[i] > curMax )\n            {\n                curMax = values[i];\n                mode = i;\n            }\n        }\n        return mode;\n    }", "language": "java", "code": "public static int Mode( int[] values ){\n        int mode = 0, curMax = 0;\n\n        for ( int i = 0, length = values.length; i < length; i++ )\n        {\n            if ( values[i] > curMax )\n            {\n                curMax = values[i];\n                mode = i;\n            }\n        }\n        return mode;\n    }", "code_tokens": ["public", "static", "int", "Mode", "(", "int", "[", "]", "values", ")", "{", "int", "mode", "=", "0", ",", "curMax", "=", "0", ";", "for", "(", "int", "i", "=", "0", ",", "length", "=", "values", ".", "length", ";", "i", "<", "length", ";", "i", "++", ")", "{", "if", "(", "values", "[", "i", "]", ">", "curMax", ")", "{", "curMax", "=", "values", "[", "i", "]", ";", "mode", "=", "i", ";", "}", "}", "return", "mode", ";", "}"], "docstring": "Calculate Mode value.\n@param values Values.\n@return Returns mode value of the histogram array.", "docstring_tokens": ["Calculate", "Mode", "value", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/statistics/HistogramStatistics.java#L201-L213", "partition": "train", "up_fun_num": 8, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.IntRange;"], "function": ["public final class HistogramStatistics\n", "    public static double Entropy( int[] values )\n", "    public static IntRange GetRange( int[] values, double percent )\n", "    public static double Kurtosis(int[] values)\n", "    public static double Kurtosis(int[] values, double mean, double stdDeviation)\n", "    public static double Mean( int[] values )\n", "    public static int Median( int[] values )\n", "    public static double Skewness(int[] values)\n", "    public static double Skewness(int[] values, double mean, double stdDeviation)\n", "    public static double StdDev( int[] values )\n", "    public static double StdDev( int[] values, double mean )\n"], "context": "// Catalano Imaging Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2007-2008\n// andrew.kirillov at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.statistics;\n\n\nimport com.harium.keel.catalano.core.IntRange;\n\n/**\n * Set of histogram statistics functions.\n * @author Diego Catalano\n */\npublic final class HistogramStatistics\n{\n\n    /**\n     * Don't let anyone instantiate this class.\n     */\n    private HistogramStatistics() {}\n\n    /**\n     * Calculate entropy value.\n     * @param values Values.\n     * @return Returns entropy value of the specified histogram array.\n     */\n    public static double Entropy( int[] values )\n    {\n        int     n = values.length;\n        int     total = 0;\n        double  entropy = 0;\n        double  p;\n\n        // calculate total amount of hits\n        for ( int i = 0; i < n; i++ )\n        {\n            total += values[i];\n        }\n\n        if ( total != 0 )\n        {\n            // for all values\n            for ( int i = 0; i < n; i++ )\n            {\n                // get item's probability\n                p = (double) values[i] / total;\n                // calculate entropy\n                if ( p != 0 )\n                    entropy += ( -p * (Math.log10(p) / Math.log10(2)) );\n            }\n        }\n        return entropy;\n    }\n\n    /**\n     * Get range around median containing specified percentage of values.\n     * @param values Values.\n     * @param percent Values percentage around median.\n     * @return Returns the range which containes specifies percentage of values.\n     */\n    public static IntRange GetRange( int[] values, double percent )\n    {\n        int total = 0, n = values.length;\n\n        // for all values\n        for ( int i = 0; i < n; i++ )\n        {\n            // accumalate total\n            total += values[i];\n        }\n\n        int min, max, hits;\n        int h = (int) ( total * ( percent + ( 1 - percent ) / 2 ) );\n\n        // get range min value\n        for ( min = 0, hits = total; min < n; min++ )\n        {\n            hits -= values[min];\n            if ( hits < h )\n                break;\n        }\n        // get range max value\n        for ( max = n - 1, hits = total; max >= 0; max-- )\n        {\n            hits -= values[max];\n            if ( hits < h )\n                break;\n        }\n        return new IntRange( min, max );\n    }\n\n    /**\n     * Calculate Kurtosis value.\n     * @param values Values.\n     * @return Returns kurtosis value of the specified histogram array.\n     */\n    public static double Kurtosis(int[] values)\n    {\n        double mean = Mean(values);\n        double std = StdDev(values, mean);\n        return Kurtosis(values, mean, std);\n    }\n\n    /**\n     * Calculate Kurtosis value.\n     * @param values Values.\n     * @param mean Specified mean.\n     * @param stdDeviation Specified standard deviation.\n     * @return Returns kurtosis value of the specified histogram array.\n     */\n    public static double Kurtosis(int[] values, double mean, double stdDeviation)\n    {\n        double n = 0;\n        for (int i = 0; i < values.length; i++)\n            n += values[i];\n\n        double part1 = n * (n + 1);\n        part1 /= ((n - 1) * (n - 2) * (n - 3));\n\n        double part2 = 0;\n        for (int i = 0; i < values.length; i++)\n        {\n            part2 += Math.pow((i - mean) / stdDeviation, 4) * values[i];\n        }\n\n        double part3 = 3 * Math.pow((n - 1), 2);\n        part3 /= (n - 2) * (n - 3);\n\n        return part1 * part2 - part3;\n    }\n\n    /**\n     * Calculate Mean value.\n     * @param values Values.\n     * @return Mean.\n     */\n    public static double Mean( int[] values )\n    {\n        int     hits;\n        long    total = 0;\n        double  mean = 0;\n\n        // for all values\n        for ( int i = 0, n = values.length; i < n; i++ )\n        {\n            hits = values[i];\n            // accumulate mean\n            mean += i * hits;\n            // accumalate total\n            total += hits;\n        }\n        return ( total == 0 ) ? 0 : mean / total;\n    }\n\n    /**\n      * Calculate Median value.\n      * @param values Values.\n      * @return Median.\n      */\n    public static int Median( int[] values )\n    {\n        int total = 0, n = values.length;\n\n        // for all values\n        for ( int i = 0; i < n; i++ )\n        {\n            // accumalate total\n            total += values[i];\n        }\n\n        int halfTotal = total / 2;\n        int median = 0, v = 0;\n\n        // find median value\n        for ( ; median < n; median++ )\n        {\n            v += values[median];\n            if ( v >= halfTotal )\n                break;\n        }\n\n        return median;\n    }\n\n    /**\n     * Calculate Mode value.\n     * @param values Values.\n     * @return Returns mode value of the histogram array.\n     */\n\n    /**\n     * Calculate Skewness value.\n     * @param values Values.\n     * @return Returns skewness value of the specified histogram array.\n     */\n    public static double Skewness(int[] values)\n    {\n        double mean = Mean(values);\n        double std = StdDev(values, mean);\n        return Skewness(values, mean, std);\n    }\n\n    /**\n     * Calculate Skewness value.\n     * @param values Values.\n     * @param mean Specified mean.\n     * @param stdDeviation Specified standard deviation.\n     * @return Returns skewness value of the specified histogram array.\n     */\n    public static double Skewness(int[] values, double mean, double stdDeviation)\n    {\n        double n = 0;\n        for (int i = 0; i < values.length; i++)\n            n += values[i];\n\n        double part1 = n / (n - 1) * (n - 2);\n\n        double part2 = 0;\n        for (int i = 0; i < values.length; i++)\n        {\n            part2 += Math.pow((i - mean) / stdDeviation, 3) * values[i];\n        }\n\n        return part1 * part2;\n    }\n\n    /**\n     * Calculate standart deviation.\n     * @param values Values.\n     * @return Standart deviation.\n     */\n    public static double StdDev( int[] values )\n    {\n        return StdDev( values, Mean( values ) );\n    }\n\n    /**\n     * Calculate standart deviation.\n     * @param values Values.\n     * @param mean Mean.\n     * @return Standart deviation.\n     */\n    public static double StdDev( int[] values, double mean )\n    {\n        double  stddev = 0;\n        double  diff;\n        int     hits;\n        int     total = 0;\n\n        // for all values\n        for ( int i = 0, n = values.length; i < n; i++ )\n        {\n            hits = values[i];\n            diff = (double) i - mean;\n            // accumulate std.dev.\n            stddev += diff * diff * hits;\n            // accumalate total\n            total += hits;\n        }\n\n        return ( total == 0 ) ? 0 : Math.sqrt( stddev / (total - 1) );\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/statistics/HistogramStatistics.java", "func_name": "HistogramStatistics.StdDev", "original_string": "public static double StdDev( int[] values, double mean ){\n        double  stddev = 0;\n        double  diff;\n        int     hits;\n        int     total = 0;\n\n        // for all values\n        for ( int i = 0, n = values.length; i < n; i++ )\n        {\n            hits = values[i];\n            diff = (double) i - mean;\n            // accumulate std.dev.\n            stddev += diff * diff * hits;\n            // accumalate total\n            total += hits;\n        }\n\n        return ( total == 0 ) ? 0 : Math.sqrt( stddev / (total - 1) );\n    }", "language": "java", "code": "public static double StdDev( int[] values, double mean ){\n        double  stddev = 0;\n        double  diff;\n        int     hits;\n        int     total = 0;\n\n        // for all values\n        for ( int i = 0, n = values.length; i < n; i++ )\n        {\n            hits = values[i];\n            diff = (double) i - mean;\n            // accumulate std.dev.\n            stddev += diff * diff * hits;\n            // accumalate total\n            total += hits;\n        }\n\n        return ( total == 0 ) ? 0 : Math.sqrt( stddev / (total - 1) );\n    }", "code_tokens": ["public", "static", "double", "StdDev", "(", "int", "[", "]", "values", ",", "double", "mean", ")", "{", "double", "stddev", "=", "0", ";", "double", "diff", ";", "int", "hits", ";", "int", "total", "=", "0", ";", "// for all values", "for", "(", "int", "i", "=", "0", ",", "n", "=", "values", ".", "length", ";", "i", "<", "n", ";", "i", "++", ")", "{", "hits", "=", "values", "[", "i", "]", ";", "diff", "=", "(", "double", ")", "i", "-", "mean", ";", "// accumulate std.dev.", "stddev", "+=", "diff", "*", "diff", "*", "hits", ";", "// accumalate total", "total", "+=", "hits", ";", "}", "return", "(", "total", "==", "0", ")", "?", "0", ":", "Math", ".", "sqrt", "(", "stddev", "/", "(", "total", "-", "1", ")", ")", ";", "}"], "docstring": "Calculate standart deviation.\n@param values Values.\n@param mean Mean.\n@return Standart deviation.", "docstring_tokens": ["Calculate", "standart", "deviation", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/statistics/HistogramStatistics.java#L263-L281", "partition": "train", "up_fun_num": 11, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.IntRange;"], "function": ["public final class HistogramStatistics\n", "    public static double Entropy( int[] values )\n", "    public static IntRange GetRange( int[] values, double percent )\n", "    public static double Kurtosis(int[] values)\n", "    public static double Kurtosis(int[] values, double mean, double stdDeviation)\n", "    public static double Mean( int[] values )\n", "    public static int Median( int[] values )\n", "    public static int Mode( int[] values )\n", "    public static double Skewness(int[] values)\n", "    public static double Skewness(int[] values, double mean, double stdDeviation)\n", "    public static double StdDev( int[] values )\n"], "context": "// Catalano Imaging Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2007-2008\n// andrew.kirillov at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.statistics;\n\n\nimport com.harium.keel.catalano.core.IntRange;\n\n/**\n * Set of histogram statistics functions.\n * @author Diego Catalano\n */\npublic final class HistogramStatistics\n{\n\n    /**\n     * Don't let anyone instantiate this class.\n     */\n    private HistogramStatistics() {}\n\n    /**\n     * Calculate entropy value.\n     * @param values Values.\n     * @return Returns entropy value of the specified histogram array.\n     */\n    public static double Entropy( int[] values )\n    {\n        int     n = values.length;\n        int     total = 0;\n        double  entropy = 0;\n        double  p;\n\n        // calculate total amount of hits\n        for ( int i = 0; i < n; i++ )\n        {\n            total += values[i];\n        }\n\n        if ( total != 0 )\n        {\n            // for all values\n            for ( int i = 0; i < n; i++ )\n            {\n                // get item's probability\n                p = (double) values[i] / total;\n                // calculate entropy\n                if ( p != 0 )\n                    entropy += ( -p * (Math.log10(p) / Math.log10(2)) );\n            }\n        }\n        return entropy;\n    }\n\n    /**\n     * Get range around median containing specified percentage of values.\n     * @param values Values.\n     * @param percent Values percentage around median.\n     * @return Returns the range which containes specifies percentage of values.\n     */\n    public static IntRange GetRange( int[] values, double percent )\n    {\n        int total = 0, n = values.length;\n\n        // for all values\n        for ( int i = 0; i < n; i++ )\n        {\n            // accumalate total\n            total += values[i];\n        }\n\n        int min, max, hits;\n        int h = (int) ( total * ( percent + ( 1 - percent ) / 2 ) );\n\n        // get range min value\n        for ( min = 0, hits = total; min < n; min++ )\n        {\n            hits -= values[min];\n            if ( hits < h )\n                break;\n        }\n        // get range max value\n        for ( max = n - 1, hits = total; max >= 0; max-- )\n        {\n            hits -= values[max];\n            if ( hits < h )\n                break;\n        }\n        return new IntRange( min, max );\n    }\n\n    /**\n     * Calculate Kurtosis value.\n     * @param values Values.\n     * @return Returns kurtosis value of the specified histogram array.\n     */\n    public static double Kurtosis(int[] values)\n    {\n        double mean = Mean(values);\n        double std = StdDev(values, mean);\n        return Kurtosis(values, mean, std);\n    }\n\n    /**\n     * Calculate Kurtosis value.\n     * @param values Values.\n     * @param mean Specified mean.\n     * @param stdDeviation Specified standard deviation.\n     * @return Returns kurtosis value of the specified histogram array.\n     */\n    public static double Kurtosis(int[] values, double mean, double stdDeviation)\n    {\n        double n = 0;\n        for (int i = 0; i < values.length; i++)\n            n += values[i];\n\n        double part1 = n * (n + 1);\n        part1 /= ((n - 1) * (n - 2) * (n - 3));\n\n        double part2 = 0;\n        for (int i = 0; i < values.length; i++)\n        {\n            part2 += Math.pow((i - mean) / stdDeviation, 4) * values[i];\n        }\n\n        double part3 = 3 * Math.pow((n - 1), 2);\n        part3 /= (n - 2) * (n - 3);\n\n        return part1 * part2 - part3;\n    }\n\n    /**\n     * Calculate Mean value.\n     * @param values Values.\n     * @return Mean.\n     */\n    public static double Mean( int[] values )\n    {\n        int     hits;\n        long    total = 0;\n        double  mean = 0;\n\n        // for all values\n        for ( int i = 0, n = values.length; i < n; i++ )\n        {\n            hits = values[i];\n            // accumulate mean\n            mean += i * hits;\n            // accumalate total\n            total += hits;\n        }\n        return ( total == 0 ) ? 0 : mean / total;\n    }\n\n    /**\n      * Calculate Median value.\n      * @param values Values.\n      * @return Median.\n      */\n    public static int Median( int[] values )\n    {\n        int total = 0, n = values.length;\n\n        // for all values\n        for ( int i = 0; i < n; i++ )\n        {\n            // accumalate total\n            total += values[i];\n        }\n\n        int halfTotal = total / 2;\n        int median = 0, v = 0;\n\n        // find median value\n        for ( ; median < n; median++ )\n        {\n            v += values[median];\n            if ( v >= halfTotal )\n                break;\n        }\n\n        return median;\n    }\n\n    /**\n     * Calculate Mode value.\n     * @param values Values.\n     * @return Returns mode value of the histogram array.\n     */\n    public static int Mode( int[] values )\n    {\n        int mode = 0, curMax = 0;\n\n        for ( int i = 0, length = values.length; i < length; i++ )\n        {\n            if ( values[i] > curMax )\n            {\n                curMax = values[i];\n                mode = i;\n            }\n        }\n        return mode;\n    }\n\n    /**\n     * Calculate Skewness value.\n     * @param values Values.\n     * @return Returns skewness value of the specified histogram array.\n     */\n    public static double Skewness(int[] values)\n    {\n        double mean = Mean(values);\n        double std = StdDev(values, mean);\n        return Skewness(values, mean, std);\n    }\n\n    /**\n     * Calculate Skewness value.\n     * @param values Values.\n     * @param mean Specified mean.\n     * @param stdDeviation Specified standard deviation.\n     * @return Returns skewness value of the specified histogram array.\n     */\n    public static double Skewness(int[] values, double mean, double stdDeviation)\n    {\n        double n = 0;\n        for (int i = 0; i < values.length; i++)\n            n += values[i];\n\n        double part1 = n / (n - 1) * (n - 2);\n\n        double part2 = 0;\n        for (int i = 0; i < values.length; i++)\n        {\n            part2 += Math.pow((i - mean) / stdDeviation, 3) * values[i];\n        }\n\n        return part1 * part2;\n    }\n\n    /**\n     * Calculate standart deviation.\n     * @param values Values.\n     * @return Standart deviation.\n     */\n    public static double StdDev( int[] values )\n    {\n        return StdDev( values, Mean( values ) );\n    }\n\n    /**\n     * Calculate standart deviation.\n     * @param values Values.\n     * @param mean Mean.\n     * @return Standart deviation.\n     */\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/transform/DiscreteCosineTransform.java", "func_name": "DiscreteCosineTransform.Forward", "original_string": "public static void Forward(double[] data) {\n\n        double[] result = new double[data.length];\n        double sum;\n        double scale = Math.sqrt(2.0 / data.length);\n        for (int f = 0; f < data.length; f++) {\n            sum = 0;\n            for (int t = 0; t < data.length; t++) {\n                double cos = Math.cos(((2.0 * t + 1.0) * f * Math.PI) / (2.0 * data.length));\n                sum += data[t] * cos * alpha(f);\n            }\n            result[f] = scale * sum;\n        }\n        for (int i = 0; i < data.length; i++) {\n            data[i] = result[i];\n        }\n    }", "language": "java", "code": "public static void Forward(double[] data) {\n\n        double[] result = new double[data.length];\n        double sum;\n        double scale = Math.sqrt(2.0 / data.length);\n        for (int f = 0; f < data.length; f++) {\n            sum = 0;\n            for (int t = 0; t < data.length; t++) {\n                double cos = Math.cos(((2.0 * t + 1.0) * f * Math.PI) / (2.0 * data.length));\n                sum += data[t] * cos * alpha(f);\n            }\n            result[f] = scale * sum;\n        }\n        for (int i = 0; i < data.length; i++) {\n            data[i] = result[i];\n        }\n    }", "code_tokens": ["public", "static", "void", "Forward", "(", "double", "[", "]", "data", ")", "{", "double", "[", "]", "result", "=", "new", "double", "[", "data", ".", "length", "]", ";", "double", "sum", ";", "double", "scale", "=", "Math", ".", "sqrt", "(", "2.0", "/", "data", ".", "length", ")", ";", "for", "(", "int", "f", "=", "0", ";", "f", "<", "data", ".", "length", ";", "f", "++", ")", "{", "sum", "=", "0", ";", "for", "(", "int", "t", "=", "0", ";", "t", "<", "data", ".", "length", ";", "t", "++", ")", "{", "double", "cos", "=", "Math", ".", "cos", "(", "(", "(", "2.0", "*", "t", "+", "1.0", ")", "*", "f", "*", "Math", ".", "PI", ")", "/", "(", "2.0", "*", "data", ".", "length", ")", ")", ";", "sum", "+=", "data", "[", "t", "]", "*", "cos", "*", "alpha", "(", "f", ")", ";", "}", "result", "[", "f", "]", "=", "scale", "*", "sum", ";", "}", "for", "(", "int", "i", "=", "0", ";", "i", "<", "data", ".", "length", ";", "i", "++", ")", "{", "data", "[", "i", "]", "=", "result", "[", "i", "]", ";", "}", "}"], "docstring": "1-D Forward Discrete Cosine Transform.\n\n@param data Data.", "docstring_tokens": ["1", "-", "D", "Forward", "Discrete", "Cosine", "Transform", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/transform/DiscreteCosineTransform.java#L45-L61", "partition": "train", "up_fun_num": 2, "levels": [0, 1, 1, 1, 1], "package": [], "function": ["public final class DiscreteCosineTransform\n", "    public static void Forward(double[][] data)\n", "    public static void Backward(double[] data)\n", "    public static void Backward(double[][] data)\n", "    private static double alpha(double v)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.transform;\n\n/**\n * Discrete Cosine Transform.\n * The cosine transform, like the Fourier Transform, uses sinusoidal basis function. The difference is\n * that the cosine transform basis functions are not complex; they use only cosine functions, and not sine functions.\n *\n * @author Diego Catalano\n * @see Computer Imaging - Scott E Umbaugh. Chapter 5, p. 220.\n */\npublic final class DiscreteCosineTransform\n{\n\n    /**\n     * Don't let anyone instantiate this class.\n     */\n    private DiscreteCosineTransform()\n    {\n    }\n\n    /**\n     * 1-D Forward Discrete Cosine Transform.\n     *\n     * @param data Data.\n     */\n\n    /**\n     * 2-D Forward Discrete Cosine Transform.\n     *\n     * @param data Data.\n     */\n    public static void Forward(double[][] data)\n    {\n        int rows = data.length;\n        int cols = data[0].length;\n\n        double[] row = new double[cols];\n        double[] col = new double[rows];\n\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < row.length; j++)\n                row[j] = data[i][j];\n\n            Forward(row);\n\n            for (int j = 0; j < row.length; j++)\n                data[i][j] = row[j];\n        }\n\n        for (int j = 0; j < cols; j++)\n        {\n            for (int i = 0; i < col.length; i++)\n                col[i] = data[i][j];\n\n            Forward(col);\n\n            for (int i = 0; i < col.length; i++)\n                data[i][j] = col[i];\n        }\n    }\n\n    /**\n     * 1-D Backward Discrete Cosine Transform.\n     *\n     * @param data Data.\n     */\n    public static void Backward(double[] data)\n    {\n\n        double[] result = new double[data.length];\n        double sum;\n        double scale = Math.sqrt(2.0 / data.length);\n        for (int t = 0; t < data.length; t++)\n        {\n            sum = 0;\n            for (int j = 0; j < data.length; j++)\n            {\n                double cos = Math.cos(((2 * t + 1) * j * Math.PI) / (2 * data.length));\n                sum += alpha(j) * data[j] * cos;\n            }\n            result[t] = scale * sum;\n        }\n        for (int i = 0; i < data.length; i++)\n        {\n            data[i] = result[i];\n        }\n    }\n\n    /**\n     * 2-D Backward Discrete Cosine Transform.\n     *\n     * @param data Data.\n     */\n    public static void Backward(double[][] data)\n    {\n        int rows = data.length;\n        int cols = data[0].length;\n\n        double[] row = new double[cols];\n        double[] col = new double[rows];\n\n        for (int j = 0; j < cols; j++)\n        {\n            for (int i = 0; i < row.length; i++)\n                col[i] = data[i][j];\n\n            Backward(col);\n\n            for (int i = 0; i < col.length; i++)\n                data[i][j] = col[i];\n        }\n\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < row.length; j++)\n                row[j] = data[i][j];\n\n            Backward(row);\n\n            for (int j = 0; j < row.length; j++)\n                data[i][j] = row[j];\n        }\n    }\n\n    private static double alpha(double v)\n    {\n        if (v == 0)\n        {\n            return 1 / Math.sqrt(2);\n        }\n        return 1;\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/transform/DiscreteCosineTransform.java", "func_name": "DiscreteCosineTransform.Forward", "original_string": "public static void Forward(double[][] data) {\n        int rows = data.length;\n        int cols = data[0].length;\n\n        double[] row = new double[cols];\n        double[] col = new double[rows];\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < row.length; j++)\n                row[j] = data[i][j];\n\n            Forward(row);\n\n            for (int j = 0; j < row.length; j++)\n                data[i][j] = row[j];\n        }\n\n        for (int j = 0; j < cols; j++) {\n            for (int i = 0; i < col.length; i++)\n                col[i] = data[i][j];\n\n            Forward(col);\n\n            for (int i = 0; i < col.length; i++)\n                data[i][j] = col[i];\n        }\n    }", "language": "java", "code": "public static void Forward(double[][] data) {\n        int rows = data.length;\n        int cols = data[0].length;\n\n        double[] row = new double[cols];\n        double[] col = new double[rows];\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < row.length; j++)\n                row[j] = data[i][j];\n\n            Forward(row);\n\n            for (int j = 0; j < row.length; j++)\n                data[i][j] = row[j];\n        }\n\n        for (int j = 0; j < cols; j++) {\n            for (int i = 0; i < col.length; i++)\n                col[i] = data[i][j];\n\n            Forward(col);\n\n            for (int i = 0; i < col.length; i++)\n                data[i][j] = col[i];\n        }\n    }", "code_tokens": ["public", "static", "void", "Forward", "(", "double", "[", "]", "[", "]", "data", ")", "{", "int", "rows", "=", "data", ".", "length", ";", "int", "cols", "=", "data", "[", "0", "]", ".", "length", ";", "double", "[", "]", "row", "=", "new", "double", "[", "cols", "]", ";", "double", "[", "]", "col", "=", "new", "double", "[", "rows", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "rows", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "0", ";", "j", "<", "row", ".", "length", ";", "j", "++", ")", "row", "[", "j", "]", "=", "data", "[", "i", "]", "[", "j", "]", ";", "Forward", "(", "row", ")", ";", "for", "(", "int", "j", "=", "0", ";", "j", "<", "row", ".", "length", ";", "j", "++", ")", "data", "[", "i", "]", "[", "j", "]", "=", "row", "[", "j", "]", ";", "}", "for", "(", "int", "j", "=", "0", ";", "j", "<", "cols", ";", "j", "++", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "col", ".", "length", ";", "i", "++", ")", "col", "[", "i", "]", "=", "data", "[", "i", "]", "[", "j", "]", ";", "Forward", "(", "col", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "col", ".", "length", ";", "i", "++", ")", "data", "[", "i", "]", "[", "j", "]", "=", "col", "[", "i", "]", ";", "}", "}"], "docstring": "2-D Forward Discrete Cosine Transform.\n\n@param data Data.", "docstring_tokens": ["2", "-", "D", "Forward", "Discrete", "Cosine", "Transform", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/transform/DiscreteCosineTransform.java#L68-L94", "partition": "train", "up_fun_num": 3, "levels": [0, 1, 1, 1, 1], "package": [], "function": ["public final class DiscreteCosineTransform\n", "    public static void Forward(double[] data)\n", "    public static void Backward(double[] data)\n", "    public static void Backward(double[][] data)\n", "    private static double alpha(double v)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.transform;\n\n/**\n * Discrete Cosine Transform.\n * The cosine transform, like the Fourier Transform, uses sinusoidal basis function. The difference is\n * that the cosine transform basis functions are not complex; they use only cosine functions, and not sine functions.\n *\n * @author Diego Catalano\n * @see Computer Imaging - Scott E Umbaugh. Chapter 5, p. 220.\n */\npublic final class DiscreteCosineTransform\n{\n\n    /**\n     * Don't let anyone instantiate this class.\n     */\n    private DiscreteCosineTransform()\n    {\n    }\n\n    /**\n     * 1-D Forward Discrete Cosine Transform.\n     *\n     * @param data Data.\n     */\n    public static void Forward(double[] data)\n    {\n\n        double[] result = new double[data.length];\n        double sum;\n        double scale = Math.sqrt(2.0 / data.length);\n        for (int f = 0; f < data.length; f++)\n        {\n            sum = 0;\n            for (int t = 0; t < data.length; t++)\n            {\n                double cos = Math.cos(((2.0 * t + 1.0) * f * Math.PI) / (2.0 * data.length));\n                sum += data[t] * cos * alpha(f);\n            }\n            result[f] = scale * sum;\n        }\n        for (int i = 0; i < data.length; i++)\n        {\n            data[i] = result[i];\n        }\n    }\n\n    /**\n     * 2-D Forward Discrete Cosine Transform.\n     *\n     * @param data Data.\n     */\n\n    /**\n     * 1-D Backward Discrete Cosine Transform.\n     *\n     * @param data Data.\n     */\n    public static void Backward(double[] data)\n    {\n\n        double[] result = new double[data.length];\n        double sum;\n        double scale = Math.sqrt(2.0 / data.length);\n        for (int t = 0; t < data.length; t++)\n        {\n            sum = 0;\n            for (int j = 0; j < data.length; j++)\n            {\n                double cos = Math.cos(((2 * t + 1) * j * Math.PI) / (2 * data.length));\n                sum += alpha(j) * data[j] * cos;\n            }\n            result[t] = scale * sum;\n        }\n        for (int i = 0; i < data.length; i++)\n        {\n            data[i] = result[i];\n        }\n    }\n\n    /**\n     * 2-D Backward Discrete Cosine Transform.\n     *\n     * @param data Data.\n     */\n    public static void Backward(double[][] data)\n    {\n        int rows = data.length;\n        int cols = data[0].length;\n\n        double[] row = new double[cols];\n        double[] col = new double[rows];\n\n        for (int j = 0; j < cols; j++)\n        {\n            for (int i = 0; i < row.length; i++)\n                col[i] = data[i][j];\n\n            Backward(col);\n\n            for (int i = 0; i < col.length; i++)\n                data[i][j] = col[i];\n        }\n\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < row.length; j++)\n                row[j] = data[i][j];\n\n            Backward(row);\n\n            for (int j = 0; j < row.length; j++)\n                data[i][j] = row[j];\n        }\n    }\n\n    private static double alpha(double v)\n    {\n        if (v == 0)\n        {\n            return 1 / Math.sqrt(2);\n        }\n        return 1;\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/transform/DiscreteCosineTransform.java", "func_name": "DiscreteCosineTransform.Backward", "original_string": "public static void Backward(double[] data) {\n\n        double[] result = new double[data.length];\n        double sum;\n        double scale = Math.sqrt(2.0 / data.length);\n        for (int t = 0; t < data.length; t++) {\n            sum = 0;\n            for (int j = 0; j < data.length; j++) {\n                double cos = Math.cos(((2 * t + 1) * j * Math.PI) / (2 * data.length));\n                sum += alpha(j) * data[j] * cos;\n            }\n            result[t] = scale * sum;\n        }\n        for (int i = 0; i < data.length; i++) {\n            data[i] = result[i];\n        }\n    }", "language": "java", "code": "public static void Backward(double[] data) {\n\n        double[] result = new double[data.length];\n        double sum;\n        double scale = Math.sqrt(2.0 / data.length);\n        for (int t = 0; t < data.length; t++) {\n            sum = 0;\n            for (int j = 0; j < data.length; j++) {\n                double cos = Math.cos(((2 * t + 1) * j * Math.PI) / (2 * data.length));\n                sum += alpha(j) * data[j] * cos;\n            }\n            result[t] = scale * sum;\n        }\n        for (int i = 0; i < data.length; i++) {\n            data[i] = result[i];\n        }\n    }", "code_tokens": ["public", "static", "void", "Backward", "(", "double", "[", "]", "data", ")", "{", "double", "[", "]", "result", "=", "new", "double", "[", "data", ".", "length", "]", ";", "double", "sum", ";", "double", "scale", "=", "Math", ".", "sqrt", "(", "2.0", "/", "data", ".", "length", ")", ";", "for", "(", "int", "t", "=", "0", ";", "t", "<", "data", ".", "length", ";", "t", "++", ")", "{", "sum", "=", "0", ";", "for", "(", "int", "j", "=", "0", ";", "j", "<", "data", ".", "length", ";", "j", "++", ")", "{", "double", "cos", "=", "Math", ".", "cos", "(", "(", "(", "2", "*", "t", "+", "1", ")", "*", "j", "*", "Math", ".", "PI", ")", "/", "(", "2", "*", "data", ".", "length", ")", ")", ";", "sum", "+=", "alpha", "(", "j", ")", "*", "data", "[", "j", "]", "*", "cos", ";", "}", "result", "[", "t", "]", "=", "scale", "*", "sum", ";", "}", "for", "(", "int", "i", "=", "0", ";", "i", "<", "data", ".", "length", ";", "i", "++", ")", "{", "data", "[", "i", "]", "=", "result", "[", "i", "]", ";", "}", "}"], "docstring": "1-D Backward Discrete Cosine Transform.\n\n@param data Data.", "docstring_tokens": ["1", "-", "D", "Backward", "Discrete", "Cosine", "Transform", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/transform/DiscreteCosineTransform.java#L101-L117", "partition": "train", "up_fun_num": 4, "levels": [0, 1, 1, 1, 1], "package": [], "function": ["public final class DiscreteCosineTransform\n", "    public static void Forward(double[] data)\n", "    public static void Forward(double[][] data)\n", "    public static void Backward(double[][] data)\n", "    private static double alpha(double v)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.transform;\n\n/**\n * Discrete Cosine Transform.\n * The cosine transform, like the Fourier Transform, uses sinusoidal basis function. The difference is\n * that the cosine transform basis functions are not complex; they use only cosine functions, and not sine functions.\n *\n * @author Diego Catalano\n * @see Computer Imaging - Scott E Umbaugh. Chapter 5, p. 220.\n */\npublic final class DiscreteCosineTransform\n{\n\n    /**\n     * Don't let anyone instantiate this class.\n     */\n    private DiscreteCosineTransform()\n    {\n    }\n\n    /**\n     * 1-D Forward Discrete Cosine Transform.\n     *\n     * @param data Data.\n     */\n    public static void Forward(double[] data)\n    {\n\n        double[] result = new double[data.length];\n        double sum;\n        double scale = Math.sqrt(2.0 / data.length);\n        for (int f = 0; f < data.length; f++)\n        {\n            sum = 0;\n            for (int t = 0; t < data.length; t++)\n            {\n                double cos = Math.cos(((2.0 * t + 1.0) * f * Math.PI) / (2.0 * data.length));\n                sum += data[t] * cos * alpha(f);\n            }\n            result[f] = scale * sum;\n        }\n        for (int i = 0; i < data.length; i++)\n        {\n            data[i] = result[i];\n        }\n    }\n\n    /**\n     * 2-D Forward Discrete Cosine Transform.\n     *\n     * @param data Data.\n     */\n    public static void Forward(double[][] data)\n    {\n        int rows = data.length;\n        int cols = data[0].length;\n\n        double[] row = new double[cols];\n        double[] col = new double[rows];\n\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < row.length; j++)\n                row[j] = data[i][j];\n\n            Forward(row);\n\n            for (int j = 0; j < row.length; j++)\n                data[i][j] = row[j];\n        }\n\n        for (int j = 0; j < cols; j++)\n        {\n            for (int i = 0; i < col.length; i++)\n                col[i] = data[i][j];\n\n            Forward(col);\n\n            for (int i = 0; i < col.length; i++)\n                data[i][j] = col[i];\n        }\n    }\n\n    /**\n     * 1-D Backward Discrete Cosine Transform.\n     *\n     * @param data Data.\n     */\n\n    /**\n     * 2-D Backward Discrete Cosine Transform.\n     *\n     * @param data Data.\n     */\n    public static void Backward(double[][] data)\n    {\n        int rows = data.length;\n        int cols = data[0].length;\n\n        double[] row = new double[cols];\n        double[] col = new double[rows];\n\n        for (int j = 0; j < cols; j++)\n        {\n            for (int i = 0; i < row.length; i++)\n                col[i] = data[i][j];\n\n            Backward(col);\n\n            for (int i = 0; i < col.length; i++)\n                data[i][j] = col[i];\n        }\n\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < row.length; j++)\n                row[j] = data[i][j];\n\n            Backward(row);\n\n            for (int j = 0; j < row.length; j++)\n                data[i][j] = row[j];\n        }\n    }\n\n    private static double alpha(double v)\n    {\n        if (v == 0)\n        {\n            return 1 / Math.sqrt(2);\n        }\n        return 1;\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/effect/LevelsLinear.java", "func_name": "LevelsLinear.setInRGB", "original_string": "public void setInRGB(IntRange inRGB) {\r\n        this.inRed = inRGB;\r\n        this.inGreen = inRGB;\r\n        this.inBlue = inRGB;\r\n\r\n        CalculateMap(inRGB, outRed, mapRed);\r\n        CalculateMap(inRGB, outGreen, mapGreen);\r\n        CalculateMap(inRGB, outBlue, mapBlue);\r\n    }", "language": "java", "code": "public void setInRGB(IntRange inRGB) {\r\n        this.inRed = inRGB;\r\n        this.inGreen = inRGB;\r\n        this.inBlue = inRGB;\r\n\r\n        CalculateMap(inRGB, outRed, mapRed);\r\n        CalculateMap(inRGB, outGreen, mapGreen);\r\n        CalculateMap(inRGB, outBlue, mapBlue);\r\n    }", "code_tokens": ["public", "void", "setInRGB", "(", "IntRange", "inRGB", ")", "{", "this", ".", "inRed", "=", "inRGB", ";", "this", ".", "inGreen", "=", "inRGB", ";", "this", ".", "inBlue", "=", "inRGB", ";", "CalculateMap", "(", "inRGB", ",", "outRed", ",", "mapRed", ")", ";", "CalculateMap", "(", "inRGB", ",", "outGreen", ",", "mapGreen", ")", ";", "CalculateMap", "(", "inRGB", ",", "outBlue", ",", "mapBlue", ")", ";", "}"], "docstring": "Set RGB input range.\n\n@param inRGB Range.", "docstring_tokens": ["Set", "RGB", "input", "range", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/effect/LevelsLinear.java#L222-L230", "partition": "train", "up_fun_num": 18, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.IntRange;", "import com.harium.keel.core.Effect;", "import com.harium.keel.core.source.ImageSource;", "import com.harium.keel.effect.helper.EffectHelper;"], "function": ["public class LevelsLinear implements Effect\n", "    public IntRange getInBlue()\n", "    public void setInBlue(IntRange inBlue)\n", "    public IntRange getInGray()\n", "    public void setInGray(IntRange inGray)\n", "    public IntRange getInGreen()\n", "    public void setInGreen(IntRange inGreen)\n", "    public IntRange getInRed()\n", "    public void setInRed(IntRange inRed)\n", "    public IntRange getOutBlue()\n", "    public void setOutBlue(IntRange outBlue)\n", "    public IntRange getOutGray()\n", "    public void setOutGray(IntRange outGray)\n", "    public IntRange getOutGreen()\n", "    public void setOutGreen(IntRange outGreen)\n", "    public IntRange getOutRed()\n", "    public void setOutRed(IntRange outRed)\n", "    public void setOutRGB(IntRange outRGB)\n", "    public ImageSource apply(ImageSource fastBitmap)\n", "    private void CalculateMap(IntRange inRange, IntRange outRange, int[] map)\n"], "context": "// Catalano Imaging Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2007-2008\n// andrew.kirillov at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.effect;\n\n\nimport com.harium.keel.catalano.core.IntRange;\nimport com.harium.keel.core.Effect;\nimport com.harium.keel.core.source.ImageSource;\nimport com.harium.keel.effect.helper.EffectHelper;\n\n/**\n * Linear correction of RGB channels.\n * <p>The filter performs linear correction of RGB channels by mapping specified channels' input ranges to output ranges.</p>\n * <p>\n * <p><li>Supported types: Grayscale, RGB.\n * <br><li>Coordinate System: Matrix.\n *\n * @author Diego Catalano\n */\npublic class LevelsLinear implements Effect\n{\n\n    private IntRange inRed = new IntRange(0, 255);\n    private IntRange inGreen = new IntRange(0, 255);\n    private IntRange inBlue = new IntRange(0, 255);\n    private IntRange inGray = new IntRange(0, 255);\n\n    private IntRange outRed = new IntRange(0, 255);\n    private IntRange outGreen = new IntRange(0, 255);\n    private IntRange outBlue = new IntRange(0, 255);\n    private IntRange outGray = new IntRange(0, 255);\n\n    private int[] mapRed = new int[256];\n    private int[] mapGreen = new int[256];\n    private int[] mapBlue = new int[256];\n    private int[] mapGray = new int[256];\n\n    /**\n     * Initialize a new instance of the LevelsLinear class.\n     */\n    public LevelsLinear()\n    {\n    }\n\n    /**\n     * Get blue component's input range.\n     *\n     * @return Range.\n     */\n    public IntRange getInBlue()\n    {\n        return inBlue;\n    }\n\n    /**\n     * Set blue component's input range.\n     *\n     * @param inBlue Range.\n     */\n    public void setInBlue(IntRange inBlue)\n    {\n        this.inBlue = inBlue;\n        CalculateMap(inBlue, outBlue, mapBlue);\n    }\n\n    /**\n     * Get gray component's input range.\n     *\n     * @return Range.\n     */\n    public IntRange getInGray()\n    {\n        return inGray;\n    }\n\n    /**\n     * Set gray component's input range.\n     *\n     * @param inGray Range.\n     */\n    public void setInGray(IntRange inGray)\n    {\n        this.inGray = inGray;\n        CalculateMap(inGray, outGray, mapGray);\n    }\n\n    /**\n     * Get green component's input range.\n     *\n     * @return Range.\n     */\n    public IntRange getInGreen()\n    {\n        return inGreen;\n    }\n\n    /**\n     * Set green component's input range.\n     *\n     * @param inGreen Range.\n     */\n    public void setInGreen(IntRange inGreen)\n    {\n        this.inGreen = inGreen;\n        CalculateMap(inGreen, outGreen, mapGreen);\n    }\n\n    /**\n     * Get red component's input range.\n     *\n     * @return Range.\n     */\n    public IntRange getInRed()\n    {\n        return inRed;\n    }\n\n    /**\n     * Get red component's input range.\n     *\n     * @param inRed Range.\n     */\n    public void setInRed(IntRange inRed)\n    {\n        this.inRed = inRed;\n        CalculateMap(inRed, outRed, mapRed);\n    }\n\n    /**\n     * Get blue component's output range.\n     *\n     * @return Range.\n     */\n    public IntRange getOutBlue()\n    {\n        return outBlue;\n    }\n\n    /**\n     * Set blue component's output range.\n     *\n     * @param outBlue Range.\n     */\n    public void setOutBlue(IntRange outBlue)\n    {\n        this.outBlue = outBlue;\n        CalculateMap(inBlue, outBlue, mapBlue);\n    }\n\n    /**\n     * Get gray component's output range.\n     *\n     * @return Range.\n     */\n    public IntRange getOutGray()\n    {\n        return outGray;\n    }\n\n    /**\n     * Set gray component's output range.\n     *\n     * @param outGray Range.\n     */\n    public void setOutGray(IntRange outGray)\n    {\n        this.outGray = outGray;\n        CalculateMap(inGray, outGray, mapGray);\n    }\n\n    /**\n     * Get green component's output range.\n     *\n     * @return Range.\n     */\n    public IntRange getOutGreen()\n    {\n        return outGreen;\n    }\n\n    /**\n     * Set blue component's output range.\n     *\n     * @param outGreen Range.\n     */\n    public void setOutGreen(IntRange outGreen)\n    {\n        this.outGreen = outGreen;\n        CalculateMap(inGreen, outGreen, mapGreen);\n    }\n\n    /**\n     * Get red component's output range.\n     *\n     * @return Range.\n     */\n    public IntRange getOutRed()\n    {\n        return outRed;\n    }\n\n    /**\n     * Set red component's output range.\n     *\n     * @param outRed Range.\n     */\n    public void setOutRed(IntRange outRed)\n    {\n        this.outRed = outRed;\n        CalculateMap(inRed, outRed, mapRed);\n    }\n\n    /**\n     * Set RGB input range.\n     *\n     * @param inRGB Range.\n     */\n\n    /**\n     * Set RGB output range.\n     *\n     * @param outRGB Range.\n     */\n    public void setOutRGB(IntRange outRGB)\n    {\n        this.outRed = outRGB;\n        this.outGreen = outRGB;\n        this.outBlue = outRGB;\n\n        CalculateMap(inRed, outRGB, mapRed);\n        CalculateMap(inGreen, outRGB, mapGreen);\n        CalculateMap(inBlue, outRGB, mapBlue);\n    }\n\n    @Override\n    public ImageSource apply(ImageSource fastBitmap)\n    {\n\n        int size = EffectHelper.getSize(fastBitmap);\n\n        if (fastBitmap.isGrayscale())\n        {\n\n            CalculateMap(inGray, outGray, mapGray);\n\n            for (int i = 0; i < size; i++)\n            {\n                EffectHelper.setRGB(i, mapGray[EffectHelper.getRGB(i, fastBitmap)], fastBitmap);\n            }\n        }\n        else\n        {\n\n            CalculateMap(inRed, outRed, mapRed);\n            CalculateMap(inGreen, outGreen, mapGreen);\n            CalculateMap(inBlue, outBlue, mapBlue);\n\n            for (int i = 0; i < size; i++)\n            {\n                int r = mapRed[EffectHelper.getRed(i, fastBitmap)];\n                int g = mapGreen[EffectHelper.getGreen(i, fastBitmap)];\n                int b = mapBlue[EffectHelper.getBlue(i, fastBitmap)];\n\n                EffectHelper.setRGB(i, r, g, b, fastBitmap);\n            }\n        }\n\n        return fastBitmap;\n\n    }\n\n    /**\n     * Calculate conversion map.\n     *\n     * @param inRange  Input range.\n     * @param outRange Output range.\n     * @param map      Conversion map.\n     */\n    private void CalculateMap(IntRange inRange, IntRange outRange, int[] map)\n    {\n        double k = 0, b = 0;\n\n        if (inRange.getMax() != inRange.getMin())\n        {\n            k = (double) (outRange.getMax() - outRange.getMin()) / (double) (inRange.getMax() - inRange.getMin());\n            b = (double) (outRange.getMin()) - k * inRange.getMin();\n        }\n\n        for (int i = 0; i < 256; i++)\n        {\n            int v = (int) i;\n\n            if (v >= inRange.getMax())\n                v = outRange.getMax();\n            else if (v <= inRange.getMin())\n                v = outRange.getMin();\n            else\n                v = (int) (k * v + b);\n\n            map[i] = v;\n        }\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/effect/LevelsLinear.java", "func_name": "LevelsLinear.setOutRGB", "original_string": "public void setOutRGB(IntRange outRGB) {\r\n        this.outRed = outRGB;\r\n        this.outGreen = outRGB;\r\n        this.outBlue = outRGB;\r\n\r\n        CalculateMap(inRed, outRGB, mapRed);\r\n        CalculateMap(inGreen, outRGB, mapGreen);\r\n        CalculateMap(inBlue, outRGB, mapBlue);\r\n    }", "language": "java", "code": "public void setOutRGB(IntRange outRGB) {\r\n        this.outRed = outRGB;\r\n        this.outGreen = outRGB;\r\n        this.outBlue = outRGB;\r\n\r\n        CalculateMap(inRed, outRGB, mapRed);\r\n        CalculateMap(inGreen, outRGB, mapGreen);\r\n        CalculateMap(inBlue, outRGB, mapBlue);\r\n    }", "code_tokens": ["public", "void", "setOutRGB", "(", "IntRange", "outRGB", ")", "{", "this", ".", "outRed", "=", "outRGB", ";", "this", ".", "outGreen", "=", "outRGB", ";", "this", ".", "outBlue", "=", "outRGB", ";", "CalculateMap", "(", "inRed", ",", "outRGB", ",", "mapRed", ")", ";", "CalculateMap", "(", "inGreen", ",", "outRGB", ",", "mapGreen", ")", ";", "CalculateMap", "(", "inBlue", ",", "outRGB", ",", "mapBlue", ")", ";", "}"], "docstring": "Set RGB output range.\n\n@param outRGB Range.", "docstring_tokens": ["Set", "RGB", "output", "range", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/effect/LevelsLinear.java#L237-L245", "partition": "train", "up_fun_num": 19, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.IntRange;", "import com.harium.keel.core.Effect;", "import com.harium.keel.core.source.ImageSource;", "import com.harium.keel.effect.helper.EffectHelper;"], "function": ["public class LevelsLinear implements Effect\n", "    public IntRange getInBlue()\n", "    public void setInBlue(IntRange inBlue)\n", "    public IntRange getInGray()\n", "    public void setInGray(IntRange inGray)\n", "    public IntRange getInGreen()\n", "    public void setInGreen(IntRange inGreen)\n", "    public IntRange getInRed()\n", "    public void setInRed(IntRange inRed)\n", "    public IntRange getOutBlue()\n", "    public void setOutBlue(IntRange outBlue)\n", "    public IntRange getOutGray()\n", "    public void setOutGray(IntRange outGray)\n", "    public IntRange getOutGreen()\n", "    public void setOutGreen(IntRange outGreen)\n", "    public IntRange getOutRed()\n", "    public void setOutRed(IntRange outRed)\n", "    public void setInRGB(IntRange inRGB)\n", "    public ImageSource apply(ImageSource fastBitmap)\n", "    private void CalculateMap(IntRange inRange, IntRange outRange, int[] map)\n"], "context": "// Catalano Imaging Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2007-2008\n// andrew.kirillov at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.effect;\n\n\nimport com.harium.keel.catalano.core.IntRange;\nimport com.harium.keel.core.Effect;\nimport com.harium.keel.core.source.ImageSource;\nimport com.harium.keel.effect.helper.EffectHelper;\n\n/**\n * Linear correction of RGB channels.\n * <p>The filter performs linear correction of RGB channels by mapping specified channels' input ranges to output ranges.</p>\n * <p>\n * <p><li>Supported types: Grayscale, RGB.\n * <br><li>Coordinate System: Matrix.\n *\n * @author Diego Catalano\n */\npublic class LevelsLinear implements Effect\n{\n\n    private IntRange inRed = new IntRange(0, 255);\n    private IntRange inGreen = new IntRange(0, 255);\n    private IntRange inBlue = new IntRange(0, 255);\n    private IntRange inGray = new IntRange(0, 255);\n\n    private IntRange outRed = new IntRange(0, 255);\n    private IntRange outGreen = new IntRange(0, 255);\n    private IntRange outBlue = new IntRange(0, 255);\n    private IntRange outGray = new IntRange(0, 255);\n\n    private int[] mapRed = new int[256];\n    private int[] mapGreen = new int[256];\n    private int[] mapBlue = new int[256];\n    private int[] mapGray = new int[256];\n\n    /**\n     * Initialize a new instance of the LevelsLinear class.\n     */\n    public LevelsLinear()\n    {\n    }\n\n    /**\n     * Get blue component's input range.\n     *\n     * @return Range.\n     */\n    public IntRange getInBlue()\n    {\n        return inBlue;\n    }\n\n    /**\n     * Set blue component's input range.\n     *\n     * @param inBlue Range.\n     */\n    public void setInBlue(IntRange inBlue)\n    {\n        this.inBlue = inBlue;\n        CalculateMap(inBlue, outBlue, mapBlue);\n    }\n\n    /**\n     * Get gray component's input range.\n     *\n     * @return Range.\n     */\n    public IntRange getInGray()\n    {\n        return inGray;\n    }\n\n    /**\n     * Set gray component's input range.\n     *\n     * @param inGray Range.\n     */\n    public void setInGray(IntRange inGray)\n    {\n        this.inGray = inGray;\n        CalculateMap(inGray, outGray, mapGray);\n    }\n\n    /**\n     * Get green component's input range.\n     *\n     * @return Range.\n     */\n    public IntRange getInGreen()\n    {\n        return inGreen;\n    }\n\n    /**\n     * Set green component's input range.\n     *\n     * @param inGreen Range.\n     */\n    public void setInGreen(IntRange inGreen)\n    {\n        this.inGreen = inGreen;\n        CalculateMap(inGreen, outGreen, mapGreen);\n    }\n\n    /**\n     * Get red component's input range.\n     *\n     * @return Range.\n     */\n    public IntRange getInRed()\n    {\n        return inRed;\n    }\n\n    /**\n     * Get red component's input range.\n     *\n     * @param inRed Range.\n     */\n    public void setInRed(IntRange inRed)\n    {\n        this.inRed = inRed;\n        CalculateMap(inRed, outRed, mapRed);\n    }\n\n    /**\n     * Get blue component's output range.\n     *\n     * @return Range.\n     */\n    public IntRange getOutBlue()\n    {\n        return outBlue;\n    }\n\n    /**\n     * Set blue component's output range.\n     *\n     * @param outBlue Range.\n     */\n    public void setOutBlue(IntRange outBlue)\n    {\n        this.outBlue = outBlue;\n        CalculateMap(inBlue, outBlue, mapBlue);\n    }\n\n    /**\n     * Get gray component's output range.\n     *\n     * @return Range.\n     */\n    public IntRange getOutGray()\n    {\n        return outGray;\n    }\n\n    /**\n     * Set gray component's output range.\n     *\n     * @param outGray Range.\n     */\n    public void setOutGray(IntRange outGray)\n    {\n        this.outGray = outGray;\n        CalculateMap(inGray, outGray, mapGray);\n    }\n\n    /**\n     * Get green component's output range.\n     *\n     * @return Range.\n     */\n    public IntRange getOutGreen()\n    {\n        return outGreen;\n    }\n\n    /**\n     * Set blue component's output range.\n     *\n     * @param outGreen Range.\n     */\n    public void setOutGreen(IntRange outGreen)\n    {\n        this.outGreen = outGreen;\n        CalculateMap(inGreen, outGreen, mapGreen);\n    }\n\n    /**\n     * Get red component's output range.\n     *\n     * @return Range.\n     */\n    public IntRange getOutRed()\n    {\n        return outRed;\n    }\n\n    /**\n     * Set red component's output range.\n     *\n     * @param outRed Range.\n     */\n    public void setOutRed(IntRange outRed)\n    {\n        this.outRed = outRed;\n        CalculateMap(inRed, outRed, mapRed);\n    }\n\n    /**\n     * Set RGB input range.\n     *\n     * @param inRGB Range.\n     */\n    public void setInRGB(IntRange inRGB)\n    {\n        this.inRed = inRGB;\n        this.inGreen = inRGB;\n        this.inBlue = inRGB;\n\n        CalculateMap(inRGB, outRed, mapRed);\n        CalculateMap(inRGB, outGreen, mapGreen);\n        CalculateMap(inRGB, outBlue, mapBlue);\n    }\n\n    /**\n     * Set RGB output range.\n     *\n     * @param outRGB Range.\n     */\n\n    @Override\n    public ImageSource apply(ImageSource fastBitmap)\n    {\n\n        int size = EffectHelper.getSize(fastBitmap);\n\n        if (fastBitmap.isGrayscale())\n        {\n\n            CalculateMap(inGray, outGray, mapGray);\n\n            for (int i = 0; i < size; i++)\n            {\n                EffectHelper.setRGB(i, mapGray[EffectHelper.getRGB(i, fastBitmap)], fastBitmap);\n            }\n        }\n        else\n        {\n\n            CalculateMap(inRed, outRed, mapRed);\n            CalculateMap(inGreen, outGreen, mapGreen);\n            CalculateMap(inBlue, outBlue, mapBlue);\n\n            for (int i = 0; i < size; i++)\n            {\n                int r = mapRed[EffectHelper.getRed(i, fastBitmap)];\n                int g = mapGreen[EffectHelper.getGreen(i, fastBitmap)];\n                int b = mapBlue[EffectHelper.getBlue(i, fastBitmap)];\n\n                EffectHelper.setRGB(i, r, g, b, fastBitmap);\n            }\n        }\n\n        return fastBitmap;\n\n    }\n\n    /**\n     * Calculate conversion map.\n     *\n     * @param inRange  Input range.\n     * @param outRange Output range.\n     * @param map      Conversion map.\n     */\n    private void CalculateMap(IntRange inRange, IntRange outRange, int[] map)\n    {\n        double k = 0, b = 0;\n\n        if (inRange.getMax() != inRange.getMin())\n        {\n            k = (double) (outRange.getMax() - outRange.getMin()) / (double) (inRange.getMax() - inRange.getMin());\n            b = (double) (outRange.getMin()) - k * inRange.getMin();\n        }\n\n        for (int i = 0; i < 256; i++)\n        {\n            int v = (int) i;\n\n            if (v >= inRange.getMax())\n                v = outRange.getMax();\n            else if (v <= inRange.getMin())\n                v = outRange.getMin();\n            else\n                v = (int) (k * v + b);\n\n            map[i] = v;\n        }\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/effect/LevelsLinear.java", "func_name": "LevelsLinear.CalculateMap", "original_string": "private void CalculateMap(IntRange inRange, IntRange outRange, int[] map) {\r\n        double k = 0, b = 0;\r\n\r\n        if (inRange.getMax() != inRange.getMin()) {\r\n            k = (double) (outRange.getMax() - outRange.getMin()) / (double) (inRange.getMax() - inRange.getMin());\r\n            b = (double) (outRange.getMin()) - k * inRange.getMin();\r\n        }\r\n\r\n        for (int i = 0; i < 256; i++) {\r\n            int v = (int) i;\r\n\r\n            if (v >= inRange.getMax())\r\n                v = outRange.getMax();\r\n            else if (v <= inRange.getMin())\r\n                v = outRange.getMin();\r\n            else\r\n                v = (int) (k * v + b);\r\n\r\n            map[i] = v;\r\n        }\r\n    }", "language": "java", "code": "private void CalculateMap(IntRange inRange, IntRange outRange, int[] map) {\r\n        double k = 0, b = 0;\r\n\r\n        if (inRange.getMax() != inRange.getMin()) {\r\n            k = (double) (outRange.getMax() - outRange.getMin()) / (double) (inRange.getMax() - inRange.getMin());\r\n            b = (double) (outRange.getMin()) - k * inRange.getMin();\r\n        }\r\n\r\n        for (int i = 0; i < 256; i++) {\r\n            int v = (int) i;\r\n\r\n            if (v >= inRange.getMax())\r\n                v = outRange.getMax();\r\n            else if (v <= inRange.getMin())\r\n                v = outRange.getMin();\r\n            else\r\n                v = (int) (k * v + b);\r\n\r\n            map[i] = v;\r\n        }\r\n    }", "code_tokens": ["private", "void", "CalculateMap", "(", "IntRange", "inRange", ",", "IntRange", "outRange", ",", "int", "[", "]", "map", ")", "{", "double", "k", "=", "0", ",", "b", "=", "0", ";", "if", "(", "inRange", ".", "getMax", "(", ")", "!=", "inRange", ".", "getMin", "(", ")", ")", "{", "k", "=", "(", "double", ")", "(", "outRange", ".", "getMax", "(", ")", "-", "outRange", ".", "getMin", "(", ")", ")", "/", "(", "double", ")", "(", "inRange", ".", "getMax", "(", ")", "-", "inRange", ".", "getMin", "(", ")", ")", ";", "b", "=", "(", "double", ")", "(", "outRange", ".", "getMin", "(", ")", ")", "-", "k", "*", "inRange", ".", "getMin", "(", ")", ";", "}", "for", "(", "int", "i", "=", "0", ";", "i", "<", "256", ";", "i", "++", ")", "{", "int", "v", "=", "(", "int", ")", "i", ";", "if", "(", "v", ">=", "inRange", ".", "getMax", "(", ")", ")", "v", "=", "outRange", ".", "getMax", "(", ")", ";", "else", "if", "(", "v", "<=", "inRange", ".", "getMin", "(", ")", ")", "v", "=", "outRange", ".", "getMin", "(", ")", ";", "else", "v", "=", "(", "int", ")", "(", "k", "*", "v", "+", "b", ")", ";", "map", "[", "i", "]", "=", "v", ";", "}", "}"], "docstring": "Calculate conversion map.\n\n@param inRange  Input range.\n@param outRange Output range.\n@param map      Conversion map.", "docstring_tokens": ["Calculate", "conversion", "map", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/effect/LevelsLinear.java#L285-L305", "partition": "train", "up_fun_num": 20, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.IntRange;", "import com.harium.keel.core.Effect;", "import com.harium.keel.core.source.ImageSource;", "import com.harium.keel.effect.helper.EffectHelper;"], "function": ["public class LevelsLinear implements Effect\n", "    public IntRange getInBlue()\n", "    public void setInBlue(IntRange inBlue)\n", "    public IntRange getInGray()\n", "    public void setInGray(IntRange inGray)\n", "    public IntRange getInGreen()\n", "    public void setInGreen(IntRange inGreen)\n", "    public IntRange getInRed()\n", "    public void setInRed(IntRange inRed)\n", "    public IntRange getOutBlue()\n", "    public void setOutBlue(IntRange outBlue)\n", "    public IntRange getOutGray()\n", "    public void setOutGray(IntRange outGray)\n", "    public IntRange getOutGreen()\n", "    public void setOutGreen(IntRange outGreen)\n", "    public IntRange getOutRed()\n", "    public void setOutRed(IntRange outRed)\n", "    public void setInRGB(IntRange inRGB)\n", "    public void setOutRGB(IntRange outRGB)\n", "    public ImageSource apply(ImageSource fastBitmap)\n"], "context": "// Catalano Imaging Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2007-2008\n// andrew.kirillov at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.effect;\n\n\nimport com.harium.keel.catalano.core.IntRange;\nimport com.harium.keel.core.Effect;\nimport com.harium.keel.core.source.ImageSource;\nimport com.harium.keel.effect.helper.EffectHelper;\n\n/**\n * Linear correction of RGB channels.\n * <p>The filter performs linear correction of RGB channels by mapping specified channels' input ranges to output ranges.</p>\n * <p>\n * <p><li>Supported types: Grayscale, RGB.\n * <br><li>Coordinate System: Matrix.\n *\n * @author Diego Catalano\n */\npublic class LevelsLinear implements Effect\n{\n\n    private IntRange inRed = new IntRange(0, 255);\n    private IntRange inGreen = new IntRange(0, 255);\n    private IntRange inBlue = new IntRange(0, 255);\n    private IntRange inGray = new IntRange(0, 255);\n\n    private IntRange outRed = new IntRange(0, 255);\n    private IntRange outGreen = new IntRange(0, 255);\n    private IntRange outBlue = new IntRange(0, 255);\n    private IntRange outGray = new IntRange(0, 255);\n\n    private int[] mapRed = new int[256];\n    private int[] mapGreen = new int[256];\n    private int[] mapBlue = new int[256];\n    private int[] mapGray = new int[256];\n\n    /**\n     * Initialize a new instance of the LevelsLinear class.\n     */\n    public LevelsLinear()\n    {\n    }\n\n    /**\n     * Get blue component's input range.\n     *\n     * @return Range.\n     */\n    public IntRange getInBlue()\n    {\n        return inBlue;\n    }\n\n    /**\n     * Set blue component's input range.\n     *\n     * @param inBlue Range.\n     */\n    public void setInBlue(IntRange inBlue)\n    {\n        this.inBlue = inBlue;\n        CalculateMap(inBlue, outBlue, mapBlue);\n    }\n\n    /**\n     * Get gray component's input range.\n     *\n     * @return Range.\n     */\n    public IntRange getInGray()\n    {\n        return inGray;\n    }\n\n    /**\n     * Set gray component's input range.\n     *\n     * @param inGray Range.\n     */\n    public void setInGray(IntRange inGray)\n    {\n        this.inGray = inGray;\n        CalculateMap(inGray, outGray, mapGray);\n    }\n\n    /**\n     * Get green component's input range.\n     *\n     * @return Range.\n     */\n    public IntRange getInGreen()\n    {\n        return inGreen;\n    }\n\n    /**\n     * Set green component's input range.\n     *\n     * @param inGreen Range.\n     */\n    public void setInGreen(IntRange inGreen)\n    {\n        this.inGreen = inGreen;\n        CalculateMap(inGreen, outGreen, mapGreen);\n    }\n\n    /**\n     * Get red component's input range.\n     *\n     * @return Range.\n     */\n    public IntRange getInRed()\n    {\n        return inRed;\n    }\n\n    /**\n     * Get red component's input range.\n     *\n     * @param inRed Range.\n     */\n    public void setInRed(IntRange inRed)\n    {\n        this.inRed = inRed;\n        CalculateMap(inRed, outRed, mapRed);\n    }\n\n    /**\n     * Get blue component's output range.\n     *\n     * @return Range.\n     */\n    public IntRange getOutBlue()\n    {\n        return outBlue;\n    }\n\n    /**\n     * Set blue component's output range.\n     *\n     * @param outBlue Range.\n     */\n    public void setOutBlue(IntRange outBlue)\n    {\n        this.outBlue = outBlue;\n        CalculateMap(inBlue, outBlue, mapBlue);\n    }\n\n    /**\n     * Get gray component's output range.\n     *\n     * @return Range.\n     */\n    public IntRange getOutGray()\n    {\n        return outGray;\n    }\n\n    /**\n     * Set gray component's output range.\n     *\n     * @param outGray Range.\n     */\n    public void setOutGray(IntRange outGray)\n    {\n        this.outGray = outGray;\n        CalculateMap(inGray, outGray, mapGray);\n    }\n\n    /**\n     * Get green component's output range.\n     *\n     * @return Range.\n     */\n    public IntRange getOutGreen()\n    {\n        return outGreen;\n    }\n\n    /**\n     * Set blue component's output range.\n     *\n     * @param outGreen Range.\n     */\n    public void setOutGreen(IntRange outGreen)\n    {\n        this.outGreen = outGreen;\n        CalculateMap(inGreen, outGreen, mapGreen);\n    }\n\n    /**\n     * Get red component's output range.\n     *\n     * @return Range.\n     */\n    public IntRange getOutRed()\n    {\n        return outRed;\n    }\n\n    /**\n     * Set red component's output range.\n     *\n     * @param outRed Range.\n     */\n    public void setOutRed(IntRange outRed)\n    {\n        this.outRed = outRed;\n        CalculateMap(inRed, outRed, mapRed);\n    }\n\n    /**\n     * Set RGB input range.\n     *\n     * @param inRGB Range.\n     */\n    public void setInRGB(IntRange inRGB)\n    {\n        this.inRed = inRGB;\n        this.inGreen = inRGB;\n        this.inBlue = inRGB;\n\n        CalculateMap(inRGB, outRed, mapRed);\n        CalculateMap(inRGB, outGreen, mapGreen);\n        CalculateMap(inRGB, outBlue, mapBlue);\n    }\n\n    /**\n     * Set RGB output range.\n     *\n     * @param outRGB Range.\n     */\n    public void setOutRGB(IntRange outRGB)\n    {\n        this.outRed = outRGB;\n        this.outGreen = outRGB;\n        this.outBlue = outRGB;\n\n        CalculateMap(inRed, outRGB, mapRed);\n        CalculateMap(inGreen, outRGB, mapGreen);\n        CalculateMap(inBlue, outRGB, mapBlue);\n    }\n\n    @Override\n    public ImageSource apply(ImageSource fastBitmap)\n    {\n\n        int size = EffectHelper.getSize(fastBitmap);\n\n        if (fastBitmap.isGrayscale())\n        {\n\n            CalculateMap(inGray, outGray, mapGray);\n\n            for (int i = 0; i < size; i++)\n            {\n                EffectHelper.setRGB(i, mapGray[EffectHelper.getRGB(i, fastBitmap)], fastBitmap);\n            }\n        }\n        else\n        {\n\n            CalculateMap(inRed, outRed, mapRed);\n            CalculateMap(inGreen, outGreen, mapGreen);\n            CalculateMap(inBlue, outBlue, mapBlue);\n\n            for (int i = 0; i < size; i++)\n            {\n                int r = mapRed[EffectHelper.getRed(i, fastBitmap)];\n                int g = mapGreen[EffectHelper.getGreen(i, fastBitmap)];\n                int b = mapBlue[EffectHelper.getBlue(i, fastBitmap)];\n\n                EffectHelper.setRGB(i, r, g, b, fastBitmap);\n            }\n        }\n\n        return fastBitmap;\n\n    }\n\n    /**\n     * Calculate conversion map.\n     *\n     * @param inRange  Input range.\n     * @param outRange Output range.\n     * @param map      Conversion map.\n     */\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/tools/ImageStatistics.java", "func_name": "ImageStatistics.Maximum", "original_string": "public static int Maximum(ImageSource fastBitmap, int startX, int startY, int width, int height) {\r\n        int max = 0;\r\n\r\n        if (fastBitmap.isGrayscale()) {\r\n            for (int i = startX; i < height; i++) {\r\n                for (int j = startY; j < width; j++) {\r\n                    int gray = fastBitmap.getRGB(j, i);\r\n                    if (gray > max) {\r\n                        max = gray;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            for (int i = startX; i < height; i++) {\r\n                for (int j = startY; j < width; j++) {\r\n                    int gray = fastBitmap.getG(j, i);\r\n                    if (gray > max) {\r\n                        max = gray;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return max;\r\n    }", "language": "java", "code": "public static int Maximum(ImageSource fastBitmap, int startX, int startY, int width, int height) {\r\n        int max = 0;\r\n\r\n        if (fastBitmap.isGrayscale()) {\r\n            for (int i = startX; i < height; i++) {\r\n                for (int j = startY; j < width; j++) {\r\n                    int gray = fastBitmap.getRGB(j, i);\r\n                    if (gray > max) {\r\n                        max = gray;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            for (int i = startX; i < height; i++) {\r\n                for (int j = startY; j < width; j++) {\r\n                    int gray = fastBitmap.getG(j, i);\r\n                    if (gray > max) {\r\n                        max = gray;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return max;\r\n    }", "code_tokens": ["public", "static", "int", "Maximum", "(", "ImageSource", "fastBitmap", ",", "int", "startX", ",", "int", "startY", ",", "int", "width", ",", "int", "height", ")", "{", "int", "max", "=", "0", ";", "if", "(", "fastBitmap", ".", "isGrayscale", "(", ")", ")", "{", "for", "(", "int", "i", "=", "startX", ";", "i", "<", "height", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "startY", ";", "j", "<", "width", ";", "j", "++", ")", "{", "int", "gray", "=", "fastBitmap", ".", "getRGB", "(", "j", ",", "i", ")", ";", "if", "(", "gray", ">", "max", ")", "{", "max", "=", "gray", ";", "}", "}", "}", "}", "else", "{", "for", "(", "int", "i", "=", "startX", ";", "i", "<", "height", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "startY", ";", "j", "<", "width", ";", "j", "++", ")", "{", "int", "gray", "=", "fastBitmap", ".", "getG", "(", "j", ",", "i", ")", ";", "if", "(", "gray", ">", "max", ")", "{", "max", "=", "gray", ";", "}", "}", "}", "}", "return", "max", ";", "}"], "docstring": "Get maximum gray value in the image.\n\n@param fastBitmap Image to be processed.\n@param startX     Initial X axis coordinate.\n@param startY     Initial Y axis coordinate.\n@param width      Width.\n@param height     Height.\n@return Maximum gray.", "docstring_tokens": ["Get", "maximum", "gray", "value", "in", "the", "image", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/tools/ImageStatistics.java#L263-L287", "partition": "train", "up_fun_num": 13, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.core.source.ImageSource;", "import com.harium.keel.effect.helper.EffectHelper;"], "function": ["public class ImageStatistics\n", "    public ImageHistogram getHistogramGray()\n", "    public ImageHistogram getHistogramRed()\n", "    public ImageHistogram getHistogramGreen()\n", "    public ImageHistogram getHistogramBlue()\n", "    public int PixelsCount()\n", "    public static float Mean(ImageSource fastBitmap)\n", "    public static float Mean(ImageSource fastBitmap, int startX, int startY, int width, int height)\n", "    public static float Variance(ImageSource fastBitmap)\n", "    public static float Variance(ImageSource fastBitmap, float mean)\n", "    public static float Variance(ImageSource fastBitmap, float mean, int startX, int startY, int width, int height)\n", "    public static int Maximum(ImageSource fastBitmap)\n", "    public static int Minimum(ImageSource fastBitmap)\n", "    public static int Minimum(ImageSource fastBitmap, int startX, int startY, int width, int height)\n"], "context": "// Catalano Imaging Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2007-2008\n// andrew.kirillov at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.tools;\n\nimport com.harium.keel.core.source.ImageSource;\nimport com.harium.keel.effect.helper.EffectHelper;\n\n/**\n * Gather statistics about image in Gray or RGB color space.\n *\n * @author Diego Catalano\n */\npublic class ImageStatistics\n{\n\n    private ImageHistogram gray;\n    private ImageHistogram red;\n    private ImageHistogram green;\n    private ImageHistogram blue;\n\n    private int pixels;\n\n    /**\n     * Image histogram of gray channel.\n     *\n     * @return Histogram.\n     */\n    public ImageHistogram getHistogramGray()\n    {\n        if (gray == null)\n            throw new IllegalArgumentException(\"Histogram gray is null\");\n\n        return gray;\n    }\n\n    /**\n     * Image histogram of red channel.\n     *\n     * @return Histogram.\n     */\n    public ImageHistogram getHistogramRed()\n    {\n        if (red == null)\n            throw new IllegalArgumentException(\"Histogram red is null\");\n\n        return red;\n    }\n\n    /**\n     * Image histogram of green channel.\n     *\n     * @return Histogram.\n     */\n    public ImageHistogram getHistogramGreen()\n    {\n        if (green == null)\n            throw new IllegalArgumentException(\"Histogram green is null\");\n\n        return green;\n    }\n\n    /**\n     * Image histogram of blue channel.\n     *\n     * @return Histogram.\n     */\n    public ImageHistogram getHistogramBlue()\n    {\n        if (blue == null)\n            throw new IllegalArgumentException(\"Histogram blue is null\");\n\n        return blue;\n    }\n\n    /**\n     * Initialize a new instance of the ImageStatistics class.\n     *\n     * @param fastBitmap Image to be processed.\n     */\n    public ImageStatistics(ImageSource fastBitmap)\n    {\n        this(fastBitmap, 256);\n    }\n\n    /**\n     * Initialize a new instance of the ImageStatistics class.\n     *\n     * @param fastBitmap Image to be processed.\n     * @param bins       Number of bins.\n     */\n    public ImageStatistics(ImageSource fastBitmap, int bins)\n    {\n\n        pixels = 0;\n        red = green = blue = gray = null;\n\n        float factor = bins / 256f;\n        int size = EffectHelper.getSize(fastBitmap);\n\n        if (fastBitmap.isGrayscale())\n        {\n            int[] g = new int[bins];\n\n            int G;\n\n            for (int i = 0; i < size; i++)\n            {\n                G = EffectHelper.getGray(i, fastBitmap);\n\n                g[(int) (G * factor)]++;\n                pixels++;\n            }\n\n            gray = new ImageHistogram(g);\n\n        }\n        else\n        {\n            int[] r = new int[bins];\n            int[] g = new int[bins];\n            int[] b = new int[bins];\n\n            int R, G, B;\n\n            for (int i = 0; i < size; i++)\n            {\n                R = EffectHelper.getRed(i, fastBitmap);\n                G = EffectHelper.getGreen(i, fastBitmap);\n                B = EffectHelper.getBlue(i, fastBitmap);\n\n                r[(int) (R * factor)]++;\n                g[(int) (G * factor)]++;\n                b[(int) (B * factor)]++;\n                pixels++;\n            }\n            red = new ImageHistogram(r);\n            green = new ImageHistogram(g);\n            blue = new ImageHistogram(b);\n        }\n    }\n\n    /**\n     * Count pixels.\n     *\n     * @return amount of pixels.\n     */\n    public int PixelsCount()\n    {\n        return pixels;\n    }\n\n    /**\n     * Calculate Mean value.\n     *\n     * @param fastBitmap Image to be processed.\n     * @return Mean.\n     */\n    public static float Mean(ImageSource fastBitmap)\n    {\n        return Mean(fastBitmap, 0, 0, fastBitmap.getWidth(), fastBitmap.getHeight());\n    }\n\n    /**\n     * Calculate Mean value.\n     *\n     * @param fastBitmap Image to be processed.\n     * @param startX     Initial X axis coordinate.\n     * @param startY     Initial Y axis coordinate.\n     * @param width      Width.\n     * @param height     Height.\n     * @return Mean.\n     */\n    public static float Mean(ImageSource fastBitmap, int startX, int startY, int width, int height)\n    {\n        float mean = 0;\n        if (fastBitmap.isGrayscale())\n        {\n            for (int i = startX; i < height; i++)\n            {\n                for (int j = startY; j < width; j++)\n                {\n                    mean += fastBitmap.getRGB(j, i);\n                }\n            }\n            return mean / (width * height);\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"ImageStatistics: Only compute mean in grayscale images.\");\n        }\n    }\n\n    /**\n     * Calculate Variance.\n     *\n     * @param fastBitmap Image to be processed.\n     * @return Variance.\n     */\n    public static float Variance(ImageSource fastBitmap)\n    {\n        float mean = Mean(fastBitmap);\n        return Variance(fastBitmap, mean);\n    }\n\n    /**\n     * Calculate Variance.\n     *\n     * @param fastBitmap Image to be processed.\n     * @param mean       Mean.\n     * @return Variance.\n     */\n    public static float Variance(ImageSource fastBitmap, float mean)\n    {\n        return Variance(fastBitmap, mean, 0, 0, fastBitmap.getWidth(), fastBitmap.getHeight());\n    }\n\n    /**\n     * Calculate Variance.\n     *\n     * @param fastBitmap Image to be processed.\n     * @param mean       Mean.\n     * @param startX     Initial X axis coordinate.\n     * @param startY     Initial Y axis coordinate.\n     * @param width      Width.\n     * @param height     Height.\n     * @return Variance.\n     */\n    public static float Variance(ImageSource fastBitmap, float mean, int startX, int startY, int width, int height)\n    {\n\n        float sum = 0;\n        if (fastBitmap.isGrayscale())\n        {\n            for (int i = startX; i < height; i++)\n            {\n                for (int j = startY; j < width; j++)\n                {\n                    sum += Math.pow(fastBitmap.getRGB(j, i) - mean, 2);\n                }\n            }\n            return sum / (float) ((width * height) - 1);\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"ImageStatistics: Only compute variance in grayscale images.\");\n        }\n    }\n\n    /**\n     * Get maximum gray value in the image.\n     *\n     * @param fastBitmap Image to be processed.\n     * @return Maximum gray.\n     */\n    public static int Maximum(ImageSource fastBitmap)\n    {\n        return Maximum(fastBitmap, 0, 0, fastBitmap.getWidth(), fastBitmap.getHeight());\n    }\n\n    /**\n     * Get maximum gray value in the image.\n     *\n     * @param fastBitmap Image to be processed.\n     * @param startX     Initial X axis coordinate.\n     * @param startY     Initial Y axis coordinate.\n     * @param width      Width.\n     * @param height     Height.\n     * @return Maximum gray.\n     */\n\n    /**\n     * Get minimum gray value in the image.\n     *\n     * @param fastBitmap Image to be processed.\n     * @return minimum gray.\n     */\n    public static int Minimum(ImageSource fastBitmap)\n    {\n        return Minimum(fastBitmap, 0, 0, fastBitmap.getWidth(), fastBitmap.getHeight());\n    }\n\n    /**\n     * Get minimum gray value in the image.\n     *\n     * @param fastBitmap Image to be processed.\n     * @param startX     Initial X axis coordinate.\n     * @param startY     Initial Y axis coordinate.\n     * @param width      Width.\n     * @param height     Height.\n     * @return Minimum gray.\n     */\n    public static int Minimum(ImageSource fastBitmap, int startX, int startY, int width, int height)\n    {\n        int min = 255;\n        if (fastBitmap.isGrayscale())\n        {\n            for (int i = startX; i < height; i++)\n            {\n                for (int j = startY; j < width; j++)\n                {\n                    int gray = fastBitmap.getRGB(j, i);\n                    if (gray < min)\n                    {\n                        min = gray;\n                    }\n                }\n            }\n        }\n        else\n        {\n            for (int i = startX; i < height; i++)\n            {\n                for (int j = startY; j < width; j++)\n                {\n                    int gray = fastBitmap.getG(j, i);\n                    if (gray < min)\n                    {\n                        min = gray;\n                    }\n                }\n            }\n        }\n        return min;\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/tools/ImageStatistics.java", "func_name": "ImageStatistics.Minimum", "original_string": "public static int Minimum(ImageSource fastBitmap, int startX, int startY, int width, int height) {\r\n        int min = 255;\r\n        if (fastBitmap.isGrayscale()) {\r\n            for (int i = startX; i < height; i++) {\r\n                for (int j = startY; j < width; j++) {\r\n                    int gray = fastBitmap.getRGB(j, i);\r\n                    if (gray < min) {\r\n                        min = gray;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            for (int i = startX; i < height; i++) {\r\n                for (int j = startY; j < width; j++) {\r\n                    int gray = fastBitmap.getG(j, i);\r\n                    if (gray < min) {\r\n                        min = gray;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return min;\r\n    }", "language": "java", "code": "public static int Minimum(ImageSource fastBitmap, int startX, int startY, int width, int height) {\r\n        int min = 255;\r\n        if (fastBitmap.isGrayscale()) {\r\n            for (int i = startX; i < height; i++) {\r\n                for (int j = startY; j < width; j++) {\r\n                    int gray = fastBitmap.getRGB(j, i);\r\n                    if (gray < min) {\r\n                        min = gray;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            for (int i = startX; i < height; i++) {\r\n                for (int j = startY; j < width; j++) {\r\n                    int gray = fastBitmap.getG(j, i);\r\n                    if (gray < min) {\r\n                        min = gray;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return min;\r\n    }", "code_tokens": ["public", "static", "int", "Minimum", "(", "ImageSource", "fastBitmap", ",", "int", "startX", ",", "int", "startY", ",", "int", "width", ",", "int", "height", ")", "{", "int", "min", "=", "255", ";", "if", "(", "fastBitmap", ".", "isGrayscale", "(", ")", ")", "{", "for", "(", "int", "i", "=", "startX", ";", "i", "<", "height", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "startY", ";", "j", "<", "width", ";", "j", "++", ")", "{", "int", "gray", "=", "fastBitmap", ".", "getRGB", "(", "j", ",", "i", ")", ";", "if", "(", "gray", "<", "min", ")", "{", "min", "=", "gray", ";", "}", "}", "}", "}", "else", "{", "for", "(", "int", "i", "=", "startX", ";", "i", "<", "height", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "startY", ";", "j", "<", "width", ";", "j", "++", ")", "{", "int", "gray", "=", "fastBitmap", ".", "getG", "(", "j", ",", "i", ")", ";", "if", "(", "gray", "<", "min", ")", "{", "min", "=", "gray", ";", "}", "}", "}", "}", "return", "min", ";", "}"], "docstring": "Get minimum gray value in the image.\n\n@param fastBitmap Image to be processed.\n@param startX     Initial X axis coordinate.\n@param startY     Initial Y axis coordinate.\n@param width      Width.\n@param height     Height.\n@return Minimum gray.", "docstring_tokens": ["Get", "minimum", "gray", "value", "in", "the", "image", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/tools/ImageStatistics.java#L309-L331", "partition": "train", "up_fun_num": 14, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.core.source.ImageSource;", "import com.harium.keel.effect.helper.EffectHelper;"], "function": ["public class ImageStatistics\n", "    public ImageHistogram getHistogramGray()\n", "    public ImageHistogram getHistogramRed()\n", "    public ImageHistogram getHistogramGreen()\n", "    public ImageHistogram getHistogramBlue()\n", "    public int PixelsCount()\n", "    public static float Mean(ImageSource fastBitmap)\n", "    public static float Mean(ImageSource fastBitmap, int startX, int startY, int width, int height)\n", "    public static float Variance(ImageSource fastBitmap)\n", "    public static float Variance(ImageSource fastBitmap, float mean)\n", "    public static float Variance(ImageSource fastBitmap, float mean, int startX, int startY, int width, int height)\n", "    public static int Maximum(ImageSource fastBitmap)\n", "    public static int Maximum(ImageSource fastBitmap, int startX, int startY, int width, int height)\n", "    public static int Minimum(ImageSource fastBitmap)\n"], "context": "// Catalano Imaging Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2007-2008\n// andrew.kirillov at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.tools;\n\nimport com.harium.keel.core.source.ImageSource;\nimport com.harium.keel.effect.helper.EffectHelper;\n\n/**\n * Gather statistics about image in Gray or RGB color space.\n *\n * @author Diego Catalano\n */\npublic class ImageStatistics\n{\n\n    private ImageHistogram gray;\n    private ImageHistogram red;\n    private ImageHistogram green;\n    private ImageHistogram blue;\n\n    private int pixels;\n\n    /**\n     * Image histogram of gray channel.\n     *\n     * @return Histogram.\n     */\n    public ImageHistogram getHistogramGray()\n    {\n        if (gray == null)\n            throw new IllegalArgumentException(\"Histogram gray is null\");\n\n        return gray;\n    }\n\n    /**\n     * Image histogram of red channel.\n     *\n     * @return Histogram.\n     */\n    public ImageHistogram getHistogramRed()\n    {\n        if (red == null)\n            throw new IllegalArgumentException(\"Histogram red is null\");\n\n        return red;\n    }\n\n    /**\n     * Image histogram of green channel.\n     *\n     * @return Histogram.\n     */\n    public ImageHistogram getHistogramGreen()\n    {\n        if (green == null)\n            throw new IllegalArgumentException(\"Histogram green is null\");\n\n        return green;\n    }\n\n    /**\n     * Image histogram of blue channel.\n     *\n     * @return Histogram.\n     */\n    public ImageHistogram getHistogramBlue()\n    {\n        if (blue == null)\n            throw new IllegalArgumentException(\"Histogram blue is null\");\n\n        return blue;\n    }\n\n    /**\n     * Initialize a new instance of the ImageStatistics class.\n     *\n     * @param fastBitmap Image to be processed.\n     */\n    public ImageStatistics(ImageSource fastBitmap)\n    {\n        this(fastBitmap, 256);\n    }\n\n    /**\n     * Initialize a new instance of the ImageStatistics class.\n     *\n     * @param fastBitmap Image to be processed.\n     * @param bins       Number of bins.\n     */\n    public ImageStatistics(ImageSource fastBitmap, int bins)\n    {\n\n        pixels = 0;\n        red = green = blue = gray = null;\n\n        float factor = bins / 256f;\n        int size = EffectHelper.getSize(fastBitmap);\n\n        if (fastBitmap.isGrayscale())\n        {\n            int[] g = new int[bins];\n\n            int G;\n\n            for (int i = 0; i < size; i++)\n            {\n                G = EffectHelper.getGray(i, fastBitmap);\n\n                g[(int) (G * factor)]++;\n                pixels++;\n            }\n\n            gray = new ImageHistogram(g);\n\n        }\n        else\n        {\n            int[] r = new int[bins];\n            int[] g = new int[bins];\n            int[] b = new int[bins];\n\n            int R, G, B;\n\n            for (int i = 0; i < size; i++)\n            {\n                R = EffectHelper.getRed(i, fastBitmap);\n                G = EffectHelper.getGreen(i, fastBitmap);\n                B = EffectHelper.getBlue(i, fastBitmap);\n\n                r[(int) (R * factor)]++;\n                g[(int) (G * factor)]++;\n                b[(int) (B * factor)]++;\n                pixels++;\n            }\n            red = new ImageHistogram(r);\n            green = new ImageHistogram(g);\n            blue = new ImageHistogram(b);\n        }\n    }\n\n    /**\n     * Count pixels.\n     *\n     * @return amount of pixels.\n     */\n    public int PixelsCount()\n    {\n        return pixels;\n    }\n\n    /**\n     * Calculate Mean value.\n     *\n     * @param fastBitmap Image to be processed.\n     * @return Mean.\n     */\n    public static float Mean(ImageSource fastBitmap)\n    {\n        return Mean(fastBitmap, 0, 0, fastBitmap.getWidth(), fastBitmap.getHeight());\n    }\n\n    /**\n     * Calculate Mean value.\n     *\n     * @param fastBitmap Image to be processed.\n     * @param startX     Initial X axis coordinate.\n     * @param startY     Initial Y axis coordinate.\n     * @param width      Width.\n     * @param height     Height.\n     * @return Mean.\n     */\n    public static float Mean(ImageSource fastBitmap, int startX, int startY, int width, int height)\n    {\n        float mean = 0;\n        if (fastBitmap.isGrayscale())\n        {\n            for (int i = startX; i < height; i++)\n            {\n                for (int j = startY; j < width; j++)\n                {\n                    mean += fastBitmap.getRGB(j, i);\n                }\n            }\n            return mean / (width * height);\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"ImageStatistics: Only compute mean in grayscale images.\");\n        }\n    }\n\n    /**\n     * Calculate Variance.\n     *\n     * @param fastBitmap Image to be processed.\n     * @return Variance.\n     */\n    public static float Variance(ImageSource fastBitmap)\n    {\n        float mean = Mean(fastBitmap);\n        return Variance(fastBitmap, mean);\n    }\n\n    /**\n     * Calculate Variance.\n     *\n     * @param fastBitmap Image to be processed.\n     * @param mean       Mean.\n     * @return Variance.\n     */\n    public static float Variance(ImageSource fastBitmap, float mean)\n    {\n        return Variance(fastBitmap, mean, 0, 0, fastBitmap.getWidth(), fastBitmap.getHeight());\n    }\n\n    /**\n     * Calculate Variance.\n     *\n     * @param fastBitmap Image to be processed.\n     * @param mean       Mean.\n     * @param startX     Initial X axis coordinate.\n     * @param startY     Initial Y axis coordinate.\n     * @param width      Width.\n     * @param height     Height.\n     * @return Variance.\n     */\n    public static float Variance(ImageSource fastBitmap, float mean, int startX, int startY, int width, int height)\n    {\n\n        float sum = 0;\n        if (fastBitmap.isGrayscale())\n        {\n            for (int i = startX; i < height; i++)\n            {\n                for (int j = startY; j < width; j++)\n                {\n                    sum += Math.pow(fastBitmap.getRGB(j, i) - mean, 2);\n                }\n            }\n            return sum / (float) ((width * height) - 1);\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"ImageStatistics: Only compute variance in grayscale images.\");\n        }\n    }\n\n    /**\n     * Get maximum gray value in the image.\n     *\n     * @param fastBitmap Image to be processed.\n     * @return Maximum gray.\n     */\n    public static int Maximum(ImageSource fastBitmap)\n    {\n        return Maximum(fastBitmap, 0, 0, fastBitmap.getWidth(), fastBitmap.getHeight());\n    }\n\n    /**\n     * Get maximum gray value in the image.\n     *\n     * @param fastBitmap Image to be processed.\n     * @param startX     Initial X axis coordinate.\n     * @param startY     Initial Y axis coordinate.\n     * @param width      Width.\n     * @param height     Height.\n     * @return Maximum gray.\n     */\n    public static int Maximum(ImageSource fastBitmap, int startX, int startY, int width, int height)\n    {\n        int max = 0;\n\n        if (fastBitmap.isGrayscale())\n        {\n            for (int i = startX; i < height; i++)\n            {\n                for (int j = startY; j < width; j++)\n                {\n                    int gray = fastBitmap.getRGB(j, i);\n                    if (gray > max)\n                    {\n                        max = gray;\n                    }\n                }\n            }\n        }\n        else\n        {\n            for (int i = startX; i < height; i++)\n            {\n                for (int j = startY; j < width; j++)\n                {\n                    int gray = fastBitmap.getG(j, i);\n                    if (gray > max)\n                    {\n                        max = gray;\n                    }\n                }\n            }\n        }\n\n        return max;\n    }\n\n    /**\n     * Get minimum gray value in the image.\n     *\n     * @param fastBitmap Image to be processed.\n     * @return minimum gray.\n     */\n    public static int Minimum(ImageSource fastBitmap)\n    {\n        return Minimum(fastBitmap, 0, 0, fastBitmap.getWidth(), fastBitmap.getHeight());\n    }\n\n    /**\n     * Get minimum gray value in the image.\n     *\n     * @param fastBitmap Image to be processed.\n     * @param startX     Initial X axis coordinate.\n     * @param startY     Initial Y axis coordinate.\n     * @param width      Width.\n     * @param height     Height.\n     * @return Minimum gray.\n     */\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/distance/Distance.java", "func_name": "Distance.Bhattacharyya", "original_string": "public static double Bhattacharyya(double[] histogram1, double[] histogram2) {\n        int bins = histogram1.length; // histogram bins\n        double b = 0; // Bhattacharyya's coefficient\n\n        for (int i = 0; i < bins; i++)\n            b += Math.sqrt(histogram1[i]) * Math.sqrt(histogram2[i]);\n\n        // Bhattacharyya distance between the two distributions\n        return Math.sqrt(1.0 - b);\n    }", "language": "java", "code": "public static double Bhattacharyya(double[] histogram1, double[] histogram2) {\n        int bins = histogram1.length; // histogram bins\n        double b = 0; // Bhattacharyya's coefficient\n\n        for (int i = 0; i < bins; i++)\n            b += Math.sqrt(histogram1[i]) * Math.sqrt(histogram2[i]);\n\n        // Bhattacharyya distance between the two distributions\n        return Math.sqrt(1.0 - b);\n    }", "code_tokens": ["public", "static", "double", "Bhattacharyya", "(", "double", "[", "]", "histogram1", ",", "double", "[", "]", "histogram2", ")", "{", "int", "bins", "=", "histogram1", ".", "length", ";", "// histogram bins", "double", "b", "=", "0", ";", "// Bhattacharyya's coefficient", "for", "(", "int", "i", "=", "0", ";", "i", "<", "bins", ";", "i", "++", ")", "b", "+=", "Math", ".", "sqrt", "(", "histogram1", "[", "i", "]", ")", "*", "Math", ".", "sqrt", "(", "histogram2", "[", "i", "]", ")", ";", "// Bhattacharyya distance between the two distributions", "return", "Math", ".", "sqrt", "(", "1.0", "-", "b", ")", ";", "}"], "docstring": "Bhattacharyya distance between two normalized histograms.\n\n@param histogram1 Normalized histogram.\n@param histogram2 Normalized histogram.\n@return The Bhattacharyya distance between the two histograms.", "docstring_tokens": ["Bhattacharyya", "distance", "between", "two", "normalized", "histograms", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/distance/Distance.java#L68-L77", "partition": "train", "up_fun_num": 3, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.IntPoint;", "import com.harium.keel.catalano.math.Constants;", "import com.harium.keel.catalano.math.Matrix;"], "function": ["public final class Distance\n", "    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n", "    public static double BrayCurtis(double[] p, double[] q)\n", "    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n", "    public static double BrayCurtis(IntPoint p, IntPoint q)\n", "    public static double Canberra(double[] p, double[] q)\n", "    public static double Canberra(double x1, double y1, double x2, double y2)\n", "    public static double Canberra(IntPoint p, IntPoint q)\n", "    public static double Chebyshev(double[] p, double[] q)\n", "    public static double Chebyshev(double x1, double y1, double x2, double y2)\n", "    public static double Chebyshev(IntPoint p, IntPoint q)\n", "    public static double Chessboard(double[] x, double[] y)\n", "    public static double Chessboard(double x1, double y1, double x2, double y2)\n", "    public static double Chessboard(IntPoint p, IntPoint q)\n", "    public static double ChiSquare(double[] histogram1, double[] histogram2)\n", "    public static double Correlation(double[] p, double[] q)\n", "    public static double Cosine(double[] p, double[] q)\n", "    public static double Cosine(double x1, double y1, double x2, double y2)\n", "    public static double Cosine(IntPoint p, IntPoint q)\n", "    public static double Euclidean(double[] p, double[] q)\n", "    public static double Euclidean(double x1, double y1, double x2, double y2)\n", "    public static double Euclidean(IntPoint p, IntPoint q)\n", "    public static int Hamming(String first, String second)\n", "    public static double JaccardDistance(double[] p, double[] q)\n", "    public static double JDivergence(double[] p, double[] q)\n", "    public static double JensenDifferenceDivergence(double[] p, double[] q)\n", "    public static double JensenShannonDivergence(double[] p, double[] q)\n", "    public static double KDivergence(double[] p, double[] q)\n", "    public static double KumarJohnsonDivergence(double[] p, double[] q)\n", "    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n", "    public static double Mahalanobis(double[][] A, double[][] B)\n", "    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n", "    private static double[][] Covariance(double[][] matrix)\n", "    private static double[][] Covariance(double[][] matrix, double[] means)\n", "    public static double Manhattan(double[] p, double[] q)\n", "    public static double Manhattan(double x1, double y1, double x2, double y2)\n", "    public static double Manhattan(IntPoint p, IntPoint q)\n", "    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n", "    public static double Minkowski(IntPoint p, IntPoint q, int r)\n", "    public static double Minkowski(double[] u, double[] v, double p)\n", "    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n", "    public static double SquaredEuclidean(double[] x, double[] y)\n", "    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n", "    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n", "    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n", "    public static double Taneja(double[] p, double[] q)\n", "    public static double TopsoeDivergence(double[] p, double[] q)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2012\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.distance;\n\n\nimport com.harium.keel.catalano.core.IntPoint;\nimport com.harium.keel.catalano.math.Constants;\nimport com.harium.keel.catalano.math.Matrix;\n\n/**\n * Defines a set of extension methods defining distance measures.\n * References: http://www.ajmaa.org/RGMIA/papers/v7n4/Gsdmi_RGMIA.pdf\n * http://arabic-icr.googlecode.com/git/Papers/Comprehensive%20Survey%20on%20Distance-Similarity.pdf\n *\n * @author Diego Catalano\n */\npublic final class Distance\n{\n\n    /**\n     * Don't let anyone initialize this class.\n     */\n    private Distance()\n    {\n    }\n\n    ;\n\n    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double num = p[i] + q[i];\n                r += (num / 2) * Math.log(num / (2 * Math.sqrt(den)));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Bhattacharyya distance between two normalized histograms.\n     *\n     * @param histogram1 Normalized histogram.\n     * @param histogram2 Normalized histogram.\n     * @return The Bhattacharyya distance between the two histograms.\n     */\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double[] p, double[] q)\n    {\n        double sumP, sumN;\n        sumP = sumN = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumN += Math.abs(p[i] - q[i]);\n            sumP += Math.abs(p[i] + q[i]);\n        }\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 X2 axis coordinate.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n    {\n        double sumN = Math.abs(x1 - x2) + Math.abs(y1 - y2);\n        double sumP = Math.abs(x1 + x2) + Math.abs(y1 + y2);\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(IntPoint p, IntPoint q)\n    {\n        return BrayCurtis(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double[] p, double[] q)\n    {\n        double distance = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            distance += Math.abs(p[i] - q[i]) / (Math.abs(p[i]) + Math.abs(q[i]));\n        }\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double x1, double y1, double x2, double y2)\n    {\n        double distance;\n\n        distance = Math.abs(x1 - x2) / (Math.abs(x1) + Math.abs(x2));\n        distance += Math.abs(y1 - y2) / (Math.abs(y1) + Math.abs(y2));\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(IntPoint p, IntPoint q)\n    {\n        return Canberra(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double[] p, double[] q)\n    {\n        double max = Math.abs(p[0] - q[0]);\n\n        for (int i = 1; i < p.length; i++)\n        {\n            double abs = Math.abs(p[i] - q[i]);\n            if (abs > max) max = abs;\n        }\n\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double x1, double y1, double x2, double y2)\n    {\n        double max = Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(IntPoint p, IntPoint q)\n    {\n        return Chebyshev(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double[] x, double[] y)\n    {\n\n        double d = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            d = Math.max(d, x[i] - y[i]);\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.max(dx, dy);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(IntPoint p, IntPoint q)\n    {\n        return Chessboard(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chi Square distance between two normalized histograms.\n     *\n     * @param histogram1 Histogram.\n     * @param histogram2 Histogram.\n     * @return The Chi Square distance between x and y.\n     */\n    public static double ChiSquare(double[] histogram1, double[] histogram2)\n    {\n        double r = 0;\n        for (int i = 0; i < histogram1.length; i++)\n        {\n            double t = histogram1[i] + histogram2[i];\n            if (t != 0)\n                r += Math.pow(histogram1[i] - histogram2[i], 2) / t;\n        }\n\n        return 0.5 * r;\n    }\n\n    /**\n     * Gets the Correlation distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Correlation distance between x and y.\n     */\n    public static double Correlation(double[] p, double[] q)\n    {\n\n        double x = 0;\n        double y = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            x += -p[i];\n            y += -q[i];\n        }\n\n        x /= p.length;\n        y /= q.length;\n\n        double num = 0;\n        double den1 = 0;\n        double den2 = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            num += (p[i] + x) * (q[i] + y);\n\n            den1 += Math.abs(Math.pow(p[i] + x, 2));\n            den2 += Math.abs(Math.pow(q[i] + x, 2));\n        }\n\n        return 1 - (num / (Math.sqrt(den1) * Math.sqrt(den2)));\n\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double[] p, double[] q)\n    {\n        double sumProduct = 0;\n        double sumP = 0, sumQ = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumProduct += p[i] * q[i];\n            sumP += Math.pow(Math.abs(p[i]), 2);\n            sumQ += Math.pow(Math.abs(q[i]), 2);\n        }\n\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double x1, double y1, double x2, double y2)\n    {\n\n        double sumProduct = x1 * x2 + y1 * y2;\n        double sumP = Math.pow(Math.abs(x1), 2) + Math.pow(Math.abs(x2), 2);\n        double sumQ = Math.pow(Math.abs(y1), 2) + Math.pow(Math.abs(y2), 2);\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(IntPoint p, IntPoint q)\n    {\n        return Cosine(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double[] p, double[] q)\n    {\n        return Math.sqrt(SquaredEuclidean(p, q));\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(IntPoint p, IntPoint q)\n    {\n        return Euclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Hamming distance between two strings.\n     *\n     * @param first  First string.\n     * @param second Second string.\n     * @return The Hamming distance between p and q.\n     */\n    public static int Hamming(String first, String second)\n    {\n\n        if (first.length() != second.length())\n            throw new IllegalArgumentException(\"The size of string must be the same.\");\n\n        int diff = 0;\n        for (int i = 0; i < first.length(); i++)\n            if (first.charAt(i) != second.charAt(i))\n                diff++;\n        return diff;\n    }\n\n    /**\n     * Gets the Jaccard distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Jaccard distance between x and y.\n     */\n    public static double JaccardDistance(double[] p, double[] q)\n    {\n        double distance = 0;\n        int intersection = 0, union = 0;\n\n        for (int x = 0; x < p.length; x++)\n        {\n            if ((p[x] != 0) || (q[x] != 0))\n            {\n                if (p[x] == q[x])\n                {\n                    intersection++;\n                }\n\n                union++;\n            }\n        }\n\n        if (union != 0)\n            distance = 1.0 - ((double) intersection / (double) union);\n        else\n            distance = 0;\n\n        return distance;\n    }\n\n    /**\n     * Gets the J-Divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The J-Divergence between p and q.\n     */\n    public static double JDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += (p[i] - q[i]) * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen difference divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Jensen difference between p and q.\n     */\n    public static double JensenDifferenceDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                double pq = p[i] + q[i];\n                k += (p[i] * Math.log(p[i]) + q[i] * Math.log(q[i])) / 2 - (pq / 2) * Math.log(pq / 2);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen Shannon divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The Jensen Shannon divergence between u and v.\n     */\n    public static double JensenShannonDivergence(double[] p, double[] q)\n    {\n        double[] m = new double[p.length];\n        for (int i = 0; i < m.length; i++)\n        {\n            m[i] = (p[i] + q[i]) / 2;\n        }\n\n        return (KullbackLeiblerDivergence(p, m) + KullbackLeiblerDivergence(q, m)) / 2;\n    }\n\n    /**\n     * Gets the K-Divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The K-Divergence between u and v.\n     */\n    public static double KDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] + q[i];\n            if (den != 0 && p[i] != 0)\n                r += p[i] * Math.log(2 * p[i] / den);\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Kumar-Johnson divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kumar-Johnson divergence between p and q.\n     */\n    public static double KumarJohnsonDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                r += Math.pow(p[i] * p[i] - q[i] * q[i], 2) / 2 * Math.pow(p[i] * q[i], 1.5);\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Kullback Leibler divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kullback Leibler divergence between u and v.\n     */\n    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += p[i] * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Mahalanobis distance.\n     *\n     * @param A Matrix A.\n     * @param B Matrix B.\n     * @return The Mahalanobis distance between A and B.\n     */\n    public static double Mahalanobis(double[][] A, double[][] B)\n    {\n\n        if (A[0].length != B[0].length)\n            throw new IllegalArgumentException(\"The number of columns of both matrix must be equals.\");\n\n        double[][] subA = new double[A.length][A[0].length];\n        double[][] subB = new double[B.length][B[0].length];\n\n        //Center data A\n        double[] meansA = new double[A[0].length];\n        for (int j = 0; j < A[0].length; j++)\n        {\n            for (int i = 0; i < A.length; i++)\n            {\n                meansA[j] += A[i][j];\n            }\n            meansA[j] /= (double) A.length;\n            for (int i = 0; i < A.length; i++)\n            {\n                subA[i][j] = A[i][j] - meansA[j];\n            }\n        }\n\n        //Center data B\n        double[] meansB = new double[B[0].length];\n        for (int j = 0; j < B[0].length; j++)\n        {\n            for (int i = 0; i < B.length; i++)\n            {\n                meansB[j] += B[i][j];\n            }\n            meansB[j] /= (double) B.length;\n            for (int i = 0; i < B.length; i++)\n            {\n                subB[i][j] = B[i][j] - meansB[j];\n            }\n        }\n\n        //Matrix of covariance\n        double[][] covA = Covariance(subA);\n        double[][] covB = Covariance(subB);\n\n        //Pooled covariance\n        double rows = subA.length + subB.length;\n        double[][] pCov = new double[covA.length][covA[0].length];\n        for (int i = 0; i < pCov.length; i++)\n        {\n            for (int j = 0; j < pCov[0].length; j++)\n            {\n                pCov[i][j] = covA[i][j] * ((double) subA.length / rows) + covB[i][j] * ((double) subB.length / rows);\n            }\n        }\n\n        //Inverse of pooled covariance\n        pCov = Matrix.Inverse(pCov);\n\n        //compute mean difference\n        double[] diff = new double[A[0].length];\n        for (int i = 0; i < diff.length; i++)\n        {\n            diff[i] = meansA[i] - meansB[i];\n        }\n\n        return Math.sqrt(Matrix.InnerProduct(Matrix.MultiplyByTranspose(pCov, diff), diff));\n\n    }\n\n    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n    {\n        double result = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            result += (x[i] - meanX) * (y[i] - meanY);\n        }\n\n        return result / (double) (x.length);\n    }\n\n    private static double[][] Covariance(double[][] matrix)\n    {\n        double[] means = new double[matrix[0].length];\n        for (int i = 0; i < matrix.length; i++)\n        {\n            for (int j = 0; j < matrix[0].length; j++)\n            {\n                means[j] += matrix[i][j];\n            }\n        }\n\n        for (int i = 0; i < means.length; i++)\n        {\n            means[i] /= means.length;\n        }\n\n        return Covariance(matrix, means);\n    }\n\n    private static double[][] Covariance(double[][] matrix, double[] means)\n    {\n        double[][] cov = new double[means.length][means.length];\n\n        for (int i = 0; i < cov.length; i++)\n        {\n            for (int j = 0; j < cov[0].length; j++)\n            {\n                cov[i][j] = Covariance(Matrix.getColumn(matrix, i), Matrix.getColumn(matrix, j), means[i], means[j]);\n            }\n        }\n\n        return cov;\n\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double[] p, double[] q)\n    {\n        double sum = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            sum += Math.abs(p[i] - q[i]);\n        }\n        return sum;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return dx + dy;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(IntPoint p, IntPoint q)\n    {\n        return Manhattan(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @param r  Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n    {\n        double sum = Math.pow(Math.abs(x1 - x2), r);\n        sum += Math.pow(Math.abs(y1 - y2), r);\n        return Math.pow(sum, 1 / r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @param r Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(IntPoint p, IntPoint q, int r)\n    {\n        return Minkowski(p.x, p.y, q.x, q.y, r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param u A point in space.\n     * @param v A point in space.\n     * @param p Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double[] u, double[] v, double p)\n    {\n        double distance = 0;\n        for (int i = 0; i < u.length; i++)\n        {\n            distance += Math.pow(Math.abs(u[i] - v[i]), p);\n        }\n        return Math.pow(distance, 1 / p);\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Quasi-Euclidean distance between x and y.\n     */\n    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        if (Math.abs(x1 - x2) > Math.abs(y1 - y2))\n        {\n            return Math.abs(x1 - x2) + (Constants.Sqrt2 - 1) * Math.abs(y1 - y2);\n        }\n        return (Constants.Sqrt2 - 1) * Math.abs(x1 - x2) + Math.abs(y1 - y2);\n\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Quasi Euclidean distance between p and q.\n     */\n    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n    {\n        return QuasiEuclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Square Euclidean distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Square Euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double[] x, double[] y)\n    {\n        double d = 0.0, u;\n\n        for (int i = 0; i < x.length; i++)\n        {\n            u = x[i] - y[i];\n            d += u * u;\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n    {\n\n        double dx = q.x - p.x;\n        double dy = q.y - p.y;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Symmetric Chi-square divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric chi-square divergence between p and q.\n     */\n    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double p1 = p[i] - q[i];\n                double p2 = p[i] + q[i];\n                r += (p1 * p1 * p2) / den;\n            }\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Symmetric Kullback-Leibler distance.\n     * This metric is valid only for real and positive P and Q.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric Kullback Leibler distance between p and q.\n     */\n    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n    {\n        double dist = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            dist += (p[i] - q[i]) * (Math.log(p[i]) - Math.log(q[i]));\n        }\n\n        return dist;\n    }\n\n    /**\n     * Gets the Taneja divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Taneja divergence between p and q.\n     */\n    public static double Taneja(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double pq = p[i] + q[i];\n                r += (pq / 2) * Math.log(pq / (2 * Math.sqrt(p[i] * q[i])));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Topsoe divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Topsoe divergence between p and q.\n     */\n    public static double TopsoeDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double den = p[i] + q[i];\n                r += p[i] * Math.log(2 * p[i] / den) + q[i] * Math.log(2 * q[i] / den);\n            }\n        }\n        return r;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/distance/Distance.java", "func_name": "Distance.ChiSquare", "original_string": "public static double ChiSquare(double[] histogram1, double[] histogram2) {\n        double r = 0;\n        for (int i = 0; i < histogram1.length; i++) {\n            double t = histogram1[i] + histogram2[i];\n            if (t != 0)\n                r += Math.pow(histogram1[i] - histogram2[i], 2) / t;\n        }\n\n        return 0.5 * r;\n    }", "language": "java", "code": "public static double ChiSquare(double[] histogram1, double[] histogram2) {\n        double r = 0;\n        for (int i = 0; i < histogram1.length; i++) {\n            double t = histogram1[i] + histogram2[i];\n            if (t != 0)\n                r += Math.pow(histogram1[i] - histogram2[i], 2) / t;\n        }\n\n        return 0.5 * r;\n    }", "code_tokens": ["public", "static", "double", "ChiSquare", "(", "double", "[", "]", "histogram1", ",", "double", "[", "]", "histogram2", ")", "{", "double", "r", "=", "0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "histogram1", ".", "length", ";", "i", "++", ")", "{", "double", "t", "=", "histogram1", "[", "i", "]", "+", "histogram2", "[", "i", "]", ";", "if", "(", "t", "!=", "0", ")", "r", "+=", "Math", ".", "pow", "(", "histogram1", "[", "i", "]", "-", "histogram2", "[", "i", "]", ",", "2", ")", "/", "t", ";", "}", "return", "0.5", "*", "r", ";", "}"], "docstring": "Gets the Chi Square distance between two normalized histograms.\n\n@param histogram1 Histogram.\n@param histogram2 Histogram.\n@return The Chi Square distance between x and y.", "docstring_tokens": ["Gets", "the", "Chi", "Square", "distance", "between", "two", "normalized", "histograms", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/distance/Distance.java#L265-L274", "partition": "train", "up_fun_num": 16, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.IntPoint;", "import com.harium.keel.catalano.math.Constants;", "import com.harium.keel.catalano.math.Matrix;"], "function": ["public final class Distance\n", "    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n", "    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n", "    public static double BrayCurtis(double[] p, double[] q)\n", "    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n", "    public static double BrayCurtis(IntPoint p, IntPoint q)\n", "    public static double Canberra(double[] p, double[] q)\n", "    public static double Canberra(double x1, double y1, double x2, double y2)\n", "    public static double Canberra(IntPoint p, IntPoint q)\n", "    public static double Chebyshev(double[] p, double[] q)\n", "    public static double Chebyshev(double x1, double y1, double x2, double y2)\n", "    public static double Chebyshev(IntPoint p, IntPoint q)\n", "    public static double Chessboard(double[] x, double[] y)\n", "    public static double Chessboard(double x1, double y1, double x2, double y2)\n", "    public static double Chessboard(IntPoint p, IntPoint q)\n", "    public static double Correlation(double[] p, double[] q)\n", "    public static double Cosine(double[] p, double[] q)\n", "    public static double Cosine(double x1, double y1, double x2, double y2)\n", "    public static double Cosine(IntPoint p, IntPoint q)\n", "    public static double Euclidean(double[] p, double[] q)\n", "    public static double Euclidean(double x1, double y1, double x2, double y2)\n", "    public static double Euclidean(IntPoint p, IntPoint q)\n", "    public static int Hamming(String first, String second)\n", "    public static double JaccardDistance(double[] p, double[] q)\n", "    public static double JDivergence(double[] p, double[] q)\n", "    public static double JensenDifferenceDivergence(double[] p, double[] q)\n", "    public static double JensenShannonDivergence(double[] p, double[] q)\n", "    public static double KDivergence(double[] p, double[] q)\n", "    public static double KumarJohnsonDivergence(double[] p, double[] q)\n", "    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n", "    public static double Mahalanobis(double[][] A, double[][] B)\n", "    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n", "    private static double[][] Covariance(double[][] matrix)\n", "    private static double[][] Covariance(double[][] matrix, double[] means)\n", "    public static double Manhattan(double[] p, double[] q)\n", "    public static double Manhattan(double x1, double y1, double x2, double y2)\n", "    public static double Manhattan(IntPoint p, IntPoint q)\n", "    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n", "    public static double Minkowski(IntPoint p, IntPoint q, int r)\n", "    public static double Minkowski(double[] u, double[] v, double p)\n", "    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n", "    public static double SquaredEuclidean(double[] x, double[] y)\n", "    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n", "    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n", "    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n", "    public static double Taneja(double[] p, double[] q)\n", "    public static double TopsoeDivergence(double[] p, double[] q)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2012\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.distance;\n\n\nimport com.harium.keel.catalano.core.IntPoint;\nimport com.harium.keel.catalano.math.Constants;\nimport com.harium.keel.catalano.math.Matrix;\n\n/**\n * Defines a set of extension methods defining distance measures.\n * References: http://www.ajmaa.org/RGMIA/papers/v7n4/Gsdmi_RGMIA.pdf\n * http://arabic-icr.googlecode.com/git/Papers/Comprehensive%20Survey%20on%20Distance-Similarity.pdf\n *\n * @author Diego Catalano\n */\npublic final class Distance\n{\n\n    /**\n     * Don't let anyone initialize this class.\n     */\n    private Distance()\n    {\n    }\n\n    ;\n\n    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double num = p[i] + q[i];\n                r += (num / 2) * Math.log(num / (2 * Math.sqrt(den)));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Bhattacharyya distance between two normalized histograms.\n     *\n     * @param histogram1 Normalized histogram.\n     * @param histogram2 Normalized histogram.\n     * @return The Bhattacharyya distance between the two histograms.\n     */\n    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n    {\n        int bins = histogram1.length; // histogram bins\n        double b = 0; // Bhattacharyya's coefficient\n\n        for (int i = 0; i < bins; i++)\n            b += Math.sqrt(histogram1[i]) * Math.sqrt(histogram2[i]);\n\n        // Bhattacharyya distance between the two distributions\n        return Math.sqrt(1.0 - b);\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double[] p, double[] q)\n    {\n        double sumP, sumN;\n        sumP = sumN = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumN += Math.abs(p[i] - q[i]);\n            sumP += Math.abs(p[i] + q[i]);\n        }\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 X2 axis coordinate.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n    {\n        double sumN = Math.abs(x1 - x2) + Math.abs(y1 - y2);\n        double sumP = Math.abs(x1 + x2) + Math.abs(y1 + y2);\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(IntPoint p, IntPoint q)\n    {\n        return BrayCurtis(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double[] p, double[] q)\n    {\n        double distance = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            distance += Math.abs(p[i] - q[i]) / (Math.abs(p[i]) + Math.abs(q[i]));\n        }\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double x1, double y1, double x2, double y2)\n    {\n        double distance;\n\n        distance = Math.abs(x1 - x2) / (Math.abs(x1) + Math.abs(x2));\n        distance += Math.abs(y1 - y2) / (Math.abs(y1) + Math.abs(y2));\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(IntPoint p, IntPoint q)\n    {\n        return Canberra(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double[] p, double[] q)\n    {\n        double max = Math.abs(p[0] - q[0]);\n\n        for (int i = 1; i < p.length; i++)\n        {\n            double abs = Math.abs(p[i] - q[i]);\n            if (abs > max) max = abs;\n        }\n\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double x1, double y1, double x2, double y2)\n    {\n        double max = Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(IntPoint p, IntPoint q)\n    {\n        return Chebyshev(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double[] x, double[] y)\n    {\n\n        double d = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            d = Math.max(d, x[i] - y[i]);\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.max(dx, dy);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(IntPoint p, IntPoint q)\n    {\n        return Chessboard(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chi Square distance between two normalized histograms.\n     *\n     * @param histogram1 Histogram.\n     * @param histogram2 Histogram.\n     * @return The Chi Square distance between x and y.\n     */\n\n    /**\n     * Gets the Correlation distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Correlation distance between x and y.\n     */\n    public static double Correlation(double[] p, double[] q)\n    {\n\n        double x = 0;\n        double y = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            x += -p[i];\n            y += -q[i];\n        }\n\n        x /= p.length;\n        y /= q.length;\n\n        double num = 0;\n        double den1 = 0;\n        double den2 = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            num += (p[i] + x) * (q[i] + y);\n\n            den1 += Math.abs(Math.pow(p[i] + x, 2));\n            den2 += Math.abs(Math.pow(q[i] + x, 2));\n        }\n\n        return 1 - (num / (Math.sqrt(den1) * Math.sqrt(den2)));\n\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double[] p, double[] q)\n    {\n        double sumProduct = 0;\n        double sumP = 0, sumQ = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumProduct += p[i] * q[i];\n            sumP += Math.pow(Math.abs(p[i]), 2);\n            sumQ += Math.pow(Math.abs(q[i]), 2);\n        }\n\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double x1, double y1, double x2, double y2)\n    {\n\n        double sumProduct = x1 * x2 + y1 * y2;\n        double sumP = Math.pow(Math.abs(x1), 2) + Math.pow(Math.abs(x2), 2);\n        double sumQ = Math.pow(Math.abs(y1), 2) + Math.pow(Math.abs(y2), 2);\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(IntPoint p, IntPoint q)\n    {\n        return Cosine(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double[] p, double[] q)\n    {\n        return Math.sqrt(SquaredEuclidean(p, q));\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(IntPoint p, IntPoint q)\n    {\n        return Euclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Hamming distance between two strings.\n     *\n     * @param first  First string.\n     * @param second Second string.\n     * @return The Hamming distance between p and q.\n     */\n    public static int Hamming(String first, String second)\n    {\n\n        if (first.length() != second.length())\n            throw new IllegalArgumentException(\"The size of string must be the same.\");\n\n        int diff = 0;\n        for (int i = 0; i < first.length(); i++)\n            if (first.charAt(i) != second.charAt(i))\n                diff++;\n        return diff;\n    }\n\n    /**\n     * Gets the Jaccard distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Jaccard distance between x and y.\n     */\n    public static double JaccardDistance(double[] p, double[] q)\n    {\n        double distance = 0;\n        int intersection = 0, union = 0;\n\n        for (int x = 0; x < p.length; x++)\n        {\n            if ((p[x] != 0) || (q[x] != 0))\n            {\n                if (p[x] == q[x])\n                {\n                    intersection++;\n                }\n\n                union++;\n            }\n        }\n\n        if (union != 0)\n            distance = 1.0 - ((double) intersection / (double) union);\n        else\n            distance = 0;\n\n        return distance;\n    }\n\n    /**\n     * Gets the J-Divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The J-Divergence between p and q.\n     */\n    public static double JDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += (p[i] - q[i]) * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen difference divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Jensen difference between p and q.\n     */\n    public static double JensenDifferenceDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                double pq = p[i] + q[i];\n                k += (p[i] * Math.log(p[i]) + q[i] * Math.log(q[i])) / 2 - (pq / 2) * Math.log(pq / 2);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen Shannon divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The Jensen Shannon divergence between u and v.\n     */\n    public static double JensenShannonDivergence(double[] p, double[] q)\n    {\n        double[] m = new double[p.length];\n        for (int i = 0; i < m.length; i++)\n        {\n            m[i] = (p[i] + q[i]) / 2;\n        }\n\n        return (KullbackLeiblerDivergence(p, m) + KullbackLeiblerDivergence(q, m)) / 2;\n    }\n\n    /**\n     * Gets the K-Divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The K-Divergence between u and v.\n     */\n    public static double KDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] + q[i];\n            if (den != 0 && p[i] != 0)\n                r += p[i] * Math.log(2 * p[i] / den);\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Kumar-Johnson divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kumar-Johnson divergence between p and q.\n     */\n    public static double KumarJohnsonDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                r += Math.pow(p[i] * p[i] - q[i] * q[i], 2) / 2 * Math.pow(p[i] * q[i], 1.5);\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Kullback Leibler divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kullback Leibler divergence between u and v.\n     */\n    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += p[i] * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Mahalanobis distance.\n     *\n     * @param A Matrix A.\n     * @param B Matrix B.\n     * @return The Mahalanobis distance between A and B.\n     */\n    public static double Mahalanobis(double[][] A, double[][] B)\n    {\n\n        if (A[0].length != B[0].length)\n            throw new IllegalArgumentException(\"The number of columns of both matrix must be equals.\");\n\n        double[][] subA = new double[A.length][A[0].length];\n        double[][] subB = new double[B.length][B[0].length];\n\n        //Center data A\n        double[] meansA = new double[A[0].length];\n        for (int j = 0; j < A[0].length; j++)\n        {\n            for (int i = 0; i < A.length; i++)\n            {\n                meansA[j] += A[i][j];\n            }\n            meansA[j] /= (double) A.length;\n            for (int i = 0; i < A.length; i++)\n            {\n                subA[i][j] = A[i][j] - meansA[j];\n            }\n        }\n\n        //Center data B\n        double[] meansB = new double[B[0].length];\n        for (int j = 0; j < B[0].length; j++)\n        {\n            for (int i = 0; i < B.length; i++)\n            {\n                meansB[j] += B[i][j];\n            }\n            meansB[j] /= (double) B.length;\n            for (int i = 0; i < B.length; i++)\n            {\n                subB[i][j] = B[i][j] - meansB[j];\n            }\n        }\n\n        //Matrix of covariance\n        double[][] covA = Covariance(subA);\n        double[][] covB = Covariance(subB);\n\n        //Pooled covariance\n        double rows = subA.length + subB.length;\n        double[][] pCov = new double[covA.length][covA[0].length];\n        for (int i = 0; i < pCov.length; i++)\n        {\n            for (int j = 0; j < pCov[0].length; j++)\n            {\n                pCov[i][j] = covA[i][j] * ((double) subA.length / rows) + covB[i][j] * ((double) subB.length / rows);\n            }\n        }\n\n        //Inverse of pooled covariance\n        pCov = Matrix.Inverse(pCov);\n\n        //compute mean difference\n        double[] diff = new double[A[0].length];\n        for (int i = 0; i < diff.length; i++)\n        {\n            diff[i] = meansA[i] - meansB[i];\n        }\n\n        return Math.sqrt(Matrix.InnerProduct(Matrix.MultiplyByTranspose(pCov, diff), diff));\n\n    }\n\n    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n    {\n        double result = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            result += (x[i] - meanX) * (y[i] - meanY);\n        }\n\n        return result / (double) (x.length);\n    }\n\n    private static double[][] Covariance(double[][] matrix)\n    {\n        double[] means = new double[matrix[0].length];\n        for (int i = 0; i < matrix.length; i++)\n        {\n            for (int j = 0; j < matrix[0].length; j++)\n            {\n                means[j] += matrix[i][j];\n            }\n        }\n\n        for (int i = 0; i < means.length; i++)\n        {\n            means[i] /= means.length;\n        }\n\n        return Covariance(matrix, means);\n    }\n\n    private static double[][] Covariance(double[][] matrix, double[] means)\n    {\n        double[][] cov = new double[means.length][means.length];\n\n        for (int i = 0; i < cov.length; i++)\n        {\n            for (int j = 0; j < cov[0].length; j++)\n            {\n                cov[i][j] = Covariance(Matrix.getColumn(matrix, i), Matrix.getColumn(matrix, j), means[i], means[j]);\n            }\n        }\n\n        return cov;\n\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double[] p, double[] q)\n    {\n        double sum = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            sum += Math.abs(p[i] - q[i]);\n        }\n        return sum;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return dx + dy;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(IntPoint p, IntPoint q)\n    {\n        return Manhattan(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @param r  Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n    {\n        double sum = Math.pow(Math.abs(x1 - x2), r);\n        sum += Math.pow(Math.abs(y1 - y2), r);\n        return Math.pow(sum, 1 / r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @param r Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(IntPoint p, IntPoint q, int r)\n    {\n        return Minkowski(p.x, p.y, q.x, q.y, r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param u A point in space.\n     * @param v A point in space.\n     * @param p Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double[] u, double[] v, double p)\n    {\n        double distance = 0;\n        for (int i = 0; i < u.length; i++)\n        {\n            distance += Math.pow(Math.abs(u[i] - v[i]), p);\n        }\n        return Math.pow(distance, 1 / p);\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Quasi-Euclidean distance between x and y.\n     */\n    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        if (Math.abs(x1 - x2) > Math.abs(y1 - y2))\n        {\n            return Math.abs(x1 - x2) + (Constants.Sqrt2 - 1) * Math.abs(y1 - y2);\n        }\n        return (Constants.Sqrt2 - 1) * Math.abs(x1 - x2) + Math.abs(y1 - y2);\n\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Quasi Euclidean distance between p and q.\n     */\n    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n    {\n        return QuasiEuclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Square Euclidean distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Square Euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double[] x, double[] y)\n    {\n        double d = 0.0, u;\n\n        for (int i = 0; i < x.length; i++)\n        {\n            u = x[i] - y[i];\n            d += u * u;\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n    {\n\n        double dx = q.x - p.x;\n        double dy = q.y - p.y;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Symmetric Chi-square divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric chi-square divergence between p and q.\n     */\n    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double p1 = p[i] - q[i];\n                double p2 = p[i] + q[i];\n                r += (p1 * p1 * p2) / den;\n            }\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Symmetric Kullback-Leibler distance.\n     * This metric is valid only for real and positive P and Q.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric Kullback Leibler distance between p and q.\n     */\n    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n    {\n        double dist = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            dist += (p[i] - q[i]) * (Math.log(p[i]) - Math.log(q[i]));\n        }\n\n        return dist;\n    }\n\n    /**\n     * Gets the Taneja divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Taneja divergence between p and q.\n     */\n    public static double Taneja(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double pq = p[i] + q[i];\n                r += (pq / 2) * Math.log(pq / (2 * Math.sqrt(p[i] * q[i])));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Topsoe divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Topsoe divergence between p and q.\n     */\n    public static double TopsoeDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double den = p[i] + q[i];\n                r += p[i] * Math.log(2 * p[i] / den) + q[i] * Math.log(2 * q[i] / den);\n            }\n        }\n        return r;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/distance/Distance.java", "func_name": "Distance.Correlation", "original_string": "public static double Correlation(double[] p, double[] q) {\n\n        double x = 0;\n        double y = 0;\n\n        for (int i = 0; i < p.length; i++) {\n            x += -p[i];\n            y += -q[i];\n        }\n\n        x /= p.length;\n        y /= q.length;\n\n        double num = 0;\n        double den1 = 0;\n        double den2 = 0;\n        for (int i = 0; i < p.length; i++) {\n            num += (p[i] + x) * (q[i] + y);\n\n            den1 += Math.abs(Math.pow(p[i] + x, 2));\n            den2 += Math.abs(Math.pow(q[i] + x, 2));\n        }\n\n        return 1 - (num / (Math.sqrt(den1) * Math.sqrt(den2)));\n\n    }", "language": "java", "code": "public static double Correlation(double[] p, double[] q) {\n\n        double x = 0;\n        double y = 0;\n\n        for (int i = 0; i < p.length; i++) {\n            x += -p[i];\n            y += -q[i];\n        }\n\n        x /= p.length;\n        y /= q.length;\n\n        double num = 0;\n        double den1 = 0;\n        double den2 = 0;\n        for (int i = 0; i < p.length; i++) {\n            num += (p[i] + x) * (q[i] + y);\n\n            den1 += Math.abs(Math.pow(p[i] + x, 2));\n            den2 += Math.abs(Math.pow(q[i] + x, 2));\n        }\n\n        return 1 - (num / (Math.sqrt(den1) * Math.sqrt(den2)));\n\n    }", "code_tokens": ["public", "static", "double", "Correlation", "(", "double", "[", "]", "p", ",", "double", "[", "]", "q", ")", "{", "double", "x", "=", "0", ";", "double", "y", "=", "0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "p", ".", "length", ";", "i", "++", ")", "{", "x", "+=", "-", "p", "[", "i", "]", ";", "y", "+=", "-", "q", "[", "i", "]", ";", "}", "x", "/=", "p", ".", "length", ";", "y", "/=", "q", ".", "length", ";", "double", "num", "=", "0", ";", "double", "den1", "=", "0", ";", "double", "den2", "=", "0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "p", ".", "length", ";", "i", "++", ")", "{", "num", "+=", "(", "p", "[", "i", "]", "+", "x", ")", "*", "(", "q", "[", "i", "]", "+", "y", ")", ";", "den1", "+=", "Math", ".", "abs", "(", "Math", ".", "pow", "(", "p", "[", "i", "]", "+", "x", ",", "2", ")", ")", ";", "den2", "+=", "Math", ".", "abs", "(", "Math", ".", "pow", "(", "q", "[", "i", "]", "+", "x", ",", "2", ")", ")", ";", "}", "return", "1", "-", "(", "num", "/", "(", "Math", ".", "sqrt", "(", "den1", ")", "*", "Math", ".", "sqrt", "(", "den2", ")", ")", ")", ";", "}"], "docstring": "Gets the Correlation distance between two points.\n\n@param p A point in space.\n@param q A point in space.\n@return The Correlation distance between x and y.", "docstring_tokens": ["Gets", "the", "Correlation", "distance", "between", "two", "points", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/distance/Distance.java#L283-L308", "partition": "train", "up_fun_num": 17, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.IntPoint;", "import com.harium.keel.catalano.math.Constants;", "import com.harium.keel.catalano.math.Matrix;"], "function": ["public final class Distance\n", "    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n", "    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n", "    public static double BrayCurtis(double[] p, double[] q)\n", "    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n", "    public static double BrayCurtis(IntPoint p, IntPoint q)\n", "    public static double Canberra(double[] p, double[] q)\n", "    public static double Canberra(double x1, double y1, double x2, double y2)\n", "    public static double Canberra(IntPoint p, IntPoint q)\n", "    public static double Chebyshev(double[] p, double[] q)\n", "    public static double Chebyshev(double x1, double y1, double x2, double y2)\n", "    public static double Chebyshev(IntPoint p, IntPoint q)\n", "    public static double Chessboard(double[] x, double[] y)\n", "    public static double Chessboard(double x1, double y1, double x2, double y2)\n", "    public static double Chessboard(IntPoint p, IntPoint q)\n", "    public static double ChiSquare(double[] histogram1, double[] histogram2)\n", "    public static double Cosine(double[] p, double[] q)\n", "    public static double Cosine(double x1, double y1, double x2, double y2)\n", "    public static double Cosine(IntPoint p, IntPoint q)\n", "    public static double Euclidean(double[] p, double[] q)\n", "    public static double Euclidean(double x1, double y1, double x2, double y2)\n", "    public static double Euclidean(IntPoint p, IntPoint q)\n", "    public static int Hamming(String first, String second)\n", "    public static double JaccardDistance(double[] p, double[] q)\n", "    public static double JDivergence(double[] p, double[] q)\n", "    public static double JensenDifferenceDivergence(double[] p, double[] q)\n", "    public static double JensenShannonDivergence(double[] p, double[] q)\n", "    public static double KDivergence(double[] p, double[] q)\n", "    public static double KumarJohnsonDivergence(double[] p, double[] q)\n", "    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n", "    public static double Mahalanobis(double[][] A, double[][] B)\n", "    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n", "    private static double[][] Covariance(double[][] matrix)\n", "    private static double[][] Covariance(double[][] matrix, double[] means)\n", "    public static double Manhattan(double[] p, double[] q)\n", "    public static double Manhattan(double x1, double y1, double x2, double y2)\n", "    public static double Manhattan(IntPoint p, IntPoint q)\n", "    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n", "    public static double Minkowski(IntPoint p, IntPoint q, int r)\n", "    public static double Minkowski(double[] u, double[] v, double p)\n", "    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n", "    public static double SquaredEuclidean(double[] x, double[] y)\n", "    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n", "    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n", "    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n", "    public static double Taneja(double[] p, double[] q)\n", "    public static double TopsoeDivergence(double[] p, double[] q)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2012\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.distance;\n\n\nimport com.harium.keel.catalano.core.IntPoint;\nimport com.harium.keel.catalano.math.Constants;\nimport com.harium.keel.catalano.math.Matrix;\n\n/**\n * Defines a set of extension methods defining distance measures.\n * References: http://www.ajmaa.org/RGMIA/papers/v7n4/Gsdmi_RGMIA.pdf\n * http://arabic-icr.googlecode.com/git/Papers/Comprehensive%20Survey%20on%20Distance-Similarity.pdf\n *\n * @author Diego Catalano\n */\npublic final class Distance\n{\n\n    /**\n     * Don't let anyone initialize this class.\n     */\n    private Distance()\n    {\n    }\n\n    ;\n\n    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double num = p[i] + q[i];\n                r += (num / 2) * Math.log(num / (2 * Math.sqrt(den)));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Bhattacharyya distance between two normalized histograms.\n     *\n     * @param histogram1 Normalized histogram.\n     * @param histogram2 Normalized histogram.\n     * @return The Bhattacharyya distance between the two histograms.\n     */\n    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n    {\n        int bins = histogram1.length; // histogram bins\n        double b = 0; // Bhattacharyya's coefficient\n\n        for (int i = 0; i < bins; i++)\n            b += Math.sqrt(histogram1[i]) * Math.sqrt(histogram2[i]);\n\n        // Bhattacharyya distance between the two distributions\n        return Math.sqrt(1.0 - b);\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double[] p, double[] q)\n    {\n        double sumP, sumN;\n        sumP = sumN = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumN += Math.abs(p[i] - q[i]);\n            sumP += Math.abs(p[i] + q[i]);\n        }\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 X2 axis coordinate.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n    {\n        double sumN = Math.abs(x1 - x2) + Math.abs(y1 - y2);\n        double sumP = Math.abs(x1 + x2) + Math.abs(y1 + y2);\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(IntPoint p, IntPoint q)\n    {\n        return BrayCurtis(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double[] p, double[] q)\n    {\n        double distance = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            distance += Math.abs(p[i] - q[i]) / (Math.abs(p[i]) + Math.abs(q[i]));\n        }\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double x1, double y1, double x2, double y2)\n    {\n        double distance;\n\n        distance = Math.abs(x1 - x2) / (Math.abs(x1) + Math.abs(x2));\n        distance += Math.abs(y1 - y2) / (Math.abs(y1) + Math.abs(y2));\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(IntPoint p, IntPoint q)\n    {\n        return Canberra(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double[] p, double[] q)\n    {\n        double max = Math.abs(p[0] - q[0]);\n\n        for (int i = 1; i < p.length; i++)\n        {\n            double abs = Math.abs(p[i] - q[i]);\n            if (abs > max) max = abs;\n        }\n\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double x1, double y1, double x2, double y2)\n    {\n        double max = Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(IntPoint p, IntPoint q)\n    {\n        return Chebyshev(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double[] x, double[] y)\n    {\n\n        double d = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            d = Math.max(d, x[i] - y[i]);\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.max(dx, dy);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(IntPoint p, IntPoint q)\n    {\n        return Chessboard(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chi Square distance between two normalized histograms.\n     *\n     * @param histogram1 Histogram.\n     * @param histogram2 Histogram.\n     * @return The Chi Square distance between x and y.\n     */\n    public static double ChiSquare(double[] histogram1, double[] histogram2)\n    {\n        double r = 0;\n        for (int i = 0; i < histogram1.length; i++)\n        {\n            double t = histogram1[i] + histogram2[i];\n            if (t != 0)\n                r += Math.pow(histogram1[i] - histogram2[i], 2) / t;\n        }\n\n        return 0.5 * r;\n    }\n\n    /**\n     * Gets the Correlation distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Correlation distance between x and y.\n     */\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double[] p, double[] q)\n    {\n        double sumProduct = 0;\n        double sumP = 0, sumQ = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumProduct += p[i] * q[i];\n            sumP += Math.pow(Math.abs(p[i]), 2);\n            sumQ += Math.pow(Math.abs(q[i]), 2);\n        }\n\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double x1, double y1, double x2, double y2)\n    {\n\n        double sumProduct = x1 * x2 + y1 * y2;\n        double sumP = Math.pow(Math.abs(x1), 2) + Math.pow(Math.abs(x2), 2);\n        double sumQ = Math.pow(Math.abs(y1), 2) + Math.pow(Math.abs(y2), 2);\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(IntPoint p, IntPoint q)\n    {\n        return Cosine(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double[] p, double[] q)\n    {\n        return Math.sqrt(SquaredEuclidean(p, q));\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(IntPoint p, IntPoint q)\n    {\n        return Euclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Hamming distance between two strings.\n     *\n     * @param first  First string.\n     * @param second Second string.\n     * @return The Hamming distance between p and q.\n     */\n    public static int Hamming(String first, String second)\n    {\n\n        if (first.length() != second.length())\n            throw new IllegalArgumentException(\"The size of string must be the same.\");\n\n        int diff = 0;\n        for (int i = 0; i < first.length(); i++)\n            if (first.charAt(i) != second.charAt(i))\n                diff++;\n        return diff;\n    }\n\n    /**\n     * Gets the Jaccard distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Jaccard distance between x and y.\n     */\n    public static double JaccardDistance(double[] p, double[] q)\n    {\n        double distance = 0;\n        int intersection = 0, union = 0;\n\n        for (int x = 0; x < p.length; x++)\n        {\n            if ((p[x] != 0) || (q[x] != 0))\n            {\n                if (p[x] == q[x])\n                {\n                    intersection++;\n                }\n\n                union++;\n            }\n        }\n\n        if (union != 0)\n            distance = 1.0 - ((double) intersection / (double) union);\n        else\n            distance = 0;\n\n        return distance;\n    }\n\n    /**\n     * Gets the J-Divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The J-Divergence between p and q.\n     */\n    public static double JDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += (p[i] - q[i]) * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen difference divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Jensen difference between p and q.\n     */\n    public static double JensenDifferenceDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                double pq = p[i] + q[i];\n                k += (p[i] * Math.log(p[i]) + q[i] * Math.log(q[i])) / 2 - (pq / 2) * Math.log(pq / 2);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen Shannon divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The Jensen Shannon divergence between u and v.\n     */\n    public static double JensenShannonDivergence(double[] p, double[] q)\n    {\n        double[] m = new double[p.length];\n        for (int i = 0; i < m.length; i++)\n        {\n            m[i] = (p[i] + q[i]) / 2;\n        }\n\n        return (KullbackLeiblerDivergence(p, m) + KullbackLeiblerDivergence(q, m)) / 2;\n    }\n\n    /**\n     * Gets the K-Divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The K-Divergence between u and v.\n     */\n    public static double KDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] + q[i];\n            if (den != 0 && p[i] != 0)\n                r += p[i] * Math.log(2 * p[i] / den);\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Kumar-Johnson divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kumar-Johnson divergence between p and q.\n     */\n    public static double KumarJohnsonDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                r += Math.pow(p[i] * p[i] - q[i] * q[i], 2) / 2 * Math.pow(p[i] * q[i], 1.5);\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Kullback Leibler divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kullback Leibler divergence between u and v.\n     */\n    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += p[i] * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Mahalanobis distance.\n     *\n     * @param A Matrix A.\n     * @param B Matrix B.\n     * @return The Mahalanobis distance between A and B.\n     */\n    public static double Mahalanobis(double[][] A, double[][] B)\n    {\n\n        if (A[0].length != B[0].length)\n            throw new IllegalArgumentException(\"The number of columns of both matrix must be equals.\");\n\n        double[][] subA = new double[A.length][A[0].length];\n        double[][] subB = new double[B.length][B[0].length];\n\n        //Center data A\n        double[] meansA = new double[A[0].length];\n        for (int j = 0; j < A[0].length; j++)\n        {\n            for (int i = 0; i < A.length; i++)\n            {\n                meansA[j] += A[i][j];\n            }\n            meansA[j] /= (double) A.length;\n            for (int i = 0; i < A.length; i++)\n            {\n                subA[i][j] = A[i][j] - meansA[j];\n            }\n        }\n\n        //Center data B\n        double[] meansB = new double[B[0].length];\n        for (int j = 0; j < B[0].length; j++)\n        {\n            for (int i = 0; i < B.length; i++)\n            {\n                meansB[j] += B[i][j];\n            }\n            meansB[j] /= (double) B.length;\n            for (int i = 0; i < B.length; i++)\n            {\n                subB[i][j] = B[i][j] - meansB[j];\n            }\n        }\n\n        //Matrix of covariance\n        double[][] covA = Covariance(subA);\n        double[][] covB = Covariance(subB);\n\n        //Pooled covariance\n        double rows = subA.length + subB.length;\n        double[][] pCov = new double[covA.length][covA[0].length];\n        for (int i = 0; i < pCov.length; i++)\n        {\n            for (int j = 0; j < pCov[0].length; j++)\n            {\n                pCov[i][j] = covA[i][j] * ((double) subA.length / rows) + covB[i][j] * ((double) subB.length / rows);\n            }\n        }\n\n        //Inverse of pooled covariance\n        pCov = Matrix.Inverse(pCov);\n\n        //compute mean difference\n        double[] diff = new double[A[0].length];\n        for (int i = 0; i < diff.length; i++)\n        {\n            diff[i] = meansA[i] - meansB[i];\n        }\n\n        return Math.sqrt(Matrix.InnerProduct(Matrix.MultiplyByTranspose(pCov, diff), diff));\n\n    }\n\n    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n    {\n        double result = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            result += (x[i] - meanX) * (y[i] - meanY);\n        }\n\n        return result / (double) (x.length);\n    }\n\n    private static double[][] Covariance(double[][] matrix)\n    {\n        double[] means = new double[matrix[0].length];\n        for (int i = 0; i < matrix.length; i++)\n        {\n            for (int j = 0; j < matrix[0].length; j++)\n            {\n                means[j] += matrix[i][j];\n            }\n        }\n\n        for (int i = 0; i < means.length; i++)\n        {\n            means[i] /= means.length;\n        }\n\n        return Covariance(matrix, means);\n    }\n\n    private static double[][] Covariance(double[][] matrix, double[] means)\n    {\n        double[][] cov = new double[means.length][means.length];\n\n        for (int i = 0; i < cov.length; i++)\n        {\n            for (int j = 0; j < cov[0].length; j++)\n            {\n                cov[i][j] = Covariance(Matrix.getColumn(matrix, i), Matrix.getColumn(matrix, j), means[i], means[j]);\n            }\n        }\n\n        return cov;\n\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double[] p, double[] q)\n    {\n        double sum = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            sum += Math.abs(p[i] - q[i]);\n        }\n        return sum;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return dx + dy;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(IntPoint p, IntPoint q)\n    {\n        return Manhattan(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @param r  Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n    {\n        double sum = Math.pow(Math.abs(x1 - x2), r);\n        sum += Math.pow(Math.abs(y1 - y2), r);\n        return Math.pow(sum, 1 / r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @param r Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(IntPoint p, IntPoint q, int r)\n    {\n        return Minkowski(p.x, p.y, q.x, q.y, r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param u A point in space.\n     * @param v A point in space.\n     * @param p Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double[] u, double[] v, double p)\n    {\n        double distance = 0;\n        for (int i = 0; i < u.length; i++)\n        {\n            distance += Math.pow(Math.abs(u[i] - v[i]), p);\n        }\n        return Math.pow(distance, 1 / p);\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Quasi-Euclidean distance between x and y.\n     */\n    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        if (Math.abs(x1 - x2) > Math.abs(y1 - y2))\n        {\n            return Math.abs(x1 - x2) + (Constants.Sqrt2 - 1) * Math.abs(y1 - y2);\n        }\n        return (Constants.Sqrt2 - 1) * Math.abs(x1 - x2) + Math.abs(y1 - y2);\n\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Quasi Euclidean distance between p and q.\n     */\n    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n    {\n        return QuasiEuclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Square Euclidean distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Square Euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double[] x, double[] y)\n    {\n        double d = 0.0, u;\n\n        for (int i = 0; i < x.length; i++)\n        {\n            u = x[i] - y[i];\n            d += u * u;\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n    {\n\n        double dx = q.x - p.x;\n        double dy = q.y - p.y;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Symmetric Chi-square divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric chi-square divergence between p and q.\n     */\n    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double p1 = p[i] - q[i];\n                double p2 = p[i] + q[i];\n                r += (p1 * p1 * p2) / den;\n            }\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Symmetric Kullback-Leibler distance.\n     * This metric is valid only for real and positive P and Q.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric Kullback Leibler distance between p and q.\n     */\n    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n    {\n        double dist = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            dist += (p[i] - q[i]) * (Math.log(p[i]) - Math.log(q[i]));\n        }\n\n        return dist;\n    }\n\n    /**\n     * Gets the Taneja divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Taneja divergence between p and q.\n     */\n    public static double Taneja(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double pq = p[i] + q[i];\n                r += (pq / 2) * Math.log(pq / (2 * Math.sqrt(p[i] * q[i])));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Topsoe divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Topsoe divergence between p and q.\n     */\n    public static double TopsoeDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double den = p[i] + q[i];\n                r += p[i] * Math.log(2 * p[i] / den) + q[i] * Math.log(2 * q[i] / den);\n            }\n        }\n        return r;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/distance/Distance.java", "func_name": "Distance.Hamming", "original_string": "public static int Hamming(String first, String second) {\n\n        if (first.length() != second.length())\n            throw new IllegalArgumentException(\"The size of string must be the same.\");\n\n        int diff = 0;\n        for (int i = 0; i < first.length(); i++)\n            if (first.charAt(i) != second.charAt(i))\n                diff++;\n        return diff;\n    }", "language": "java", "code": "public static int Hamming(String first, String second) {\n\n        if (first.length() != second.length())\n            throw new IllegalArgumentException(\"The size of string must be the same.\");\n\n        int diff = 0;\n        for (int i = 0; i < first.length(); i++)\n            if (first.charAt(i) != second.charAt(i))\n                diff++;\n        return diff;\n    }", "code_tokens": ["public", "static", "int", "Hamming", "(", "String", "first", ",", "String", "second", ")", "{", "if", "(", "first", ".", "length", "(", ")", "!=", "second", ".", "length", "(", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"The size of string must be the same.\"", ")", ";", "int", "diff", "=", "0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "first", ".", "length", "(", ")", ";", "i", "++", ")", "if", "(", "first", ".", "charAt", "(", "i", ")", "!=", "second", ".", "charAt", "(", "i", ")", ")", "diff", "++", ";", "return", "diff", ";", "}"], "docstring": "Gets the Hamming distance between two strings.\n\n@param first  First string.\n@param second Second string.\n@return The Hamming distance between p and q.", "docstring_tokens": ["Gets", "the", "Hamming", "distance", "between", "two", "strings", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/distance/Distance.java#L412-L422", "partition": "train", "up_fun_num": 24, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.IntPoint;", "import com.harium.keel.catalano.math.Constants;", "import com.harium.keel.catalano.math.Matrix;"], "function": ["public final class Distance\n", "    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n", "    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n", "    public static double BrayCurtis(double[] p, double[] q)\n", "    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n", "    public static double BrayCurtis(IntPoint p, IntPoint q)\n", "    public static double Canberra(double[] p, double[] q)\n", "    public static double Canberra(double x1, double y1, double x2, double y2)\n", "    public static double Canberra(IntPoint p, IntPoint q)\n", "    public static double Chebyshev(double[] p, double[] q)\n", "    public static double Chebyshev(double x1, double y1, double x2, double y2)\n", "    public static double Chebyshev(IntPoint p, IntPoint q)\n", "    public static double Chessboard(double[] x, double[] y)\n", "    public static double Chessboard(double x1, double y1, double x2, double y2)\n", "    public static double Chessboard(IntPoint p, IntPoint q)\n", "    public static double ChiSquare(double[] histogram1, double[] histogram2)\n", "    public static double Correlation(double[] p, double[] q)\n", "    public static double Cosine(double[] p, double[] q)\n", "    public static double Cosine(double x1, double y1, double x2, double y2)\n", "    public static double Cosine(IntPoint p, IntPoint q)\n", "    public static double Euclidean(double[] p, double[] q)\n", "    public static double Euclidean(double x1, double y1, double x2, double y2)\n", "    public static double Euclidean(IntPoint p, IntPoint q)\n", "    public static double JaccardDistance(double[] p, double[] q)\n", "    public static double JDivergence(double[] p, double[] q)\n", "    public static double JensenDifferenceDivergence(double[] p, double[] q)\n", "    public static double JensenShannonDivergence(double[] p, double[] q)\n", "    public static double KDivergence(double[] p, double[] q)\n", "    public static double KumarJohnsonDivergence(double[] p, double[] q)\n", "    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n", "    public static double Mahalanobis(double[][] A, double[][] B)\n", "    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n", "    private static double[][] Covariance(double[][] matrix)\n", "    private static double[][] Covariance(double[][] matrix, double[] means)\n", "    public static double Manhattan(double[] p, double[] q)\n", "    public static double Manhattan(double x1, double y1, double x2, double y2)\n", "    public static double Manhattan(IntPoint p, IntPoint q)\n", "    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n", "    public static double Minkowski(IntPoint p, IntPoint q, int r)\n", "    public static double Minkowski(double[] u, double[] v, double p)\n", "    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n", "    public static double SquaredEuclidean(double[] x, double[] y)\n", "    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n", "    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n", "    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n", "    public static double Taneja(double[] p, double[] q)\n", "    public static double TopsoeDivergence(double[] p, double[] q)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2012\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.distance;\n\n\nimport com.harium.keel.catalano.core.IntPoint;\nimport com.harium.keel.catalano.math.Constants;\nimport com.harium.keel.catalano.math.Matrix;\n\n/**\n * Defines a set of extension methods defining distance measures.\n * References: http://www.ajmaa.org/RGMIA/papers/v7n4/Gsdmi_RGMIA.pdf\n * http://arabic-icr.googlecode.com/git/Papers/Comprehensive%20Survey%20on%20Distance-Similarity.pdf\n *\n * @author Diego Catalano\n */\npublic final class Distance\n{\n\n    /**\n     * Don't let anyone initialize this class.\n     */\n    private Distance()\n    {\n    }\n\n    ;\n\n    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double num = p[i] + q[i];\n                r += (num / 2) * Math.log(num / (2 * Math.sqrt(den)));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Bhattacharyya distance between two normalized histograms.\n     *\n     * @param histogram1 Normalized histogram.\n     * @param histogram2 Normalized histogram.\n     * @return The Bhattacharyya distance between the two histograms.\n     */\n    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n    {\n        int bins = histogram1.length; // histogram bins\n        double b = 0; // Bhattacharyya's coefficient\n\n        for (int i = 0; i < bins; i++)\n            b += Math.sqrt(histogram1[i]) * Math.sqrt(histogram2[i]);\n\n        // Bhattacharyya distance between the two distributions\n        return Math.sqrt(1.0 - b);\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double[] p, double[] q)\n    {\n        double sumP, sumN;\n        sumP = sumN = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumN += Math.abs(p[i] - q[i]);\n            sumP += Math.abs(p[i] + q[i]);\n        }\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 X2 axis coordinate.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n    {\n        double sumN = Math.abs(x1 - x2) + Math.abs(y1 - y2);\n        double sumP = Math.abs(x1 + x2) + Math.abs(y1 + y2);\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(IntPoint p, IntPoint q)\n    {\n        return BrayCurtis(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double[] p, double[] q)\n    {\n        double distance = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            distance += Math.abs(p[i] - q[i]) / (Math.abs(p[i]) + Math.abs(q[i]));\n        }\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double x1, double y1, double x2, double y2)\n    {\n        double distance;\n\n        distance = Math.abs(x1 - x2) / (Math.abs(x1) + Math.abs(x2));\n        distance += Math.abs(y1 - y2) / (Math.abs(y1) + Math.abs(y2));\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(IntPoint p, IntPoint q)\n    {\n        return Canberra(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double[] p, double[] q)\n    {\n        double max = Math.abs(p[0] - q[0]);\n\n        for (int i = 1; i < p.length; i++)\n        {\n            double abs = Math.abs(p[i] - q[i]);\n            if (abs > max) max = abs;\n        }\n\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double x1, double y1, double x2, double y2)\n    {\n        double max = Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(IntPoint p, IntPoint q)\n    {\n        return Chebyshev(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double[] x, double[] y)\n    {\n\n        double d = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            d = Math.max(d, x[i] - y[i]);\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.max(dx, dy);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(IntPoint p, IntPoint q)\n    {\n        return Chessboard(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chi Square distance between two normalized histograms.\n     *\n     * @param histogram1 Histogram.\n     * @param histogram2 Histogram.\n     * @return The Chi Square distance between x and y.\n     */\n    public static double ChiSquare(double[] histogram1, double[] histogram2)\n    {\n        double r = 0;\n        for (int i = 0; i < histogram1.length; i++)\n        {\n            double t = histogram1[i] + histogram2[i];\n            if (t != 0)\n                r += Math.pow(histogram1[i] - histogram2[i], 2) / t;\n        }\n\n        return 0.5 * r;\n    }\n\n    /**\n     * Gets the Correlation distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Correlation distance between x and y.\n     */\n    public static double Correlation(double[] p, double[] q)\n    {\n\n        double x = 0;\n        double y = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            x += -p[i];\n            y += -q[i];\n        }\n\n        x /= p.length;\n        y /= q.length;\n\n        double num = 0;\n        double den1 = 0;\n        double den2 = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            num += (p[i] + x) * (q[i] + y);\n\n            den1 += Math.abs(Math.pow(p[i] + x, 2));\n            den2 += Math.abs(Math.pow(q[i] + x, 2));\n        }\n\n        return 1 - (num / (Math.sqrt(den1) * Math.sqrt(den2)));\n\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double[] p, double[] q)\n    {\n        double sumProduct = 0;\n        double sumP = 0, sumQ = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumProduct += p[i] * q[i];\n            sumP += Math.pow(Math.abs(p[i]), 2);\n            sumQ += Math.pow(Math.abs(q[i]), 2);\n        }\n\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double x1, double y1, double x2, double y2)\n    {\n\n        double sumProduct = x1 * x2 + y1 * y2;\n        double sumP = Math.pow(Math.abs(x1), 2) + Math.pow(Math.abs(x2), 2);\n        double sumQ = Math.pow(Math.abs(y1), 2) + Math.pow(Math.abs(y2), 2);\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(IntPoint p, IntPoint q)\n    {\n        return Cosine(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double[] p, double[] q)\n    {\n        return Math.sqrt(SquaredEuclidean(p, q));\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(IntPoint p, IntPoint q)\n    {\n        return Euclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Hamming distance between two strings.\n     *\n     * @param first  First string.\n     * @param second Second string.\n     * @return The Hamming distance between p and q.\n     */\n\n    /**\n     * Gets the Jaccard distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Jaccard distance between x and y.\n     */\n    public static double JaccardDistance(double[] p, double[] q)\n    {\n        double distance = 0;\n        int intersection = 0, union = 0;\n\n        for (int x = 0; x < p.length; x++)\n        {\n            if ((p[x] != 0) || (q[x] != 0))\n            {\n                if (p[x] == q[x])\n                {\n                    intersection++;\n                }\n\n                union++;\n            }\n        }\n\n        if (union != 0)\n            distance = 1.0 - ((double) intersection / (double) union);\n        else\n            distance = 0;\n\n        return distance;\n    }\n\n    /**\n     * Gets the J-Divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The J-Divergence between p and q.\n     */\n    public static double JDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += (p[i] - q[i]) * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen difference divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Jensen difference between p and q.\n     */\n    public static double JensenDifferenceDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                double pq = p[i] + q[i];\n                k += (p[i] * Math.log(p[i]) + q[i] * Math.log(q[i])) / 2 - (pq / 2) * Math.log(pq / 2);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen Shannon divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The Jensen Shannon divergence between u and v.\n     */\n    public static double JensenShannonDivergence(double[] p, double[] q)\n    {\n        double[] m = new double[p.length];\n        for (int i = 0; i < m.length; i++)\n        {\n            m[i] = (p[i] + q[i]) / 2;\n        }\n\n        return (KullbackLeiblerDivergence(p, m) + KullbackLeiblerDivergence(q, m)) / 2;\n    }\n\n    /**\n     * Gets the K-Divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The K-Divergence between u and v.\n     */\n    public static double KDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] + q[i];\n            if (den != 0 && p[i] != 0)\n                r += p[i] * Math.log(2 * p[i] / den);\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Kumar-Johnson divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kumar-Johnson divergence between p and q.\n     */\n    public static double KumarJohnsonDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                r += Math.pow(p[i] * p[i] - q[i] * q[i], 2) / 2 * Math.pow(p[i] * q[i], 1.5);\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Kullback Leibler divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kullback Leibler divergence between u and v.\n     */\n    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += p[i] * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Mahalanobis distance.\n     *\n     * @param A Matrix A.\n     * @param B Matrix B.\n     * @return The Mahalanobis distance between A and B.\n     */\n    public static double Mahalanobis(double[][] A, double[][] B)\n    {\n\n        if (A[0].length != B[0].length)\n            throw new IllegalArgumentException(\"The number of columns of both matrix must be equals.\");\n\n        double[][] subA = new double[A.length][A[0].length];\n        double[][] subB = new double[B.length][B[0].length];\n\n        //Center data A\n        double[] meansA = new double[A[0].length];\n        for (int j = 0; j < A[0].length; j++)\n        {\n            for (int i = 0; i < A.length; i++)\n            {\n                meansA[j] += A[i][j];\n            }\n            meansA[j] /= (double) A.length;\n            for (int i = 0; i < A.length; i++)\n            {\n                subA[i][j] = A[i][j] - meansA[j];\n            }\n        }\n\n        //Center data B\n        double[] meansB = new double[B[0].length];\n        for (int j = 0; j < B[0].length; j++)\n        {\n            for (int i = 0; i < B.length; i++)\n            {\n                meansB[j] += B[i][j];\n            }\n            meansB[j] /= (double) B.length;\n            for (int i = 0; i < B.length; i++)\n            {\n                subB[i][j] = B[i][j] - meansB[j];\n            }\n        }\n\n        //Matrix of covariance\n        double[][] covA = Covariance(subA);\n        double[][] covB = Covariance(subB);\n\n        //Pooled covariance\n        double rows = subA.length + subB.length;\n        double[][] pCov = new double[covA.length][covA[0].length];\n        for (int i = 0; i < pCov.length; i++)\n        {\n            for (int j = 0; j < pCov[0].length; j++)\n            {\n                pCov[i][j] = covA[i][j] * ((double) subA.length / rows) + covB[i][j] * ((double) subB.length / rows);\n            }\n        }\n\n        //Inverse of pooled covariance\n        pCov = Matrix.Inverse(pCov);\n\n        //compute mean difference\n        double[] diff = new double[A[0].length];\n        for (int i = 0; i < diff.length; i++)\n        {\n            diff[i] = meansA[i] - meansB[i];\n        }\n\n        return Math.sqrt(Matrix.InnerProduct(Matrix.MultiplyByTranspose(pCov, diff), diff));\n\n    }\n\n    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n    {\n        double result = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            result += (x[i] - meanX) * (y[i] - meanY);\n        }\n\n        return result / (double) (x.length);\n    }\n\n    private static double[][] Covariance(double[][] matrix)\n    {\n        double[] means = new double[matrix[0].length];\n        for (int i = 0; i < matrix.length; i++)\n        {\n            for (int j = 0; j < matrix[0].length; j++)\n            {\n                means[j] += matrix[i][j];\n            }\n        }\n\n        for (int i = 0; i < means.length; i++)\n        {\n            means[i] /= means.length;\n        }\n\n        return Covariance(matrix, means);\n    }\n\n    private static double[][] Covariance(double[][] matrix, double[] means)\n    {\n        double[][] cov = new double[means.length][means.length];\n\n        for (int i = 0; i < cov.length; i++)\n        {\n            for (int j = 0; j < cov[0].length; j++)\n            {\n                cov[i][j] = Covariance(Matrix.getColumn(matrix, i), Matrix.getColumn(matrix, j), means[i], means[j]);\n            }\n        }\n\n        return cov;\n\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double[] p, double[] q)\n    {\n        double sum = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            sum += Math.abs(p[i] - q[i]);\n        }\n        return sum;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return dx + dy;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(IntPoint p, IntPoint q)\n    {\n        return Manhattan(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @param r  Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n    {\n        double sum = Math.pow(Math.abs(x1 - x2), r);\n        sum += Math.pow(Math.abs(y1 - y2), r);\n        return Math.pow(sum, 1 / r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @param r Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(IntPoint p, IntPoint q, int r)\n    {\n        return Minkowski(p.x, p.y, q.x, q.y, r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param u A point in space.\n     * @param v A point in space.\n     * @param p Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double[] u, double[] v, double p)\n    {\n        double distance = 0;\n        for (int i = 0; i < u.length; i++)\n        {\n            distance += Math.pow(Math.abs(u[i] - v[i]), p);\n        }\n        return Math.pow(distance, 1 / p);\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Quasi-Euclidean distance between x and y.\n     */\n    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        if (Math.abs(x1 - x2) > Math.abs(y1 - y2))\n        {\n            return Math.abs(x1 - x2) + (Constants.Sqrt2 - 1) * Math.abs(y1 - y2);\n        }\n        return (Constants.Sqrt2 - 1) * Math.abs(x1 - x2) + Math.abs(y1 - y2);\n\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Quasi Euclidean distance between p and q.\n     */\n    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n    {\n        return QuasiEuclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Square Euclidean distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Square Euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double[] x, double[] y)\n    {\n        double d = 0.0, u;\n\n        for (int i = 0; i < x.length; i++)\n        {\n            u = x[i] - y[i];\n            d += u * u;\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n    {\n\n        double dx = q.x - p.x;\n        double dy = q.y - p.y;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Symmetric Chi-square divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric chi-square divergence between p and q.\n     */\n    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double p1 = p[i] - q[i];\n                double p2 = p[i] + q[i];\n                r += (p1 * p1 * p2) / den;\n            }\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Symmetric Kullback-Leibler distance.\n     * This metric is valid only for real and positive P and Q.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric Kullback Leibler distance between p and q.\n     */\n    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n    {\n        double dist = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            dist += (p[i] - q[i]) * (Math.log(p[i]) - Math.log(q[i]));\n        }\n\n        return dist;\n    }\n\n    /**\n     * Gets the Taneja divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Taneja divergence between p and q.\n     */\n    public static double Taneja(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double pq = p[i] + q[i];\n                r += (pq / 2) * Math.log(pq / (2 * Math.sqrt(p[i] * q[i])));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Topsoe divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Topsoe divergence between p and q.\n     */\n    public static double TopsoeDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double den = p[i] + q[i];\n                r += p[i] * Math.log(2 * p[i] / den) + q[i] * Math.log(2 * q[i] / den);\n            }\n        }\n        return r;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/distance/Distance.java", "func_name": "Distance.JaccardDistance", "original_string": "public static double JaccardDistance(double[] p, double[] q) {\n        double distance = 0;\n        int intersection = 0, union = 0;\n\n        for (int x = 0; x < p.length; x++) {\n            if ((p[x] != 0) || (q[x] != 0)) {\n                if (p[x] == q[x]) {\n                    intersection++;\n                }\n\n                union++;\n            }\n        }\n\n        if (union != 0)\n            distance = 1.0 - ((double) intersection / (double) union);\n        else\n            distance = 0;\n\n        return distance;\n    }", "language": "java", "code": "public static double JaccardDistance(double[] p, double[] q) {\n        double distance = 0;\n        int intersection = 0, union = 0;\n\n        for (int x = 0; x < p.length; x++) {\n            if ((p[x] != 0) || (q[x] != 0)) {\n                if (p[x] == q[x]) {\n                    intersection++;\n                }\n\n                union++;\n            }\n        }\n\n        if (union != 0)\n            distance = 1.0 - ((double) intersection / (double) union);\n        else\n            distance = 0;\n\n        return distance;\n    }", "code_tokens": ["public", "static", "double", "JaccardDistance", "(", "double", "[", "]", "p", ",", "double", "[", "]", "q", ")", "{", "double", "distance", "=", "0", ";", "int", "intersection", "=", "0", ",", "union", "=", "0", ";", "for", "(", "int", "x", "=", "0", ";", "x", "<", "p", ".", "length", ";", "x", "++", ")", "{", "if", "(", "(", "p", "[", "x", "]", "!=", "0", ")", "||", "(", "q", "[", "x", "]", "!=", "0", ")", ")", "{", "if", "(", "p", "[", "x", "]", "==", "q", "[", "x", "]", ")", "{", "intersection", "++", ";", "}", "union", "++", ";", "}", "}", "if", "(", "union", "!=", "0", ")", "distance", "=", "1.0", "-", "(", "(", "double", ")", "intersection", "/", "(", "double", ")", "union", ")", ";", "else", "distance", "=", "0", ";", "return", "distance", ";", "}"], "docstring": "Gets the Jaccard distance between two points.\n\n@param p A point in space.\n@param q A point in space.\n@return The Jaccard distance between x and y.", "docstring_tokens": ["Gets", "the", "Jaccard", "distance", "between", "two", "points", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/distance/Distance.java#L431-L451", "partition": "train", "up_fun_num": 25, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.IntPoint;", "import com.harium.keel.catalano.math.Constants;", "import com.harium.keel.catalano.math.Matrix;"], "function": ["public final class Distance\n", "    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n", "    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n", "    public static double BrayCurtis(double[] p, double[] q)\n", "    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n", "    public static double BrayCurtis(IntPoint p, IntPoint q)\n", "    public static double Canberra(double[] p, double[] q)\n", "    public static double Canberra(double x1, double y1, double x2, double y2)\n", "    public static double Canberra(IntPoint p, IntPoint q)\n", "    public static double Chebyshev(double[] p, double[] q)\n", "    public static double Chebyshev(double x1, double y1, double x2, double y2)\n", "    public static double Chebyshev(IntPoint p, IntPoint q)\n", "    public static double Chessboard(double[] x, double[] y)\n", "    public static double Chessboard(double x1, double y1, double x2, double y2)\n", "    public static double Chessboard(IntPoint p, IntPoint q)\n", "    public static double ChiSquare(double[] histogram1, double[] histogram2)\n", "    public static double Correlation(double[] p, double[] q)\n", "    public static double Cosine(double[] p, double[] q)\n", "    public static double Cosine(double x1, double y1, double x2, double y2)\n", "    public static double Cosine(IntPoint p, IntPoint q)\n", "    public static double Euclidean(double[] p, double[] q)\n", "    public static double Euclidean(double x1, double y1, double x2, double y2)\n", "    public static double Euclidean(IntPoint p, IntPoint q)\n", "    public static int Hamming(String first, String second)\n", "    public static double JDivergence(double[] p, double[] q)\n", "    public static double JensenDifferenceDivergence(double[] p, double[] q)\n", "    public static double JensenShannonDivergence(double[] p, double[] q)\n", "    public static double KDivergence(double[] p, double[] q)\n", "    public static double KumarJohnsonDivergence(double[] p, double[] q)\n", "    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n", "    public static double Mahalanobis(double[][] A, double[][] B)\n", "    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n", "    private static double[][] Covariance(double[][] matrix)\n", "    private static double[][] Covariance(double[][] matrix, double[] means)\n", "    public static double Manhattan(double[] p, double[] q)\n", "    public static double Manhattan(double x1, double y1, double x2, double y2)\n", "    public static double Manhattan(IntPoint p, IntPoint q)\n", "    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n", "    public static double Minkowski(IntPoint p, IntPoint q, int r)\n", "    public static double Minkowski(double[] u, double[] v, double p)\n", "    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n", "    public static double SquaredEuclidean(double[] x, double[] y)\n", "    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n", "    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n", "    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n", "    public static double Taneja(double[] p, double[] q)\n", "    public static double TopsoeDivergence(double[] p, double[] q)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2012\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.distance;\n\n\nimport com.harium.keel.catalano.core.IntPoint;\nimport com.harium.keel.catalano.math.Constants;\nimport com.harium.keel.catalano.math.Matrix;\n\n/**\n * Defines a set of extension methods defining distance measures.\n * References: http://www.ajmaa.org/RGMIA/papers/v7n4/Gsdmi_RGMIA.pdf\n * http://arabic-icr.googlecode.com/git/Papers/Comprehensive%20Survey%20on%20Distance-Similarity.pdf\n *\n * @author Diego Catalano\n */\npublic final class Distance\n{\n\n    /**\n     * Don't let anyone initialize this class.\n     */\n    private Distance()\n    {\n    }\n\n    ;\n\n    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double num = p[i] + q[i];\n                r += (num / 2) * Math.log(num / (2 * Math.sqrt(den)));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Bhattacharyya distance between two normalized histograms.\n     *\n     * @param histogram1 Normalized histogram.\n     * @param histogram2 Normalized histogram.\n     * @return The Bhattacharyya distance between the two histograms.\n     */\n    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n    {\n        int bins = histogram1.length; // histogram bins\n        double b = 0; // Bhattacharyya's coefficient\n\n        for (int i = 0; i < bins; i++)\n            b += Math.sqrt(histogram1[i]) * Math.sqrt(histogram2[i]);\n\n        // Bhattacharyya distance between the two distributions\n        return Math.sqrt(1.0 - b);\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double[] p, double[] q)\n    {\n        double sumP, sumN;\n        sumP = sumN = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumN += Math.abs(p[i] - q[i]);\n            sumP += Math.abs(p[i] + q[i]);\n        }\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 X2 axis coordinate.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n    {\n        double sumN = Math.abs(x1 - x2) + Math.abs(y1 - y2);\n        double sumP = Math.abs(x1 + x2) + Math.abs(y1 + y2);\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(IntPoint p, IntPoint q)\n    {\n        return BrayCurtis(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double[] p, double[] q)\n    {\n        double distance = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            distance += Math.abs(p[i] - q[i]) / (Math.abs(p[i]) + Math.abs(q[i]));\n        }\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double x1, double y1, double x2, double y2)\n    {\n        double distance;\n\n        distance = Math.abs(x1 - x2) / (Math.abs(x1) + Math.abs(x2));\n        distance += Math.abs(y1 - y2) / (Math.abs(y1) + Math.abs(y2));\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(IntPoint p, IntPoint q)\n    {\n        return Canberra(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double[] p, double[] q)\n    {\n        double max = Math.abs(p[0] - q[0]);\n\n        for (int i = 1; i < p.length; i++)\n        {\n            double abs = Math.abs(p[i] - q[i]);\n            if (abs > max) max = abs;\n        }\n\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double x1, double y1, double x2, double y2)\n    {\n        double max = Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(IntPoint p, IntPoint q)\n    {\n        return Chebyshev(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double[] x, double[] y)\n    {\n\n        double d = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            d = Math.max(d, x[i] - y[i]);\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.max(dx, dy);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(IntPoint p, IntPoint q)\n    {\n        return Chessboard(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chi Square distance between two normalized histograms.\n     *\n     * @param histogram1 Histogram.\n     * @param histogram2 Histogram.\n     * @return The Chi Square distance between x and y.\n     */\n    public static double ChiSquare(double[] histogram1, double[] histogram2)\n    {\n        double r = 0;\n        for (int i = 0; i < histogram1.length; i++)\n        {\n            double t = histogram1[i] + histogram2[i];\n            if (t != 0)\n                r += Math.pow(histogram1[i] - histogram2[i], 2) / t;\n        }\n\n        return 0.5 * r;\n    }\n\n    /**\n     * Gets the Correlation distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Correlation distance between x and y.\n     */\n    public static double Correlation(double[] p, double[] q)\n    {\n\n        double x = 0;\n        double y = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            x += -p[i];\n            y += -q[i];\n        }\n\n        x /= p.length;\n        y /= q.length;\n\n        double num = 0;\n        double den1 = 0;\n        double den2 = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            num += (p[i] + x) * (q[i] + y);\n\n            den1 += Math.abs(Math.pow(p[i] + x, 2));\n            den2 += Math.abs(Math.pow(q[i] + x, 2));\n        }\n\n        return 1 - (num / (Math.sqrt(den1) * Math.sqrt(den2)));\n\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double[] p, double[] q)\n    {\n        double sumProduct = 0;\n        double sumP = 0, sumQ = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumProduct += p[i] * q[i];\n            sumP += Math.pow(Math.abs(p[i]), 2);\n            sumQ += Math.pow(Math.abs(q[i]), 2);\n        }\n\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double x1, double y1, double x2, double y2)\n    {\n\n        double sumProduct = x1 * x2 + y1 * y2;\n        double sumP = Math.pow(Math.abs(x1), 2) + Math.pow(Math.abs(x2), 2);\n        double sumQ = Math.pow(Math.abs(y1), 2) + Math.pow(Math.abs(y2), 2);\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(IntPoint p, IntPoint q)\n    {\n        return Cosine(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double[] p, double[] q)\n    {\n        return Math.sqrt(SquaredEuclidean(p, q));\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(IntPoint p, IntPoint q)\n    {\n        return Euclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Hamming distance between two strings.\n     *\n     * @param first  First string.\n     * @param second Second string.\n     * @return The Hamming distance between p and q.\n     */\n    public static int Hamming(String first, String second)\n    {\n\n        if (first.length() != second.length())\n            throw new IllegalArgumentException(\"The size of string must be the same.\");\n\n        int diff = 0;\n        for (int i = 0; i < first.length(); i++)\n            if (first.charAt(i) != second.charAt(i))\n                diff++;\n        return diff;\n    }\n\n    /**\n     * Gets the Jaccard distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Jaccard distance between x and y.\n     */\n\n    /**\n     * Gets the J-Divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The J-Divergence between p and q.\n     */\n    public static double JDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += (p[i] - q[i]) * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen difference divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Jensen difference between p and q.\n     */\n    public static double JensenDifferenceDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                double pq = p[i] + q[i];\n                k += (p[i] * Math.log(p[i]) + q[i] * Math.log(q[i])) / 2 - (pq / 2) * Math.log(pq / 2);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen Shannon divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The Jensen Shannon divergence between u and v.\n     */\n    public static double JensenShannonDivergence(double[] p, double[] q)\n    {\n        double[] m = new double[p.length];\n        for (int i = 0; i < m.length; i++)\n        {\n            m[i] = (p[i] + q[i]) / 2;\n        }\n\n        return (KullbackLeiblerDivergence(p, m) + KullbackLeiblerDivergence(q, m)) / 2;\n    }\n\n    /**\n     * Gets the K-Divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The K-Divergence between u and v.\n     */\n    public static double KDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] + q[i];\n            if (den != 0 && p[i] != 0)\n                r += p[i] * Math.log(2 * p[i] / den);\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Kumar-Johnson divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kumar-Johnson divergence between p and q.\n     */\n    public static double KumarJohnsonDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                r += Math.pow(p[i] * p[i] - q[i] * q[i], 2) / 2 * Math.pow(p[i] * q[i], 1.5);\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Kullback Leibler divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kullback Leibler divergence between u and v.\n     */\n    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += p[i] * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Mahalanobis distance.\n     *\n     * @param A Matrix A.\n     * @param B Matrix B.\n     * @return The Mahalanobis distance between A and B.\n     */\n    public static double Mahalanobis(double[][] A, double[][] B)\n    {\n\n        if (A[0].length != B[0].length)\n            throw new IllegalArgumentException(\"The number of columns of both matrix must be equals.\");\n\n        double[][] subA = new double[A.length][A[0].length];\n        double[][] subB = new double[B.length][B[0].length];\n\n        //Center data A\n        double[] meansA = new double[A[0].length];\n        for (int j = 0; j < A[0].length; j++)\n        {\n            for (int i = 0; i < A.length; i++)\n            {\n                meansA[j] += A[i][j];\n            }\n            meansA[j] /= (double) A.length;\n            for (int i = 0; i < A.length; i++)\n            {\n                subA[i][j] = A[i][j] - meansA[j];\n            }\n        }\n\n        //Center data B\n        double[] meansB = new double[B[0].length];\n        for (int j = 0; j < B[0].length; j++)\n        {\n            for (int i = 0; i < B.length; i++)\n            {\n                meansB[j] += B[i][j];\n            }\n            meansB[j] /= (double) B.length;\n            for (int i = 0; i < B.length; i++)\n            {\n                subB[i][j] = B[i][j] - meansB[j];\n            }\n        }\n\n        //Matrix of covariance\n        double[][] covA = Covariance(subA);\n        double[][] covB = Covariance(subB);\n\n        //Pooled covariance\n        double rows = subA.length + subB.length;\n        double[][] pCov = new double[covA.length][covA[0].length];\n        for (int i = 0; i < pCov.length; i++)\n        {\n            for (int j = 0; j < pCov[0].length; j++)\n            {\n                pCov[i][j] = covA[i][j] * ((double) subA.length / rows) + covB[i][j] * ((double) subB.length / rows);\n            }\n        }\n\n        //Inverse of pooled covariance\n        pCov = Matrix.Inverse(pCov);\n\n        //compute mean difference\n        double[] diff = new double[A[0].length];\n        for (int i = 0; i < diff.length; i++)\n        {\n            diff[i] = meansA[i] - meansB[i];\n        }\n\n        return Math.sqrt(Matrix.InnerProduct(Matrix.MultiplyByTranspose(pCov, diff), diff));\n\n    }\n\n    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n    {\n        double result = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            result += (x[i] - meanX) * (y[i] - meanY);\n        }\n\n        return result / (double) (x.length);\n    }\n\n    private static double[][] Covariance(double[][] matrix)\n    {\n        double[] means = new double[matrix[0].length];\n        for (int i = 0; i < matrix.length; i++)\n        {\n            for (int j = 0; j < matrix[0].length; j++)\n            {\n                means[j] += matrix[i][j];\n            }\n        }\n\n        for (int i = 0; i < means.length; i++)\n        {\n            means[i] /= means.length;\n        }\n\n        return Covariance(matrix, means);\n    }\n\n    private static double[][] Covariance(double[][] matrix, double[] means)\n    {\n        double[][] cov = new double[means.length][means.length];\n\n        for (int i = 0; i < cov.length; i++)\n        {\n            for (int j = 0; j < cov[0].length; j++)\n            {\n                cov[i][j] = Covariance(Matrix.getColumn(matrix, i), Matrix.getColumn(matrix, j), means[i], means[j]);\n            }\n        }\n\n        return cov;\n\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double[] p, double[] q)\n    {\n        double sum = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            sum += Math.abs(p[i] - q[i]);\n        }\n        return sum;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return dx + dy;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(IntPoint p, IntPoint q)\n    {\n        return Manhattan(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @param r  Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n    {\n        double sum = Math.pow(Math.abs(x1 - x2), r);\n        sum += Math.pow(Math.abs(y1 - y2), r);\n        return Math.pow(sum, 1 / r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @param r Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(IntPoint p, IntPoint q, int r)\n    {\n        return Minkowski(p.x, p.y, q.x, q.y, r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param u A point in space.\n     * @param v A point in space.\n     * @param p Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double[] u, double[] v, double p)\n    {\n        double distance = 0;\n        for (int i = 0; i < u.length; i++)\n        {\n            distance += Math.pow(Math.abs(u[i] - v[i]), p);\n        }\n        return Math.pow(distance, 1 / p);\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Quasi-Euclidean distance between x and y.\n     */\n    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        if (Math.abs(x1 - x2) > Math.abs(y1 - y2))\n        {\n            return Math.abs(x1 - x2) + (Constants.Sqrt2 - 1) * Math.abs(y1 - y2);\n        }\n        return (Constants.Sqrt2 - 1) * Math.abs(x1 - x2) + Math.abs(y1 - y2);\n\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Quasi Euclidean distance between p and q.\n     */\n    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n    {\n        return QuasiEuclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Square Euclidean distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Square Euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double[] x, double[] y)\n    {\n        double d = 0.0, u;\n\n        for (int i = 0; i < x.length; i++)\n        {\n            u = x[i] - y[i];\n            d += u * u;\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n    {\n\n        double dx = q.x - p.x;\n        double dy = q.y - p.y;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Symmetric Chi-square divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric chi-square divergence between p and q.\n     */\n    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double p1 = p[i] - q[i];\n                double p2 = p[i] + q[i];\n                r += (p1 * p1 * p2) / den;\n            }\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Symmetric Kullback-Leibler distance.\n     * This metric is valid only for real and positive P and Q.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric Kullback Leibler distance between p and q.\n     */\n    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n    {\n        double dist = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            dist += (p[i] - q[i]) * (Math.log(p[i]) - Math.log(q[i]));\n        }\n\n        return dist;\n    }\n\n    /**\n     * Gets the Taneja divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Taneja divergence between p and q.\n     */\n    public static double Taneja(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double pq = p[i] + q[i];\n                r += (pq / 2) * Math.log(pq / (2 * Math.sqrt(p[i] * q[i])));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Topsoe divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Topsoe divergence between p and q.\n     */\n    public static double TopsoeDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double den = p[i] + q[i];\n                r += p[i] * Math.log(2 * p[i] / den) + q[i] * Math.log(2 * q[i] / den);\n            }\n        }\n        return r;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/distance/Distance.java", "func_name": "Distance.JensenShannonDivergence", "original_string": "public static double JensenShannonDivergence(double[] p, double[] q) {\n        double[] m = new double[p.length];\n        for (int i = 0; i < m.length; i++) {\n            m[i] = (p[i] + q[i]) / 2;\n        }\n\n        return (KullbackLeiblerDivergence(p, m) + KullbackLeiblerDivergence(q, m)) / 2;\n    }", "language": "java", "code": "public static double JensenShannonDivergence(double[] p, double[] q) {\n        double[] m = new double[p.length];\n        for (int i = 0; i < m.length; i++) {\n            m[i] = (p[i] + q[i]) / 2;\n        }\n\n        return (KullbackLeiblerDivergence(p, m) + KullbackLeiblerDivergence(q, m)) / 2;\n    }", "code_tokens": ["public", "static", "double", "JensenShannonDivergence", "(", "double", "[", "]", "p", ",", "double", "[", "]", "q", ")", "{", "double", "[", "]", "m", "=", "new", "double", "[", "p", ".", "length", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "m", ".", "length", ";", "i", "++", ")", "{", "m", "[", "i", "]", "=", "(", "p", "[", "i", "]", "+", "q", "[", "i", "]", ")", "/", "2", ";", "}", "return", "(", "KullbackLeiblerDivergence", "(", "p", ",", "m", ")", "+", "KullbackLeiblerDivergence", "(", "q", ",", "m", ")", ")", "/", "2", ";", "}"], "docstring": "Gets the Jensen Shannon divergence.\n\n@param p U vector.\n@param q V vector.\n@return The Jensen Shannon divergence between u and v.", "docstring_tokens": ["Gets", "the", "Jensen", "Shannon", "divergence", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/distance/Distance.java#L509-L516", "partition": "train", "up_fun_num": 28, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.IntPoint;", "import com.harium.keel.catalano.math.Constants;", "import com.harium.keel.catalano.math.Matrix;"], "function": ["public final class Distance\n", "    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n", "    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n", "    public static double BrayCurtis(double[] p, double[] q)\n", "    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n", "    public static double BrayCurtis(IntPoint p, IntPoint q)\n", "    public static double Canberra(double[] p, double[] q)\n", "    public static double Canberra(double x1, double y1, double x2, double y2)\n", "    public static double Canberra(IntPoint p, IntPoint q)\n", "    public static double Chebyshev(double[] p, double[] q)\n", "    public static double Chebyshev(double x1, double y1, double x2, double y2)\n", "    public static double Chebyshev(IntPoint p, IntPoint q)\n", "    public static double Chessboard(double[] x, double[] y)\n", "    public static double Chessboard(double x1, double y1, double x2, double y2)\n", "    public static double Chessboard(IntPoint p, IntPoint q)\n", "    public static double ChiSquare(double[] histogram1, double[] histogram2)\n", "    public static double Correlation(double[] p, double[] q)\n", "    public static double Cosine(double[] p, double[] q)\n", "    public static double Cosine(double x1, double y1, double x2, double y2)\n", "    public static double Cosine(IntPoint p, IntPoint q)\n", "    public static double Euclidean(double[] p, double[] q)\n", "    public static double Euclidean(double x1, double y1, double x2, double y2)\n", "    public static double Euclidean(IntPoint p, IntPoint q)\n", "    public static int Hamming(String first, String second)\n", "    public static double JaccardDistance(double[] p, double[] q)\n", "    public static double JDivergence(double[] p, double[] q)\n", "    public static double JensenDifferenceDivergence(double[] p, double[] q)\n", "    public static double KDivergence(double[] p, double[] q)\n", "    public static double KumarJohnsonDivergence(double[] p, double[] q)\n", "    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n", "    public static double Mahalanobis(double[][] A, double[][] B)\n", "    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n", "    private static double[][] Covariance(double[][] matrix)\n", "    private static double[][] Covariance(double[][] matrix, double[] means)\n", "    public static double Manhattan(double[] p, double[] q)\n", "    public static double Manhattan(double x1, double y1, double x2, double y2)\n", "    public static double Manhattan(IntPoint p, IntPoint q)\n", "    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n", "    public static double Minkowski(IntPoint p, IntPoint q, int r)\n", "    public static double Minkowski(double[] u, double[] v, double p)\n", "    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n", "    public static double SquaredEuclidean(double[] x, double[] y)\n", "    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n", "    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n", "    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n", "    public static double Taneja(double[] p, double[] q)\n", "    public static double TopsoeDivergence(double[] p, double[] q)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2012\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.distance;\n\n\nimport com.harium.keel.catalano.core.IntPoint;\nimport com.harium.keel.catalano.math.Constants;\nimport com.harium.keel.catalano.math.Matrix;\n\n/**\n * Defines a set of extension methods defining distance measures.\n * References: http://www.ajmaa.org/RGMIA/papers/v7n4/Gsdmi_RGMIA.pdf\n * http://arabic-icr.googlecode.com/git/Papers/Comprehensive%20Survey%20on%20Distance-Similarity.pdf\n *\n * @author Diego Catalano\n */\npublic final class Distance\n{\n\n    /**\n     * Don't let anyone initialize this class.\n     */\n    private Distance()\n    {\n    }\n\n    ;\n\n    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double num = p[i] + q[i];\n                r += (num / 2) * Math.log(num / (2 * Math.sqrt(den)));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Bhattacharyya distance between two normalized histograms.\n     *\n     * @param histogram1 Normalized histogram.\n     * @param histogram2 Normalized histogram.\n     * @return The Bhattacharyya distance between the two histograms.\n     */\n    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n    {\n        int bins = histogram1.length; // histogram bins\n        double b = 0; // Bhattacharyya's coefficient\n\n        for (int i = 0; i < bins; i++)\n            b += Math.sqrt(histogram1[i]) * Math.sqrt(histogram2[i]);\n\n        // Bhattacharyya distance between the two distributions\n        return Math.sqrt(1.0 - b);\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double[] p, double[] q)\n    {\n        double sumP, sumN;\n        sumP = sumN = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumN += Math.abs(p[i] - q[i]);\n            sumP += Math.abs(p[i] + q[i]);\n        }\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 X2 axis coordinate.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n    {\n        double sumN = Math.abs(x1 - x2) + Math.abs(y1 - y2);\n        double sumP = Math.abs(x1 + x2) + Math.abs(y1 + y2);\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(IntPoint p, IntPoint q)\n    {\n        return BrayCurtis(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double[] p, double[] q)\n    {\n        double distance = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            distance += Math.abs(p[i] - q[i]) / (Math.abs(p[i]) + Math.abs(q[i]));\n        }\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double x1, double y1, double x2, double y2)\n    {\n        double distance;\n\n        distance = Math.abs(x1 - x2) / (Math.abs(x1) + Math.abs(x2));\n        distance += Math.abs(y1 - y2) / (Math.abs(y1) + Math.abs(y2));\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(IntPoint p, IntPoint q)\n    {\n        return Canberra(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double[] p, double[] q)\n    {\n        double max = Math.abs(p[0] - q[0]);\n\n        for (int i = 1; i < p.length; i++)\n        {\n            double abs = Math.abs(p[i] - q[i]);\n            if (abs > max) max = abs;\n        }\n\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double x1, double y1, double x2, double y2)\n    {\n        double max = Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(IntPoint p, IntPoint q)\n    {\n        return Chebyshev(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double[] x, double[] y)\n    {\n\n        double d = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            d = Math.max(d, x[i] - y[i]);\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.max(dx, dy);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(IntPoint p, IntPoint q)\n    {\n        return Chessboard(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chi Square distance between two normalized histograms.\n     *\n     * @param histogram1 Histogram.\n     * @param histogram2 Histogram.\n     * @return The Chi Square distance between x and y.\n     */\n    public static double ChiSquare(double[] histogram1, double[] histogram2)\n    {\n        double r = 0;\n        for (int i = 0; i < histogram1.length; i++)\n        {\n            double t = histogram1[i] + histogram2[i];\n            if (t != 0)\n                r += Math.pow(histogram1[i] - histogram2[i], 2) / t;\n        }\n\n        return 0.5 * r;\n    }\n\n    /**\n     * Gets the Correlation distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Correlation distance between x and y.\n     */\n    public static double Correlation(double[] p, double[] q)\n    {\n\n        double x = 0;\n        double y = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            x += -p[i];\n            y += -q[i];\n        }\n\n        x /= p.length;\n        y /= q.length;\n\n        double num = 0;\n        double den1 = 0;\n        double den2 = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            num += (p[i] + x) * (q[i] + y);\n\n            den1 += Math.abs(Math.pow(p[i] + x, 2));\n            den2 += Math.abs(Math.pow(q[i] + x, 2));\n        }\n\n        return 1 - (num / (Math.sqrt(den1) * Math.sqrt(den2)));\n\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double[] p, double[] q)\n    {\n        double sumProduct = 0;\n        double sumP = 0, sumQ = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumProduct += p[i] * q[i];\n            sumP += Math.pow(Math.abs(p[i]), 2);\n            sumQ += Math.pow(Math.abs(q[i]), 2);\n        }\n\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double x1, double y1, double x2, double y2)\n    {\n\n        double sumProduct = x1 * x2 + y1 * y2;\n        double sumP = Math.pow(Math.abs(x1), 2) + Math.pow(Math.abs(x2), 2);\n        double sumQ = Math.pow(Math.abs(y1), 2) + Math.pow(Math.abs(y2), 2);\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(IntPoint p, IntPoint q)\n    {\n        return Cosine(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double[] p, double[] q)\n    {\n        return Math.sqrt(SquaredEuclidean(p, q));\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(IntPoint p, IntPoint q)\n    {\n        return Euclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Hamming distance between two strings.\n     *\n     * @param first  First string.\n     * @param second Second string.\n     * @return The Hamming distance between p and q.\n     */\n    public static int Hamming(String first, String second)\n    {\n\n        if (first.length() != second.length())\n            throw new IllegalArgumentException(\"The size of string must be the same.\");\n\n        int diff = 0;\n        for (int i = 0; i < first.length(); i++)\n            if (first.charAt(i) != second.charAt(i))\n                diff++;\n        return diff;\n    }\n\n    /**\n     * Gets the Jaccard distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Jaccard distance between x and y.\n     */\n    public static double JaccardDistance(double[] p, double[] q)\n    {\n        double distance = 0;\n        int intersection = 0, union = 0;\n\n        for (int x = 0; x < p.length; x++)\n        {\n            if ((p[x] != 0) || (q[x] != 0))\n            {\n                if (p[x] == q[x])\n                {\n                    intersection++;\n                }\n\n                union++;\n            }\n        }\n\n        if (union != 0)\n            distance = 1.0 - ((double) intersection / (double) union);\n        else\n            distance = 0;\n\n        return distance;\n    }\n\n    /**\n     * Gets the J-Divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The J-Divergence between p and q.\n     */\n    public static double JDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += (p[i] - q[i]) * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen difference divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Jensen difference between p and q.\n     */\n    public static double JensenDifferenceDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                double pq = p[i] + q[i];\n                k += (p[i] * Math.log(p[i]) + q[i] * Math.log(q[i])) / 2 - (pq / 2) * Math.log(pq / 2);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen Shannon divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The Jensen Shannon divergence between u and v.\n     */\n\n    /**\n     * Gets the K-Divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The K-Divergence between u and v.\n     */\n    public static double KDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] + q[i];\n            if (den != 0 && p[i] != 0)\n                r += p[i] * Math.log(2 * p[i] / den);\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Kumar-Johnson divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kumar-Johnson divergence between p and q.\n     */\n    public static double KumarJohnsonDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                r += Math.pow(p[i] * p[i] - q[i] * q[i], 2) / 2 * Math.pow(p[i] * q[i], 1.5);\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Kullback Leibler divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kullback Leibler divergence between u and v.\n     */\n    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += p[i] * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Mahalanobis distance.\n     *\n     * @param A Matrix A.\n     * @param B Matrix B.\n     * @return The Mahalanobis distance between A and B.\n     */\n    public static double Mahalanobis(double[][] A, double[][] B)\n    {\n\n        if (A[0].length != B[0].length)\n            throw new IllegalArgumentException(\"The number of columns of both matrix must be equals.\");\n\n        double[][] subA = new double[A.length][A[0].length];\n        double[][] subB = new double[B.length][B[0].length];\n\n        //Center data A\n        double[] meansA = new double[A[0].length];\n        for (int j = 0; j < A[0].length; j++)\n        {\n            for (int i = 0; i < A.length; i++)\n            {\n                meansA[j] += A[i][j];\n            }\n            meansA[j] /= (double) A.length;\n            for (int i = 0; i < A.length; i++)\n            {\n                subA[i][j] = A[i][j] - meansA[j];\n            }\n        }\n\n        //Center data B\n        double[] meansB = new double[B[0].length];\n        for (int j = 0; j < B[0].length; j++)\n        {\n            for (int i = 0; i < B.length; i++)\n            {\n                meansB[j] += B[i][j];\n            }\n            meansB[j] /= (double) B.length;\n            for (int i = 0; i < B.length; i++)\n            {\n                subB[i][j] = B[i][j] - meansB[j];\n            }\n        }\n\n        //Matrix of covariance\n        double[][] covA = Covariance(subA);\n        double[][] covB = Covariance(subB);\n\n        //Pooled covariance\n        double rows = subA.length + subB.length;\n        double[][] pCov = new double[covA.length][covA[0].length];\n        for (int i = 0; i < pCov.length; i++)\n        {\n            for (int j = 0; j < pCov[0].length; j++)\n            {\n                pCov[i][j] = covA[i][j] * ((double) subA.length / rows) + covB[i][j] * ((double) subB.length / rows);\n            }\n        }\n\n        //Inverse of pooled covariance\n        pCov = Matrix.Inverse(pCov);\n\n        //compute mean difference\n        double[] diff = new double[A[0].length];\n        for (int i = 0; i < diff.length; i++)\n        {\n            diff[i] = meansA[i] - meansB[i];\n        }\n\n        return Math.sqrt(Matrix.InnerProduct(Matrix.MultiplyByTranspose(pCov, diff), diff));\n\n    }\n\n    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n    {\n        double result = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            result += (x[i] - meanX) * (y[i] - meanY);\n        }\n\n        return result / (double) (x.length);\n    }\n\n    private static double[][] Covariance(double[][] matrix)\n    {\n        double[] means = new double[matrix[0].length];\n        for (int i = 0; i < matrix.length; i++)\n        {\n            for (int j = 0; j < matrix[0].length; j++)\n            {\n                means[j] += matrix[i][j];\n            }\n        }\n\n        for (int i = 0; i < means.length; i++)\n        {\n            means[i] /= means.length;\n        }\n\n        return Covariance(matrix, means);\n    }\n\n    private static double[][] Covariance(double[][] matrix, double[] means)\n    {\n        double[][] cov = new double[means.length][means.length];\n\n        for (int i = 0; i < cov.length; i++)\n        {\n            for (int j = 0; j < cov[0].length; j++)\n            {\n                cov[i][j] = Covariance(Matrix.getColumn(matrix, i), Matrix.getColumn(matrix, j), means[i], means[j]);\n            }\n        }\n\n        return cov;\n\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double[] p, double[] q)\n    {\n        double sum = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            sum += Math.abs(p[i] - q[i]);\n        }\n        return sum;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return dx + dy;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(IntPoint p, IntPoint q)\n    {\n        return Manhattan(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @param r  Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n    {\n        double sum = Math.pow(Math.abs(x1 - x2), r);\n        sum += Math.pow(Math.abs(y1 - y2), r);\n        return Math.pow(sum, 1 / r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @param r Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(IntPoint p, IntPoint q, int r)\n    {\n        return Minkowski(p.x, p.y, q.x, q.y, r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param u A point in space.\n     * @param v A point in space.\n     * @param p Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double[] u, double[] v, double p)\n    {\n        double distance = 0;\n        for (int i = 0; i < u.length; i++)\n        {\n            distance += Math.pow(Math.abs(u[i] - v[i]), p);\n        }\n        return Math.pow(distance, 1 / p);\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Quasi-Euclidean distance between x and y.\n     */\n    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        if (Math.abs(x1 - x2) > Math.abs(y1 - y2))\n        {\n            return Math.abs(x1 - x2) + (Constants.Sqrt2 - 1) * Math.abs(y1 - y2);\n        }\n        return (Constants.Sqrt2 - 1) * Math.abs(x1 - x2) + Math.abs(y1 - y2);\n\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Quasi Euclidean distance between p and q.\n     */\n    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n    {\n        return QuasiEuclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Square Euclidean distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Square Euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double[] x, double[] y)\n    {\n        double d = 0.0, u;\n\n        for (int i = 0; i < x.length; i++)\n        {\n            u = x[i] - y[i];\n            d += u * u;\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n    {\n\n        double dx = q.x - p.x;\n        double dy = q.y - p.y;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Symmetric Chi-square divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric chi-square divergence between p and q.\n     */\n    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double p1 = p[i] - q[i];\n                double p2 = p[i] + q[i];\n                r += (p1 * p1 * p2) / den;\n            }\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Symmetric Kullback-Leibler distance.\n     * This metric is valid only for real and positive P and Q.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric Kullback Leibler distance between p and q.\n     */\n    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n    {\n        double dist = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            dist += (p[i] - q[i]) * (Math.log(p[i]) - Math.log(q[i]));\n        }\n\n        return dist;\n    }\n\n    /**\n     * Gets the Taneja divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Taneja divergence between p and q.\n     */\n    public static double Taneja(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double pq = p[i] + q[i];\n                r += (pq / 2) * Math.log(pq / (2 * Math.sqrt(p[i] * q[i])));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Topsoe divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Topsoe divergence between p and q.\n     */\n    public static double TopsoeDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double den = p[i] + q[i];\n                r += p[i] * Math.log(2 * p[i] / den) + q[i] * Math.log(2 * q[i] / den);\n            }\n        }\n        return r;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/distance/Distance.java", "func_name": "Distance.KumarJohnsonDivergence", "original_string": "public static double KumarJohnsonDivergence(double[] p, double[] q) {\n        double r = 0;\n        for (int i = 0; i < p.length; i++) {\n            if (p[i] != 0 && q[i] != 0) {\n                r += Math.pow(p[i] * p[i] - q[i] * q[i], 2) / 2 * Math.pow(p[i] * q[i], 1.5);\n            }\n        }\n        return r;\n    }", "language": "java", "code": "public static double KumarJohnsonDivergence(double[] p, double[] q) {\n        double r = 0;\n        for (int i = 0; i < p.length; i++) {\n            if (p[i] != 0 && q[i] != 0) {\n                r += Math.pow(p[i] * p[i] - q[i] * q[i], 2) / 2 * Math.pow(p[i] * q[i], 1.5);\n            }\n        }\n        return r;\n    }", "code_tokens": ["public", "static", "double", "KumarJohnsonDivergence", "(", "double", "[", "]", "p", ",", "double", "[", "]", "q", ")", "{", "double", "r", "=", "0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "p", ".", "length", ";", "i", "++", ")", "{", "if", "(", "p", "[", "i", "]", "!=", "0", "&&", "q", "[", "i", "]", "!=", "0", ")", "{", "r", "+=", "Math", ".", "pow", "(", "p", "[", "i", "]", "*", "p", "[", "i", "]", "-", "q", "[", "i", "]", "*", "q", "[", "i", "]", ",", "2", ")", "/", "2", "*", "Math", ".", "pow", "(", "p", "[", "i", "]", "*", "q", "[", "i", "]", ",", "1.5", ")", ";", "}", "}", "return", "r", ";", "}"], "docstring": "Gets the Kumar-Johnson divergence.\n\n@param p P vector.\n@param q Q vector.\n@return The Kumar-Johnson divergence between p and q.", "docstring_tokens": ["Gets", "the", "Kumar", "-", "Johnson", "divergence", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/distance/Distance.java#L543-L551", "partition": "train", "up_fun_num": 30, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.IntPoint;", "import com.harium.keel.catalano.math.Constants;", "import com.harium.keel.catalano.math.Matrix;"], "function": ["public final class Distance\n", "    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n", "    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n", "    public static double BrayCurtis(double[] p, double[] q)\n", "    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n", "    public static double BrayCurtis(IntPoint p, IntPoint q)\n", "    public static double Canberra(double[] p, double[] q)\n", "    public static double Canberra(double x1, double y1, double x2, double y2)\n", "    public static double Canberra(IntPoint p, IntPoint q)\n", "    public static double Chebyshev(double[] p, double[] q)\n", "    public static double Chebyshev(double x1, double y1, double x2, double y2)\n", "    public static double Chebyshev(IntPoint p, IntPoint q)\n", "    public static double Chessboard(double[] x, double[] y)\n", "    public static double Chessboard(double x1, double y1, double x2, double y2)\n", "    public static double Chessboard(IntPoint p, IntPoint q)\n", "    public static double ChiSquare(double[] histogram1, double[] histogram2)\n", "    public static double Correlation(double[] p, double[] q)\n", "    public static double Cosine(double[] p, double[] q)\n", "    public static double Cosine(double x1, double y1, double x2, double y2)\n", "    public static double Cosine(IntPoint p, IntPoint q)\n", "    public static double Euclidean(double[] p, double[] q)\n", "    public static double Euclidean(double x1, double y1, double x2, double y2)\n", "    public static double Euclidean(IntPoint p, IntPoint q)\n", "    public static int Hamming(String first, String second)\n", "    public static double JaccardDistance(double[] p, double[] q)\n", "    public static double JDivergence(double[] p, double[] q)\n", "    public static double JensenDifferenceDivergence(double[] p, double[] q)\n", "    public static double JensenShannonDivergence(double[] p, double[] q)\n", "    public static double KDivergence(double[] p, double[] q)\n", "    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n", "    public static double Mahalanobis(double[][] A, double[][] B)\n", "    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n", "    private static double[][] Covariance(double[][] matrix)\n", "    private static double[][] Covariance(double[][] matrix, double[] means)\n", "    public static double Manhattan(double[] p, double[] q)\n", "    public static double Manhattan(double x1, double y1, double x2, double y2)\n", "    public static double Manhattan(IntPoint p, IntPoint q)\n", "    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n", "    public static double Minkowski(IntPoint p, IntPoint q, int r)\n", "    public static double Minkowski(double[] u, double[] v, double p)\n", "    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n", "    public static double SquaredEuclidean(double[] x, double[] y)\n", "    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n", "    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n", "    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n", "    public static double Taneja(double[] p, double[] q)\n", "    public static double TopsoeDivergence(double[] p, double[] q)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2012\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.distance;\n\n\nimport com.harium.keel.catalano.core.IntPoint;\nimport com.harium.keel.catalano.math.Constants;\nimport com.harium.keel.catalano.math.Matrix;\n\n/**\n * Defines a set of extension methods defining distance measures.\n * References: http://www.ajmaa.org/RGMIA/papers/v7n4/Gsdmi_RGMIA.pdf\n * http://arabic-icr.googlecode.com/git/Papers/Comprehensive%20Survey%20on%20Distance-Similarity.pdf\n *\n * @author Diego Catalano\n */\npublic final class Distance\n{\n\n    /**\n     * Don't let anyone initialize this class.\n     */\n    private Distance()\n    {\n    }\n\n    ;\n\n    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double num = p[i] + q[i];\n                r += (num / 2) * Math.log(num / (2 * Math.sqrt(den)));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Bhattacharyya distance between two normalized histograms.\n     *\n     * @param histogram1 Normalized histogram.\n     * @param histogram2 Normalized histogram.\n     * @return The Bhattacharyya distance between the two histograms.\n     */\n    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n    {\n        int bins = histogram1.length; // histogram bins\n        double b = 0; // Bhattacharyya's coefficient\n\n        for (int i = 0; i < bins; i++)\n            b += Math.sqrt(histogram1[i]) * Math.sqrt(histogram2[i]);\n\n        // Bhattacharyya distance between the two distributions\n        return Math.sqrt(1.0 - b);\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double[] p, double[] q)\n    {\n        double sumP, sumN;\n        sumP = sumN = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumN += Math.abs(p[i] - q[i]);\n            sumP += Math.abs(p[i] + q[i]);\n        }\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 X2 axis coordinate.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n    {\n        double sumN = Math.abs(x1 - x2) + Math.abs(y1 - y2);\n        double sumP = Math.abs(x1 + x2) + Math.abs(y1 + y2);\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(IntPoint p, IntPoint q)\n    {\n        return BrayCurtis(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double[] p, double[] q)\n    {\n        double distance = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            distance += Math.abs(p[i] - q[i]) / (Math.abs(p[i]) + Math.abs(q[i]));\n        }\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double x1, double y1, double x2, double y2)\n    {\n        double distance;\n\n        distance = Math.abs(x1 - x2) / (Math.abs(x1) + Math.abs(x2));\n        distance += Math.abs(y1 - y2) / (Math.abs(y1) + Math.abs(y2));\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(IntPoint p, IntPoint q)\n    {\n        return Canberra(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double[] p, double[] q)\n    {\n        double max = Math.abs(p[0] - q[0]);\n\n        for (int i = 1; i < p.length; i++)\n        {\n            double abs = Math.abs(p[i] - q[i]);\n            if (abs > max) max = abs;\n        }\n\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double x1, double y1, double x2, double y2)\n    {\n        double max = Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(IntPoint p, IntPoint q)\n    {\n        return Chebyshev(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double[] x, double[] y)\n    {\n\n        double d = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            d = Math.max(d, x[i] - y[i]);\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.max(dx, dy);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(IntPoint p, IntPoint q)\n    {\n        return Chessboard(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chi Square distance between two normalized histograms.\n     *\n     * @param histogram1 Histogram.\n     * @param histogram2 Histogram.\n     * @return The Chi Square distance between x and y.\n     */\n    public static double ChiSquare(double[] histogram1, double[] histogram2)\n    {\n        double r = 0;\n        for (int i = 0; i < histogram1.length; i++)\n        {\n            double t = histogram1[i] + histogram2[i];\n            if (t != 0)\n                r += Math.pow(histogram1[i] - histogram2[i], 2) / t;\n        }\n\n        return 0.5 * r;\n    }\n\n    /**\n     * Gets the Correlation distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Correlation distance between x and y.\n     */\n    public static double Correlation(double[] p, double[] q)\n    {\n\n        double x = 0;\n        double y = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            x += -p[i];\n            y += -q[i];\n        }\n\n        x /= p.length;\n        y /= q.length;\n\n        double num = 0;\n        double den1 = 0;\n        double den2 = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            num += (p[i] + x) * (q[i] + y);\n\n            den1 += Math.abs(Math.pow(p[i] + x, 2));\n            den2 += Math.abs(Math.pow(q[i] + x, 2));\n        }\n\n        return 1 - (num / (Math.sqrt(den1) * Math.sqrt(den2)));\n\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double[] p, double[] q)\n    {\n        double sumProduct = 0;\n        double sumP = 0, sumQ = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumProduct += p[i] * q[i];\n            sumP += Math.pow(Math.abs(p[i]), 2);\n            sumQ += Math.pow(Math.abs(q[i]), 2);\n        }\n\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double x1, double y1, double x2, double y2)\n    {\n\n        double sumProduct = x1 * x2 + y1 * y2;\n        double sumP = Math.pow(Math.abs(x1), 2) + Math.pow(Math.abs(x2), 2);\n        double sumQ = Math.pow(Math.abs(y1), 2) + Math.pow(Math.abs(y2), 2);\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(IntPoint p, IntPoint q)\n    {\n        return Cosine(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double[] p, double[] q)\n    {\n        return Math.sqrt(SquaredEuclidean(p, q));\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(IntPoint p, IntPoint q)\n    {\n        return Euclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Hamming distance between two strings.\n     *\n     * @param first  First string.\n     * @param second Second string.\n     * @return The Hamming distance between p and q.\n     */\n    public static int Hamming(String first, String second)\n    {\n\n        if (first.length() != second.length())\n            throw new IllegalArgumentException(\"The size of string must be the same.\");\n\n        int diff = 0;\n        for (int i = 0; i < first.length(); i++)\n            if (first.charAt(i) != second.charAt(i))\n                diff++;\n        return diff;\n    }\n\n    /**\n     * Gets the Jaccard distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Jaccard distance between x and y.\n     */\n    public static double JaccardDistance(double[] p, double[] q)\n    {\n        double distance = 0;\n        int intersection = 0, union = 0;\n\n        for (int x = 0; x < p.length; x++)\n        {\n            if ((p[x] != 0) || (q[x] != 0))\n            {\n                if (p[x] == q[x])\n                {\n                    intersection++;\n                }\n\n                union++;\n            }\n        }\n\n        if (union != 0)\n            distance = 1.0 - ((double) intersection / (double) union);\n        else\n            distance = 0;\n\n        return distance;\n    }\n\n    /**\n     * Gets the J-Divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The J-Divergence between p and q.\n     */\n    public static double JDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += (p[i] - q[i]) * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen difference divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Jensen difference between p and q.\n     */\n    public static double JensenDifferenceDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                double pq = p[i] + q[i];\n                k += (p[i] * Math.log(p[i]) + q[i] * Math.log(q[i])) / 2 - (pq / 2) * Math.log(pq / 2);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen Shannon divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The Jensen Shannon divergence between u and v.\n     */\n    public static double JensenShannonDivergence(double[] p, double[] q)\n    {\n        double[] m = new double[p.length];\n        for (int i = 0; i < m.length; i++)\n        {\n            m[i] = (p[i] + q[i]) / 2;\n        }\n\n        return (KullbackLeiblerDivergence(p, m) + KullbackLeiblerDivergence(q, m)) / 2;\n    }\n\n    /**\n     * Gets the K-Divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The K-Divergence between u and v.\n     */\n    public static double KDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] + q[i];\n            if (den != 0 && p[i] != 0)\n                r += p[i] * Math.log(2 * p[i] / den);\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Kumar-Johnson divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kumar-Johnson divergence between p and q.\n     */\n\n    /**\n     * Gets the Kullback Leibler divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kullback Leibler divergence between u and v.\n     */\n    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += p[i] * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Mahalanobis distance.\n     *\n     * @param A Matrix A.\n     * @param B Matrix B.\n     * @return The Mahalanobis distance between A and B.\n     */\n    public static double Mahalanobis(double[][] A, double[][] B)\n    {\n\n        if (A[0].length != B[0].length)\n            throw new IllegalArgumentException(\"The number of columns of both matrix must be equals.\");\n\n        double[][] subA = new double[A.length][A[0].length];\n        double[][] subB = new double[B.length][B[0].length];\n\n        //Center data A\n        double[] meansA = new double[A[0].length];\n        for (int j = 0; j < A[0].length; j++)\n        {\n            for (int i = 0; i < A.length; i++)\n            {\n                meansA[j] += A[i][j];\n            }\n            meansA[j] /= (double) A.length;\n            for (int i = 0; i < A.length; i++)\n            {\n                subA[i][j] = A[i][j] - meansA[j];\n            }\n        }\n\n        //Center data B\n        double[] meansB = new double[B[0].length];\n        for (int j = 0; j < B[0].length; j++)\n        {\n            for (int i = 0; i < B.length; i++)\n            {\n                meansB[j] += B[i][j];\n            }\n            meansB[j] /= (double) B.length;\n            for (int i = 0; i < B.length; i++)\n            {\n                subB[i][j] = B[i][j] - meansB[j];\n            }\n        }\n\n        //Matrix of covariance\n        double[][] covA = Covariance(subA);\n        double[][] covB = Covariance(subB);\n\n        //Pooled covariance\n        double rows = subA.length + subB.length;\n        double[][] pCov = new double[covA.length][covA[0].length];\n        for (int i = 0; i < pCov.length; i++)\n        {\n            for (int j = 0; j < pCov[0].length; j++)\n            {\n                pCov[i][j] = covA[i][j] * ((double) subA.length / rows) + covB[i][j] * ((double) subB.length / rows);\n            }\n        }\n\n        //Inverse of pooled covariance\n        pCov = Matrix.Inverse(pCov);\n\n        //compute mean difference\n        double[] diff = new double[A[0].length];\n        for (int i = 0; i < diff.length; i++)\n        {\n            diff[i] = meansA[i] - meansB[i];\n        }\n\n        return Math.sqrt(Matrix.InnerProduct(Matrix.MultiplyByTranspose(pCov, diff), diff));\n\n    }\n\n    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n    {\n        double result = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            result += (x[i] - meanX) * (y[i] - meanY);\n        }\n\n        return result / (double) (x.length);\n    }\n\n    private static double[][] Covariance(double[][] matrix)\n    {\n        double[] means = new double[matrix[0].length];\n        for (int i = 0; i < matrix.length; i++)\n        {\n            for (int j = 0; j < matrix[0].length; j++)\n            {\n                means[j] += matrix[i][j];\n            }\n        }\n\n        for (int i = 0; i < means.length; i++)\n        {\n            means[i] /= means.length;\n        }\n\n        return Covariance(matrix, means);\n    }\n\n    private static double[][] Covariance(double[][] matrix, double[] means)\n    {\n        double[][] cov = new double[means.length][means.length];\n\n        for (int i = 0; i < cov.length; i++)\n        {\n            for (int j = 0; j < cov[0].length; j++)\n            {\n                cov[i][j] = Covariance(Matrix.getColumn(matrix, i), Matrix.getColumn(matrix, j), means[i], means[j]);\n            }\n        }\n\n        return cov;\n\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double[] p, double[] q)\n    {\n        double sum = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            sum += Math.abs(p[i] - q[i]);\n        }\n        return sum;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return dx + dy;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(IntPoint p, IntPoint q)\n    {\n        return Manhattan(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @param r  Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n    {\n        double sum = Math.pow(Math.abs(x1 - x2), r);\n        sum += Math.pow(Math.abs(y1 - y2), r);\n        return Math.pow(sum, 1 / r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @param r Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(IntPoint p, IntPoint q, int r)\n    {\n        return Minkowski(p.x, p.y, q.x, q.y, r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param u A point in space.\n     * @param v A point in space.\n     * @param p Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double[] u, double[] v, double p)\n    {\n        double distance = 0;\n        for (int i = 0; i < u.length; i++)\n        {\n            distance += Math.pow(Math.abs(u[i] - v[i]), p);\n        }\n        return Math.pow(distance, 1 / p);\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Quasi-Euclidean distance between x and y.\n     */\n    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        if (Math.abs(x1 - x2) > Math.abs(y1 - y2))\n        {\n            return Math.abs(x1 - x2) + (Constants.Sqrt2 - 1) * Math.abs(y1 - y2);\n        }\n        return (Constants.Sqrt2 - 1) * Math.abs(x1 - x2) + Math.abs(y1 - y2);\n\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Quasi Euclidean distance between p and q.\n     */\n    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n    {\n        return QuasiEuclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Square Euclidean distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Square Euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double[] x, double[] y)\n    {\n        double d = 0.0, u;\n\n        for (int i = 0; i < x.length; i++)\n        {\n            u = x[i] - y[i];\n            d += u * u;\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n    {\n\n        double dx = q.x - p.x;\n        double dy = q.y - p.y;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Symmetric Chi-square divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric chi-square divergence between p and q.\n     */\n    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double p1 = p[i] - q[i];\n                double p2 = p[i] + q[i];\n                r += (p1 * p1 * p2) / den;\n            }\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Symmetric Kullback-Leibler distance.\n     * This metric is valid only for real and positive P and Q.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric Kullback Leibler distance between p and q.\n     */\n    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n    {\n        double dist = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            dist += (p[i] - q[i]) * (Math.log(p[i]) - Math.log(q[i]));\n        }\n\n        return dist;\n    }\n\n    /**\n     * Gets the Taneja divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Taneja divergence between p and q.\n     */\n    public static double Taneja(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double pq = p[i] + q[i];\n                r += (pq / 2) * Math.log(pq / (2 * Math.sqrt(p[i] * q[i])));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Topsoe divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Topsoe divergence between p and q.\n     */\n    public static double TopsoeDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double den = p[i] + q[i];\n                r += p[i] * Math.log(2 * p[i] / den) + q[i] * Math.log(2 * q[i] / den);\n            }\n        }\n        return r;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/distance/Distance.java", "func_name": "Distance.KullbackLeiblerDivergence", "original_string": "public static double KullbackLeiblerDivergence(double[] p, double[] q) {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++) {\n            if (p[i] != 0 && q[i] != 0) {\n                intersection = true;\n                k += p[i] * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }", "language": "java", "code": "public static double KullbackLeiblerDivergence(double[] p, double[] q) {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++) {\n            if (p[i] != 0 && q[i] != 0) {\n                intersection = true;\n                k += p[i] * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }", "code_tokens": ["public", "static", "double", "KullbackLeiblerDivergence", "(", "double", "[", "]", "p", ",", "double", "[", "]", "q", ")", "{", "boolean", "intersection", "=", "false", ";", "double", "k", "=", "0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "p", ".", "length", ";", "i", "++", ")", "{", "if", "(", "p", "[", "i", "]", "!=", "0", "&&", "q", "[", "i", "]", "!=", "0", ")", "{", "intersection", "=", "true", ";", "k", "+=", "p", "[", "i", "]", "*", "Math", ".", "log", "(", "p", "[", "i", "]", "/", "q", "[", "i", "]", ")", ";", "}", "}", "if", "(", "intersection", ")", "return", "k", ";", "else", "return", "Double", ".", "POSITIVE_INFINITY", ";", "}"], "docstring": "Gets the Kullback Leibler divergence.\n\n@param p P vector.\n@param q Q vector.\n@return The Kullback Leibler divergence between u and v.", "docstring_tokens": ["Gets", "the", "Kullback", "Leibler", "divergence", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/distance/Distance.java#L560-L575", "partition": "train", "up_fun_num": 31, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.IntPoint;", "import com.harium.keel.catalano.math.Constants;", "import com.harium.keel.catalano.math.Matrix;"], "function": ["public final class Distance\n", "    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n", "    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n", "    public static double BrayCurtis(double[] p, double[] q)\n", "    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n", "    public static double BrayCurtis(IntPoint p, IntPoint q)\n", "    public static double Canberra(double[] p, double[] q)\n", "    public static double Canberra(double x1, double y1, double x2, double y2)\n", "    public static double Canberra(IntPoint p, IntPoint q)\n", "    public static double Chebyshev(double[] p, double[] q)\n", "    public static double Chebyshev(double x1, double y1, double x2, double y2)\n", "    public static double Chebyshev(IntPoint p, IntPoint q)\n", "    public static double Chessboard(double[] x, double[] y)\n", "    public static double Chessboard(double x1, double y1, double x2, double y2)\n", "    public static double Chessboard(IntPoint p, IntPoint q)\n", "    public static double ChiSquare(double[] histogram1, double[] histogram2)\n", "    public static double Correlation(double[] p, double[] q)\n", "    public static double Cosine(double[] p, double[] q)\n", "    public static double Cosine(double x1, double y1, double x2, double y2)\n", "    public static double Cosine(IntPoint p, IntPoint q)\n", "    public static double Euclidean(double[] p, double[] q)\n", "    public static double Euclidean(double x1, double y1, double x2, double y2)\n", "    public static double Euclidean(IntPoint p, IntPoint q)\n", "    public static int Hamming(String first, String second)\n", "    public static double JaccardDistance(double[] p, double[] q)\n", "    public static double JDivergence(double[] p, double[] q)\n", "    public static double JensenDifferenceDivergence(double[] p, double[] q)\n", "    public static double JensenShannonDivergence(double[] p, double[] q)\n", "    public static double KDivergence(double[] p, double[] q)\n", "    public static double KumarJohnsonDivergence(double[] p, double[] q)\n", "    public static double Mahalanobis(double[][] A, double[][] B)\n", "    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n", "    private static double[][] Covariance(double[][] matrix)\n", "    private static double[][] Covariance(double[][] matrix, double[] means)\n", "    public static double Manhattan(double[] p, double[] q)\n", "    public static double Manhattan(double x1, double y1, double x2, double y2)\n", "    public static double Manhattan(IntPoint p, IntPoint q)\n", "    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n", "    public static double Minkowski(IntPoint p, IntPoint q, int r)\n", "    public static double Minkowski(double[] u, double[] v, double p)\n", "    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n", "    public static double SquaredEuclidean(double[] x, double[] y)\n", "    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n", "    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n", "    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n", "    public static double Taneja(double[] p, double[] q)\n", "    public static double TopsoeDivergence(double[] p, double[] q)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2012\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.distance;\n\n\nimport com.harium.keel.catalano.core.IntPoint;\nimport com.harium.keel.catalano.math.Constants;\nimport com.harium.keel.catalano.math.Matrix;\n\n/**\n * Defines a set of extension methods defining distance measures.\n * References: http://www.ajmaa.org/RGMIA/papers/v7n4/Gsdmi_RGMIA.pdf\n * http://arabic-icr.googlecode.com/git/Papers/Comprehensive%20Survey%20on%20Distance-Similarity.pdf\n *\n * @author Diego Catalano\n */\npublic final class Distance\n{\n\n    /**\n     * Don't let anyone initialize this class.\n     */\n    private Distance()\n    {\n    }\n\n    ;\n\n    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double num = p[i] + q[i];\n                r += (num / 2) * Math.log(num / (2 * Math.sqrt(den)));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Bhattacharyya distance between two normalized histograms.\n     *\n     * @param histogram1 Normalized histogram.\n     * @param histogram2 Normalized histogram.\n     * @return The Bhattacharyya distance between the two histograms.\n     */\n    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n    {\n        int bins = histogram1.length; // histogram bins\n        double b = 0; // Bhattacharyya's coefficient\n\n        for (int i = 0; i < bins; i++)\n            b += Math.sqrt(histogram1[i]) * Math.sqrt(histogram2[i]);\n\n        // Bhattacharyya distance between the two distributions\n        return Math.sqrt(1.0 - b);\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double[] p, double[] q)\n    {\n        double sumP, sumN;\n        sumP = sumN = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumN += Math.abs(p[i] - q[i]);\n            sumP += Math.abs(p[i] + q[i]);\n        }\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 X2 axis coordinate.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n    {\n        double sumN = Math.abs(x1 - x2) + Math.abs(y1 - y2);\n        double sumP = Math.abs(x1 + x2) + Math.abs(y1 + y2);\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(IntPoint p, IntPoint q)\n    {\n        return BrayCurtis(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double[] p, double[] q)\n    {\n        double distance = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            distance += Math.abs(p[i] - q[i]) / (Math.abs(p[i]) + Math.abs(q[i]));\n        }\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double x1, double y1, double x2, double y2)\n    {\n        double distance;\n\n        distance = Math.abs(x1 - x2) / (Math.abs(x1) + Math.abs(x2));\n        distance += Math.abs(y1 - y2) / (Math.abs(y1) + Math.abs(y2));\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(IntPoint p, IntPoint q)\n    {\n        return Canberra(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double[] p, double[] q)\n    {\n        double max = Math.abs(p[0] - q[0]);\n\n        for (int i = 1; i < p.length; i++)\n        {\n            double abs = Math.abs(p[i] - q[i]);\n            if (abs > max) max = abs;\n        }\n\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double x1, double y1, double x2, double y2)\n    {\n        double max = Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(IntPoint p, IntPoint q)\n    {\n        return Chebyshev(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double[] x, double[] y)\n    {\n\n        double d = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            d = Math.max(d, x[i] - y[i]);\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.max(dx, dy);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(IntPoint p, IntPoint q)\n    {\n        return Chessboard(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chi Square distance between two normalized histograms.\n     *\n     * @param histogram1 Histogram.\n     * @param histogram2 Histogram.\n     * @return The Chi Square distance between x and y.\n     */\n    public static double ChiSquare(double[] histogram1, double[] histogram2)\n    {\n        double r = 0;\n        for (int i = 0; i < histogram1.length; i++)\n        {\n            double t = histogram1[i] + histogram2[i];\n            if (t != 0)\n                r += Math.pow(histogram1[i] - histogram2[i], 2) / t;\n        }\n\n        return 0.5 * r;\n    }\n\n    /**\n     * Gets the Correlation distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Correlation distance between x and y.\n     */\n    public static double Correlation(double[] p, double[] q)\n    {\n\n        double x = 0;\n        double y = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            x += -p[i];\n            y += -q[i];\n        }\n\n        x /= p.length;\n        y /= q.length;\n\n        double num = 0;\n        double den1 = 0;\n        double den2 = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            num += (p[i] + x) * (q[i] + y);\n\n            den1 += Math.abs(Math.pow(p[i] + x, 2));\n            den2 += Math.abs(Math.pow(q[i] + x, 2));\n        }\n\n        return 1 - (num / (Math.sqrt(den1) * Math.sqrt(den2)));\n\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double[] p, double[] q)\n    {\n        double sumProduct = 0;\n        double sumP = 0, sumQ = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumProduct += p[i] * q[i];\n            sumP += Math.pow(Math.abs(p[i]), 2);\n            sumQ += Math.pow(Math.abs(q[i]), 2);\n        }\n\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double x1, double y1, double x2, double y2)\n    {\n\n        double sumProduct = x1 * x2 + y1 * y2;\n        double sumP = Math.pow(Math.abs(x1), 2) + Math.pow(Math.abs(x2), 2);\n        double sumQ = Math.pow(Math.abs(y1), 2) + Math.pow(Math.abs(y2), 2);\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(IntPoint p, IntPoint q)\n    {\n        return Cosine(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double[] p, double[] q)\n    {\n        return Math.sqrt(SquaredEuclidean(p, q));\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(IntPoint p, IntPoint q)\n    {\n        return Euclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Hamming distance between two strings.\n     *\n     * @param first  First string.\n     * @param second Second string.\n     * @return The Hamming distance between p and q.\n     */\n    public static int Hamming(String first, String second)\n    {\n\n        if (first.length() != second.length())\n            throw new IllegalArgumentException(\"The size of string must be the same.\");\n\n        int diff = 0;\n        for (int i = 0; i < first.length(); i++)\n            if (first.charAt(i) != second.charAt(i))\n                diff++;\n        return diff;\n    }\n\n    /**\n     * Gets the Jaccard distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Jaccard distance between x and y.\n     */\n    public static double JaccardDistance(double[] p, double[] q)\n    {\n        double distance = 0;\n        int intersection = 0, union = 0;\n\n        for (int x = 0; x < p.length; x++)\n        {\n            if ((p[x] != 0) || (q[x] != 0))\n            {\n                if (p[x] == q[x])\n                {\n                    intersection++;\n                }\n\n                union++;\n            }\n        }\n\n        if (union != 0)\n            distance = 1.0 - ((double) intersection / (double) union);\n        else\n            distance = 0;\n\n        return distance;\n    }\n\n    /**\n     * Gets the J-Divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The J-Divergence between p and q.\n     */\n    public static double JDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += (p[i] - q[i]) * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen difference divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Jensen difference between p and q.\n     */\n    public static double JensenDifferenceDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                double pq = p[i] + q[i];\n                k += (p[i] * Math.log(p[i]) + q[i] * Math.log(q[i])) / 2 - (pq / 2) * Math.log(pq / 2);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen Shannon divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The Jensen Shannon divergence between u and v.\n     */\n    public static double JensenShannonDivergence(double[] p, double[] q)\n    {\n        double[] m = new double[p.length];\n        for (int i = 0; i < m.length; i++)\n        {\n            m[i] = (p[i] + q[i]) / 2;\n        }\n\n        return (KullbackLeiblerDivergence(p, m) + KullbackLeiblerDivergence(q, m)) / 2;\n    }\n\n    /**\n     * Gets the K-Divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The K-Divergence between u and v.\n     */\n    public static double KDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] + q[i];\n            if (den != 0 && p[i] != 0)\n                r += p[i] * Math.log(2 * p[i] / den);\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Kumar-Johnson divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kumar-Johnson divergence between p and q.\n     */\n    public static double KumarJohnsonDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                r += Math.pow(p[i] * p[i] - q[i] * q[i], 2) / 2 * Math.pow(p[i] * q[i], 1.5);\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Kullback Leibler divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kullback Leibler divergence between u and v.\n     */\n\n    /**\n     * Gets the Mahalanobis distance.\n     *\n     * @param A Matrix A.\n     * @param B Matrix B.\n     * @return The Mahalanobis distance between A and B.\n     */\n    public static double Mahalanobis(double[][] A, double[][] B)\n    {\n\n        if (A[0].length != B[0].length)\n            throw new IllegalArgumentException(\"The number of columns of both matrix must be equals.\");\n\n        double[][] subA = new double[A.length][A[0].length];\n        double[][] subB = new double[B.length][B[0].length];\n\n        //Center data A\n        double[] meansA = new double[A[0].length];\n        for (int j = 0; j < A[0].length; j++)\n        {\n            for (int i = 0; i < A.length; i++)\n            {\n                meansA[j] += A[i][j];\n            }\n            meansA[j] /= (double) A.length;\n            for (int i = 0; i < A.length; i++)\n            {\n                subA[i][j] = A[i][j] - meansA[j];\n            }\n        }\n\n        //Center data B\n        double[] meansB = new double[B[0].length];\n        for (int j = 0; j < B[0].length; j++)\n        {\n            for (int i = 0; i < B.length; i++)\n            {\n                meansB[j] += B[i][j];\n            }\n            meansB[j] /= (double) B.length;\n            for (int i = 0; i < B.length; i++)\n            {\n                subB[i][j] = B[i][j] - meansB[j];\n            }\n        }\n\n        //Matrix of covariance\n        double[][] covA = Covariance(subA);\n        double[][] covB = Covariance(subB);\n\n        //Pooled covariance\n        double rows = subA.length + subB.length;\n        double[][] pCov = new double[covA.length][covA[0].length];\n        for (int i = 0; i < pCov.length; i++)\n        {\n            for (int j = 0; j < pCov[0].length; j++)\n            {\n                pCov[i][j] = covA[i][j] * ((double) subA.length / rows) + covB[i][j] * ((double) subB.length / rows);\n            }\n        }\n\n        //Inverse of pooled covariance\n        pCov = Matrix.Inverse(pCov);\n\n        //compute mean difference\n        double[] diff = new double[A[0].length];\n        for (int i = 0; i < diff.length; i++)\n        {\n            diff[i] = meansA[i] - meansB[i];\n        }\n\n        return Math.sqrt(Matrix.InnerProduct(Matrix.MultiplyByTranspose(pCov, diff), diff));\n\n    }\n\n    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n    {\n        double result = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            result += (x[i] - meanX) * (y[i] - meanY);\n        }\n\n        return result / (double) (x.length);\n    }\n\n    private static double[][] Covariance(double[][] matrix)\n    {\n        double[] means = new double[matrix[0].length];\n        for (int i = 0; i < matrix.length; i++)\n        {\n            for (int j = 0; j < matrix[0].length; j++)\n            {\n                means[j] += matrix[i][j];\n            }\n        }\n\n        for (int i = 0; i < means.length; i++)\n        {\n            means[i] /= means.length;\n        }\n\n        return Covariance(matrix, means);\n    }\n\n    private static double[][] Covariance(double[][] matrix, double[] means)\n    {\n        double[][] cov = new double[means.length][means.length];\n\n        for (int i = 0; i < cov.length; i++)\n        {\n            for (int j = 0; j < cov[0].length; j++)\n            {\n                cov[i][j] = Covariance(Matrix.getColumn(matrix, i), Matrix.getColumn(matrix, j), means[i], means[j]);\n            }\n        }\n\n        return cov;\n\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double[] p, double[] q)\n    {\n        double sum = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            sum += Math.abs(p[i] - q[i]);\n        }\n        return sum;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return dx + dy;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(IntPoint p, IntPoint q)\n    {\n        return Manhattan(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @param r  Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n    {\n        double sum = Math.pow(Math.abs(x1 - x2), r);\n        sum += Math.pow(Math.abs(y1 - y2), r);\n        return Math.pow(sum, 1 / r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @param r Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(IntPoint p, IntPoint q, int r)\n    {\n        return Minkowski(p.x, p.y, q.x, q.y, r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param u A point in space.\n     * @param v A point in space.\n     * @param p Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double[] u, double[] v, double p)\n    {\n        double distance = 0;\n        for (int i = 0; i < u.length; i++)\n        {\n            distance += Math.pow(Math.abs(u[i] - v[i]), p);\n        }\n        return Math.pow(distance, 1 / p);\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Quasi-Euclidean distance between x and y.\n     */\n    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        if (Math.abs(x1 - x2) > Math.abs(y1 - y2))\n        {\n            return Math.abs(x1 - x2) + (Constants.Sqrt2 - 1) * Math.abs(y1 - y2);\n        }\n        return (Constants.Sqrt2 - 1) * Math.abs(x1 - x2) + Math.abs(y1 - y2);\n\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Quasi Euclidean distance between p and q.\n     */\n    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n    {\n        return QuasiEuclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Square Euclidean distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Square Euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double[] x, double[] y)\n    {\n        double d = 0.0, u;\n\n        for (int i = 0; i < x.length; i++)\n        {\n            u = x[i] - y[i];\n            d += u * u;\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n    {\n\n        double dx = q.x - p.x;\n        double dy = q.y - p.y;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Symmetric Chi-square divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric chi-square divergence between p and q.\n     */\n    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double p1 = p[i] - q[i];\n                double p2 = p[i] + q[i];\n                r += (p1 * p1 * p2) / den;\n            }\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Symmetric Kullback-Leibler distance.\n     * This metric is valid only for real and positive P and Q.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric Kullback Leibler distance between p and q.\n     */\n    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n    {\n        double dist = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            dist += (p[i] - q[i]) * (Math.log(p[i]) - Math.log(q[i]));\n        }\n\n        return dist;\n    }\n\n    /**\n     * Gets the Taneja divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Taneja divergence between p and q.\n     */\n    public static double Taneja(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double pq = p[i] + q[i];\n                r += (pq / 2) * Math.log(pq / (2 * Math.sqrt(p[i] * q[i])));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Topsoe divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Topsoe divergence between p and q.\n     */\n    public static double TopsoeDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double den = p[i] + q[i];\n                r += p[i] * Math.log(2 * p[i] / den) + q[i] * Math.log(2 * q[i] / den);\n            }\n        }\n        return r;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/distance/Distance.java", "func_name": "Distance.SquaredEuclidean", "original_string": "public static double SquaredEuclidean(double[] x, double[] y) {\n        double d = 0.0, u;\n\n        for (int i = 0; i < x.length; i++) {\n            u = x[i] - y[i];\n            d += u * u;\n        }\n\n        return d;\n    }", "language": "java", "code": "public static double SquaredEuclidean(double[] x, double[] y) {\n        double d = 0.0, u;\n\n        for (int i = 0; i < x.length; i++) {\n            u = x[i] - y[i];\n            d += u * u;\n        }\n\n        return d;\n    }", "code_tokens": ["public", "static", "double", "SquaredEuclidean", "(", "double", "[", "]", "x", ",", "double", "[", "]", "y", ")", "{", "double", "d", "=", "0.0", ",", "u", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "x", ".", "length", ";", "i", "++", ")", "{", "u", "=", "x", "[", "i", "]", "-", "y", "[", "i", "]", ";", "d", "+=", "u", "*", "u", ";", "}", "return", "d", ";", "}"], "docstring": "Gets the Square Euclidean distance between two points.\n\n@param x A point in space.\n@param y A point in space.\n@return The Square Euclidean distance between x and y.", "docstring_tokens": ["Gets", "the", "Square", "Euclidean", "distance", "between", "two", "points", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/distance/Distance.java#L801-L810", "partition": "train", "up_fun_num": 44, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.IntPoint;", "import com.harium.keel.catalano.math.Constants;", "import com.harium.keel.catalano.math.Matrix;"], "function": ["public final class Distance\n", "    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n", "    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n", "    public static double BrayCurtis(double[] p, double[] q)\n", "    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n", "    public static double BrayCurtis(IntPoint p, IntPoint q)\n", "    public static double Canberra(double[] p, double[] q)\n", "    public static double Canberra(double x1, double y1, double x2, double y2)\n", "    public static double Canberra(IntPoint p, IntPoint q)\n", "    public static double Chebyshev(double[] p, double[] q)\n", "    public static double Chebyshev(double x1, double y1, double x2, double y2)\n", "    public static double Chebyshev(IntPoint p, IntPoint q)\n", "    public static double Chessboard(double[] x, double[] y)\n", "    public static double Chessboard(double x1, double y1, double x2, double y2)\n", "    public static double Chessboard(IntPoint p, IntPoint q)\n", "    public static double ChiSquare(double[] histogram1, double[] histogram2)\n", "    public static double Correlation(double[] p, double[] q)\n", "    public static double Cosine(double[] p, double[] q)\n", "    public static double Cosine(double x1, double y1, double x2, double y2)\n", "    public static double Cosine(IntPoint p, IntPoint q)\n", "    public static double Euclidean(double[] p, double[] q)\n", "    public static double Euclidean(double x1, double y1, double x2, double y2)\n", "    public static double Euclidean(IntPoint p, IntPoint q)\n", "    public static int Hamming(String first, String second)\n", "    public static double JaccardDistance(double[] p, double[] q)\n", "    public static double JDivergence(double[] p, double[] q)\n", "    public static double JensenDifferenceDivergence(double[] p, double[] q)\n", "    public static double JensenShannonDivergence(double[] p, double[] q)\n", "    public static double KDivergence(double[] p, double[] q)\n", "    public static double KumarJohnsonDivergence(double[] p, double[] q)\n", "    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n", "    public static double Mahalanobis(double[][] A, double[][] B)\n", "    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n", "    private static double[][] Covariance(double[][] matrix)\n", "    private static double[][] Covariance(double[][] matrix, double[] means)\n", "    public static double Manhattan(double[] p, double[] q)\n", "    public static double Manhattan(double x1, double y1, double x2, double y2)\n", "    public static double Manhattan(IntPoint p, IntPoint q)\n", "    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n", "    public static double Minkowski(IntPoint p, IntPoint q, int r)\n", "    public static double Minkowski(double[] u, double[] v, double p)\n", "    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n", "    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n", "    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n", "    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n", "    public static double Taneja(double[] p, double[] q)\n", "    public static double TopsoeDivergence(double[] p, double[] q)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2012\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.distance;\n\n\nimport com.harium.keel.catalano.core.IntPoint;\nimport com.harium.keel.catalano.math.Constants;\nimport com.harium.keel.catalano.math.Matrix;\n\n/**\n * Defines a set of extension methods defining distance measures.\n * References: http://www.ajmaa.org/RGMIA/papers/v7n4/Gsdmi_RGMIA.pdf\n * http://arabic-icr.googlecode.com/git/Papers/Comprehensive%20Survey%20on%20Distance-Similarity.pdf\n *\n * @author Diego Catalano\n */\npublic final class Distance\n{\n\n    /**\n     * Don't let anyone initialize this class.\n     */\n    private Distance()\n    {\n    }\n\n    ;\n\n    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double num = p[i] + q[i];\n                r += (num / 2) * Math.log(num / (2 * Math.sqrt(den)));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Bhattacharyya distance between two normalized histograms.\n     *\n     * @param histogram1 Normalized histogram.\n     * @param histogram2 Normalized histogram.\n     * @return The Bhattacharyya distance between the two histograms.\n     */\n    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n    {\n        int bins = histogram1.length; // histogram bins\n        double b = 0; // Bhattacharyya's coefficient\n\n        for (int i = 0; i < bins; i++)\n            b += Math.sqrt(histogram1[i]) * Math.sqrt(histogram2[i]);\n\n        // Bhattacharyya distance between the two distributions\n        return Math.sqrt(1.0 - b);\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double[] p, double[] q)\n    {\n        double sumP, sumN;\n        sumP = sumN = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumN += Math.abs(p[i] - q[i]);\n            sumP += Math.abs(p[i] + q[i]);\n        }\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 X2 axis coordinate.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n    {\n        double sumN = Math.abs(x1 - x2) + Math.abs(y1 - y2);\n        double sumP = Math.abs(x1 + x2) + Math.abs(y1 + y2);\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(IntPoint p, IntPoint q)\n    {\n        return BrayCurtis(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double[] p, double[] q)\n    {\n        double distance = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            distance += Math.abs(p[i] - q[i]) / (Math.abs(p[i]) + Math.abs(q[i]));\n        }\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double x1, double y1, double x2, double y2)\n    {\n        double distance;\n\n        distance = Math.abs(x1 - x2) / (Math.abs(x1) + Math.abs(x2));\n        distance += Math.abs(y1 - y2) / (Math.abs(y1) + Math.abs(y2));\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(IntPoint p, IntPoint q)\n    {\n        return Canberra(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double[] p, double[] q)\n    {\n        double max = Math.abs(p[0] - q[0]);\n\n        for (int i = 1; i < p.length; i++)\n        {\n            double abs = Math.abs(p[i] - q[i]);\n            if (abs > max) max = abs;\n        }\n\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double x1, double y1, double x2, double y2)\n    {\n        double max = Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(IntPoint p, IntPoint q)\n    {\n        return Chebyshev(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double[] x, double[] y)\n    {\n\n        double d = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            d = Math.max(d, x[i] - y[i]);\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.max(dx, dy);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(IntPoint p, IntPoint q)\n    {\n        return Chessboard(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chi Square distance between two normalized histograms.\n     *\n     * @param histogram1 Histogram.\n     * @param histogram2 Histogram.\n     * @return The Chi Square distance between x and y.\n     */\n    public static double ChiSquare(double[] histogram1, double[] histogram2)\n    {\n        double r = 0;\n        for (int i = 0; i < histogram1.length; i++)\n        {\n            double t = histogram1[i] + histogram2[i];\n            if (t != 0)\n                r += Math.pow(histogram1[i] - histogram2[i], 2) / t;\n        }\n\n        return 0.5 * r;\n    }\n\n    /**\n     * Gets the Correlation distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Correlation distance between x and y.\n     */\n    public static double Correlation(double[] p, double[] q)\n    {\n\n        double x = 0;\n        double y = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            x += -p[i];\n            y += -q[i];\n        }\n\n        x /= p.length;\n        y /= q.length;\n\n        double num = 0;\n        double den1 = 0;\n        double den2 = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            num += (p[i] + x) * (q[i] + y);\n\n            den1 += Math.abs(Math.pow(p[i] + x, 2));\n            den2 += Math.abs(Math.pow(q[i] + x, 2));\n        }\n\n        return 1 - (num / (Math.sqrt(den1) * Math.sqrt(den2)));\n\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double[] p, double[] q)\n    {\n        double sumProduct = 0;\n        double sumP = 0, sumQ = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumProduct += p[i] * q[i];\n            sumP += Math.pow(Math.abs(p[i]), 2);\n            sumQ += Math.pow(Math.abs(q[i]), 2);\n        }\n\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double x1, double y1, double x2, double y2)\n    {\n\n        double sumProduct = x1 * x2 + y1 * y2;\n        double sumP = Math.pow(Math.abs(x1), 2) + Math.pow(Math.abs(x2), 2);\n        double sumQ = Math.pow(Math.abs(y1), 2) + Math.pow(Math.abs(y2), 2);\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(IntPoint p, IntPoint q)\n    {\n        return Cosine(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double[] p, double[] q)\n    {\n        return Math.sqrt(SquaredEuclidean(p, q));\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(IntPoint p, IntPoint q)\n    {\n        return Euclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Hamming distance between two strings.\n     *\n     * @param first  First string.\n     * @param second Second string.\n     * @return The Hamming distance between p and q.\n     */\n    public static int Hamming(String first, String second)\n    {\n\n        if (first.length() != second.length())\n            throw new IllegalArgumentException(\"The size of string must be the same.\");\n\n        int diff = 0;\n        for (int i = 0; i < first.length(); i++)\n            if (first.charAt(i) != second.charAt(i))\n                diff++;\n        return diff;\n    }\n\n    /**\n     * Gets the Jaccard distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Jaccard distance between x and y.\n     */\n    public static double JaccardDistance(double[] p, double[] q)\n    {\n        double distance = 0;\n        int intersection = 0, union = 0;\n\n        for (int x = 0; x < p.length; x++)\n        {\n            if ((p[x] != 0) || (q[x] != 0))\n            {\n                if (p[x] == q[x])\n                {\n                    intersection++;\n                }\n\n                union++;\n            }\n        }\n\n        if (union != 0)\n            distance = 1.0 - ((double) intersection / (double) union);\n        else\n            distance = 0;\n\n        return distance;\n    }\n\n    /**\n     * Gets the J-Divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The J-Divergence between p and q.\n     */\n    public static double JDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += (p[i] - q[i]) * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen difference divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Jensen difference between p and q.\n     */\n    public static double JensenDifferenceDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                double pq = p[i] + q[i];\n                k += (p[i] * Math.log(p[i]) + q[i] * Math.log(q[i])) / 2 - (pq / 2) * Math.log(pq / 2);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen Shannon divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The Jensen Shannon divergence between u and v.\n     */\n    public static double JensenShannonDivergence(double[] p, double[] q)\n    {\n        double[] m = new double[p.length];\n        for (int i = 0; i < m.length; i++)\n        {\n            m[i] = (p[i] + q[i]) / 2;\n        }\n\n        return (KullbackLeiblerDivergence(p, m) + KullbackLeiblerDivergence(q, m)) / 2;\n    }\n\n    /**\n     * Gets the K-Divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The K-Divergence between u and v.\n     */\n    public static double KDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] + q[i];\n            if (den != 0 && p[i] != 0)\n                r += p[i] * Math.log(2 * p[i] / den);\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Kumar-Johnson divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kumar-Johnson divergence between p and q.\n     */\n    public static double KumarJohnsonDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                r += Math.pow(p[i] * p[i] - q[i] * q[i], 2) / 2 * Math.pow(p[i] * q[i], 1.5);\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Kullback Leibler divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kullback Leibler divergence between u and v.\n     */\n    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += p[i] * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Mahalanobis distance.\n     *\n     * @param A Matrix A.\n     * @param B Matrix B.\n     * @return The Mahalanobis distance between A and B.\n     */\n    public static double Mahalanobis(double[][] A, double[][] B)\n    {\n\n        if (A[0].length != B[0].length)\n            throw new IllegalArgumentException(\"The number of columns of both matrix must be equals.\");\n\n        double[][] subA = new double[A.length][A[0].length];\n        double[][] subB = new double[B.length][B[0].length];\n\n        //Center data A\n        double[] meansA = new double[A[0].length];\n        for (int j = 0; j < A[0].length; j++)\n        {\n            for (int i = 0; i < A.length; i++)\n            {\n                meansA[j] += A[i][j];\n            }\n            meansA[j] /= (double) A.length;\n            for (int i = 0; i < A.length; i++)\n            {\n                subA[i][j] = A[i][j] - meansA[j];\n            }\n        }\n\n        //Center data B\n        double[] meansB = new double[B[0].length];\n        for (int j = 0; j < B[0].length; j++)\n        {\n            for (int i = 0; i < B.length; i++)\n            {\n                meansB[j] += B[i][j];\n            }\n            meansB[j] /= (double) B.length;\n            for (int i = 0; i < B.length; i++)\n            {\n                subB[i][j] = B[i][j] - meansB[j];\n            }\n        }\n\n        //Matrix of covariance\n        double[][] covA = Covariance(subA);\n        double[][] covB = Covariance(subB);\n\n        //Pooled covariance\n        double rows = subA.length + subB.length;\n        double[][] pCov = new double[covA.length][covA[0].length];\n        for (int i = 0; i < pCov.length; i++)\n        {\n            for (int j = 0; j < pCov[0].length; j++)\n            {\n                pCov[i][j] = covA[i][j] * ((double) subA.length / rows) + covB[i][j] * ((double) subB.length / rows);\n            }\n        }\n\n        //Inverse of pooled covariance\n        pCov = Matrix.Inverse(pCov);\n\n        //compute mean difference\n        double[] diff = new double[A[0].length];\n        for (int i = 0; i < diff.length; i++)\n        {\n            diff[i] = meansA[i] - meansB[i];\n        }\n\n        return Math.sqrt(Matrix.InnerProduct(Matrix.MultiplyByTranspose(pCov, diff), diff));\n\n    }\n\n    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n    {\n        double result = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            result += (x[i] - meanX) * (y[i] - meanY);\n        }\n\n        return result / (double) (x.length);\n    }\n\n    private static double[][] Covariance(double[][] matrix)\n    {\n        double[] means = new double[matrix[0].length];\n        for (int i = 0; i < matrix.length; i++)\n        {\n            for (int j = 0; j < matrix[0].length; j++)\n            {\n                means[j] += matrix[i][j];\n            }\n        }\n\n        for (int i = 0; i < means.length; i++)\n        {\n            means[i] /= means.length;\n        }\n\n        return Covariance(matrix, means);\n    }\n\n    private static double[][] Covariance(double[][] matrix, double[] means)\n    {\n        double[][] cov = new double[means.length][means.length];\n\n        for (int i = 0; i < cov.length; i++)\n        {\n            for (int j = 0; j < cov[0].length; j++)\n            {\n                cov[i][j] = Covariance(Matrix.getColumn(matrix, i), Matrix.getColumn(matrix, j), means[i], means[j]);\n            }\n        }\n\n        return cov;\n\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double[] p, double[] q)\n    {\n        double sum = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            sum += Math.abs(p[i] - q[i]);\n        }\n        return sum;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return dx + dy;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(IntPoint p, IntPoint q)\n    {\n        return Manhattan(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @param r  Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n    {\n        double sum = Math.pow(Math.abs(x1 - x2), r);\n        sum += Math.pow(Math.abs(y1 - y2), r);\n        return Math.pow(sum, 1 / r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @param r Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(IntPoint p, IntPoint q, int r)\n    {\n        return Minkowski(p.x, p.y, q.x, q.y, r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param u A point in space.\n     * @param v A point in space.\n     * @param p Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double[] u, double[] v, double p)\n    {\n        double distance = 0;\n        for (int i = 0; i < u.length; i++)\n        {\n            distance += Math.pow(Math.abs(u[i] - v[i]), p);\n        }\n        return Math.pow(distance, 1 / p);\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Quasi-Euclidean distance between x and y.\n     */\n    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        if (Math.abs(x1 - x2) > Math.abs(y1 - y2))\n        {\n            return Math.abs(x1 - x2) + (Constants.Sqrt2 - 1) * Math.abs(y1 - y2);\n        }\n        return (Constants.Sqrt2 - 1) * Math.abs(x1 - x2) + Math.abs(y1 - y2);\n\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Quasi Euclidean distance between p and q.\n     */\n    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n    {\n        return QuasiEuclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Square Euclidean distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Square Euclidean distance between x and y.\n     */\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n    {\n\n        double dx = q.x - p.x;\n        double dy = q.y - p.y;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Symmetric Chi-square divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric chi-square divergence between p and q.\n     */\n    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double p1 = p[i] - q[i];\n                double p2 = p[i] + q[i];\n                r += (p1 * p1 * p2) / den;\n            }\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Symmetric Kullback-Leibler distance.\n     * This metric is valid only for real and positive P and Q.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric Kullback Leibler distance between p and q.\n     */\n    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n    {\n        double dist = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            dist += (p[i] - q[i]) * (Math.log(p[i]) - Math.log(q[i]));\n        }\n\n        return dist;\n    }\n\n    /**\n     * Gets the Taneja divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Taneja divergence between p and q.\n     */\n    public static double Taneja(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double pq = p[i] + q[i];\n                r += (pq / 2) * Math.log(pq / (2 * Math.sqrt(p[i] * q[i])));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Topsoe divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Topsoe divergence between p and q.\n     */\n    public static double TopsoeDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double den = p[i] + q[i];\n                r += p[i] * Math.log(2 * p[i] / den) + q[i] * Math.log(2 * q[i] / den);\n            }\n        }\n        return r;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/distance/Distance.java", "func_name": "Distance.SymmetricChiSquareDivergence", "original_string": "public static double SymmetricChiSquareDivergence(double[] p, double[] q) {\n        double r = 0;\n        for (int i = 0; i < p.length; i++) {\n            double den = p[i] * q[i];\n            if (den != 0) {\n                double p1 = p[i] - q[i];\n                double p2 = p[i] + q[i];\n                r += (p1 * p1 * p2) / den;\n            }\n        }\n\n        return r;\n    }", "language": "java", "code": "public static double SymmetricChiSquareDivergence(double[] p, double[] q) {\n        double r = 0;\n        for (int i = 0; i < p.length; i++) {\n            double den = p[i] * q[i];\n            if (den != 0) {\n                double p1 = p[i] - q[i];\n                double p2 = p[i] + q[i];\n                r += (p1 * p1 * p2) / den;\n            }\n        }\n\n        return r;\n    }", "code_tokens": ["public", "static", "double", "SymmetricChiSquareDivergence", "(", "double", "[", "]", "p", ",", "double", "[", "]", "q", ")", "{", "double", "r", "=", "0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "p", ".", "length", ";", "i", "++", ")", "{", "double", "den", "=", "p", "[", "i", "]", "*", "q", "[", "i", "]", ";", "if", "(", "den", "!=", "0", ")", "{", "double", "p1", "=", "p", "[", "i", "]", "-", "q", "[", "i", "]", ";", "double", "p2", "=", "p", "[", "i", "]", "+", "q", "[", "i", "]", ";", "r", "+=", "(", "p1", "*", "p1", "*", "p2", ")", "/", "den", ";", "}", "}", "return", "r", ";", "}"], "docstring": "Gets the Symmetric Chi-square divergence.\n\n@param p P vector.\n@param q Q vector.\n@return The Symmetric chi-square divergence between p and q.", "docstring_tokens": ["Gets", "the", "Symmetric", "Chi", "-", "square", "divergence", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/distance/Distance.java#L851-L863", "partition": "train", "up_fun_num": 47, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.IntPoint;", "import com.harium.keel.catalano.math.Constants;", "import com.harium.keel.catalano.math.Matrix;"], "function": ["public final class Distance\n", "    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n", "    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n", "    public static double BrayCurtis(double[] p, double[] q)\n", "    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n", "    public static double BrayCurtis(IntPoint p, IntPoint q)\n", "    public static double Canberra(double[] p, double[] q)\n", "    public static double Canberra(double x1, double y1, double x2, double y2)\n", "    public static double Canberra(IntPoint p, IntPoint q)\n", "    public static double Chebyshev(double[] p, double[] q)\n", "    public static double Chebyshev(double x1, double y1, double x2, double y2)\n", "    public static double Chebyshev(IntPoint p, IntPoint q)\n", "    public static double Chessboard(double[] x, double[] y)\n", "    public static double Chessboard(double x1, double y1, double x2, double y2)\n", "    public static double Chessboard(IntPoint p, IntPoint q)\n", "    public static double ChiSquare(double[] histogram1, double[] histogram2)\n", "    public static double Correlation(double[] p, double[] q)\n", "    public static double Cosine(double[] p, double[] q)\n", "    public static double Cosine(double x1, double y1, double x2, double y2)\n", "    public static double Cosine(IntPoint p, IntPoint q)\n", "    public static double Euclidean(double[] p, double[] q)\n", "    public static double Euclidean(double x1, double y1, double x2, double y2)\n", "    public static double Euclidean(IntPoint p, IntPoint q)\n", "    public static int Hamming(String first, String second)\n", "    public static double JaccardDistance(double[] p, double[] q)\n", "    public static double JDivergence(double[] p, double[] q)\n", "    public static double JensenDifferenceDivergence(double[] p, double[] q)\n", "    public static double JensenShannonDivergence(double[] p, double[] q)\n", "    public static double KDivergence(double[] p, double[] q)\n", "    public static double KumarJohnsonDivergence(double[] p, double[] q)\n", "    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n", "    public static double Mahalanobis(double[][] A, double[][] B)\n", "    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n", "    private static double[][] Covariance(double[][] matrix)\n", "    private static double[][] Covariance(double[][] matrix, double[] means)\n", "    public static double Manhattan(double[] p, double[] q)\n", "    public static double Manhattan(double x1, double y1, double x2, double y2)\n", "    public static double Manhattan(IntPoint p, IntPoint q)\n", "    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n", "    public static double Minkowski(IntPoint p, IntPoint q, int r)\n", "    public static double Minkowski(double[] u, double[] v, double p)\n", "    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n", "    public static double SquaredEuclidean(double[] x, double[] y)\n", "    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n", "    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n", "    public static double Taneja(double[] p, double[] q)\n", "    public static double TopsoeDivergence(double[] p, double[] q)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2012\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.distance;\n\n\nimport com.harium.keel.catalano.core.IntPoint;\nimport com.harium.keel.catalano.math.Constants;\nimport com.harium.keel.catalano.math.Matrix;\n\n/**\n * Defines a set of extension methods defining distance measures.\n * References: http://www.ajmaa.org/RGMIA/papers/v7n4/Gsdmi_RGMIA.pdf\n * http://arabic-icr.googlecode.com/git/Papers/Comprehensive%20Survey%20on%20Distance-Similarity.pdf\n *\n * @author Diego Catalano\n */\npublic final class Distance\n{\n\n    /**\n     * Don't let anyone initialize this class.\n     */\n    private Distance()\n    {\n    }\n\n    ;\n\n    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double num = p[i] + q[i];\n                r += (num / 2) * Math.log(num / (2 * Math.sqrt(den)));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Bhattacharyya distance between two normalized histograms.\n     *\n     * @param histogram1 Normalized histogram.\n     * @param histogram2 Normalized histogram.\n     * @return The Bhattacharyya distance between the two histograms.\n     */\n    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n    {\n        int bins = histogram1.length; // histogram bins\n        double b = 0; // Bhattacharyya's coefficient\n\n        for (int i = 0; i < bins; i++)\n            b += Math.sqrt(histogram1[i]) * Math.sqrt(histogram2[i]);\n\n        // Bhattacharyya distance between the two distributions\n        return Math.sqrt(1.0 - b);\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double[] p, double[] q)\n    {\n        double sumP, sumN;\n        sumP = sumN = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumN += Math.abs(p[i] - q[i]);\n            sumP += Math.abs(p[i] + q[i]);\n        }\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 X2 axis coordinate.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n    {\n        double sumN = Math.abs(x1 - x2) + Math.abs(y1 - y2);\n        double sumP = Math.abs(x1 + x2) + Math.abs(y1 + y2);\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(IntPoint p, IntPoint q)\n    {\n        return BrayCurtis(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double[] p, double[] q)\n    {\n        double distance = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            distance += Math.abs(p[i] - q[i]) / (Math.abs(p[i]) + Math.abs(q[i]));\n        }\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double x1, double y1, double x2, double y2)\n    {\n        double distance;\n\n        distance = Math.abs(x1 - x2) / (Math.abs(x1) + Math.abs(x2));\n        distance += Math.abs(y1 - y2) / (Math.abs(y1) + Math.abs(y2));\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(IntPoint p, IntPoint q)\n    {\n        return Canberra(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double[] p, double[] q)\n    {\n        double max = Math.abs(p[0] - q[0]);\n\n        for (int i = 1; i < p.length; i++)\n        {\n            double abs = Math.abs(p[i] - q[i]);\n            if (abs > max) max = abs;\n        }\n\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double x1, double y1, double x2, double y2)\n    {\n        double max = Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(IntPoint p, IntPoint q)\n    {\n        return Chebyshev(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double[] x, double[] y)\n    {\n\n        double d = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            d = Math.max(d, x[i] - y[i]);\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.max(dx, dy);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(IntPoint p, IntPoint q)\n    {\n        return Chessboard(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chi Square distance between two normalized histograms.\n     *\n     * @param histogram1 Histogram.\n     * @param histogram2 Histogram.\n     * @return The Chi Square distance between x and y.\n     */\n    public static double ChiSquare(double[] histogram1, double[] histogram2)\n    {\n        double r = 0;\n        for (int i = 0; i < histogram1.length; i++)\n        {\n            double t = histogram1[i] + histogram2[i];\n            if (t != 0)\n                r += Math.pow(histogram1[i] - histogram2[i], 2) / t;\n        }\n\n        return 0.5 * r;\n    }\n\n    /**\n     * Gets the Correlation distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Correlation distance between x and y.\n     */\n    public static double Correlation(double[] p, double[] q)\n    {\n\n        double x = 0;\n        double y = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            x += -p[i];\n            y += -q[i];\n        }\n\n        x /= p.length;\n        y /= q.length;\n\n        double num = 0;\n        double den1 = 0;\n        double den2 = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            num += (p[i] + x) * (q[i] + y);\n\n            den1 += Math.abs(Math.pow(p[i] + x, 2));\n            den2 += Math.abs(Math.pow(q[i] + x, 2));\n        }\n\n        return 1 - (num / (Math.sqrt(den1) * Math.sqrt(den2)));\n\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double[] p, double[] q)\n    {\n        double sumProduct = 0;\n        double sumP = 0, sumQ = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumProduct += p[i] * q[i];\n            sumP += Math.pow(Math.abs(p[i]), 2);\n            sumQ += Math.pow(Math.abs(q[i]), 2);\n        }\n\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double x1, double y1, double x2, double y2)\n    {\n\n        double sumProduct = x1 * x2 + y1 * y2;\n        double sumP = Math.pow(Math.abs(x1), 2) + Math.pow(Math.abs(x2), 2);\n        double sumQ = Math.pow(Math.abs(y1), 2) + Math.pow(Math.abs(y2), 2);\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(IntPoint p, IntPoint q)\n    {\n        return Cosine(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double[] p, double[] q)\n    {\n        return Math.sqrt(SquaredEuclidean(p, q));\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(IntPoint p, IntPoint q)\n    {\n        return Euclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Hamming distance between two strings.\n     *\n     * @param first  First string.\n     * @param second Second string.\n     * @return The Hamming distance between p and q.\n     */\n    public static int Hamming(String first, String second)\n    {\n\n        if (first.length() != second.length())\n            throw new IllegalArgumentException(\"The size of string must be the same.\");\n\n        int diff = 0;\n        for (int i = 0; i < first.length(); i++)\n            if (first.charAt(i) != second.charAt(i))\n                diff++;\n        return diff;\n    }\n\n    /**\n     * Gets the Jaccard distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Jaccard distance between x and y.\n     */\n    public static double JaccardDistance(double[] p, double[] q)\n    {\n        double distance = 0;\n        int intersection = 0, union = 0;\n\n        for (int x = 0; x < p.length; x++)\n        {\n            if ((p[x] != 0) || (q[x] != 0))\n            {\n                if (p[x] == q[x])\n                {\n                    intersection++;\n                }\n\n                union++;\n            }\n        }\n\n        if (union != 0)\n            distance = 1.0 - ((double) intersection / (double) union);\n        else\n            distance = 0;\n\n        return distance;\n    }\n\n    /**\n     * Gets the J-Divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The J-Divergence between p and q.\n     */\n    public static double JDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += (p[i] - q[i]) * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen difference divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Jensen difference between p and q.\n     */\n    public static double JensenDifferenceDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                double pq = p[i] + q[i];\n                k += (p[i] * Math.log(p[i]) + q[i] * Math.log(q[i])) / 2 - (pq / 2) * Math.log(pq / 2);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen Shannon divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The Jensen Shannon divergence between u and v.\n     */\n    public static double JensenShannonDivergence(double[] p, double[] q)\n    {\n        double[] m = new double[p.length];\n        for (int i = 0; i < m.length; i++)\n        {\n            m[i] = (p[i] + q[i]) / 2;\n        }\n\n        return (KullbackLeiblerDivergence(p, m) + KullbackLeiblerDivergence(q, m)) / 2;\n    }\n\n    /**\n     * Gets the K-Divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The K-Divergence between u and v.\n     */\n    public static double KDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] + q[i];\n            if (den != 0 && p[i] != 0)\n                r += p[i] * Math.log(2 * p[i] / den);\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Kumar-Johnson divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kumar-Johnson divergence between p and q.\n     */\n    public static double KumarJohnsonDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                r += Math.pow(p[i] * p[i] - q[i] * q[i], 2) / 2 * Math.pow(p[i] * q[i], 1.5);\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Kullback Leibler divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kullback Leibler divergence between u and v.\n     */\n    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += p[i] * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Mahalanobis distance.\n     *\n     * @param A Matrix A.\n     * @param B Matrix B.\n     * @return The Mahalanobis distance between A and B.\n     */\n    public static double Mahalanobis(double[][] A, double[][] B)\n    {\n\n        if (A[0].length != B[0].length)\n            throw new IllegalArgumentException(\"The number of columns of both matrix must be equals.\");\n\n        double[][] subA = new double[A.length][A[0].length];\n        double[][] subB = new double[B.length][B[0].length];\n\n        //Center data A\n        double[] meansA = new double[A[0].length];\n        for (int j = 0; j < A[0].length; j++)\n        {\n            for (int i = 0; i < A.length; i++)\n            {\n                meansA[j] += A[i][j];\n            }\n            meansA[j] /= (double) A.length;\n            for (int i = 0; i < A.length; i++)\n            {\n                subA[i][j] = A[i][j] - meansA[j];\n            }\n        }\n\n        //Center data B\n        double[] meansB = new double[B[0].length];\n        for (int j = 0; j < B[0].length; j++)\n        {\n            for (int i = 0; i < B.length; i++)\n            {\n                meansB[j] += B[i][j];\n            }\n            meansB[j] /= (double) B.length;\n            for (int i = 0; i < B.length; i++)\n            {\n                subB[i][j] = B[i][j] - meansB[j];\n            }\n        }\n\n        //Matrix of covariance\n        double[][] covA = Covariance(subA);\n        double[][] covB = Covariance(subB);\n\n        //Pooled covariance\n        double rows = subA.length + subB.length;\n        double[][] pCov = new double[covA.length][covA[0].length];\n        for (int i = 0; i < pCov.length; i++)\n        {\n            for (int j = 0; j < pCov[0].length; j++)\n            {\n                pCov[i][j] = covA[i][j] * ((double) subA.length / rows) + covB[i][j] * ((double) subB.length / rows);\n            }\n        }\n\n        //Inverse of pooled covariance\n        pCov = Matrix.Inverse(pCov);\n\n        //compute mean difference\n        double[] diff = new double[A[0].length];\n        for (int i = 0; i < diff.length; i++)\n        {\n            diff[i] = meansA[i] - meansB[i];\n        }\n\n        return Math.sqrt(Matrix.InnerProduct(Matrix.MultiplyByTranspose(pCov, diff), diff));\n\n    }\n\n    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n    {\n        double result = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            result += (x[i] - meanX) * (y[i] - meanY);\n        }\n\n        return result / (double) (x.length);\n    }\n\n    private static double[][] Covariance(double[][] matrix)\n    {\n        double[] means = new double[matrix[0].length];\n        for (int i = 0; i < matrix.length; i++)\n        {\n            for (int j = 0; j < matrix[0].length; j++)\n            {\n                means[j] += matrix[i][j];\n            }\n        }\n\n        for (int i = 0; i < means.length; i++)\n        {\n            means[i] /= means.length;\n        }\n\n        return Covariance(matrix, means);\n    }\n\n    private static double[][] Covariance(double[][] matrix, double[] means)\n    {\n        double[][] cov = new double[means.length][means.length];\n\n        for (int i = 0; i < cov.length; i++)\n        {\n            for (int j = 0; j < cov[0].length; j++)\n            {\n                cov[i][j] = Covariance(Matrix.getColumn(matrix, i), Matrix.getColumn(matrix, j), means[i], means[j]);\n            }\n        }\n\n        return cov;\n\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double[] p, double[] q)\n    {\n        double sum = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            sum += Math.abs(p[i] - q[i]);\n        }\n        return sum;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return dx + dy;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(IntPoint p, IntPoint q)\n    {\n        return Manhattan(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @param r  Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n    {\n        double sum = Math.pow(Math.abs(x1 - x2), r);\n        sum += Math.pow(Math.abs(y1 - y2), r);\n        return Math.pow(sum, 1 / r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @param r Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(IntPoint p, IntPoint q, int r)\n    {\n        return Minkowski(p.x, p.y, q.x, q.y, r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param u A point in space.\n     * @param v A point in space.\n     * @param p Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double[] u, double[] v, double p)\n    {\n        double distance = 0;\n        for (int i = 0; i < u.length; i++)\n        {\n            distance += Math.pow(Math.abs(u[i] - v[i]), p);\n        }\n        return Math.pow(distance, 1 / p);\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Quasi-Euclidean distance between x and y.\n     */\n    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        if (Math.abs(x1 - x2) > Math.abs(y1 - y2))\n        {\n            return Math.abs(x1 - x2) + (Constants.Sqrt2 - 1) * Math.abs(y1 - y2);\n        }\n        return (Constants.Sqrt2 - 1) * Math.abs(x1 - x2) + Math.abs(y1 - y2);\n\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Quasi Euclidean distance between p and q.\n     */\n    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n    {\n        return QuasiEuclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Square Euclidean distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Square Euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double[] x, double[] y)\n    {\n        double d = 0.0, u;\n\n        for (int i = 0; i < x.length; i++)\n        {\n            u = x[i] - y[i];\n            d += u * u;\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n    {\n\n        double dx = q.x - p.x;\n        double dy = q.y - p.y;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Symmetric Chi-square divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric chi-square divergence between p and q.\n     */\n\n    /**\n     * Gets the Symmetric Kullback-Leibler distance.\n     * This metric is valid only for real and positive P and Q.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric Kullback Leibler distance between p and q.\n     */\n    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n    {\n        double dist = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            dist += (p[i] - q[i]) * (Math.log(p[i]) - Math.log(q[i]));\n        }\n\n        return dist;\n    }\n\n    /**\n     * Gets the Taneja divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Taneja divergence between p and q.\n     */\n    public static double Taneja(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double pq = p[i] + q[i];\n                r += (pq / 2) * Math.log(pq / (2 * Math.sqrt(p[i] * q[i])));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Topsoe divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Topsoe divergence between p and q.\n     */\n    public static double TopsoeDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double den = p[i] + q[i];\n                r += p[i] * Math.log(2 * p[i] / den) + q[i] * Math.log(2 * q[i] / den);\n            }\n        }\n        return r;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/distance/Distance.java", "func_name": "Distance.SymmetricKullbackLeibler", "original_string": "public static double SymmetricKullbackLeibler(double[] p, double[] q) {\n        double dist = 0;\n        for (int i = 0; i < p.length; i++) {\n            dist += (p[i] - q[i]) * (Math.log(p[i]) - Math.log(q[i]));\n        }\n\n        return dist;\n    }", "language": "java", "code": "public static double SymmetricKullbackLeibler(double[] p, double[] q) {\n        double dist = 0;\n        for (int i = 0; i < p.length; i++) {\n            dist += (p[i] - q[i]) * (Math.log(p[i]) - Math.log(q[i]));\n        }\n\n        return dist;\n    }", "code_tokens": ["public", "static", "double", "SymmetricKullbackLeibler", "(", "double", "[", "]", "p", ",", "double", "[", "]", "q", ")", "{", "double", "dist", "=", "0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "p", ".", "length", ";", "i", "++", ")", "{", "dist", "+=", "(", "p", "[", "i", "]", "-", "q", "[", "i", "]", ")", "*", "(", "Math", ".", "log", "(", "p", "[", "i", "]", ")", "-", "Math", ".", "log", "(", "q", "[", "i", "]", ")", ")", ";", "}", "return", "dist", ";", "}"], "docstring": "Gets the Symmetric Kullback-Leibler distance.\nThis metric is valid only for real and positive P and Q.\n\n@param p P vector.\n@param q Q vector.\n@return The Symmetric Kullback Leibler distance between p and q.", "docstring_tokens": ["Gets", "the", "Symmetric", "Kullback", "-", "Leibler", "distance", ".", "This", "metric", "is", "valid", "only", "for", "real", "and", "positive", "P", "and", "Q", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/distance/Distance.java#L873-L880", "partition": "train", "up_fun_num": 48, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.IntPoint;", "import com.harium.keel.catalano.math.Constants;", "import com.harium.keel.catalano.math.Matrix;"], "function": ["public final class Distance\n", "    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n", "    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n", "    public static double BrayCurtis(double[] p, double[] q)\n", "    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n", "    public static double BrayCurtis(IntPoint p, IntPoint q)\n", "    public static double Canberra(double[] p, double[] q)\n", "    public static double Canberra(double x1, double y1, double x2, double y2)\n", "    public static double Canberra(IntPoint p, IntPoint q)\n", "    public static double Chebyshev(double[] p, double[] q)\n", "    public static double Chebyshev(double x1, double y1, double x2, double y2)\n", "    public static double Chebyshev(IntPoint p, IntPoint q)\n", "    public static double Chessboard(double[] x, double[] y)\n", "    public static double Chessboard(double x1, double y1, double x2, double y2)\n", "    public static double Chessboard(IntPoint p, IntPoint q)\n", "    public static double ChiSquare(double[] histogram1, double[] histogram2)\n", "    public static double Correlation(double[] p, double[] q)\n", "    public static double Cosine(double[] p, double[] q)\n", "    public static double Cosine(double x1, double y1, double x2, double y2)\n", "    public static double Cosine(IntPoint p, IntPoint q)\n", "    public static double Euclidean(double[] p, double[] q)\n", "    public static double Euclidean(double x1, double y1, double x2, double y2)\n", "    public static double Euclidean(IntPoint p, IntPoint q)\n", "    public static int Hamming(String first, String second)\n", "    public static double JaccardDistance(double[] p, double[] q)\n", "    public static double JDivergence(double[] p, double[] q)\n", "    public static double JensenDifferenceDivergence(double[] p, double[] q)\n", "    public static double JensenShannonDivergence(double[] p, double[] q)\n", "    public static double KDivergence(double[] p, double[] q)\n", "    public static double KumarJohnsonDivergence(double[] p, double[] q)\n", "    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n", "    public static double Mahalanobis(double[][] A, double[][] B)\n", "    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n", "    private static double[][] Covariance(double[][] matrix)\n", "    private static double[][] Covariance(double[][] matrix, double[] means)\n", "    public static double Manhattan(double[] p, double[] q)\n", "    public static double Manhattan(double x1, double y1, double x2, double y2)\n", "    public static double Manhattan(IntPoint p, IntPoint q)\n", "    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n", "    public static double Minkowski(IntPoint p, IntPoint q, int r)\n", "    public static double Minkowski(double[] u, double[] v, double p)\n", "    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n", "    public static double SquaredEuclidean(double[] x, double[] y)\n", "    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n", "    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n", "    public static double Taneja(double[] p, double[] q)\n", "    public static double TopsoeDivergence(double[] p, double[] q)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2012\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.distance;\n\n\nimport com.harium.keel.catalano.core.IntPoint;\nimport com.harium.keel.catalano.math.Constants;\nimport com.harium.keel.catalano.math.Matrix;\n\n/**\n * Defines a set of extension methods defining distance measures.\n * References: http://www.ajmaa.org/RGMIA/papers/v7n4/Gsdmi_RGMIA.pdf\n * http://arabic-icr.googlecode.com/git/Papers/Comprehensive%20Survey%20on%20Distance-Similarity.pdf\n *\n * @author Diego Catalano\n */\npublic final class Distance\n{\n\n    /**\n     * Don't let anyone initialize this class.\n     */\n    private Distance()\n    {\n    }\n\n    ;\n\n    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double num = p[i] + q[i];\n                r += (num / 2) * Math.log(num / (2 * Math.sqrt(den)));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Bhattacharyya distance between two normalized histograms.\n     *\n     * @param histogram1 Normalized histogram.\n     * @param histogram2 Normalized histogram.\n     * @return The Bhattacharyya distance between the two histograms.\n     */\n    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n    {\n        int bins = histogram1.length; // histogram bins\n        double b = 0; // Bhattacharyya's coefficient\n\n        for (int i = 0; i < bins; i++)\n            b += Math.sqrt(histogram1[i]) * Math.sqrt(histogram2[i]);\n\n        // Bhattacharyya distance between the two distributions\n        return Math.sqrt(1.0 - b);\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double[] p, double[] q)\n    {\n        double sumP, sumN;\n        sumP = sumN = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumN += Math.abs(p[i] - q[i]);\n            sumP += Math.abs(p[i] + q[i]);\n        }\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 X2 axis coordinate.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n    {\n        double sumN = Math.abs(x1 - x2) + Math.abs(y1 - y2);\n        double sumP = Math.abs(x1 + x2) + Math.abs(y1 + y2);\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(IntPoint p, IntPoint q)\n    {\n        return BrayCurtis(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double[] p, double[] q)\n    {\n        double distance = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            distance += Math.abs(p[i] - q[i]) / (Math.abs(p[i]) + Math.abs(q[i]));\n        }\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double x1, double y1, double x2, double y2)\n    {\n        double distance;\n\n        distance = Math.abs(x1 - x2) / (Math.abs(x1) + Math.abs(x2));\n        distance += Math.abs(y1 - y2) / (Math.abs(y1) + Math.abs(y2));\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(IntPoint p, IntPoint q)\n    {\n        return Canberra(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double[] p, double[] q)\n    {\n        double max = Math.abs(p[0] - q[0]);\n\n        for (int i = 1; i < p.length; i++)\n        {\n            double abs = Math.abs(p[i] - q[i]);\n            if (abs > max) max = abs;\n        }\n\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double x1, double y1, double x2, double y2)\n    {\n        double max = Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(IntPoint p, IntPoint q)\n    {\n        return Chebyshev(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double[] x, double[] y)\n    {\n\n        double d = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            d = Math.max(d, x[i] - y[i]);\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.max(dx, dy);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(IntPoint p, IntPoint q)\n    {\n        return Chessboard(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chi Square distance between two normalized histograms.\n     *\n     * @param histogram1 Histogram.\n     * @param histogram2 Histogram.\n     * @return The Chi Square distance between x and y.\n     */\n    public static double ChiSquare(double[] histogram1, double[] histogram2)\n    {\n        double r = 0;\n        for (int i = 0; i < histogram1.length; i++)\n        {\n            double t = histogram1[i] + histogram2[i];\n            if (t != 0)\n                r += Math.pow(histogram1[i] - histogram2[i], 2) / t;\n        }\n\n        return 0.5 * r;\n    }\n\n    /**\n     * Gets the Correlation distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Correlation distance between x and y.\n     */\n    public static double Correlation(double[] p, double[] q)\n    {\n\n        double x = 0;\n        double y = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            x += -p[i];\n            y += -q[i];\n        }\n\n        x /= p.length;\n        y /= q.length;\n\n        double num = 0;\n        double den1 = 0;\n        double den2 = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            num += (p[i] + x) * (q[i] + y);\n\n            den1 += Math.abs(Math.pow(p[i] + x, 2));\n            den2 += Math.abs(Math.pow(q[i] + x, 2));\n        }\n\n        return 1 - (num / (Math.sqrt(den1) * Math.sqrt(den2)));\n\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double[] p, double[] q)\n    {\n        double sumProduct = 0;\n        double sumP = 0, sumQ = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumProduct += p[i] * q[i];\n            sumP += Math.pow(Math.abs(p[i]), 2);\n            sumQ += Math.pow(Math.abs(q[i]), 2);\n        }\n\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double x1, double y1, double x2, double y2)\n    {\n\n        double sumProduct = x1 * x2 + y1 * y2;\n        double sumP = Math.pow(Math.abs(x1), 2) + Math.pow(Math.abs(x2), 2);\n        double sumQ = Math.pow(Math.abs(y1), 2) + Math.pow(Math.abs(y2), 2);\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(IntPoint p, IntPoint q)\n    {\n        return Cosine(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double[] p, double[] q)\n    {\n        return Math.sqrt(SquaredEuclidean(p, q));\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(IntPoint p, IntPoint q)\n    {\n        return Euclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Hamming distance between two strings.\n     *\n     * @param first  First string.\n     * @param second Second string.\n     * @return The Hamming distance between p and q.\n     */\n    public static int Hamming(String first, String second)\n    {\n\n        if (first.length() != second.length())\n            throw new IllegalArgumentException(\"The size of string must be the same.\");\n\n        int diff = 0;\n        for (int i = 0; i < first.length(); i++)\n            if (first.charAt(i) != second.charAt(i))\n                diff++;\n        return diff;\n    }\n\n    /**\n     * Gets the Jaccard distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Jaccard distance between x and y.\n     */\n    public static double JaccardDistance(double[] p, double[] q)\n    {\n        double distance = 0;\n        int intersection = 0, union = 0;\n\n        for (int x = 0; x < p.length; x++)\n        {\n            if ((p[x] != 0) || (q[x] != 0))\n            {\n                if (p[x] == q[x])\n                {\n                    intersection++;\n                }\n\n                union++;\n            }\n        }\n\n        if (union != 0)\n            distance = 1.0 - ((double) intersection / (double) union);\n        else\n            distance = 0;\n\n        return distance;\n    }\n\n    /**\n     * Gets the J-Divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The J-Divergence between p and q.\n     */\n    public static double JDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += (p[i] - q[i]) * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen difference divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Jensen difference between p and q.\n     */\n    public static double JensenDifferenceDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                double pq = p[i] + q[i];\n                k += (p[i] * Math.log(p[i]) + q[i] * Math.log(q[i])) / 2 - (pq / 2) * Math.log(pq / 2);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen Shannon divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The Jensen Shannon divergence between u and v.\n     */\n    public static double JensenShannonDivergence(double[] p, double[] q)\n    {\n        double[] m = new double[p.length];\n        for (int i = 0; i < m.length; i++)\n        {\n            m[i] = (p[i] + q[i]) / 2;\n        }\n\n        return (KullbackLeiblerDivergence(p, m) + KullbackLeiblerDivergence(q, m)) / 2;\n    }\n\n    /**\n     * Gets the K-Divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The K-Divergence between u and v.\n     */\n    public static double KDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] + q[i];\n            if (den != 0 && p[i] != 0)\n                r += p[i] * Math.log(2 * p[i] / den);\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Kumar-Johnson divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kumar-Johnson divergence between p and q.\n     */\n    public static double KumarJohnsonDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                r += Math.pow(p[i] * p[i] - q[i] * q[i], 2) / 2 * Math.pow(p[i] * q[i], 1.5);\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Kullback Leibler divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kullback Leibler divergence between u and v.\n     */\n    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += p[i] * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Mahalanobis distance.\n     *\n     * @param A Matrix A.\n     * @param B Matrix B.\n     * @return The Mahalanobis distance between A and B.\n     */\n    public static double Mahalanobis(double[][] A, double[][] B)\n    {\n\n        if (A[0].length != B[0].length)\n            throw new IllegalArgumentException(\"The number of columns of both matrix must be equals.\");\n\n        double[][] subA = new double[A.length][A[0].length];\n        double[][] subB = new double[B.length][B[0].length];\n\n        //Center data A\n        double[] meansA = new double[A[0].length];\n        for (int j = 0; j < A[0].length; j++)\n        {\n            for (int i = 0; i < A.length; i++)\n            {\n                meansA[j] += A[i][j];\n            }\n            meansA[j] /= (double) A.length;\n            for (int i = 0; i < A.length; i++)\n            {\n                subA[i][j] = A[i][j] - meansA[j];\n            }\n        }\n\n        //Center data B\n        double[] meansB = new double[B[0].length];\n        for (int j = 0; j < B[0].length; j++)\n        {\n            for (int i = 0; i < B.length; i++)\n            {\n                meansB[j] += B[i][j];\n            }\n            meansB[j] /= (double) B.length;\n            for (int i = 0; i < B.length; i++)\n            {\n                subB[i][j] = B[i][j] - meansB[j];\n            }\n        }\n\n        //Matrix of covariance\n        double[][] covA = Covariance(subA);\n        double[][] covB = Covariance(subB);\n\n        //Pooled covariance\n        double rows = subA.length + subB.length;\n        double[][] pCov = new double[covA.length][covA[0].length];\n        for (int i = 0; i < pCov.length; i++)\n        {\n            for (int j = 0; j < pCov[0].length; j++)\n            {\n                pCov[i][j] = covA[i][j] * ((double) subA.length / rows) + covB[i][j] * ((double) subB.length / rows);\n            }\n        }\n\n        //Inverse of pooled covariance\n        pCov = Matrix.Inverse(pCov);\n\n        //compute mean difference\n        double[] diff = new double[A[0].length];\n        for (int i = 0; i < diff.length; i++)\n        {\n            diff[i] = meansA[i] - meansB[i];\n        }\n\n        return Math.sqrt(Matrix.InnerProduct(Matrix.MultiplyByTranspose(pCov, diff), diff));\n\n    }\n\n    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n    {\n        double result = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            result += (x[i] - meanX) * (y[i] - meanY);\n        }\n\n        return result / (double) (x.length);\n    }\n\n    private static double[][] Covariance(double[][] matrix)\n    {\n        double[] means = new double[matrix[0].length];\n        for (int i = 0; i < matrix.length; i++)\n        {\n            for (int j = 0; j < matrix[0].length; j++)\n            {\n                means[j] += matrix[i][j];\n            }\n        }\n\n        for (int i = 0; i < means.length; i++)\n        {\n            means[i] /= means.length;\n        }\n\n        return Covariance(matrix, means);\n    }\n\n    private static double[][] Covariance(double[][] matrix, double[] means)\n    {\n        double[][] cov = new double[means.length][means.length];\n\n        for (int i = 0; i < cov.length; i++)\n        {\n            for (int j = 0; j < cov[0].length; j++)\n            {\n                cov[i][j] = Covariance(Matrix.getColumn(matrix, i), Matrix.getColumn(matrix, j), means[i], means[j]);\n            }\n        }\n\n        return cov;\n\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double[] p, double[] q)\n    {\n        double sum = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            sum += Math.abs(p[i] - q[i]);\n        }\n        return sum;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return dx + dy;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(IntPoint p, IntPoint q)\n    {\n        return Manhattan(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @param r  Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n    {\n        double sum = Math.pow(Math.abs(x1 - x2), r);\n        sum += Math.pow(Math.abs(y1 - y2), r);\n        return Math.pow(sum, 1 / r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @param r Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(IntPoint p, IntPoint q, int r)\n    {\n        return Minkowski(p.x, p.y, q.x, q.y, r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param u A point in space.\n     * @param v A point in space.\n     * @param p Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double[] u, double[] v, double p)\n    {\n        double distance = 0;\n        for (int i = 0; i < u.length; i++)\n        {\n            distance += Math.pow(Math.abs(u[i] - v[i]), p);\n        }\n        return Math.pow(distance, 1 / p);\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Quasi-Euclidean distance between x and y.\n     */\n    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        if (Math.abs(x1 - x2) > Math.abs(y1 - y2))\n        {\n            return Math.abs(x1 - x2) + (Constants.Sqrt2 - 1) * Math.abs(y1 - y2);\n        }\n        return (Constants.Sqrt2 - 1) * Math.abs(x1 - x2) + Math.abs(y1 - y2);\n\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Quasi Euclidean distance between p and q.\n     */\n    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n    {\n        return QuasiEuclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Square Euclidean distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Square Euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double[] x, double[] y)\n    {\n        double d = 0.0, u;\n\n        for (int i = 0; i < x.length; i++)\n        {\n            u = x[i] - y[i];\n            d += u * u;\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n    {\n\n        double dx = q.x - p.x;\n        double dy = q.y - p.y;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Symmetric Chi-square divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric chi-square divergence between p and q.\n     */\n    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double p1 = p[i] - q[i];\n                double p2 = p[i] + q[i];\n                r += (p1 * p1 * p2) / den;\n            }\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Symmetric Kullback-Leibler distance.\n     * This metric is valid only for real and positive P and Q.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric Kullback Leibler distance between p and q.\n     */\n\n    /**\n     * Gets the Taneja divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Taneja divergence between p and q.\n     */\n    public static double Taneja(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double pq = p[i] + q[i];\n                r += (pq / 2) * Math.log(pq / (2 * Math.sqrt(p[i] * q[i])));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Topsoe divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Topsoe divergence between p and q.\n     */\n    public static double TopsoeDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double den = p[i] + q[i];\n                r += p[i] * Math.log(2 * p[i] / den) + q[i] * Math.log(2 * q[i] / den);\n            }\n        }\n        return r;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/distance/Distance.java", "func_name": "Distance.Taneja", "original_string": "public static double Taneja(double[] p, double[] q) {\n        double r = 0;\n        for (int i = 0; i < p.length; i++) {\n            if (p[i] != 0 && q[i] != 0) {\n                double pq = p[i] + q[i];\n                r += (pq / 2) * Math.log(pq / (2 * Math.sqrt(p[i] * q[i])));\n            }\n        }\n        return r;\n    }", "language": "java", "code": "public static double Taneja(double[] p, double[] q) {\n        double r = 0;\n        for (int i = 0; i < p.length; i++) {\n            if (p[i] != 0 && q[i] != 0) {\n                double pq = p[i] + q[i];\n                r += (pq / 2) * Math.log(pq / (2 * Math.sqrt(p[i] * q[i])));\n            }\n        }\n        return r;\n    }", "code_tokens": ["public", "static", "double", "Taneja", "(", "double", "[", "]", "p", ",", "double", "[", "]", "q", ")", "{", "double", "r", "=", "0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "p", ".", "length", ";", "i", "++", ")", "{", "if", "(", "p", "[", "i", "]", "!=", "0", "&&", "q", "[", "i", "]", "!=", "0", ")", "{", "double", "pq", "=", "p", "[", "i", "]", "+", "q", "[", "i", "]", ";", "r", "+=", "(", "pq", "/", "2", ")", "*", "Math", ".", "log", "(", "pq", "/", "(", "2", "*", "Math", ".", "sqrt", "(", "p", "[", "i", "]", "*", "q", "[", "i", "]", ")", ")", ")", ";", "}", "}", "return", "r", ";", "}"], "docstring": "Gets the Taneja divergence.\n\n@param p P vector.\n@param q Q vector.\n@return The Taneja divergence between p and q.", "docstring_tokens": ["Gets", "the", "Taneja", "divergence", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/distance/Distance.java#L889-L898", "partition": "train", "up_fun_num": 49, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.IntPoint;", "import com.harium.keel.catalano.math.Constants;", "import com.harium.keel.catalano.math.Matrix;"], "function": ["public final class Distance\n", "    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n", "    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n", "    public static double BrayCurtis(double[] p, double[] q)\n", "    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n", "    public static double BrayCurtis(IntPoint p, IntPoint q)\n", "    public static double Canberra(double[] p, double[] q)\n", "    public static double Canberra(double x1, double y1, double x2, double y2)\n", "    public static double Canberra(IntPoint p, IntPoint q)\n", "    public static double Chebyshev(double[] p, double[] q)\n", "    public static double Chebyshev(double x1, double y1, double x2, double y2)\n", "    public static double Chebyshev(IntPoint p, IntPoint q)\n", "    public static double Chessboard(double[] x, double[] y)\n", "    public static double Chessboard(double x1, double y1, double x2, double y2)\n", "    public static double Chessboard(IntPoint p, IntPoint q)\n", "    public static double ChiSquare(double[] histogram1, double[] histogram2)\n", "    public static double Correlation(double[] p, double[] q)\n", "    public static double Cosine(double[] p, double[] q)\n", "    public static double Cosine(double x1, double y1, double x2, double y2)\n", "    public static double Cosine(IntPoint p, IntPoint q)\n", "    public static double Euclidean(double[] p, double[] q)\n", "    public static double Euclidean(double x1, double y1, double x2, double y2)\n", "    public static double Euclidean(IntPoint p, IntPoint q)\n", "    public static int Hamming(String first, String second)\n", "    public static double JaccardDistance(double[] p, double[] q)\n", "    public static double JDivergence(double[] p, double[] q)\n", "    public static double JensenDifferenceDivergence(double[] p, double[] q)\n", "    public static double JensenShannonDivergence(double[] p, double[] q)\n", "    public static double KDivergence(double[] p, double[] q)\n", "    public static double KumarJohnsonDivergence(double[] p, double[] q)\n", "    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n", "    public static double Mahalanobis(double[][] A, double[][] B)\n", "    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n", "    private static double[][] Covariance(double[][] matrix)\n", "    private static double[][] Covariance(double[][] matrix, double[] means)\n", "    public static double Manhattan(double[] p, double[] q)\n", "    public static double Manhattan(double x1, double y1, double x2, double y2)\n", "    public static double Manhattan(IntPoint p, IntPoint q)\n", "    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n", "    public static double Minkowski(IntPoint p, IntPoint q, int r)\n", "    public static double Minkowski(double[] u, double[] v, double p)\n", "    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n", "    public static double SquaredEuclidean(double[] x, double[] y)\n", "    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n", "    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n", "    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n", "    public static double TopsoeDivergence(double[] p, double[] q)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2012\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.distance;\n\n\nimport com.harium.keel.catalano.core.IntPoint;\nimport com.harium.keel.catalano.math.Constants;\nimport com.harium.keel.catalano.math.Matrix;\n\n/**\n * Defines a set of extension methods defining distance measures.\n * References: http://www.ajmaa.org/RGMIA/papers/v7n4/Gsdmi_RGMIA.pdf\n * http://arabic-icr.googlecode.com/git/Papers/Comprehensive%20Survey%20on%20Distance-Similarity.pdf\n *\n * @author Diego Catalano\n */\npublic final class Distance\n{\n\n    /**\n     * Don't let anyone initialize this class.\n     */\n    private Distance()\n    {\n    }\n\n    ;\n\n    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double num = p[i] + q[i];\n                r += (num / 2) * Math.log(num / (2 * Math.sqrt(den)));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Bhattacharyya distance between two normalized histograms.\n     *\n     * @param histogram1 Normalized histogram.\n     * @param histogram2 Normalized histogram.\n     * @return The Bhattacharyya distance between the two histograms.\n     */\n    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n    {\n        int bins = histogram1.length; // histogram bins\n        double b = 0; // Bhattacharyya's coefficient\n\n        for (int i = 0; i < bins; i++)\n            b += Math.sqrt(histogram1[i]) * Math.sqrt(histogram2[i]);\n\n        // Bhattacharyya distance between the two distributions\n        return Math.sqrt(1.0 - b);\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double[] p, double[] q)\n    {\n        double sumP, sumN;\n        sumP = sumN = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumN += Math.abs(p[i] - q[i]);\n            sumP += Math.abs(p[i] + q[i]);\n        }\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 X2 axis coordinate.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n    {\n        double sumN = Math.abs(x1 - x2) + Math.abs(y1 - y2);\n        double sumP = Math.abs(x1 + x2) + Math.abs(y1 + y2);\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(IntPoint p, IntPoint q)\n    {\n        return BrayCurtis(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double[] p, double[] q)\n    {\n        double distance = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            distance += Math.abs(p[i] - q[i]) / (Math.abs(p[i]) + Math.abs(q[i]));\n        }\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double x1, double y1, double x2, double y2)\n    {\n        double distance;\n\n        distance = Math.abs(x1 - x2) / (Math.abs(x1) + Math.abs(x2));\n        distance += Math.abs(y1 - y2) / (Math.abs(y1) + Math.abs(y2));\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(IntPoint p, IntPoint q)\n    {\n        return Canberra(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double[] p, double[] q)\n    {\n        double max = Math.abs(p[0] - q[0]);\n\n        for (int i = 1; i < p.length; i++)\n        {\n            double abs = Math.abs(p[i] - q[i]);\n            if (abs > max) max = abs;\n        }\n\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double x1, double y1, double x2, double y2)\n    {\n        double max = Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(IntPoint p, IntPoint q)\n    {\n        return Chebyshev(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double[] x, double[] y)\n    {\n\n        double d = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            d = Math.max(d, x[i] - y[i]);\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.max(dx, dy);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(IntPoint p, IntPoint q)\n    {\n        return Chessboard(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chi Square distance between two normalized histograms.\n     *\n     * @param histogram1 Histogram.\n     * @param histogram2 Histogram.\n     * @return The Chi Square distance between x and y.\n     */\n    public static double ChiSquare(double[] histogram1, double[] histogram2)\n    {\n        double r = 0;\n        for (int i = 0; i < histogram1.length; i++)\n        {\n            double t = histogram1[i] + histogram2[i];\n            if (t != 0)\n                r += Math.pow(histogram1[i] - histogram2[i], 2) / t;\n        }\n\n        return 0.5 * r;\n    }\n\n    /**\n     * Gets the Correlation distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Correlation distance between x and y.\n     */\n    public static double Correlation(double[] p, double[] q)\n    {\n\n        double x = 0;\n        double y = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            x += -p[i];\n            y += -q[i];\n        }\n\n        x /= p.length;\n        y /= q.length;\n\n        double num = 0;\n        double den1 = 0;\n        double den2 = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            num += (p[i] + x) * (q[i] + y);\n\n            den1 += Math.abs(Math.pow(p[i] + x, 2));\n            den2 += Math.abs(Math.pow(q[i] + x, 2));\n        }\n\n        return 1 - (num / (Math.sqrt(den1) * Math.sqrt(den2)));\n\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double[] p, double[] q)\n    {\n        double sumProduct = 0;\n        double sumP = 0, sumQ = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumProduct += p[i] * q[i];\n            sumP += Math.pow(Math.abs(p[i]), 2);\n            sumQ += Math.pow(Math.abs(q[i]), 2);\n        }\n\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double x1, double y1, double x2, double y2)\n    {\n\n        double sumProduct = x1 * x2 + y1 * y2;\n        double sumP = Math.pow(Math.abs(x1), 2) + Math.pow(Math.abs(x2), 2);\n        double sumQ = Math.pow(Math.abs(y1), 2) + Math.pow(Math.abs(y2), 2);\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(IntPoint p, IntPoint q)\n    {\n        return Cosine(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double[] p, double[] q)\n    {\n        return Math.sqrt(SquaredEuclidean(p, q));\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(IntPoint p, IntPoint q)\n    {\n        return Euclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Hamming distance between two strings.\n     *\n     * @param first  First string.\n     * @param second Second string.\n     * @return The Hamming distance between p and q.\n     */\n    public static int Hamming(String first, String second)\n    {\n\n        if (first.length() != second.length())\n            throw new IllegalArgumentException(\"The size of string must be the same.\");\n\n        int diff = 0;\n        for (int i = 0; i < first.length(); i++)\n            if (first.charAt(i) != second.charAt(i))\n                diff++;\n        return diff;\n    }\n\n    /**\n     * Gets the Jaccard distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Jaccard distance between x and y.\n     */\n    public static double JaccardDistance(double[] p, double[] q)\n    {\n        double distance = 0;\n        int intersection = 0, union = 0;\n\n        for (int x = 0; x < p.length; x++)\n        {\n            if ((p[x] != 0) || (q[x] != 0))\n            {\n                if (p[x] == q[x])\n                {\n                    intersection++;\n                }\n\n                union++;\n            }\n        }\n\n        if (union != 0)\n            distance = 1.0 - ((double) intersection / (double) union);\n        else\n            distance = 0;\n\n        return distance;\n    }\n\n    /**\n     * Gets the J-Divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The J-Divergence between p and q.\n     */\n    public static double JDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += (p[i] - q[i]) * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen difference divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Jensen difference between p and q.\n     */\n    public static double JensenDifferenceDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                double pq = p[i] + q[i];\n                k += (p[i] * Math.log(p[i]) + q[i] * Math.log(q[i])) / 2 - (pq / 2) * Math.log(pq / 2);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen Shannon divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The Jensen Shannon divergence between u and v.\n     */\n    public static double JensenShannonDivergence(double[] p, double[] q)\n    {\n        double[] m = new double[p.length];\n        for (int i = 0; i < m.length; i++)\n        {\n            m[i] = (p[i] + q[i]) / 2;\n        }\n\n        return (KullbackLeiblerDivergence(p, m) + KullbackLeiblerDivergence(q, m)) / 2;\n    }\n\n    /**\n     * Gets the K-Divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The K-Divergence between u and v.\n     */\n    public static double KDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] + q[i];\n            if (den != 0 && p[i] != 0)\n                r += p[i] * Math.log(2 * p[i] / den);\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Kumar-Johnson divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kumar-Johnson divergence between p and q.\n     */\n    public static double KumarJohnsonDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                r += Math.pow(p[i] * p[i] - q[i] * q[i], 2) / 2 * Math.pow(p[i] * q[i], 1.5);\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Kullback Leibler divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kullback Leibler divergence between u and v.\n     */\n    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += p[i] * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Mahalanobis distance.\n     *\n     * @param A Matrix A.\n     * @param B Matrix B.\n     * @return The Mahalanobis distance between A and B.\n     */\n    public static double Mahalanobis(double[][] A, double[][] B)\n    {\n\n        if (A[0].length != B[0].length)\n            throw new IllegalArgumentException(\"The number of columns of both matrix must be equals.\");\n\n        double[][] subA = new double[A.length][A[0].length];\n        double[][] subB = new double[B.length][B[0].length];\n\n        //Center data A\n        double[] meansA = new double[A[0].length];\n        for (int j = 0; j < A[0].length; j++)\n        {\n            for (int i = 0; i < A.length; i++)\n            {\n                meansA[j] += A[i][j];\n            }\n            meansA[j] /= (double) A.length;\n            for (int i = 0; i < A.length; i++)\n            {\n                subA[i][j] = A[i][j] - meansA[j];\n            }\n        }\n\n        //Center data B\n        double[] meansB = new double[B[0].length];\n        for (int j = 0; j < B[0].length; j++)\n        {\n            for (int i = 0; i < B.length; i++)\n            {\n                meansB[j] += B[i][j];\n            }\n            meansB[j] /= (double) B.length;\n            for (int i = 0; i < B.length; i++)\n            {\n                subB[i][j] = B[i][j] - meansB[j];\n            }\n        }\n\n        //Matrix of covariance\n        double[][] covA = Covariance(subA);\n        double[][] covB = Covariance(subB);\n\n        //Pooled covariance\n        double rows = subA.length + subB.length;\n        double[][] pCov = new double[covA.length][covA[0].length];\n        for (int i = 0; i < pCov.length; i++)\n        {\n            for (int j = 0; j < pCov[0].length; j++)\n            {\n                pCov[i][j] = covA[i][j] * ((double) subA.length / rows) + covB[i][j] * ((double) subB.length / rows);\n            }\n        }\n\n        //Inverse of pooled covariance\n        pCov = Matrix.Inverse(pCov);\n\n        //compute mean difference\n        double[] diff = new double[A[0].length];\n        for (int i = 0; i < diff.length; i++)\n        {\n            diff[i] = meansA[i] - meansB[i];\n        }\n\n        return Math.sqrt(Matrix.InnerProduct(Matrix.MultiplyByTranspose(pCov, diff), diff));\n\n    }\n\n    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n    {\n        double result = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            result += (x[i] - meanX) * (y[i] - meanY);\n        }\n\n        return result / (double) (x.length);\n    }\n\n    private static double[][] Covariance(double[][] matrix)\n    {\n        double[] means = new double[matrix[0].length];\n        for (int i = 0; i < matrix.length; i++)\n        {\n            for (int j = 0; j < matrix[0].length; j++)\n            {\n                means[j] += matrix[i][j];\n            }\n        }\n\n        for (int i = 0; i < means.length; i++)\n        {\n            means[i] /= means.length;\n        }\n\n        return Covariance(matrix, means);\n    }\n\n    private static double[][] Covariance(double[][] matrix, double[] means)\n    {\n        double[][] cov = new double[means.length][means.length];\n\n        for (int i = 0; i < cov.length; i++)\n        {\n            for (int j = 0; j < cov[0].length; j++)\n            {\n                cov[i][j] = Covariance(Matrix.getColumn(matrix, i), Matrix.getColumn(matrix, j), means[i], means[j]);\n            }\n        }\n\n        return cov;\n\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double[] p, double[] q)\n    {\n        double sum = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            sum += Math.abs(p[i] - q[i]);\n        }\n        return sum;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return dx + dy;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(IntPoint p, IntPoint q)\n    {\n        return Manhattan(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @param r  Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n    {\n        double sum = Math.pow(Math.abs(x1 - x2), r);\n        sum += Math.pow(Math.abs(y1 - y2), r);\n        return Math.pow(sum, 1 / r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @param r Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(IntPoint p, IntPoint q, int r)\n    {\n        return Minkowski(p.x, p.y, q.x, q.y, r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param u A point in space.\n     * @param v A point in space.\n     * @param p Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double[] u, double[] v, double p)\n    {\n        double distance = 0;\n        for (int i = 0; i < u.length; i++)\n        {\n            distance += Math.pow(Math.abs(u[i] - v[i]), p);\n        }\n        return Math.pow(distance, 1 / p);\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Quasi-Euclidean distance between x and y.\n     */\n    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        if (Math.abs(x1 - x2) > Math.abs(y1 - y2))\n        {\n            return Math.abs(x1 - x2) + (Constants.Sqrt2 - 1) * Math.abs(y1 - y2);\n        }\n        return (Constants.Sqrt2 - 1) * Math.abs(x1 - x2) + Math.abs(y1 - y2);\n\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Quasi Euclidean distance between p and q.\n     */\n    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n    {\n        return QuasiEuclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Square Euclidean distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Square Euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double[] x, double[] y)\n    {\n        double d = 0.0, u;\n\n        for (int i = 0; i < x.length; i++)\n        {\n            u = x[i] - y[i];\n            d += u * u;\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n    {\n\n        double dx = q.x - p.x;\n        double dy = q.y - p.y;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Symmetric Chi-square divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric chi-square divergence between p and q.\n     */\n    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double p1 = p[i] - q[i];\n                double p2 = p[i] + q[i];\n                r += (p1 * p1 * p2) / den;\n            }\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Symmetric Kullback-Leibler distance.\n     * This metric is valid only for real and positive P and Q.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric Kullback Leibler distance between p and q.\n     */\n    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n    {\n        double dist = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            dist += (p[i] - q[i]) * (Math.log(p[i]) - Math.log(q[i]));\n        }\n\n        return dist;\n    }\n\n    /**\n     * Gets the Taneja divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Taneja divergence between p and q.\n     */\n\n    /**\n     * Gets the Topsoe divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Topsoe divergence between p and q.\n     */\n    public static double TopsoeDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double den = p[i] + q[i];\n                r += p[i] * Math.log(2 * p[i] / den) + q[i] * Math.log(2 * q[i] / den);\n            }\n        }\n        return r;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/distance/Distance.java", "func_name": "Distance.TopsoeDivergence", "original_string": "public static double TopsoeDivergence(double[] p, double[] q) {\n        double r = 0;\n        for (int i = 0; i < p.length; i++) {\n            if (p[i] != 0 && q[i] != 0) {\n                double den = p[i] + q[i];\n                r += p[i] * Math.log(2 * p[i] / den) + q[i] * Math.log(2 * q[i] / den);\n            }\n        }\n        return r;\n    }", "language": "java", "code": "public static double TopsoeDivergence(double[] p, double[] q) {\n        double r = 0;\n        for (int i = 0; i < p.length; i++) {\n            if (p[i] != 0 && q[i] != 0) {\n                double den = p[i] + q[i];\n                r += p[i] * Math.log(2 * p[i] / den) + q[i] * Math.log(2 * q[i] / den);\n            }\n        }\n        return r;\n    }", "code_tokens": ["public", "static", "double", "TopsoeDivergence", "(", "double", "[", "]", "p", ",", "double", "[", "]", "q", ")", "{", "double", "r", "=", "0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "p", ".", "length", ";", "i", "++", ")", "{", "if", "(", "p", "[", "i", "]", "!=", "0", "&&", "q", "[", "i", "]", "!=", "0", ")", "{", "double", "den", "=", "p", "[", "i", "]", "+", "q", "[", "i", "]", ";", "r", "+=", "p", "[", "i", "]", "*", "Math", ".", "log", "(", "2", "*", "p", "[", "i", "]", "/", "den", ")", "+", "q", "[", "i", "]", "*", "Math", ".", "log", "(", "2", "*", "q", "[", "i", "]", "/", "den", ")", ";", "}", "}", "return", "r", ";", "}"], "docstring": "Gets the Topsoe divergence.\n\n@param p P vector.\n@param q Q vector.\n@return The Topsoe divergence between p and q.", "docstring_tokens": ["Gets", "the", "Topsoe", "divergence", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/distance/Distance.java#L907-L916", "partition": "train", "up_fun_num": 49, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.catalano.core.IntPoint;", "import com.harium.keel.catalano.math.Constants;", "import com.harium.keel.catalano.math.Matrix;"], "function": ["public final class Distance\n", "    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n", "    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n", "    public static double BrayCurtis(double[] p, double[] q)\n", "    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n", "    public static double BrayCurtis(IntPoint p, IntPoint q)\n", "    public static double Canberra(double[] p, double[] q)\n", "    public static double Canberra(double x1, double y1, double x2, double y2)\n", "    public static double Canberra(IntPoint p, IntPoint q)\n", "    public static double Chebyshev(double[] p, double[] q)\n", "    public static double Chebyshev(double x1, double y1, double x2, double y2)\n", "    public static double Chebyshev(IntPoint p, IntPoint q)\n", "    public static double Chessboard(double[] x, double[] y)\n", "    public static double Chessboard(double x1, double y1, double x2, double y2)\n", "    public static double Chessboard(IntPoint p, IntPoint q)\n", "    public static double ChiSquare(double[] histogram1, double[] histogram2)\n", "    public static double Correlation(double[] p, double[] q)\n", "    public static double Cosine(double[] p, double[] q)\n", "    public static double Cosine(double x1, double y1, double x2, double y2)\n", "    public static double Cosine(IntPoint p, IntPoint q)\n", "    public static double Euclidean(double[] p, double[] q)\n", "    public static double Euclidean(double x1, double y1, double x2, double y2)\n", "    public static double Euclidean(IntPoint p, IntPoint q)\n", "    public static int Hamming(String first, String second)\n", "    public static double JaccardDistance(double[] p, double[] q)\n", "    public static double JDivergence(double[] p, double[] q)\n", "    public static double JensenDifferenceDivergence(double[] p, double[] q)\n", "    public static double JensenShannonDivergence(double[] p, double[] q)\n", "    public static double KDivergence(double[] p, double[] q)\n", "    public static double KumarJohnsonDivergence(double[] p, double[] q)\n", "    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n", "    public static double Mahalanobis(double[][] A, double[][] B)\n", "    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n", "    private static double[][] Covariance(double[][] matrix)\n", "    private static double[][] Covariance(double[][] matrix, double[] means)\n", "    public static double Manhattan(double[] p, double[] q)\n", "    public static double Manhattan(double x1, double y1, double x2, double y2)\n", "    public static double Manhattan(IntPoint p, IntPoint q)\n", "    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n", "    public static double Minkowski(IntPoint p, IntPoint q, int r)\n", "    public static double Minkowski(double[] u, double[] v, double p)\n", "    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n", "    public static double SquaredEuclidean(double[] x, double[] y)\n", "    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n", "    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n", "    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n", "    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n", "    public static double Taneja(double[] p, double[] q)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? C\u00e9sar Souza, 2009-2012\n// cesarsouza at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.distance;\n\n\nimport com.harium.keel.catalano.core.IntPoint;\nimport com.harium.keel.catalano.math.Constants;\nimport com.harium.keel.catalano.math.Matrix;\n\n/**\n * Defines a set of extension methods defining distance measures.\n * References: http://www.ajmaa.org/RGMIA/papers/v7n4/Gsdmi_RGMIA.pdf\n * http://arabic-icr.googlecode.com/git/Papers/Comprehensive%20Survey%20on%20Distance-Similarity.pdf\n *\n * @author Diego Catalano\n */\npublic final class Distance\n{\n\n    /**\n     * Don't let anyone initialize this class.\n     */\n    private Distance()\n    {\n    }\n\n    ;\n\n    public static double ArithmeticGeometricDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double num = p[i] + q[i];\n                r += (num / 2) * Math.log(num / (2 * Math.sqrt(den)));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Bhattacharyya distance between two normalized histograms.\n     *\n     * @param histogram1 Normalized histogram.\n     * @param histogram2 Normalized histogram.\n     * @return The Bhattacharyya distance between the two histograms.\n     */\n    public static double Bhattacharyya(double[] histogram1, double[] histogram2)\n    {\n        int bins = histogram1.length; // histogram bins\n        double b = 0; // Bhattacharyya's coefficient\n\n        for (int i = 0; i < bins; i++)\n            b += Math.sqrt(histogram1[i]) * Math.sqrt(histogram2[i]);\n\n        // Bhattacharyya distance between the two distributions\n        return Math.sqrt(1.0 - b);\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double[] p, double[] q)\n    {\n        double sumP, sumN;\n        sumP = sumN = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumN += Math.abs(p[i] - q[i]);\n            sumP += Math.abs(p[i] + q[i]);\n        }\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 X2 axis coordinate.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(double x1, double y1, double x2, double y2)\n    {\n        double sumN = Math.abs(x1 - x2) + Math.abs(y1 - y2);\n        double sumP = Math.abs(x1 + x2) + Math.abs(y1 + y2);\n\n        return sumN / sumP;\n    }\n\n    /**\n     * Gets the Bray Curtis distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Bray Curtis distance between x and y.\n     */\n    public static double BrayCurtis(IntPoint p, IntPoint q)\n    {\n        return BrayCurtis(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double[] p, double[] q)\n    {\n        double distance = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            distance += Math.abs(p[i] - q[i]) / (Math.abs(p[i]) + Math.abs(q[i]));\n        }\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(double x1, double y1, double x2, double y2)\n    {\n        double distance;\n\n        distance = Math.abs(x1 - x2) / (Math.abs(x1) + Math.abs(x2));\n        distance += Math.abs(y1 - y2) / (Math.abs(y1) + Math.abs(y2));\n\n        return distance;\n    }\n\n    /**\n     * Gets the Canberra distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Canberra distance between x and y.\n     */\n    public static double Canberra(IntPoint p, IntPoint q)\n    {\n        return Canberra(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double[] p, double[] q)\n    {\n        double max = Math.abs(p[0] - q[0]);\n\n        for (int i = 1; i < p.length; i++)\n        {\n            double abs = Math.abs(p[i] - q[i]);\n            if (abs > max) max = abs;\n        }\n\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(double x1, double y1, double x2, double y2)\n    {\n        double max = Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));\n        return max;\n    }\n\n    /**\n     * Gets the Chebyshev distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chebyshev distance between x and y.\n     */\n    public static double Chebyshev(IntPoint p, IntPoint q)\n    {\n        return Chebyshev(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double[] x, double[] y)\n    {\n\n        double d = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            d = Math.max(d, x[i] - y[i]);\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.max(dx, dy);\n    }\n\n    /**\n     * Gets the Chessboard distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Chessboard distance between x and y.\n     */\n    public static double Chessboard(IntPoint p, IntPoint q)\n    {\n        return Chessboard(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Chi Square distance between two normalized histograms.\n     *\n     * @param histogram1 Histogram.\n     * @param histogram2 Histogram.\n     * @return The Chi Square distance between x and y.\n     */\n    public static double ChiSquare(double[] histogram1, double[] histogram2)\n    {\n        double r = 0;\n        for (int i = 0; i < histogram1.length; i++)\n        {\n            double t = histogram1[i] + histogram2[i];\n            if (t != 0)\n                r += Math.pow(histogram1[i] - histogram2[i], 2) / t;\n        }\n\n        return 0.5 * r;\n    }\n\n    /**\n     * Gets the Correlation distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Correlation distance between x and y.\n     */\n    public static double Correlation(double[] p, double[] q)\n    {\n\n        double x = 0;\n        double y = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            x += -p[i];\n            y += -q[i];\n        }\n\n        x /= p.length;\n        y /= q.length;\n\n        double num = 0;\n        double den1 = 0;\n        double den2 = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            num += (p[i] + x) * (q[i] + y);\n\n            den1 += Math.abs(Math.pow(p[i] + x, 2));\n            den2 += Math.abs(Math.pow(q[i] + x, 2));\n        }\n\n        return 1 - (num / (Math.sqrt(den1) * Math.sqrt(den2)));\n\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double[] p, double[] q)\n    {\n        double sumProduct = 0;\n        double sumP = 0, sumQ = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            sumProduct += p[i] * q[i];\n            sumP += Math.pow(Math.abs(p[i]), 2);\n            sumQ += Math.pow(Math.abs(q[i]), 2);\n        }\n\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(double x1, double y1, double x2, double y2)\n    {\n\n        double sumProduct = x1 * x2 + y1 * y2;\n        double sumP = Math.pow(Math.abs(x1), 2) + Math.pow(Math.abs(x2), 2);\n        double sumQ = Math.pow(Math.abs(y1), 2) + Math.pow(Math.abs(y2), 2);\n        sumP = Math.sqrt(sumP);\n        sumQ = Math.sqrt(sumQ);\n\n        double result = 1 - (sumProduct / (sumP * sumQ));\n        return result;\n    }\n\n    /**\n     * Gets the Cosine distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Cosine distance between x and y.\n     */\n    public static double Cosine(IntPoint p, IntPoint q)\n    {\n        return Cosine(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double[] p, double[] q)\n    {\n        return Math.sqrt(SquaredEuclidean(p, q));\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * Gets the Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Euclidean distance between x and y.\n     */\n    public static double Euclidean(IntPoint p, IntPoint q)\n    {\n        return Euclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Hamming distance between two strings.\n     *\n     * @param first  First string.\n     * @param second Second string.\n     * @return The Hamming distance between p and q.\n     */\n    public static int Hamming(String first, String second)\n    {\n\n        if (first.length() != second.length())\n            throw new IllegalArgumentException(\"The size of string must be the same.\");\n\n        int diff = 0;\n        for (int i = 0; i < first.length(); i++)\n            if (first.charAt(i) != second.charAt(i))\n                diff++;\n        return diff;\n    }\n\n    /**\n     * Gets the Jaccard distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Jaccard distance between x and y.\n     */\n    public static double JaccardDistance(double[] p, double[] q)\n    {\n        double distance = 0;\n        int intersection = 0, union = 0;\n\n        for (int x = 0; x < p.length; x++)\n        {\n            if ((p[x] != 0) || (q[x] != 0))\n            {\n                if (p[x] == q[x])\n                {\n                    intersection++;\n                }\n\n                union++;\n            }\n        }\n\n        if (union != 0)\n            distance = 1.0 - ((double) intersection / (double) union);\n        else\n            distance = 0;\n\n        return distance;\n    }\n\n    /**\n     * Gets the J-Divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The J-Divergence between p and q.\n     */\n    public static double JDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += (p[i] - q[i]) * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen difference divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Jensen difference between p and q.\n     */\n    public static double JensenDifferenceDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                double pq = p[i] + q[i];\n                k += (p[i] * Math.log(p[i]) + q[i] * Math.log(q[i])) / 2 - (pq / 2) * Math.log(pq / 2);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Jensen Shannon divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The Jensen Shannon divergence between u and v.\n     */\n    public static double JensenShannonDivergence(double[] p, double[] q)\n    {\n        double[] m = new double[p.length];\n        for (int i = 0; i < m.length; i++)\n        {\n            m[i] = (p[i] + q[i]) / 2;\n        }\n\n        return (KullbackLeiblerDivergence(p, m) + KullbackLeiblerDivergence(q, m)) / 2;\n    }\n\n    /**\n     * Gets the K-Divergence.\n     *\n     * @param p U vector.\n     * @param q V vector.\n     * @return The K-Divergence between u and v.\n     */\n    public static double KDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] + q[i];\n            if (den != 0 && p[i] != 0)\n                r += p[i] * Math.log(2 * p[i] / den);\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Kumar-Johnson divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kumar-Johnson divergence between p and q.\n     */\n    public static double KumarJohnsonDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                r += Math.pow(p[i] * p[i] - q[i] * q[i], 2) / 2 * Math.pow(p[i] * q[i], 1.5);\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Kullback Leibler divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Kullback Leibler divergence between u and v.\n     */\n    public static double KullbackLeiblerDivergence(double[] p, double[] q)\n    {\n        boolean intersection = false;\n        double k = 0;\n\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                intersection = true;\n                k += p[i] * Math.log(p[i] / q[i]);\n            }\n        }\n\n        if (intersection)\n            return k;\n        else\n            return Double.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Gets the Mahalanobis distance.\n     *\n     * @param A Matrix A.\n     * @param B Matrix B.\n     * @return The Mahalanobis distance between A and B.\n     */\n    public static double Mahalanobis(double[][] A, double[][] B)\n    {\n\n        if (A[0].length != B[0].length)\n            throw new IllegalArgumentException(\"The number of columns of both matrix must be equals.\");\n\n        double[][] subA = new double[A.length][A[0].length];\n        double[][] subB = new double[B.length][B[0].length];\n\n        //Center data A\n        double[] meansA = new double[A[0].length];\n        for (int j = 0; j < A[0].length; j++)\n        {\n            for (int i = 0; i < A.length; i++)\n            {\n                meansA[j] += A[i][j];\n            }\n            meansA[j] /= (double) A.length;\n            for (int i = 0; i < A.length; i++)\n            {\n                subA[i][j] = A[i][j] - meansA[j];\n            }\n        }\n\n        //Center data B\n        double[] meansB = new double[B[0].length];\n        for (int j = 0; j < B[0].length; j++)\n        {\n            for (int i = 0; i < B.length; i++)\n            {\n                meansB[j] += B[i][j];\n            }\n            meansB[j] /= (double) B.length;\n            for (int i = 0; i < B.length; i++)\n            {\n                subB[i][j] = B[i][j] - meansB[j];\n            }\n        }\n\n        //Matrix of covariance\n        double[][] covA = Covariance(subA);\n        double[][] covB = Covariance(subB);\n\n        //Pooled covariance\n        double rows = subA.length + subB.length;\n        double[][] pCov = new double[covA.length][covA[0].length];\n        for (int i = 0; i < pCov.length; i++)\n        {\n            for (int j = 0; j < pCov[0].length; j++)\n            {\n                pCov[i][j] = covA[i][j] * ((double) subA.length / rows) + covB[i][j] * ((double) subB.length / rows);\n            }\n        }\n\n        //Inverse of pooled covariance\n        pCov = Matrix.Inverse(pCov);\n\n        //compute mean difference\n        double[] diff = new double[A[0].length];\n        for (int i = 0; i < diff.length; i++)\n        {\n            diff[i] = meansA[i] - meansB[i];\n        }\n\n        return Math.sqrt(Matrix.InnerProduct(Matrix.MultiplyByTranspose(pCov, diff), diff));\n\n    }\n\n    private static double Covariance(double[] x, double[] y, double meanX, double meanY)\n    {\n        double result = 0;\n        for (int i = 0; i < x.length; i++)\n        {\n            result += (x[i] - meanX) * (y[i] - meanY);\n        }\n\n        return result / (double) (x.length);\n    }\n\n    private static double[][] Covariance(double[][] matrix)\n    {\n        double[] means = new double[matrix[0].length];\n        for (int i = 0; i < matrix.length; i++)\n        {\n            for (int j = 0; j < matrix[0].length; j++)\n            {\n                means[j] += matrix[i][j];\n            }\n        }\n\n        for (int i = 0; i < means.length; i++)\n        {\n            means[i] /= means.length;\n        }\n\n        return Covariance(matrix, means);\n    }\n\n    private static double[][] Covariance(double[][] matrix, double[] means)\n    {\n        double[][] cov = new double[means.length][means.length];\n\n        for (int i = 0; i < cov.length; i++)\n        {\n            for (int j = 0; j < cov[0].length; j++)\n            {\n                cov[i][j] = Covariance(Matrix.getColumn(matrix, i), Matrix.getColumn(matrix, j), means[i], means[j]);\n            }\n        }\n\n        return cov;\n\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p A point in space.\n     * @param q A point in space.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double[] p, double[] q)\n    {\n        double sum = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            sum += Math.abs(p[i] - q[i]);\n        }\n        return sum;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(double x1, double y1, double x2, double y2)\n    {\n        double dx = Math.abs(x1 - x2);\n        double dy = Math.abs(y1 - y2);\n\n        return dx + dy;\n    }\n\n    /**\n     * Gets the Manhattan distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Manhattan distance between x and y.\n     */\n    public static double Manhattan(IntPoint p, IntPoint q)\n    {\n        return Manhattan(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param x1 X1 axis coordinate.\n     * @param y1 Y1 axis coordinate.\n     * @param x2 X2 axis coordinate.\n     * @param y2 Y2 axis coordinate.\n     * @param r  Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double x1, double y1, double x2, double y2, int r)\n    {\n        double sum = Math.pow(Math.abs(x1 - x2), r);\n        sum += Math.pow(Math.abs(y1 - y2), r);\n        return Math.pow(sum, 1 / r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @param r Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(IntPoint p, IntPoint q, int r)\n    {\n        return Minkowski(p.x, p.y, q.x, q.y, r);\n    }\n\n    /**\n     * Gets the Minkowski distance between two points.\n     *\n     * @param u A point in space.\n     * @param v A point in space.\n     * @param p Order between two points.\n     * @return The Minkowski distance between x and y.\n     */\n    public static double Minkowski(double[] u, double[] v, double p)\n    {\n        double distance = 0;\n        for (int i = 0; i < u.length; i++)\n        {\n            distance += Math.pow(Math.abs(u[i] - v[i]), p);\n        }\n        return Math.pow(distance, 1 / p);\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Quasi-Euclidean distance between x and y.\n     */\n    public static double QuasiEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        if (Math.abs(x1 - x2) > Math.abs(y1 - y2))\n        {\n            return Math.abs(x1 - x2) + (Constants.Sqrt2 - 1) * Math.abs(y1 - y2);\n        }\n        return (Constants.Sqrt2 - 1) * Math.abs(x1 - x2) + Math.abs(y1 - y2);\n\n    }\n\n    /**\n     * Gets the Quasi-Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Quasi Euclidean distance between p and q.\n     */\n    public static double QuasiEuclidean(IntPoint p, IntPoint q)\n    {\n        return QuasiEuclidean(p.x, p.y, q.x, q.y);\n    }\n\n    /**\n     * Gets the Square Euclidean distance between two points.\n     *\n     * @param x A point in space.\n     * @param y A point in space.\n     * @return The Square Euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double[] x, double[] y)\n    {\n        double d = 0.0, u;\n\n        for (int i = 0; i < x.length; i++)\n        {\n            u = x[i] - y[i];\n            d += u * u;\n        }\n\n        return d;\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param x1 X1 axis coordinates.\n     * @param y1 Y1 axis coordinates.\n     * @param x2 X2 axis coordinates.\n     * @param y2 Y2 axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(double x1, double y1, double x2, double y2)\n    {\n\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Squared Euclidean distance between two points.\n     *\n     * @param p IntPoint with X and Y axis coordinates.\n     * @param q IntPoint with X and Y axis coordinates.\n     * @return The Squared euclidean distance between x and y.\n     */\n    public static double SquaredEuclidean(IntPoint p, IntPoint q)\n    {\n\n        double dx = q.x - p.x;\n        double dy = q.y - p.y;\n        return dx * dx + dy * dy;\n\n    }\n\n    /**\n     * Gets the Symmetric Chi-square divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric chi-square divergence between p and q.\n     */\n    public static double SymmetricChiSquareDivergence(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            double den = p[i] * q[i];\n            if (den != 0)\n            {\n                double p1 = p[i] - q[i];\n                double p2 = p[i] + q[i];\n                r += (p1 * p1 * p2) / den;\n            }\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets the Symmetric Kullback-Leibler distance.\n     * This metric is valid only for real and positive P and Q.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Symmetric Kullback Leibler distance between p and q.\n     */\n    public static double SymmetricKullbackLeibler(double[] p, double[] q)\n    {\n        double dist = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            dist += (p[i] - q[i]) * (Math.log(p[i]) - Math.log(q[i]));\n        }\n\n        return dist;\n    }\n\n    /**\n     * Gets the Taneja divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Taneja divergence between p and q.\n     */\n    public static double Taneja(double[] p, double[] q)\n    {\n        double r = 0;\n        for (int i = 0; i < p.length; i++)\n        {\n            if (p[i] != 0 && q[i] != 0)\n            {\n                double pq = p[i] + q[i];\n                r += (pq / 2) * Math.log(pq / (2 * Math.sqrt(p[i] * q[i])));\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Gets the Topsoe divergence.\n     *\n     * @param p P vector.\n     * @param q Q vector.\n     * @return The Topsoe divergence between p and q.\n     */\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/jdt/triangulation/Triangle.java", "func_name": "Triangle.contains", "original_string": "public boolean contains(Vector3 p) {\n\t\tboolean ans = false;\n\t\tif(this.halfplane || p== null) return false;\n\n\t\tif (isCorner(p)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tPointLinePosition a12 = PointLineTest.pointLineTest(a,b,p);\n\t\tPointLinePosition a23 = PointLineTest.pointLineTest(b,c,p);\n\t\tPointLinePosition a31 = PointLineTest.pointLineTest(c,a,p);\n\n\t\tif ((a12 == PointLinePosition.LEFT && a23 == PointLinePosition.LEFT && a31 == PointLinePosition.LEFT ) ||\n\t\t\t\t(a12 == PointLinePosition.RIGHT && a23 == PointLinePosition.RIGHT && a31 == PointLinePosition.RIGHT ) ||\n\t\t\t\t(a12 == PointLinePosition.ON_SEGMENT ||a23 == PointLinePosition.ON_SEGMENT ||  a31 == PointLinePosition.ON_SEGMENT)) {\n\t\t\tans = true;\n\t\t}\n\n\t\treturn ans;\n\t}", "language": "java", "code": "public boolean contains(Vector3 p) {\n\t\tboolean ans = false;\n\t\tif(this.halfplane || p== null) return false;\n\n\t\tif (isCorner(p)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tPointLinePosition a12 = PointLineTest.pointLineTest(a,b,p);\n\t\tPointLinePosition a23 = PointLineTest.pointLineTest(b,c,p);\n\t\tPointLinePosition a31 = PointLineTest.pointLineTest(c,a,p);\n\n\t\tif ((a12 == PointLinePosition.LEFT && a23 == PointLinePosition.LEFT && a31 == PointLinePosition.LEFT ) ||\n\t\t\t\t(a12 == PointLinePosition.RIGHT && a23 == PointLinePosition.RIGHT && a31 == PointLinePosition.RIGHT ) ||\n\t\t\t\t(a12 == PointLinePosition.ON_SEGMENT ||a23 == PointLinePosition.ON_SEGMENT ||  a31 == PointLinePosition.ON_SEGMENT)) {\n\t\t\tans = true;\n\t\t}\n\n\t\treturn ans;\n\t}", "code_tokens": ["public", "boolean", "contains", "(", "Vector3", "p", ")", "{", "boolean", "ans", "=", "false", ";", "if", "(", "this", ".", "halfplane", "||", "p", "==", "null", ")", "return", "false", ";", "if", "(", "isCorner", "(", "p", ")", ")", "{", "return", "true", ";", "}", "PointLinePosition", "a12", "=", "PointLineTest", ".", "pointLineTest", "(", "a", ",", "b", ",", "p", ")", ";", "PointLinePosition", "a23", "=", "PointLineTest", ".", "pointLineTest", "(", "b", ",", "c", ",", "p", ")", ";", "PointLinePosition", "a31", "=", "PointLineTest", ".", "pointLineTest", "(", "c", ",", "a", ",", "p", ")", ";", "if", "(", "(", "a12", "==", "PointLinePosition", ".", "LEFT", "&&", "a23", "==", "PointLinePosition", ".", "LEFT", "&&", "a31", "==", "PointLinePosition", ".", "LEFT", ")", "||", "(", "a12", "==", "PointLinePosition", ".", "RIGHT", "&&", "a23", "==", "PointLinePosition", ".", "RIGHT", "&&", "a31", "==", "PointLinePosition", ".", "RIGHT", ")", "||", "(", "a12", "==", "PointLinePosition", ".", "ON_SEGMENT", "||", "a23", "==", "PointLinePosition", ".", "ON_SEGMENT", "||", "a31", "==", "PointLinePosition", ".", "ON_SEGMENT", ")", ")", "{", "ans", "=", "true", ";", "}", "return", "ans", ";", "}"], "docstring": "determinates if this triangle contains the point p.\n@param p the query point\n@return true iff p is not null and is inside this triangle (Note: on boundary is considered inside!!).", "docstring_tokens": ["determinates", "if", "this", "triangle", "contains", "the", "point", "p", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/jdt/triangulation/Triangle.java#L226-L245", "partition": "train", "up_fun_num": 18, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.badlogic.gdx.math.Vector3;", "import com.harium.etyl.geometry.BoundingBox;", "import com.harium.etyl.geometry.Circle3;"], "function": ["public class Triangle\n", "    private boolean isClockWise(Vector3 a, Vector3 b, Vector3 c)\n", "    public Vector3 generateEquilateralPoint(Vector3 a, Vector3 b)\n", "    public boolean isHalfplane()\n", "    public Vector3 p1()\n", "    public Vector3 p2()\n", "    public Vector3 p3()\n", "    public Triangle next_12()\n", "    public Triangle next_23()\n", "    public Triangle next_31()\n", "    public BoundingBox getBoundingBox()\n", "    void switchneighbors( Triangle old, Triangle newTriangle )\n", "    Triangle neighbor( Vector3 p )\n", "    Triangle nextNeighbor(Vector3 p, Triangle prevTriangle)\n", "    Circle3 circumcircle()\n", "    boolean circumcircleContains( Vector3 p )\n", "    public String toString()\n", "    public boolean containsBoundaryIsOutside(Vector3 p)\n", "    public boolean isCorner(Vector3 p)\n", "    public boolean fallInsideCircumcircle(Vector3[] arrayPoints)\n", "    public float z_value(Vector3 q)\n", "    public double z(float x, float y)\n", "    public Vector3 z(Vector3 q)\n", "    public Vector3 getA()\n", "    public Vector3 getB()\n", "    public Vector3 getC()\n", "    public static float calcDet(Vector3 a, Vector3 b, Vector3 c)\n", "    public double calcDet()\n", "    public boolean shareSegment(Triangle t2)\n", "    public int sharedSegments(Triangle t2)\n", "    public int hashCode()\n", "    public boolean equals(Object obj)\n", "    public boolean equals(Triangle other)\n"], "context": "package jdt.triangulation;\n\n\nimport com.badlogic.gdx.math.Vector3;\nimport com.harium.etyl.geometry.BoundingBox;\nimport com.harium.etyl.geometry.Circle3;\n\n/**\n * This class represents a 3D triangle in a Triangulation!\n *\n */\n\npublic class Triangle\n{\n\n    protected Vector3 a;\n    protected Vector3 b;\n    protected Vector3 c;\n\n    protected Triangle abnext, bcnext, canext;\n    protected Circle3 circum;\n\n    int modCounter = 0; // modcounter for triangulation fast update.\n\n    boolean halfplane = false; // true iff it is an infinite face.\n\n    boolean mark = false;   // tag - for bfs algorithms\n\n    public static int counter = 0, counter2 = 0;\n\n    /** constructs a triangle form 3 point - store it in counterclockwised order.*/\n    public Triangle(Vector3 a, Vector3 b, Vector3 c)\n    {\n        this.a = a;\n\n        if(isClockWise(a, b, c) )\n        {\n            this.b = b;\n            this.c = c;\n        }\n        else      // RIGHT\n        {\n            System.out.println(\"Warning, ajTriangle(A,B,C) \" +\n                               \"expects points in counterclockwise order.\");\n            System.out.println(\"\" + a + b + c);\n            this.b = c;\n            this.c = b;\n        }\n        circumcircle();\n    }\n\n    private boolean isClockWise(Vector3 a, Vector3 b, Vector3 c)\n    {\n        PointLinePosition res = PointLineTest.pointLineTest(a, b, c);\n\n        return (res == PointLinePosition.LEFT) || (res == PointLinePosition.ON_SEGMENT) ||\n               (res == PointLinePosition.INFRONT_OF_A) || (res == PointLinePosition.BEHIND_B);\n    }\n\n    /**\n     * creates a half plane using the segment (A,B).\n     * @param A\n     * @param b\n     */\n    public Triangle( Vector3 A, Vector3 b)\n    {\n        //  visitflag=visitValue;\n        this.a = A;\n        this.b = b;\n        this.c = generateEquilateralPoint(a, b);\n\n        halfplane = true;\n    }\n\n    public Vector3 generateEquilateralPoint(Vector3 a, Vector3 b)\n    {\n\n        double sin = Math.sin(60 * Math.PI / 180.0);\n        double cos = Math.cos(60 * Math.PI / 180.0);\n\n        double mz = (a.z + b.z) / 2;\n\n        double cx = cos * (a.x - b.x) - sin * (a.y - b.y) + b.x;\n        double cy = sin * (a.x - b.x) + cos * (a.y - b.y) + b.y;\n\n        Vector3 c = new Vector3((float)cx, (float)cy, (float)mz);\n        return c;\n    }\n\n    /* protected void finalize() throws Throwable{\n     super.finalize();\n     _counter--;\n    } */\n\n    /**\n     * remove all pointers (for debug)\n     */\n    //public void clear() {\n    // this.abnext = null; this.bcnext=null; this.canext=null;}\n\n    /**\n     * returns true iff this triangle is actually a half plane.\n     */\n    public boolean isHalfplane()\n    {\n        return this.halfplane;\n    }\n    /**\n     * returns the first vertex of this triangle.\n     */\n    public Vector3 p1()\n    {\n        return a;\n    }\n    /**\n     * returns the second vertex of this triangle.\n     */\n    public Vector3 p2()\n    {\n        return b;\n    }\n    /**\n     * returns the 3th vertex of this triangle.\n     */\n    public Vector3 p3()\n    {\n        return c;\n    }\n    /**\n     * returns the consecutive triangle which shares this triangle p1,p2 edge.\n     */\n    public Triangle next_12()\n    {\n        return this.abnext;\n    }\n    /**\n     * returns the consecutive triangle which shares this triangle p2,p3 edge.\n     */\n    public Triangle next_23()\n    {\n        return this.bcnext;\n    }\n    /**\n     * returns the consecutive triangle which shares this triangle p3,p1 edge.\n     */\n    public Triangle next_31()\n    {\n        return this.canext;\n    }\n\n    /**\n     * @return  The bounding rectange between the minimum and maximum coordinates\n     *                of the triangle\n     */\n    public BoundingBox getBoundingBox()\n    {\n        Vector3 lowerLeft, upperRight;\n        lowerLeft = new Vector3(Math.min(a.x, Math.min(b.x, c.x)), Math.min(getA().y, Math.min(b.y, c.y)), 0);\n        upperRight = new Vector3(Math.max(a.x, Math.max(b.x, c.x)),  Math.max(getA().y, Math.max(b.y, c.y)), 0);\n        return new BoundingBox(lowerLeft, upperRight);\n    }\n\n    void switchneighbors( Triangle old, Triangle newTriangle )\n    {\n        if ( abnext == old )\n        {\n            abnext = newTriangle;\n        }\n        else if ( bcnext == old )\n        {\n            bcnext = newTriangle;\n        }\n        else if ( canext == old )\n        {\n            canext = newTriangle;\n        }\n        else System.out.println( \"Error, switchneighbors can't find Old.\" );\n    }\n\n    Triangle neighbor( Vector3 p )\n    {\n        if ( a.equals(p) ) return canext;\n        if ( b.equals(p) ) return abnext;\n        if ( c.equals(p) ) return bcnext;\n        System.out.println( \"Error, neighbors can't find p: \" + p );\n        return null;\n    }\n\n    /**\n     * Returns the neighbors that shares the given corner and is not the previous triangle.\n     * @param p The given corner\n     * @param prevTriangle The previous triangle.\n     * @return The neighbors that shares the given corner and is not the previous triangle.\n     *\n     * By: Eyal Roth & Doron Ganel.\n     */\n    Triangle nextNeighbor(Vector3 p, Triangle prevTriangle)\n    {\n        Triangle neighbor = null;\n\n        if (a.equals(p))\n        {\n            neighbor =  canext;\n        }\n        if (b.equals(p))\n        {\n            neighbor = abnext;\n        }\n        if (c.equals(p))\n        {\n            neighbor = bcnext;\n        }\n\n        if(prevTriangle == null)\n        {\n            return neighbor;\n        }\n\n        // Udi Schneider: Added a condition check for isHalfPlane. If the current\n        // neighbor is a half plane, we also want to move to the next neighbor\n        if (neighbor.equals(prevTriangle) || neighbor.isHalfplane())\n        {\n            if (a.equals(p))\n            {\n                neighbor =  abnext;\n            }\n            if (b.equals(p))\n            {\n                neighbor = bcnext;\n            }\n            if (c.equals(p))\n            {\n                neighbor = canext;\n            }\n        }\n\n        return neighbor;\n    }\n\n    Circle3 circumcircle()\n    {\n        float u = ((a.x - b.x) * (a.x + b.x) + (a.y - b.y) * (a.y + b.y)) / 2.0f;\n        float v = ((b.x - c.x) * (b.x + c.x) + (b.y - c.y) * (b.y + c.y)) / 2.0f;\n        float den = (a.x - b.x) * (b.y - c.y) - (b.x - c.x) * (a.y - b.y);\n        if ( den == 0 ) // oops, degenerate case\n            circum = new Circle3( a, Float.POSITIVE_INFINITY );\n        else\n        {\n            Vector3 cen = new Vector3((u * (b.y - c.y) - v * (a.y - b.y)) / den,\n                                      (v * (a.x - b.x) - u * (b.x - c.x)) / den, 0);\n            circum = new Circle3( cen, cen.dst(a) );\n        }\n        return circum;\n    }\n\n    boolean circumcircleContains( Vector3 p )\n    {\n        return circum.contains(p);\n    }\n\n    public String toString()\n    {\n        String res = \"\"; //+_id+\") \";\n        res += a.toString() + b.toString();\n        if ( !halfplane )\n            res += c.toString() ;\n        // res +=c.toString() +\"   | \"+abnext._id+\" \"+bcnext._id+\" \"+canext._id;\n        return res;\n    }\n\n    /**\n     * determinates if this triangle contains the point p.\n     * @param p the query point\n     * @return true iff p is not null and is inside this triangle (Note: on boundary is considered inside!!).\n     */\n\n    /**\n     * determinates if this triangle contains the point p.\n     * @param p the query point\n     *  @return true iff p is not null and is inside this triangle (Note: on boundary is considered outside!!).\n     */\n    public boolean containsBoundaryIsOutside(Vector3 p)\n    {\n        boolean ans = false;\n        if(this.halfplane || p == null) return false;\n\n        if (isCorner(p))\n        {\n            return true;\n        }\n\n        PointLinePosition a12 = PointLineTest.pointLineTest(a, b, p);\n        PointLinePosition a23 = PointLineTest.pointLineTest(b, c, p);\n        PointLinePosition a31 = PointLineTest.pointLineTest(c, a, p);\n\n        if ((a12 == PointLinePosition.LEFT && a23 == PointLinePosition.LEFT && a31 == PointLinePosition.LEFT ) ||\n                (a12 == PointLinePosition.RIGHT && a23 == PointLinePosition.RIGHT && a31 == PointLinePosition.RIGHT ))\n        {\n            ans = true;\n        }\n\n        return ans;\n    }\n\n    /**\n     * Checks if the given point is a corner of this triangle.\n     * @param p The given point.\n     * @return True iff the given point is a corner of this triangle.\n     *\n     * By Eyal Roth & Doron Ganel.\n     */\n    public boolean isCorner(Vector3 p)\n    {\n        return (p == a || p == b || p == c);\n    }\n\n    //Doron\n    public boolean fallInsideCircumcircle(Vector3[] arrayPoints)\n    {\n        boolean isInside = false;\n        Vector3 p1 = this.p1();\n        Vector3 p2 = this.p2();\n        Vector3 p3 = this.p3();\n        int i = 0;\n        while(!isInside && i < arrayPoints.length)\n        {\n            Vector3 p = arrayPoints[i];\n            if(!p.equals(p1) && !p.equals(p2) && !p.equals(p3))\n            {\n                isInside = this.circumcircleContains(p);\n            }\n            i++;\n        }\n\n        return isInside;\n    }\n\n    /**\n     * compute the Z value for the X,Y values of q. <br />\n     * assume this triangle represent a plane --> q does NOT need to be contained\n     * in this triangle.\n     *\n     * @param q query point (its Z value is ignored).\n     * @return the Z value of this plane implies by this triangle 3 points.\n     */\n    public float z_value(Vector3 q)\n    {\n        if(q == null || this.halfplane) throw new RuntimeException(\"*** ERR wrong parameters, can't approximate the z value ..***: \" + q);\n        /* incase the query point is on one of the points */\n        if(q.x == a.x & q.y == a.y) return a.z;\n        if(q.x == b.x & q.y == b.y) return b.z;\n        if(q.x == c.x & q.y == c.y) return c.z;\n\n        /*\n         *  plane: aX + bY + c = Z:\n         *  2D line: y= mX + k\n         *\n         */\n        float x = 0, x0 = q.x, x1 = a.x, x2 = b.x, x3 = c.x;\n        float y = 0, y0 = q.y, y1 = a.y, y2 = b.y, y3 = c.y;\n        float z = 0, m01 = 0, k01 = 0, m23 = 0, k23 = 0;\n\n        float r = 0;\n\n        // 0 - regular, 1-horizontal , 2-vertical.\n        int flag01 = 0;\n        if(x0 != x1)\n        {\n            m01 = (y0 - y1) / (x0 - x1);\n            k01 = y0 - m01 * x0;\n            if (m01 == 0)\n            {\n                flag01 = 1;\n            }\n        }\n        else     // 2-vertical.\n        {\n            flag01 = 2;//x01 = x0\n        }\n        int flag23 = 0;\n        if(x2 != x3)\n        {\n            m23 = (y2 - y3) / (x2 - x3);\n            k23 = y2 - m23 * x2;\n            if (m23 == 0)\n            {\n                flag23 = 1;\n            }\n        }\n        else   // 2-vertical.\n        {\n            flag23 = 2;//x01 = x0\n        }\n\n        if (flag01 == 2 )\n        {\n            x = x0;\n            y = m23 * x + k23;\n        }\n        else\n        {\n            if(flag23 == 2)\n            {\n                x = x2;\n                y = m01 * x + k01;\n            }\n            else    // regular case\n            {\n                x = (k23 - k01) / (m01 - m23);\n                y = m01 * x + k01;\n\n            }\n        }\n        if(flag23 == 2)\n        {\n            r = (y2 - y) / (y2 - y3);\n        }\n        else\n        {\n            r = (x2 - x) / (x2 - x3);\n        }\n\n        z = b.z + (c.z - b.z) * r;\n        if(flag01 == 2)\n        {\n            r = (y1 - y0) / (y1 - y);\n        }\n        else\n        {\n            r = (x1 - x0) / (x1 - x);\n        }\n        float qZ = a.z + (z - a.z) * r;\n        return qZ;\n    }\n\n    /**\n     * compute the Z value for the X,Y values of q.\n     * assume this triangle represent a plane --> q does NOT need to be contained\n     * in this triangle.\n     *\n     * @param x  x-coordinate of the query point.\n     * @param y  y-coordinate of the query point.\n     * @return z (height) value approximation given by the triangle it falls in.\n     *\n     */\n    public double z(float x, float y)\n    {\n        return z_value(new Vector3(x, y, 0));\n    }\n    /**\n     * compute the Z value for the X,Y values of q.\n     * assume this triangle represent a plane --> q does NOT need to be contained\n     * in this triangle.\n     *\n     * @param q query point (its Z value is ignored).\n     * @return q with updated Z value.\n     *\n     */\n    public Vector3 z(Vector3 q)\n    {\n        float z = z_value(q);\n        return new Vector3(q.x, q.y, z);\n    }\n\n    public Vector3 getA()\n    {\n        return a;\n    }\n\n    public Vector3 getB()\n    {\n        return b;\n    }\n\n    public Vector3 getC()\n    {\n        return c;\n    }\n\n    //checks if the triangle is not re-entrant\n    public static float calcDet(Vector3 a, Vector3 b, Vector3 c)\n    {\n        return (a.x * (b.y - c.y)) - (a.y * (b.x - c.x)) + (b.x * c.y - b.y * c.x);\n    }\n\n    public double calcDet()\n    {\n        return Triangle.calcDet(a, b, c);\n    }\n\n    /**\n     * checks if the 2 triangles shares a segment\n     * @author Doron Ganel & Eyal Roth(2009)\n     * @param t2 - a second triangle\n     * @return boolean\n     */\n    public boolean shareSegment(Triangle t2)\n    {\n        return sharedSegments(t2) >= 2;\n    }\n\n    /**\n     * checks if the 2 triangles shares a segment\n     * @author Doron Ganel & Eyal Roth(2009)\n     * @param t2 - a second triangle\n     * @return boolean\n     */\n    public int sharedSegments(Triangle t2)\n    {\n        int counter = 0;\n\n        if(a.equals(t2.a))\n        {\n            counter++;\n        }\n        if(a.equals(t2.b))\n        {\n            counter++;\n        }\n        if(a.equals(t2.c))\n        {\n            counter++;\n        }\n        if(b.equals(t2.a))\n        {\n            counter++;\n        }\n        if(b.equals(t2.b))\n        {\n            counter++;\n        }\n        if(b.equals(t2.c))\n        {\n            counter++;\n        }\n        if(c.equals(t2.a))\n        {\n            counter++;\n        }\n        if(c.equals(t2.b))\n        {\n            counter++;\n        }\n        if(c.equals(t2.c))\n        {\n            counter++;\n        }\n\n        return counter;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((a == null) ? 0 : a.hashCode());\n        result = prime * result + ((b == null) ? 0 : b.hashCode());\n        result = prime * result + ((c == null) ? 0 : c.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj)\n    {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n\n        return equals((Triangle) obj);\n    }\n\n    public boolean equals(Triangle other)\n    {\n\n        if (a == null)\n        {\n            if (other.a != null)\n            {\n                return false;\n            }\n        }\n        else if (!a.equals(other.a) && !a.equals(other.b) && !a.equals(other.c))\n        {\n            return false;\n        }\n\n        if (b == null)\n        {\n            if (other.b != null)\n            {\n                return false;\n            }\n        }\n        else if (!b.equals(other.a) && !b.equals(other.b) && !b.equals(other.c))\n        {\n            return false;\n        }\n\n        if (c == null)\n        {\n            if (other.c != null)\n            {\n                return false;\n            }\n        }\n        else if (!c.equals(other.a) && !c.equals(other.b) && !c.equals(other.c))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/jdt/triangulation/Triangle.java", "func_name": "Triangle.calcDet", "original_string": "public static float calcDet(Vector3 a ,Vector3 b, Vector3 c) {\n\t\treturn (a.x*(b.y-c.y)) - (a.y*(b.x-c.x)) + (b.x*c.y-b.y*c.x);\n\t}", "language": "java", "code": "public static float calcDet(Vector3 a ,Vector3 b, Vector3 c) {\n\t\treturn (a.x*(b.y-c.y)) - (a.y*(b.x-c.x)) + (b.x*c.y-b.y*c.x);\n\t}", "code_tokens": ["public", "static", "float", "calcDet", "(", "Vector3", "a", ",", "Vector3", "b", ",", "Vector3", "c", ")", "{", "return", "(", "a", ".", "x", "*", "(", "b", ".", "y", "-", "c", ".", "y", ")", ")", "-", "(", "a", ".", "y", "*", "(", "b", ".", "x", "-", "c", ".", "x", ")", ")", "+", "(", "b", ".", "x", "*", "c", ".", "y", "-", "b", ".", "y", "*", "c", ".", "x", ")", ";", "}"], "docstring": "checks if the triangle is not re-entrant", "docstring_tokens": ["checks", "if", "the", "triangle", "is", "not", "re", "-", "entrant"], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/jdt/triangulation/Triangle.java#L423-L425", "partition": "train", "up_fun_num": 28, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.badlogic.gdx.math.Vector3;", "import com.harium.etyl.geometry.BoundingBox;", "import com.harium.etyl.geometry.Circle3;"], "function": ["public class Triangle\n", "    private boolean isClockWise(Vector3 a, Vector3 b, Vector3 c)\n", "    public Vector3 generateEquilateralPoint(Vector3 a, Vector3 b)\n", "    public boolean isHalfplane()\n", "    public Vector3 p1()\n", "    public Vector3 p2()\n", "    public Vector3 p3()\n", "    public Triangle next_12()\n", "    public Triangle next_23()\n", "    public Triangle next_31()\n", "    public BoundingBox getBoundingBox()\n", "    void switchneighbors( Triangle old, Triangle newTriangle )\n", "    Triangle neighbor( Vector3 p )\n", "    Triangle nextNeighbor(Vector3 p, Triangle prevTriangle)\n", "    Circle3 circumcircle()\n", "    boolean circumcircleContains( Vector3 p )\n", "    public String toString()\n", "    public boolean contains(Vector3 p)\n", "    public boolean containsBoundaryIsOutside(Vector3 p)\n", "    public boolean isCorner(Vector3 p)\n", "    public boolean fallInsideCircumcircle(Vector3[] arrayPoints)\n", "    public float z_value(Vector3 q)\n", "    public double z(float x, float y)\n", "    public Vector3 z(Vector3 q)\n", "    public Vector3 getA()\n", "    public Vector3 getB()\n", "    public Vector3 getC()\n", "    public double calcDet()\n", "    public boolean shareSegment(Triangle t2)\n", "    public int sharedSegments(Triangle t2)\n", "    public int hashCode()\n", "    public boolean equals(Object obj)\n", "    public boolean equals(Triangle other)\n"], "context": "package jdt.triangulation;\n\n\nimport com.badlogic.gdx.math.Vector3;\nimport com.harium.etyl.geometry.BoundingBox;\nimport com.harium.etyl.geometry.Circle3;\n\n/**\n * This class represents a 3D triangle in a Triangulation!\n *\n */\n\npublic class Triangle\n{\n\n    protected Vector3 a;\n    protected Vector3 b;\n    protected Vector3 c;\n\n    protected Triangle abnext, bcnext, canext;\n    protected Circle3 circum;\n\n    int modCounter = 0; // modcounter for triangulation fast update.\n\n    boolean halfplane = false; // true iff it is an infinite face.\n\n    boolean mark = false;   // tag - for bfs algorithms\n\n    public static int counter = 0, counter2 = 0;\n\n    /** constructs a triangle form 3 point - store it in counterclockwised order.*/\n    public Triangle(Vector3 a, Vector3 b, Vector3 c)\n    {\n        this.a = a;\n\n        if(isClockWise(a, b, c) )\n        {\n            this.b = b;\n            this.c = c;\n        }\n        else      // RIGHT\n        {\n            System.out.println(\"Warning, ajTriangle(A,B,C) \" +\n                               \"expects points in counterclockwise order.\");\n            System.out.println(\"\" + a + b + c);\n            this.b = c;\n            this.c = b;\n        }\n        circumcircle();\n    }\n\n    private boolean isClockWise(Vector3 a, Vector3 b, Vector3 c)\n    {\n        PointLinePosition res = PointLineTest.pointLineTest(a, b, c);\n\n        return (res == PointLinePosition.LEFT) || (res == PointLinePosition.ON_SEGMENT) ||\n               (res == PointLinePosition.INFRONT_OF_A) || (res == PointLinePosition.BEHIND_B);\n    }\n\n    /**\n     * creates a half plane using the segment (A,B).\n     * @param A\n     * @param b\n     */\n    public Triangle( Vector3 A, Vector3 b)\n    {\n        //  visitflag=visitValue;\n        this.a = A;\n        this.b = b;\n        this.c = generateEquilateralPoint(a, b);\n\n        halfplane = true;\n    }\n\n    public Vector3 generateEquilateralPoint(Vector3 a, Vector3 b)\n    {\n\n        double sin = Math.sin(60 * Math.PI / 180.0);\n        double cos = Math.cos(60 * Math.PI / 180.0);\n\n        double mz = (a.z + b.z) / 2;\n\n        double cx = cos * (a.x - b.x) - sin * (a.y - b.y) + b.x;\n        double cy = sin * (a.x - b.x) + cos * (a.y - b.y) + b.y;\n\n        Vector3 c = new Vector3((float)cx, (float)cy, (float)mz);\n        return c;\n    }\n\n    /* protected void finalize() throws Throwable{\n     super.finalize();\n     _counter--;\n    } */\n\n    /**\n     * remove all pointers (for debug)\n     */\n    //public void clear() {\n    // this.abnext = null; this.bcnext=null; this.canext=null;}\n\n    /**\n     * returns true iff this triangle is actually a half plane.\n     */\n    public boolean isHalfplane()\n    {\n        return this.halfplane;\n    }\n    /**\n     * returns the first vertex of this triangle.\n     */\n    public Vector3 p1()\n    {\n        return a;\n    }\n    /**\n     * returns the second vertex of this triangle.\n     */\n    public Vector3 p2()\n    {\n        return b;\n    }\n    /**\n     * returns the 3th vertex of this triangle.\n     */\n    public Vector3 p3()\n    {\n        return c;\n    }\n    /**\n     * returns the consecutive triangle which shares this triangle p1,p2 edge.\n     */\n    public Triangle next_12()\n    {\n        return this.abnext;\n    }\n    /**\n     * returns the consecutive triangle which shares this triangle p2,p3 edge.\n     */\n    public Triangle next_23()\n    {\n        return this.bcnext;\n    }\n    /**\n     * returns the consecutive triangle which shares this triangle p3,p1 edge.\n     */\n    public Triangle next_31()\n    {\n        return this.canext;\n    }\n\n    /**\n     * @return  The bounding rectange between the minimum and maximum coordinates\n     *                of the triangle\n     */\n    public BoundingBox getBoundingBox()\n    {\n        Vector3 lowerLeft, upperRight;\n        lowerLeft = new Vector3(Math.min(a.x, Math.min(b.x, c.x)), Math.min(getA().y, Math.min(b.y, c.y)), 0);\n        upperRight = new Vector3(Math.max(a.x, Math.max(b.x, c.x)),  Math.max(getA().y, Math.max(b.y, c.y)), 0);\n        return new BoundingBox(lowerLeft, upperRight);\n    }\n\n    void switchneighbors( Triangle old, Triangle newTriangle )\n    {\n        if ( abnext == old )\n        {\n            abnext = newTriangle;\n        }\n        else if ( bcnext == old )\n        {\n            bcnext = newTriangle;\n        }\n        else if ( canext == old )\n        {\n            canext = newTriangle;\n        }\n        else System.out.println( \"Error, switchneighbors can't find Old.\" );\n    }\n\n    Triangle neighbor( Vector3 p )\n    {\n        if ( a.equals(p) ) return canext;\n        if ( b.equals(p) ) return abnext;\n        if ( c.equals(p) ) return bcnext;\n        System.out.println( \"Error, neighbors can't find p: \" + p );\n        return null;\n    }\n\n    /**\n     * Returns the neighbors that shares the given corner and is not the previous triangle.\n     * @param p The given corner\n     * @param prevTriangle The previous triangle.\n     * @return The neighbors that shares the given corner and is not the previous triangle.\n     *\n     * By: Eyal Roth & Doron Ganel.\n     */\n    Triangle nextNeighbor(Vector3 p, Triangle prevTriangle)\n    {\n        Triangle neighbor = null;\n\n        if (a.equals(p))\n        {\n            neighbor =  canext;\n        }\n        if (b.equals(p))\n        {\n            neighbor = abnext;\n        }\n        if (c.equals(p))\n        {\n            neighbor = bcnext;\n        }\n\n        if(prevTriangle == null)\n        {\n            return neighbor;\n        }\n\n        // Udi Schneider: Added a condition check for isHalfPlane. If the current\n        // neighbor is a half plane, we also want to move to the next neighbor\n        if (neighbor.equals(prevTriangle) || neighbor.isHalfplane())\n        {\n            if (a.equals(p))\n            {\n                neighbor =  abnext;\n            }\n            if (b.equals(p))\n            {\n                neighbor = bcnext;\n            }\n            if (c.equals(p))\n            {\n                neighbor = canext;\n            }\n        }\n\n        return neighbor;\n    }\n\n    Circle3 circumcircle()\n    {\n        float u = ((a.x - b.x) * (a.x + b.x) + (a.y - b.y) * (a.y + b.y)) / 2.0f;\n        float v = ((b.x - c.x) * (b.x + c.x) + (b.y - c.y) * (b.y + c.y)) / 2.0f;\n        float den = (a.x - b.x) * (b.y - c.y) - (b.x - c.x) * (a.y - b.y);\n        if ( den == 0 ) // oops, degenerate case\n            circum = new Circle3( a, Float.POSITIVE_INFINITY );\n        else\n        {\n            Vector3 cen = new Vector3((u * (b.y - c.y) - v * (a.y - b.y)) / den,\n                                      (v * (a.x - b.x) - u * (b.x - c.x)) / den, 0);\n            circum = new Circle3( cen, cen.dst(a) );\n        }\n        return circum;\n    }\n\n    boolean circumcircleContains( Vector3 p )\n    {\n        return circum.contains(p);\n    }\n\n    public String toString()\n    {\n        String res = \"\"; //+_id+\") \";\n        res += a.toString() + b.toString();\n        if ( !halfplane )\n            res += c.toString() ;\n        // res +=c.toString() +\"   | \"+abnext._id+\" \"+bcnext._id+\" \"+canext._id;\n        return res;\n    }\n\n    /**\n     * determinates if this triangle contains the point p.\n     * @param p the query point\n     * @return true iff p is not null and is inside this triangle (Note: on boundary is considered inside!!).\n     */\n    public boolean contains(Vector3 p)\n    {\n        boolean ans = false;\n        if(this.halfplane || p == null) return false;\n\n        if (isCorner(p))\n        {\n            return true;\n        }\n\n        PointLinePosition a12 = PointLineTest.pointLineTest(a, b, p);\n        PointLinePosition a23 = PointLineTest.pointLineTest(b, c, p);\n        PointLinePosition a31 = PointLineTest.pointLineTest(c, a, p);\n\n        if ((a12 == PointLinePosition.LEFT && a23 == PointLinePosition.LEFT && a31 == PointLinePosition.LEFT ) ||\n                (a12 == PointLinePosition.RIGHT && a23 == PointLinePosition.RIGHT && a31 == PointLinePosition.RIGHT ) ||\n                (a12 == PointLinePosition.ON_SEGMENT || a23 == PointLinePosition.ON_SEGMENT ||  a31 == PointLinePosition.ON_SEGMENT))\n        {\n            ans = true;\n        }\n\n        return ans;\n    }\n\n    /**\n     * determinates if this triangle contains the point p.\n     * @param p the query point\n     *  @return true iff p is not null and is inside this triangle (Note: on boundary is considered outside!!).\n     */\n    public boolean containsBoundaryIsOutside(Vector3 p)\n    {\n        boolean ans = false;\n        if(this.halfplane || p == null) return false;\n\n        if (isCorner(p))\n        {\n            return true;\n        }\n\n        PointLinePosition a12 = PointLineTest.pointLineTest(a, b, p);\n        PointLinePosition a23 = PointLineTest.pointLineTest(b, c, p);\n        PointLinePosition a31 = PointLineTest.pointLineTest(c, a, p);\n\n        if ((a12 == PointLinePosition.LEFT && a23 == PointLinePosition.LEFT && a31 == PointLinePosition.LEFT ) ||\n                (a12 == PointLinePosition.RIGHT && a23 == PointLinePosition.RIGHT && a31 == PointLinePosition.RIGHT ))\n        {\n            ans = true;\n        }\n\n        return ans;\n    }\n\n    /**\n     * Checks if the given point is a corner of this triangle.\n     * @param p The given point.\n     * @return True iff the given point is a corner of this triangle.\n     *\n     * By Eyal Roth & Doron Ganel.\n     */\n    public boolean isCorner(Vector3 p)\n    {\n        return (p == a || p == b || p == c);\n    }\n\n    //Doron\n    public boolean fallInsideCircumcircle(Vector3[] arrayPoints)\n    {\n        boolean isInside = false;\n        Vector3 p1 = this.p1();\n        Vector3 p2 = this.p2();\n        Vector3 p3 = this.p3();\n        int i = 0;\n        while(!isInside && i < arrayPoints.length)\n        {\n            Vector3 p = arrayPoints[i];\n            if(!p.equals(p1) && !p.equals(p2) && !p.equals(p3))\n            {\n                isInside = this.circumcircleContains(p);\n            }\n            i++;\n        }\n\n        return isInside;\n    }\n\n    /**\n     * compute the Z value for the X,Y values of q. <br />\n     * assume this triangle represent a plane --> q does NOT need to be contained\n     * in this triangle.\n     *\n     * @param q query point (its Z value is ignored).\n     * @return the Z value of this plane implies by this triangle 3 points.\n     */\n    public float z_value(Vector3 q)\n    {\n        if(q == null || this.halfplane) throw new RuntimeException(\"*** ERR wrong parameters, can't approximate the z value ..***: \" + q);\n        /* incase the query point is on one of the points */\n        if(q.x == a.x & q.y == a.y) return a.z;\n        if(q.x == b.x & q.y == b.y) return b.z;\n        if(q.x == c.x & q.y == c.y) return c.z;\n\n        /*\n         *  plane: aX + bY + c = Z:\n         *  2D line: y= mX + k\n         *\n         */\n        float x = 0, x0 = q.x, x1 = a.x, x2 = b.x, x3 = c.x;\n        float y = 0, y0 = q.y, y1 = a.y, y2 = b.y, y3 = c.y;\n        float z = 0, m01 = 0, k01 = 0, m23 = 0, k23 = 0;\n\n        float r = 0;\n\n        // 0 - regular, 1-horizontal , 2-vertical.\n        int flag01 = 0;\n        if(x0 != x1)\n        {\n            m01 = (y0 - y1) / (x0 - x1);\n            k01 = y0 - m01 * x0;\n            if (m01 == 0)\n            {\n                flag01 = 1;\n            }\n        }\n        else     // 2-vertical.\n        {\n            flag01 = 2;//x01 = x0\n        }\n        int flag23 = 0;\n        if(x2 != x3)\n        {\n            m23 = (y2 - y3) / (x2 - x3);\n            k23 = y2 - m23 * x2;\n            if (m23 == 0)\n            {\n                flag23 = 1;\n            }\n        }\n        else   // 2-vertical.\n        {\n            flag23 = 2;//x01 = x0\n        }\n\n        if (flag01 == 2 )\n        {\n            x = x0;\n            y = m23 * x + k23;\n        }\n        else\n        {\n            if(flag23 == 2)\n            {\n                x = x2;\n                y = m01 * x + k01;\n            }\n            else    // regular case\n            {\n                x = (k23 - k01) / (m01 - m23);\n                y = m01 * x + k01;\n\n            }\n        }\n        if(flag23 == 2)\n        {\n            r = (y2 - y) / (y2 - y3);\n        }\n        else\n        {\n            r = (x2 - x) / (x2 - x3);\n        }\n\n        z = b.z + (c.z - b.z) * r;\n        if(flag01 == 2)\n        {\n            r = (y1 - y0) / (y1 - y);\n        }\n        else\n        {\n            r = (x1 - x0) / (x1 - x);\n        }\n        float qZ = a.z + (z - a.z) * r;\n        return qZ;\n    }\n\n    /**\n     * compute the Z value for the X,Y values of q.\n     * assume this triangle represent a plane --> q does NOT need to be contained\n     * in this triangle.\n     *\n     * @param x  x-coordinate of the query point.\n     * @param y  y-coordinate of the query point.\n     * @return z (height) value approximation given by the triangle it falls in.\n     *\n     */\n    public double z(float x, float y)\n    {\n        return z_value(new Vector3(x, y, 0));\n    }\n    /**\n     * compute the Z value for the X,Y values of q.\n     * assume this triangle represent a plane --> q does NOT need to be contained\n     * in this triangle.\n     *\n     * @param q query point (its Z value is ignored).\n     * @return q with updated Z value.\n     *\n     */\n    public Vector3 z(Vector3 q)\n    {\n        float z = z_value(q);\n        return new Vector3(q.x, q.y, z);\n    }\n\n    public Vector3 getA()\n    {\n        return a;\n    }\n\n    public Vector3 getB()\n    {\n        return b;\n    }\n\n    public Vector3 getC()\n    {\n        return c;\n    }\n\n    //checks if the triangle is not re-entrant\n\n    public double calcDet()\n    {\n        return Triangle.calcDet(a, b, c);\n    }\n\n    /**\n     * checks if the 2 triangles shares a segment\n     * @author Doron Ganel & Eyal Roth(2009)\n     * @param t2 - a second triangle\n     * @return boolean\n     */\n    public boolean shareSegment(Triangle t2)\n    {\n        return sharedSegments(t2) >= 2;\n    }\n\n    /**\n     * checks if the 2 triangles shares a segment\n     * @author Doron Ganel & Eyal Roth(2009)\n     * @param t2 - a second triangle\n     * @return boolean\n     */\n    public int sharedSegments(Triangle t2)\n    {\n        int counter = 0;\n\n        if(a.equals(t2.a))\n        {\n            counter++;\n        }\n        if(a.equals(t2.b))\n        {\n            counter++;\n        }\n        if(a.equals(t2.c))\n        {\n            counter++;\n        }\n        if(b.equals(t2.a))\n        {\n            counter++;\n        }\n        if(b.equals(t2.b))\n        {\n            counter++;\n        }\n        if(b.equals(t2.c))\n        {\n            counter++;\n        }\n        if(c.equals(t2.a))\n        {\n            counter++;\n        }\n        if(c.equals(t2.b))\n        {\n            counter++;\n        }\n        if(c.equals(t2.c))\n        {\n            counter++;\n        }\n\n        return counter;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((a == null) ? 0 : a.hashCode());\n        result = prime * result + ((b == null) ? 0 : b.hashCode());\n        result = prime * result + ((c == null) ? 0 : c.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj)\n    {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n\n        return equals((Triangle) obj);\n    }\n\n    public boolean equals(Triangle other)\n    {\n\n        if (a == null)\n        {\n            if (other.a != null)\n            {\n                return false;\n            }\n        }\n        else if (!a.equals(other.a) && !a.equals(other.b) && !a.equals(other.c))\n        {\n            return false;\n        }\n\n        if (b == null)\n        {\n            if (other.b != null)\n            {\n                return false;\n            }\n        }\n        else if (!b.equals(other.a) && !b.equals(other.b) && !b.equals(other.c))\n        {\n            return false;\n        }\n\n        if (c == null)\n        {\n            if (other.c != null)\n            {\n                return false;\n            }\n        }\n        else if (!c.equals(other.a) && !c.equals(other.b) && !c.equals(other.c))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/jdt/triangulation/Triangle.java", "func_name": "Triangle.sharedSegments", "original_string": "public int sharedSegments(Triangle t2) {\n\t\tint counter = 0;\n\n\t\tif(a.equals(t2.a)) {\n\t\t\tcounter++;\n\t\t}\n\t\tif(a.equals(t2.b)) {\n\t\t\tcounter++;\n\t\t}\n\t\tif(a.equals(t2.c)) {\n\t\t\tcounter++;\n\t\t}\n\t\tif(b.equals(t2.a)) {\n\t\t\tcounter++;\n\t\t}\n\t\tif(b.equals(t2.b)) {\n\t\t\tcounter++;\n\t\t}\n\t\tif(b.equals(t2.c)) {\n\t\t\tcounter++;\n\t\t}\n\t\tif(c.equals(t2.a)) {\n\t\t\tcounter++;\n\t\t}\n\t\tif(c.equals(t2.b)) {\n\t\t\tcounter++;\n\t\t}\n\t\tif(c.equals(t2.c)) {\n\t\t\tcounter++;\n\t\t}\n\n\t\treturn counter;\n\t}", "language": "java", "code": "public int sharedSegments(Triangle t2) {\n\t\tint counter = 0;\n\n\t\tif(a.equals(t2.a)) {\n\t\t\tcounter++;\n\t\t}\n\t\tif(a.equals(t2.b)) {\n\t\t\tcounter++;\n\t\t}\n\t\tif(a.equals(t2.c)) {\n\t\t\tcounter++;\n\t\t}\n\t\tif(b.equals(t2.a)) {\n\t\t\tcounter++;\n\t\t}\n\t\tif(b.equals(t2.b)) {\n\t\t\tcounter++;\n\t\t}\n\t\tif(b.equals(t2.c)) {\n\t\t\tcounter++;\n\t\t}\n\t\tif(c.equals(t2.a)) {\n\t\t\tcounter++;\n\t\t}\n\t\tif(c.equals(t2.b)) {\n\t\t\tcounter++;\n\t\t}\n\t\tif(c.equals(t2.c)) {\n\t\t\tcounter++;\n\t\t}\n\n\t\treturn counter;\n\t}", "code_tokens": ["public", "int", "sharedSegments", "(", "Triangle", "t2", ")", "{", "int", "counter", "=", "0", ";", "if", "(", "a", ".", "equals", "(", "t2", ".", "a", ")", ")", "{", "counter", "++", ";", "}", "if", "(", "a", ".", "equals", "(", "t2", ".", "b", ")", ")", "{", "counter", "++", ";", "}", "if", "(", "a", ".", "equals", "(", "t2", ".", "c", ")", ")", "{", "counter", "++", ";", "}", "if", "(", "b", ".", "equals", "(", "t2", ".", "a", ")", ")", "{", "counter", "++", ";", "}", "if", "(", "b", ".", "equals", "(", "t2", ".", "b", ")", ")", "{", "counter", "++", ";", "}", "if", "(", "b", ".", "equals", "(", "t2", ".", "c", ")", ")", "{", "counter", "++", ";", "}", "if", "(", "c", ".", "equals", "(", "t2", ".", "a", ")", ")", "{", "counter", "++", ";", "}", "if", "(", "c", ".", "equals", "(", "t2", ".", "b", ")", ")", "{", "counter", "++", ";", "}", "if", "(", "c", ".", "equals", "(", "t2", ".", "c", ")", ")", "{", "counter", "++", ";", "}", "return", "counter", ";", "}"], "docstring": "checks if the 2 triangles shares a segment\n@author Doron Ganel & Eyal Roth(2009)\n@param t2 - a second triangle\n@return boolean", "docstring_tokens": ["checks", "if", "the", "2", "triangles", "shares", "a", "segment"], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/jdt/triangulation/Triangle.java#L447-L479", "partition": "train", "up_fun_num": 31, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.badlogic.gdx.math.Vector3;", "import com.harium.etyl.geometry.BoundingBox;", "import com.harium.etyl.geometry.Circle3;"], "function": ["public class Triangle\n", "    private boolean isClockWise(Vector3 a, Vector3 b, Vector3 c)\n", "    public Vector3 generateEquilateralPoint(Vector3 a, Vector3 b)\n", "    public boolean isHalfplane()\n", "    public Vector3 p1()\n", "    public Vector3 p2()\n", "    public Vector3 p3()\n", "    public Triangle next_12()\n", "    public Triangle next_23()\n", "    public Triangle next_31()\n", "    public BoundingBox getBoundingBox()\n", "    void switchneighbors( Triangle old, Triangle newTriangle )\n", "    Triangle neighbor( Vector3 p )\n", "    Triangle nextNeighbor(Vector3 p, Triangle prevTriangle)\n", "    Circle3 circumcircle()\n", "    boolean circumcircleContains( Vector3 p )\n", "    public String toString()\n", "    public boolean contains(Vector3 p)\n", "    public boolean containsBoundaryIsOutside(Vector3 p)\n", "    public boolean isCorner(Vector3 p)\n", "    public boolean fallInsideCircumcircle(Vector3[] arrayPoints)\n", "    public float z_value(Vector3 q)\n", "    public double z(float x, float y)\n", "    public Vector3 z(Vector3 q)\n", "    public Vector3 getA()\n", "    public Vector3 getB()\n", "    public Vector3 getC()\n", "    public static float calcDet(Vector3 a, Vector3 b, Vector3 c)\n", "    public double calcDet()\n", "    public boolean shareSegment(Triangle t2)\n", "    public int hashCode()\n", "    public boolean equals(Object obj)\n", "    public boolean equals(Triangle other)\n"], "context": "package jdt.triangulation;\n\n\nimport com.badlogic.gdx.math.Vector3;\nimport com.harium.etyl.geometry.BoundingBox;\nimport com.harium.etyl.geometry.Circle3;\n\n/**\n * This class represents a 3D triangle in a Triangulation!\n *\n */\n\npublic class Triangle\n{\n\n    protected Vector3 a;\n    protected Vector3 b;\n    protected Vector3 c;\n\n    protected Triangle abnext, bcnext, canext;\n    protected Circle3 circum;\n\n    int modCounter = 0; // modcounter for triangulation fast update.\n\n    boolean halfplane = false; // true iff it is an infinite face.\n\n    boolean mark = false;   // tag - for bfs algorithms\n\n    public static int counter = 0, counter2 = 0;\n\n    /** constructs a triangle form 3 point - store it in counterclockwised order.*/\n    public Triangle(Vector3 a, Vector3 b, Vector3 c)\n    {\n        this.a = a;\n\n        if(isClockWise(a, b, c) )\n        {\n            this.b = b;\n            this.c = c;\n        }\n        else      // RIGHT\n        {\n            System.out.println(\"Warning, ajTriangle(A,B,C) \" +\n                               \"expects points in counterclockwise order.\");\n            System.out.println(\"\" + a + b + c);\n            this.b = c;\n            this.c = b;\n        }\n        circumcircle();\n    }\n\n    private boolean isClockWise(Vector3 a, Vector3 b, Vector3 c)\n    {\n        PointLinePosition res = PointLineTest.pointLineTest(a, b, c);\n\n        return (res == PointLinePosition.LEFT) || (res == PointLinePosition.ON_SEGMENT) ||\n               (res == PointLinePosition.INFRONT_OF_A) || (res == PointLinePosition.BEHIND_B);\n    }\n\n    /**\n     * creates a half plane using the segment (A,B).\n     * @param A\n     * @param b\n     */\n    public Triangle( Vector3 A, Vector3 b)\n    {\n        //  visitflag=visitValue;\n        this.a = A;\n        this.b = b;\n        this.c = generateEquilateralPoint(a, b);\n\n        halfplane = true;\n    }\n\n    public Vector3 generateEquilateralPoint(Vector3 a, Vector3 b)\n    {\n\n        double sin = Math.sin(60 * Math.PI / 180.0);\n        double cos = Math.cos(60 * Math.PI / 180.0);\n\n        double mz = (a.z + b.z) / 2;\n\n        double cx = cos * (a.x - b.x) - sin * (a.y - b.y) + b.x;\n        double cy = sin * (a.x - b.x) + cos * (a.y - b.y) + b.y;\n\n        Vector3 c = new Vector3((float)cx, (float)cy, (float)mz);\n        return c;\n    }\n\n    /* protected void finalize() throws Throwable{\n     super.finalize();\n     _counter--;\n    } */\n\n    /**\n     * remove all pointers (for debug)\n     */\n    //public void clear() {\n    // this.abnext = null; this.bcnext=null; this.canext=null;}\n\n    /**\n     * returns true iff this triangle is actually a half plane.\n     */\n    public boolean isHalfplane()\n    {\n        return this.halfplane;\n    }\n    /**\n     * returns the first vertex of this triangle.\n     */\n    public Vector3 p1()\n    {\n        return a;\n    }\n    /**\n     * returns the second vertex of this triangle.\n     */\n    public Vector3 p2()\n    {\n        return b;\n    }\n    /**\n     * returns the 3th vertex of this triangle.\n     */\n    public Vector3 p3()\n    {\n        return c;\n    }\n    /**\n     * returns the consecutive triangle which shares this triangle p1,p2 edge.\n     */\n    public Triangle next_12()\n    {\n        return this.abnext;\n    }\n    /**\n     * returns the consecutive triangle which shares this triangle p2,p3 edge.\n     */\n    public Triangle next_23()\n    {\n        return this.bcnext;\n    }\n    /**\n     * returns the consecutive triangle which shares this triangle p3,p1 edge.\n     */\n    public Triangle next_31()\n    {\n        return this.canext;\n    }\n\n    /**\n     * @return  The bounding rectange between the minimum and maximum coordinates\n     *                of the triangle\n     */\n    public BoundingBox getBoundingBox()\n    {\n        Vector3 lowerLeft, upperRight;\n        lowerLeft = new Vector3(Math.min(a.x, Math.min(b.x, c.x)), Math.min(getA().y, Math.min(b.y, c.y)), 0);\n        upperRight = new Vector3(Math.max(a.x, Math.max(b.x, c.x)),  Math.max(getA().y, Math.max(b.y, c.y)), 0);\n        return new BoundingBox(lowerLeft, upperRight);\n    }\n\n    void switchneighbors( Triangle old, Triangle newTriangle )\n    {\n        if ( abnext == old )\n        {\n            abnext = newTriangle;\n        }\n        else if ( bcnext == old )\n        {\n            bcnext = newTriangle;\n        }\n        else if ( canext == old )\n        {\n            canext = newTriangle;\n        }\n        else System.out.println( \"Error, switchneighbors can't find Old.\" );\n    }\n\n    Triangle neighbor( Vector3 p )\n    {\n        if ( a.equals(p) ) return canext;\n        if ( b.equals(p) ) return abnext;\n        if ( c.equals(p) ) return bcnext;\n        System.out.println( \"Error, neighbors can't find p: \" + p );\n        return null;\n    }\n\n    /**\n     * Returns the neighbors that shares the given corner and is not the previous triangle.\n     * @param p The given corner\n     * @param prevTriangle The previous triangle.\n     * @return The neighbors that shares the given corner and is not the previous triangle.\n     *\n     * By: Eyal Roth & Doron Ganel.\n     */\n    Triangle nextNeighbor(Vector3 p, Triangle prevTriangle)\n    {\n        Triangle neighbor = null;\n\n        if (a.equals(p))\n        {\n            neighbor =  canext;\n        }\n        if (b.equals(p))\n        {\n            neighbor = abnext;\n        }\n        if (c.equals(p))\n        {\n            neighbor = bcnext;\n        }\n\n        if(prevTriangle == null)\n        {\n            return neighbor;\n        }\n\n        // Udi Schneider: Added a condition check for isHalfPlane. If the current\n        // neighbor is a half plane, we also want to move to the next neighbor\n        if (neighbor.equals(prevTriangle) || neighbor.isHalfplane())\n        {\n            if (a.equals(p))\n            {\n                neighbor =  abnext;\n            }\n            if (b.equals(p))\n            {\n                neighbor = bcnext;\n            }\n            if (c.equals(p))\n            {\n                neighbor = canext;\n            }\n        }\n\n        return neighbor;\n    }\n\n    Circle3 circumcircle()\n    {\n        float u = ((a.x - b.x) * (a.x + b.x) + (a.y - b.y) * (a.y + b.y)) / 2.0f;\n        float v = ((b.x - c.x) * (b.x + c.x) + (b.y - c.y) * (b.y + c.y)) / 2.0f;\n        float den = (a.x - b.x) * (b.y - c.y) - (b.x - c.x) * (a.y - b.y);\n        if ( den == 0 ) // oops, degenerate case\n            circum = new Circle3( a, Float.POSITIVE_INFINITY );\n        else\n        {\n            Vector3 cen = new Vector3((u * (b.y - c.y) - v * (a.y - b.y)) / den,\n                                      (v * (a.x - b.x) - u * (b.x - c.x)) / den, 0);\n            circum = new Circle3( cen, cen.dst(a) );\n        }\n        return circum;\n    }\n\n    boolean circumcircleContains( Vector3 p )\n    {\n        return circum.contains(p);\n    }\n\n    public String toString()\n    {\n        String res = \"\"; //+_id+\") \";\n        res += a.toString() + b.toString();\n        if ( !halfplane )\n            res += c.toString() ;\n        // res +=c.toString() +\"   | \"+abnext._id+\" \"+bcnext._id+\" \"+canext._id;\n        return res;\n    }\n\n    /**\n     * determinates if this triangle contains the point p.\n     * @param p the query point\n     * @return true iff p is not null and is inside this triangle (Note: on boundary is considered inside!!).\n     */\n    public boolean contains(Vector3 p)\n    {\n        boolean ans = false;\n        if(this.halfplane || p == null) return false;\n\n        if (isCorner(p))\n        {\n            return true;\n        }\n\n        PointLinePosition a12 = PointLineTest.pointLineTest(a, b, p);\n        PointLinePosition a23 = PointLineTest.pointLineTest(b, c, p);\n        PointLinePosition a31 = PointLineTest.pointLineTest(c, a, p);\n\n        if ((a12 == PointLinePosition.LEFT && a23 == PointLinePosition.LEFT && a31 == PointLinePosition.LEFT ) ||\n                (a12 == PointLinePosition.RIGHT && a23 == PointLinePosition.RIGHT && a31 == PointLinePosition.RIGHT ) ||\n                (a12 == PointLinePosition.ON_SEGMENT || a23 == PointLinePosition.ON_SEGMENT ||  a31 == PointLinePosition.ON_SEGMENT))\n        {\n            ans = true;\n        }\n\n        return ans;\n    }\n\n    /**\n     * determinates if this triangle contains the point p.\n     * @param p the query point\n     *  @return true iff p is not null and is inside this triangle (Note: on boundary is considered outside!!).\n     */\n    public boolean containsBoundaryIsOutside(Vector3 p)\n    {\n        boolean ans = false;\n        if(this.halfplane || p == null) return false;\n\n        if (isCorner(p))\n        {\n            return true;\n        }\n\n        PointLinePosition a12 = PointLineTest.pointLineTest(a, b, p);\n        PointLinePosition a23 = PointLineTest.pointLineTest(b, c, p);\n        PointLinePosition a31 = PointLineTest.pointLineTest(c, a, p);\n\n        if ((a12 == PointLinePosition.LEFT && a23 == PointLinePosition.LEFT && a31 == PointLinePosition.LEFT ) ||\n                (a12 == PointLinePosition.RIGHT && a23 == PointLinePosition.RIGHT && a31 == PointLinePosition.RIGHT ))\n        {\n            ans = true;\n        }\n\n        return ans;\n    }\n\n    /**\n     * Checks if the given point is a corner of this triangle.\n     * @param p The given point.\n     * @return True iff the given point is a corner of this triangle.\n     *\n     * By Eyal Roth & Doron Ganel.\n     */\n    public boolean isCorner(Vector3 p)\n    {\n        return (p == a || p == b || p == c);\n    }\n\n    //Doron\n    public boolean fallInsideCircumcircle(Vector3[] arrayPoints)\n    {\n        boolean isInside = false;\n        Vector3 p1 = this.p1();\n        Vector3 p2 = this.p2();\n        Vector3 p3 = this.p3();\n        int i = 0;\n        while(!isInside && i < arrayPoints.length)\n        {\n            Vector3 p = arrayPoints[i];\n            if(!p.equals(p1) && !p.equals(p2) && !p.equals(p3))\n            {\n                isInside = this.circumcircleContains(p);\n            }\n            i++;\n        }\n\n        return isInside;\n    }\n\n    /**\n     * compute the Z value for the X,Y values of q. <br />\n     * assume this triangle represent a plane --> q does NOT need to be contained\n     * in this triangle.\n     *\n     * @param q query point (its Z value is ignored).\n     * @return the Z value of this plane implies by this triangle 3 points.\n     */\n    public float z_value(Vector3 q)\n    {\n        if(q == null || this.halfplane) throw new RuntimeException(\"*** ERR wrong parameters, can't approximate the z value ..***: \" + q);\n        /* incase the query point is on one of the points */\n        if(q.x == a.x & q.y == a.y) return a.z;\n        if(q.x == b.x & q.y == b.y) return b.z;\n        if(q.x == c.x & q.y == c.y) return c.z;\n\n        /*\n         *  plane: aX + bY + c = Z:\n         *  2D line: y= mX + k\n         *\n         */\n        float x = 0, x0 = q.x, x1 = a.x, x2 = b.x, x3 = c.x;\n        float y = 0, y0 = q.y, y1 = a.y, y2 = b.y, y3 = c.y;\n        float z = 0, m01 = 0, k01 = 0, m23 = 0, k23 = 0;\n\n        float r = 0;\n\n        // 0 - regular, 1-horizontal , 2-vertical.\n        int flag01 = 0;\n        if(x0 != x1)\n        {\n            m01 = (y0 - y1) / (x0 - x1);\n            k01 = y0 - m01 * x0;\n            if (m01 == 0)\n            {\n                flag01 = 1;\n            }\n        }\n        else     // 2-vertical.\n        {\n            flag01 = 2;//x01 = x0\n        }\n        int flag23 = 0;\n        if(x2 != x3)\n        {\n            m23 = (y2 - y3) / (x2 - x3);\n            k23 = y2 - m23 * x2;\n            if (m23 == 0)\n            {\n                flag23 = 1;\n            }\n        }\n        else   // 2-vertical.\n        {\n            flag23 = 2;//x01 = x0\n        }\n\n        if (flag01 == 2 )\n        {\n            x = x0;\n            y = m23 * x + k23;\n        }\n        else\n        {\n            if(flag23 == 2)\n            {\n                x = x2;\n                y = m01 * x + k01;\n            }\n            else    // regular case\n            {\n                x = (k23 - k01) / (m01 - m23);\n                y = m01 * x + k01;\n\n            }\n        }\n        if(flag23 == 2)\n        {\n            r = (y2 - y) / (y2 - y3);\n        }\n        else\n        {\n            r = (x2 - x) / (x2 - x3);\n        }\n\n        z = b.z + (c.z - b.z) * r;\n        if(flag01 == 2)\n        {\n            r = (y1 - y0) / (y1 - y);\n        }\n        else\n        {\n            r = (x1 - x0) / (x1 - x);\n        }\n        float qZ = a.z + (z - a.z) * r;\n        return qZ;\n    }\n\n    /**\n     * compute the Z value for the X,Y values of q.\n     * assume this triangle represent a plane --> q does NOT need to be contained\n     * in this triangle.\n     *\n     * @param x  x-coordinate of the query point.\n     * @param y  y-coordinate of the query point.\n     * @return z (height) value approximation given by the triangle it falls in.\n     *\n     */\n    public double z(float x, float y)\n    {\n        return z_value(new Vector3(x, y, 0));\n    }\n    /**\n     * compute the Z value for the X,Y values of q.\n     * assume this triangle represent a plane --> q does NOT need to be contained\n     * in this triangle.\n     *\n     * @param q query point (its Z value is ignored).\n     * @return q with updated Z value.\n     *\n     */\n    public Vector3 z(Vector3 q)\n    {\n        float z = z_value(q);\n        return new Vector3(q.x, q.y, z);\n    }\n\n    public Vector3 getA()\n    {\n        return a;\n    }\n\n    public Vector3 getB()\n    {\n        return b;\n    }\n\n    public Vector3 getC()\n    {\n        return c;\n    }\n\n    //checks if the triangle is not re-entrant\n    public static float calcDet(Vector3 a, Vector3 b, Vector3 c)\n    {\n        return (a.x * (b.y - c.y)) - (a.y * (b.x - c.x)) + (b.x * c.y - b.y * c.x);\n    }\n\n    public double calcDet()\n    {\n        return Triangle.calcDet(a, b, c);\n    }\n\n    /**\n     * checks if the 2 triangles shares a segment\n     * @author Doron Ganel & Eyal Roth(2009)\n     * @param t2 - a second triangle\n     * @return boolean\n     */\n    public boolean shareSegment(Triangle t2)\n    {\n        return sharedSegments(t2) >= 2;\n    }\n\n    /**\n     * checks if the 2 triangles shares a segment\n     * @author Doron Ganel & Eyal Roth(2009)\n     * @param t2 - a second triangle\n     * @return boolean\n     */\n\n    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((a == null) ? 0 : a.hashCode());\n        result = prime * result + ((b == null) ? 0 : b.hashCode());\n        result = prime * result + ((c == null) ? 0 : c.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj)\n    {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n\n        return equals((Triangle) obj);\n    }\n\n    public boolean equals(Triangle other)\n    {\n\n        if (a == null)\n        {\n            if (other.a != null)\n            {\n                return false;\n            }\n        }\n        else if (!a.equals(other.a) && !a.equals(other.b) && !a.equals(other.c))\n        {\n            return false;\n        }\n\n        if (b == null)\n        {\n            if (other.b != null)\n            {\n                return false;\n            }\n        }\n        else if (!b.equals(other.a) && !b.equals(other.b) && !b.equals(other.c))\n        {\n            return false;\n        }\n\n        if (c == null)\n        {\n            if (other.c != null)\n            {\n                return false;\n            }\n        }\n        else if (!c.equals(other.a) && !c.equals(other.b) && !c.equals(other.c))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/effect/BinaryErosion.java", "func_name": "BinaryErosion.apply", "original_string": "@Override\r\n    public ImageSource apply(ImageSource source) {\r\n        if (radius != 0) {\r\n            if (source.isGrayscale()) {\r\n                return applyGrayscale(source, radius);\r\n            } else {\r\n                return applyRGB(source, radius);\r\n            }\r\n        } else {\r\n            if (source.isGrayscale()) {\r\n                return applyGrayscale(source, kernel);\r\n            } else {\r\n                return applyRGB(source, kernel);\r\n            }\r\n        }\r\n    }", "language": "java", "code": "@Override\r\n    public ImageSource apply(ImageSource source) {\r\n        if (radius != 0) {\r\n            if (source.isGrayscale()) {\r\n                return applyGrayscale(source, radius);\r\n            } else {\r\n                return applyRGB(source, radius);\r\n            }\r\n        } else {\r\n            if (source.isGrayscale()) {\r\n                return applyGrayscale(source, kernel);\r\n            } else {\r\n                return applyRGB(source, kernel);\r\n            }\r\n        }\r\n    }", "code_tokens": ["@", "Override", "public", "ImageSource", "apply", "(", "ImageSource", "source", ")", "{", "if", "(", "radius", "!=", "0", ")", "{", "if", "(", "source", ".", "isGrayscale", "(", ")", ")", "{", "return", "applyGrayscale", "(", "source", ",", "radius", ")", ";", "}", "else", "{", "return", "applyRGB", "(", "source", ",", "radius", ")", ";", "}", "}", "else", "{", "if", "(", "source", ".", "isGrayscale", "(", ")", ")", "{", "return", "applyGrayscale", "(", "source", ",", "kernel", ")", ";", "}", "else", "{", "return", "applyRGB", "(", "source", ",", "kernel", ")", ";", "}", "}", "}"], "docstring": "Apply filter to an image.\n\n@param source FastBitmap", "docstring_tokens": ["Apply", "filter", "to", "an", "image", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/effect/BinaryErosion.java#L74-L89", "partition": "train", "up_fun_num": 1, "levels": [0, 1, 1, 1, 1, 1], "package": ["import com.harium.keel.core.Effect;", "import com.harium.keel.core.helper.ColorHelper;", "import com.harium.keel.core.source.ImageSource;", "import com.harium.keel.core.source.MatrixSource;", "import com.harium.keel.core.source.OneBandSource;"], "function": ["public class BinaryErosion extends RadiusEffect implements Effect\n", "    private ImageSource applyGrayscale(ImageSource source, int radius)\n", "    private ImageSource applyRGB(ImageSource source, int radius)\n", "    private ImageSource applyGrayscale(ImageSource source, int[][] kernel)\n", "    private ImageSource applyRGB(ImageSource source, int[][] kernel)\n", "    private int calcLines(int[][] se)\n"], "context": "// Catalano Imaging Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.effect;\n\nimport com.harium.keel.core.Effect;\nimport com.harium.keel.core.helper.ColorHelper;\nimport com.harium.keel.core.source.ImageSource;\nimport com.harium.keel.core.source.MatrixSource;\nimport com.harium.keel.core.source.OneBandSource;\n\n/**\n * Binary Erosion operator from Mathematical Morphology.\n * The filter assigns minimum value of surrounding pixels to each pixel of the result image. Surrounding pixels, which should be processed, are specified by structuring element: 1 - to process the neighbor, 0 - to skip it.\n * The filter especially useful for binary image processing, where it removes pixels, which are not surrounded by specified amount of neighbors. It gives ability to remove noisy pixels (stand-alone pixels) or shrink objects.\n * <p>\n * <p><li>Supported types: Grayscale.\n * <br><li>Coordinate System: Matrix.\n *\n * @author Diego Catalano\n */\npublic class BinaryErosion extends RadiusEffect implements Effect\n{\n    private int[][] kernel;\n    private static final int BLACK = ColorHelper.getRGB(0, 0, 0);\n\n    /**\n     * Initialize a new instance of the Binary Erosion class with radius = 1.\n     */\n    public BinaryErosion()\n    {\n        this(1);\n    }\n\n    /**\n     * Initialize a new instance of the Binary Erosion class with defined.\n     *\n     * @param radius Radius\n     */\n    public BinaryErosion(int radius)\n    {\n        super(radius);\n    }\n\n    /**\n     * Initialize a new instance of the Binary Erosion class with structuring element.\n     *\n     * @param se Structuring element.\n     */\n    public BinaryErosion(int[][] se)\n    {\n        this.kernel = se;\n    }\n\n    /**\n     * Apply filter to an image.\n     *\n     * @param source FastBitmap\n     */\n\n    private ImageSource applyGrayscale(ImageSource source, int radius)\n    {\n        OneBandSource copy = OneBandSource.copy(source);\n\n        int width = source.getWidth();\n        int height = source.getHeight();\n        int l;\n\n        int Xline, Yline;\n        int lines = calcLines(radius);\n        for (int x = 0; x < height; x++)\n        {\n            for (int y = 0; y < width; y++)\n            {\n                l = copy.getRGB(y, x);\n                if (l == 0)\n                {\n                    for (int i = 0; i < lines; i++)\n                    {\n                        Xline = x + (i - radius);\n                        for (int j = 0; j < lines; j++)\n                        {\n                            Yline = y + (j - radius);\n                            if ((Xline >= 0) && (Xline < height) && (Yline >= 0) && (Yline < width))\n                            {\n                                source.setRGB(Yline, Xline, 0);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return source;\n    }\n\n    private ImageSource applyRGB(ImageSource source, int radius)\n    {\n        MatrixSource copy = new MatrixSource(source);\n\n        int width = source.getWidth();\n        int height = source.getHeight();\n        int l;\n\n        int Xline, Yline;\n        int lines = calcLines(radius);\n        for (int x = 0; x < height; x++)\n        {\n            for (int y = 0; y < width; y++)\n            {\n                l = copy.getB(y, x);\n                if (l == 0)\n                {\n                    for (int i = 0; i < lines; i++)\n                    {\n                        Xline = x + (i - radius);\n                        for (int j = 0; j < lines; j++)\n                        {\n                            Yline = y + (j - radius);\n                            if ((Xline >= 0) && (Xline < height) && (Yline >= 0) && (Yline < width))\n                            {\n\n                                source.setRGB(Yline, Xline, BLACK);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return source;\n    }\n\n    private ImageSource applyGrayscale(ImageSource source, int[][] kernel)\n    {\n        OneBandSource copy = OneBandSource.copy(source);\n\n        int width = source.getWidth();\n        int height = source.getHeight();\n        int l;\n\n        int Xline, Yline;\n        int lines = calcLines(kernel);\n        for (int x = 0; x < height; x++)\n        {\n            for (int y = 0; y < width; y++)\n            {\n                l = copy.getRGB(y, x);\n                if (l == 0)\n                {\n                    for (int i = 0; i < kernel.length; i++)\n                    {\n                        Xline = x + (i - lines);\n                        for (int j = 0; j < kernel[0].length; j++)\n                        {\n                            Yline = y + (j - lines);\n                            if ((Xline >= 0) && (Xline < height) && (Yline >= 0) && (Yline < width))\n                            {\n                                if (kernel[i][j] == 1)\n                                {\n                                    source.setRGB(Yline, Xline, 0);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return source;\n    }\n\n    private ImageSource applyRGB(ImageSource source, int[][] kernel)\n    {\n        MatrixSource copy = new MatrixSource(source);\n\n        int width = source.getWidth();\n        int height = source.getHeight();\n        int l;\n\n        int Xline, Yline;\n        int lines = calcLines(kernel);\n        for (int x = 0; x < height; x++)\n        {\n            for (int y = 0; y < width; y++)\n            {\n                l = copy.getB(y, x);\n                if (l == 0)\n                {\n                    for (int i = 0; i < kernel.length; i++)\n                    {\n                        Xline = x + (i - lines);\n                        for (int j = 0; j < kernel[0].length; j++)\n                        {\n                            Yline = y + (j - lines);\n                            if ((Xline >= 0) && (Xline < height) && (Yline >= 0) && (Yline < width))\n                            {\n                                if (kernel[i][j] == 1)\n                                {\n                                    source.setRGB(Yline, Xline, BLACK);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return source;\n    }\n\n    private int calcLines(int[][] se)\n    {\n        int lines = (se[0].length - 1) / 2;\n        return lines;\n    }\n\n}"}
{"repo": "artikcloud/artikcloud-java", "path": "src/main/java/cloud/artik/client/ApiClient.java", "func_name": "ApiClient.handleResponse", "original_string": "public <T> T handleResponse(Response response, Type returnType) throws ApiException {\n        if (response.isSuccessful()) {\n            if (returnType == null || response.code() == 204) {\n                // returning null if the returnType is not defined,\n                // or the status code is 204 (No Content)\n                return null;\n            } else {\n                return deserialize(response, returnType);\n            }\n        } else {\n            String respBody = null;\n            if (response.body() != null) {\n                try {\n                    respBody = response.body().string();\n                } catch (IOException e) {\n                    throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());\n                }\n            }\n            throw new ApiException(response.message(), response.code(), response.headers().toMultimap(), respBody);\n        }\n    }", "language": "java", "code": "public <T> T handleResponse(Response response, Type returnType) throws ApiException {\n        if (response.isSuccessful()) {\n            if (returnType == null || response.code() == 204) {\n                // returning null if the returnType is not defined,\n                // or the status code is 204 (No Content)\n                return null;\n            } else {\n                return deserialize(response, returnType);\n            }\n        } else {\n            String respBody = null;\n            if (response.body() != null) {\n                try {\n                    respBody = response.body().string();\n                } catch (IOException e) {\n                    throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());\n                }\n            }\n            throw new ApiException(response.message(), response.code(), response.headers().toMultimap(), respBody);\n        }\n    }", "code_tokens": ["public", "<", "T", ">", "T", "handleResponse", "(", "Response", "response", ",", "Type", "returnType", ")", "throws", "ApiException", "{", "if", "(", "response", ".", "isSuccessful", "(", ")", ")", "{", "if", "(", "returnType", "==", "null", "||", "response", ".", "code", "(", ")", "==", "204", ")", "{", "// returning null if the returnType is not defined,", "// or the status code is 204 (No Content)", "return", "null", ";", "}", "else", "{", "return", "deserialize", "(", "response", ",", "returnType", ")", ";", "}", "}", "else", "{", "String", "respBody", "=", "null", ";", "if", "(", "response", ".", "body", "(", ")", "!=", "null", ")", "{", "try", "{", "respBody", "=", "response", ".", "body", "(", ")", ".", "string", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "ApiException", "(", "response", ".", "message", "(", ")", ",", "e", ",", "response", ".", "code", "(", ")", ",", "response", ".", "headers", "(", ")", ".", "toMultimap", "(", ")", ")", ";", "}", "}", "throw", "new", "ApiException", "(", "response", ".", "message", "(", ")", ",", "response", ".", "code", "(", ")", ",", "response", ".", "headers", "(", ")", ".", "toMultimap", "(", ")", ",", "respBody", ")", ";", "}", "}"], "docstring": "Handle the given response, return the deserialized object when the response is successful.\n\n@param <T> Type\n@param response Response\n@param returnType Return type\n@throws ApiException If the response has a unsuccessful status code or\nfail to deserialize the response body\n@return Type", "docstring_tokens": ["Handle", "the", "given", "response", "return", "the", "deserialized", "object", "when", "the", "response", "is", "successful", "."], "sha": "412f447573e7796ab4f685c0bdd5eb76185a365c", "url": "https://github.com/artikcloud/artikcloud-java/blob/412f447573e7796ab4f685c0bdd5eb76185a365c/src/main/java/cloud/artik/client/ApiClient.java#L1029-L1049", "partition": "train", "up_fun_num": 55, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.squareup.okhttp.Call;", "import com.squareup.okhttp.Callback;", "import com.squareup.okhttp.OkHttpClient;", "import com.squareup.okhttp.Request;", "import com.squareup.okhttp.Response;", "import com.squareup.okhttp.RequestBody;", "import com.squareup.okhttp.FormEncodingBuilder;", "import com.squareup.okhttp.MultipartBuilder;", "import com.squareup.okhttp.MediaType;", "import com.squareup.okhttp.Headers;", "import com.squareup.okhttp.internal.http.HttpMethod;", "import com.squareup.okhttp.logging.HttpLoggingInterceptor;", "import com.squareup.okhttp.logging.HttpLoggingInterceptor.Level;", "import java.lang.reflect.Type;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.Map;", "import java.util.Map.Entry;", "import java.util.HashMap;", "import java.util.List;", "import java.util.ArrayList;", "import java.util.Date;", "import java.util.TimeZone;", "import java.util.concurrent.TimeUnit;", "import java.util.regex.Matcher;", "import java.util.regex.Pattern;", "import java.net.URLEncoder;", "import java.net.URLConnection;", "import java.io.File;", "import java.io.InputStream;", "import java.io.IOException;", "import java.io.UnsupportedEncodingException;", "import java.security.GeneralSecurityException;", "import java.security.KeyStore;", "import java.security.SecureRandom;", "import java.security.cert.Certificate;", "import java.security.cert.CertificateException;", "import java.security.cert.CertificateFactory;", "import java.security.cert.X509Certificate;", "import java.text.DateFormat;", "import java.text.SimpleDateFormat;", "import java.text.ParseException;", "import javax.net.ssl.HostnameVerifier;", "import javax.net.ssl.KeyManager;", "import javax.net.ssl.KeyManagerFactory;", "import javax.net.ssl.SSLContext;", "import javax.net.ssl.SSLSession;", "import javax.net.ssl.TrustManager;", "import javax.net.ssl.TrustManagerFactory;", "import javax.net.ssl.X509TrustManager;", "import okio.BufferedSink;", "import okio.Okio;", "import cloud.artik.client.auth.Authentication;", "import cloud.artik.client.auth.HttpBasicAuth;", "import cloud.artik.client.auth.ApiKeyAuth;", "import cloud.artik.client.auth.OAuth;"], "function": ["public class ApiClient\n", "    public String getBasePath()\n", "    public ApiClient setBasePath(String basePath)\n", "    public OkHttpClient getHttpClient()\n", "    public ApiClient setHttpClient(OkHttpClient httpClient)\n", "    public JSON getJSON()\n", "    public ApiClient setJSON(JSON json)\n", "    public boolean isVerifyingSsl()\n", "    public ApiClient setVerifyingSsl(boolean verifyingSsl)\n", "    public InputStream getSslCaCert()\n", "    public ApiClient setSslCaCert(InputStream sslCaCert)\n", "    public DateFormat getDateFormat()\n", "    public ApiClient setDateFormat(DateFormat dateFormat)\n", "    public DateFormat getDatetimeFormat()\n", "    public ApiClient setDatetimeFormat(DateFormat datetimeFormat)\n", "    public boolean isLenientDatetimeFormat()\n", "    public ApiClient setLenientDatetimeFormat(boolean lenientDatetimeFormat)\n", "    public Date parseDate(String str)\n", "    public Date parseDatetime(String str)\n", "    public Date parseDateOrDatetime(String str)\n", "    public String formatDate(Date date)\n", "    public String formatDatetime(Date date)\n", "    public Map<String, Authentication> getAuthentications()\n", "    public Authentication getAuthentication(String authName)\n", "    public void setUsername(String username)\n", "    public void setPassword(String password)\n", "    public void setApiKey(String apiKey)\n", "    public void setApiKeyPrefix(String apiKeyPrefix)\n", "    public void setAccessToken(String accessToken)\n", "    public ApiClient setUserAgent(String userAgent)\n", "    public ApiClient addDefaultHeader(String key, String value)\n", "    public boolean isLenientOnJson()\n", "    public ApiClient setLenientOnJson(boolean lenient)\n", "    public boolean isDebugging()\n", "    public ApiClient setDebugging(boolean debugging)\n", "    public String getTempFolderPath()\n", "    public ApiClient setTempFolderPath(String tempFolderPath)\n", "    public int getConnectTimeout()\n", "    public ApiClient setConnectTimeout(int connectionTimeout)\n", "    public String parameterToString(Object param)\n", "    public List<Pair> parameterToPairs(String collectionFormat, String name, Object value)\n", "    public String sanitizeFilename(String filename)\n", "    public boolean isJsonMime(String mime)\n", "    public String selectHeaderAccept(String[] accepts)\n", "    public String selectHeaderContentType(String[] contentTypes)\n", "    public String escapeString(String str)\n", "    public <T> T deserialize(Response response, Type returnType) throws ApiException\n", "    public RequestBody serialize(Object obj, String contentType) throws ApiException\n", "    public File downloadFileFromResponse(Response response) throws ApiException\n", "    public File prepareDownloadFile(Response response) throws IOException\n", "    public <T> ApiResponse<T> execute(Call call) throws ApiException\n", "    public <T> ApiResponse<T> execute(Call call, Type returnType) throws ApiException\n", "    public <T> void executeAsync(Call call, ApiCallback<T> callback)\n", "    public <T> void executeAsync(Call call, final Type returnType, final ApiCallback<T> callback)\n", "    public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public String buildUrl(String path, List<Pair> queryParams)\n", "    public void processHeaderParams(Map<String, String> headerParams, Request.Builder reqBuilder)\n", "    public void updateParamsForAuth(String[] authNames, List<Pair> queryParams, Map<String, String> headerParams)\n", "    public RequestBody buildRequestBodyFormEncoding(Map<String, Object> formParams)\n", "    public RequestBody buildRequestBodyMultipart(Map<String, Object> formParams)\n", "    public String guessContentTypeFromFile(File file)\n", "    private void initDatetimeFormat()\n", "    private void applySslSettings()\n", "    private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException\n"], "context": "/*\n * ARTIK Cloud API\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 2.0.0\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n\npackage cloud.artik.client;\n\nimport com.squareup.okhttp.Call;\nimport com.squareup.okhttp.Callback;\nimport com.squareup.okhttp.OkHttpClient;\nimport com.squareup.okhttp.Request;\nimport com.squareup.okhttp.Response;\nimport com.squareup.okhttp.RequestBody;\nimport com.squareup.okhttp.FormEncodingBuilder;\nimport com.squareup.okhttp.MultipartBuilder;\nimport com.squareup.okhttp.MediaType;\nimport com.squareup.okhttp.Headers;\nimport com.squareup.okhttp.internal.http.HttpMethod;\nimport com.squareup.okhttp.logging.HttpLoggingInterceptor;\nimport com.squareup.okhttp.logging.HttpLoggingInterceptor.Level;\n\nimport java.lang.reflect.Type;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.TimeZone;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport java.net.URLEncoder;\nimport java.net.URLConnection;\n\nimport java.io.File;\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\n\nimport java.security.GeneralSecurityException;\nimport java.security.KeyStore;\nimport java.security.SecureRandom;\nimport java.security.cert.Certificate;\nimport java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.KeyManager;\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.TrustManagerFactory;\nimport javax.net.ssl.X509TrustManager;\n\nimport okio.BufferedSink;\nimport okio.Okio;\n\nimport cloud.artik.client.auth.Authentication;\nimport cloud.artik.client.auth.HttpBasicAuth;\nimport cloud.artik.client.auth.ApiKeyAuth;\nimport cloud.artik.client.auth.OAuth;\n\npublic class ApiClient\n{\n    public static final double JAVA_VERSION;\n    public static final boolean IS_ANDROID;\n    public static final int ANDROID_SDK_VERSION;\n\n    static\n    {\n        JAVA_VERSION = Double.parseDouble(System.getProperty(\"java.specification.version\"));\n        boolean isAndroid;\n        try\n        {\n            Class.forName(\"android.app.Activity\");\n            isAndroid = true;\n        }\n        catch (ClassNotFoundException e)\n        {\n            isAndroid = false;\n        }\n        IS_ANDROID = isAndroid;\n        int sdkVersion = 0;\n        if (IS_ANDROID)\n        {\n            try\n            {\n                sdkVersion = Class.forName(\"android.os.Build$VERSION\").getField(\"SDK_INT\").getInt(null);\n            }\n            catch (Exception e)\n            {\n                try\n                {\n                    sdkVersion = Integer.parseInt((String) Class.forName(\"android.os.Build$VERSION\").getField(\"SDK\").get(null));\n                }\n                catch (Exception e2) { }\n            }\n        }\n        ANDROID_SDK_VERSION = sdkVersion;\n    }\n\n    /**\n     * The datetime format to be used when <code>lenientDatetimeFormat</code> is enabled.\n     */\n    public static final String LENIENT_DATETIME_FORMAT = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n\n    private String basePath = \"https://api.artik.cloud/v1.1\";\n    private boolean lenientOnJson = false;\n    private boolean debugging = false;\n    private Map<String, String> defaultHeaderMap = new HashMap<String, String>();\n    private String tempFolderPath = null;\n\n    private Map<String, Authentication> authentications;\n\n    private DateFormat dateFormat;\n    private DateFormat datetimeFormat;\n    private boolean lenientDatetimeFormat;\n    private int dateLength;\n\n    private InputStream sslCaCert;\n    private boolean verifyingSsl;\n\n    private OkHttpClient httpClient;\n    private JSON json;\n\n    private HttpLoggingInterceptor loggingInterceptor;\n\n    /*\n     * Constructor for ApiClient\n     */\n    public ApiClient()\n    {\n        httpClient = new OkHttpClient();\n\n        verifyingSsl = true;\n\n        json = new JSON(this);\n\n        /*\n         * Use RFC3339 format for date and datetime.\n         * See http://xml2rfc.ietf.org/public/rfc/html/rfc3339.html#anchor14\n         */\n        this.dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n        // Always use UTC as the default time zone when dealing with date (without time).\n        this.dateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        initDatetimeFormat();\n\n        // Be lenient on datetime formats when parsing datetime from string.\n        // See <code>parseDatetime</code>.\n        this.lenientDatetimeFormat = true;\n\n        // Set default User-Agent.\n        setUserAgent(\"Swagger-Codegen/2.2.2/java\");\n\n        // Setup authentications (key: authentication name, value: authentication).\n        authentications = new HashMap<String, Authentication>();\n        authentications.put(\"artikcloud_oauth\", new OAuth());\n        // Prevent the authentications from being modified.\n        authentications = Collections.unmodifiableMap(authentications);\n    }\n\n    /**\n     * Get base path\n     *\n     * @return Baes path\n     */\n    public String getBasePath()\n    {\n        return basePath;\n    }\n\n    /**\n     * Set base path\n     *\n     * @param basePath Base path of the URL (e.g https://api.artik.cloud/v1.1\n     * @return An instance of OkHttpClient\n     */\n    public ApiClient setBasePath(String basePath)\n    {\n        this.basePath = basePath;\n        return this;\n    }\n\n    /**\n     * Get HTTP client\n     *\n     * @return An instance of OkHttpClient\n     */\n    public OkHttpClient getHttpClient()\n    {\n        return httpClient;\n    }\n\n    /**\n     * Set HTTP client\n     *\n     * @param httpClient An instance of OkHttpClient\n     * @return Api Client\n     */\n    public ApiClient setHttpClient(OkHttpClient httpClient)\n    {\n        this.httpClient = httpClient;\n        return this;\n    }\n\n    /**\n     * Get JSON\n     *\n     * @return JSON object\n     */\n    public JSON getJSON()\n    {\n        return json;\n    }\n\n    /**\n     * Set JSON\n     *\n     * @param json JSON object\n     * @return Api client\n     */\n    public ApiClient setJSON(JSON json)\n    {\n        this.json = json;\n        return this;\n    }\n\n    /**\n     * True if isVerifyingSsl flag is on\n     *\n     * @return True if isVerifySsl flag is on\n     */\n    public boolean isVerifyingSsl()\n    {\n        return verifyingSsl;\n    }\n\n    /**\n     * Configure whether to verify certificate and hostname when making https requests.\n     * Default to true.\n     * NOTE: Do NOT set to false in production code, otherwise you would face multiple types of cryptographic attacks.\n     *\n     * @param verifyingSsl True to verify TLS/SSL connection\n     * @return ApiClient\n     */\n    public ApiClient setVerifyingSsl(boolean verifyingSsl)\n    {\n        this.verifyingSsl = verifyingSsl;\n        applySslSettings();\n        return this;\n    }\n\n    /**\n     * Get SSL CA cert.\n     *\n     * @return Input stream to the SSL CA cert\n     */\n    public InputStream getSslCaCert()\n    {\n        return sslCaCert;\n    }\n\n    /**\n     * Configure the CA certificate to be trusted when making https requests.\n     * Use null to reset to default.\n     *\n     * @param sslCaCert input stream for SSL CA cert\n     * @return ApiClient\n     */\n    public ApiClient setSslCaCert(InputStream sslCaCert)\n    {\n        this.sslCaCert = sslCaCert;\n        applySslSettings();\n        return this;\n    }\n\n    public DateFormat getDateFormat()\n    {\n        return dateFormat;\n    }\n\n    public ApiClient setDateFormat(DateFormat dateFormat)\n    {\n        this.dateFormat = dateFormat;\n        this.dateLength = this.dateFormat.format(new Date()).length();\n        return this;\n    }\n\n    public DateFormat getDatetimeFormat()\n    {\n        return datetimeFormat;\n    }\n\n    public ApiClient setDatetimeFormat(DateFormat datetimeFormat)\n    {\n        this.datetimeFormat = datetimeFormat;\n        return this;\n    }\n\n    /**\n     * Whether to allow various ISO 8601 datetime formats when parsing a datetime string.\n     * @see #parseDatetime(String)\n     * @return True if lenientDatetimeFormat flag is set to true\n     */\n    public boolean isLenientDatetimeFormat()\n    {\n        return lenientDatetimeFormat;\n    }\n\n    public ApiClient setLenientDatetimeFormat(boolean lenientDatetimeFormat)\n    {\n        this.lenientDatetimeFormat = lenientDatetimeFormat;\n        return this;\n    }\n\n    /**\n     * Parse the given date string into Date object.\n     * The default <code>dateFormat</code> supports these ISO 8601 date formats:\n     *   2015-08-16\n     *   2015-8-16\n     * @param str String to be parsed\n     * @return Date\n     */\n    public Date parseDate(String str)\n    {\n        if (str == null)\n            return null;\n        try\n        {\n            return dateFormat.parse(str);\n        }\n        catch (ParseException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Parse the given datetime string into Date object.\n     * When lenientDatetimeFormat is enabled, the following ISO 8601 datetime formats are supported:\n     *   2015-08-16T08:20:05Z\n     *   2015-8-16T8:20:05Z\n     *   2015-08-16T08:20:05+00:00\n     *   2015-08-16T08:20:05+0000\n     *   2015-08-16T08:20:05.376Z\n     *   2015-08-16T08:20:05.376+00:00\n     *   2015-08-16T08:20:05.376+00\n     * Note: The 3-digit milli-seconds is optional. Time zone is required and can be in one of\n     *   these formats:\n     *   Z (same with +0000)\n     *   +08:00 (same with +0800)\n     *   -02 (same with -0200)\n     *   -0200\n     * @see <a href=\"https://en.wikipedia.org/wiki/ISO_8601\">ISO 8601</a>\n     * @param str Date time string to be parsed\n     * @return Date representation of the string\n     */\n    public Date parseDatetime(String str)\n    {\n        if (str == null)\n            return null;\n\n        DateFormat format;\n        if (lenientDatetimeFormat)\n        {\n            /*\n             * When lenientDatetimeFormat is enabled, normalize the date string\n             * into <code>LENIENT_DATETIME_FORMAT</code> to support various formats\n             * defined by ISO 8601.\n             */\n            // normalize time zone\n            //   trailing \"Z\": 2015-08-16T08:20:05Z => 2015-08-16T08:20:05+0000\n            str = str.replaceAll(\"[zZ]\\\\z\", \"+0000\");\n            //   remove colon in time zone: 2015-08-16T08:20:05+00:00 => 2015-08-16T08:20:05+0000\n            str = str.replaceAll(\"([+-]\\\\d{2}):(\\\\d{2})\\\\z\", \"$1$2\");\n            //   expand time zone: 2015-08-16T08:20:05+00 => 2015-08-16T08:20:05+0000\n            str = str.replaceAll(\"([+-]\\\\d{2})\\\\z\", \"$100\");\n            // add milliseconds when missing\n            //   2015-08-16T08:20:05+0000 => 2015-08-16T08:20:05.000+0000\n            str = str.replaceAll(\"(:\\\\d{1,2})([+-]\\\\d{4})\\\\z\", \"$1.000$2\");\n            format = new SimpleDateFormat(LENIENT_DATETIME_FORMAT);\n        }\n        else\n        {\n            format = this.datetimeFormat;\n        }\n\n        try\n        {\n            return format.parse(str);\n        }\n        catch (ParseException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /*\n     * Parse date or date time in string format into Date object.\n     *\n     * @param str Date time string to be parsed\n     * @return Date representation of the string\n     */\n    public Date parseDateOrDatetime(String str)\n    {\n        if (str == null)\n            return null;\n        else if (str.length() <= dateLength)\n            return parseDate(str);\n        else\n            return parseDatetime(str);\n    }\n\n    /**\n     * Format the given Date object into string (Date format).\n     *\n     * @param date Date object\n     * @return Formatted date in string representation\n     */\n    public String formatDate(Date date)\n    {\n        return dateFormat.format(date);\n    }\n\n    /**\n     * Format the given Date object into string (Datetime format).\n     *\n     * @param date Date object\n     * @return Formatted datetime in string representation\n     */\n    public String formatDatetime(Date date)\n    {\n        return datetimeFormat.format(date);\n    }\n\n    /**\n     * Get authentications (key: authentication name, value: authentication).\n     *\n     * @return Map of authentication objects\n     */\n    public Map<String, Authentication> getAuthentications()\n    {\n        return authentications;\n    }\n\n    /**\n     * Get authentication for the given name.\n     *\n     * @param authName The authentication name\n     * @return The authentication, null if not found\n     */\n    public Authentication getAuthentication(String authName)\n    {\n        return authentications.get(authName);\n    }\n\n    /**\n     * Helper method to set username for the first HTTP basic authentication.\n     *\n     * @param username Username\n     */\n    public void setUsername(String username)\n    {\n        for (Authentication auth : authentications.values())\n        {\n            if (auth instanceof HttpBasicAuth)\n            {\n                ((HttpBasicAuth) auth).setUsername(username);\n                return;\n            }\n        }\n        throw new RuntimeException(\"No HTTP basic authentication configured!\");\n    }\n\n    /**\n     * Helper method to set password for the first HTTP basic authentication.\n     *\n     * @param password Password\n     */\n    public void setPassword(String password)\n    {\n        for (Authentication auth : authentications.values())\n        {\n            if (auth instanceof HttpBasicAuth)\n            {\n                ((HttpBasicAuth) auth).setPassword(password);\n                return;\n            }\n        }\n        throw new RuntimeException(\"No HTTP basic authentication configured!\");\n    }\n\n    /**\n     * Helper method to set API key value for the first API key authentication.\n     *\n     * @param apiKey API key\n     */\n    public void setApiKey(String apiKey)\n    {\n        for (Authentication auth : authentications.values())\n        {\n            if (auth instanceof ApiKeyAuth)\n            {\n                ((ApiKeyAuth) auth).setApiKey(apiKey);\n                return;\n            }\n        }\n        throw new RuntimeException(\"No API key authentication configured!\");\n    }\n\n    /**\n     * Helper method to set API key prefix for the first API key authentication.\n     *\n     * @param apiKeyPrefix API key prefix\n     */\n    public void setApiKeyPrefix(String apiKeyPrefix)\n    {\n        for (Authentication auth : authentications.values())\n        {\n            if (auth instanceof ApiKeyAuth)\n            {\n                ((ApiKeyAuth) auth).setApiKeyPrefix(apiKeyPrefix);\n                return;\n            }\n        }\n        throw new RuntimeException(\"No API key authentication configured!\");\n    }\n\n    /**\n     * Helper method to set access token for the first OAuth2 authentication.\n     *\n     * @param accessToken Access token\n     */\n    public void setAccessToken(String accessToken)\n    {\n        for (Authentication auth : authentications.values())\n        {\n            if (auth instanceof OAuth)\n            {\n                ((OAuth) auth).setAccessToken(accessToken);\n                return;\n            }\n        }\n        throw new RuntimeException(\"No OAuth2 authentication configured!\");\n    }\n\n    /**\n     * Set the User-Agent header's value (by adding to the default header map).\n     *\n     * @param userAgent HTTP request's user agent\n     * @return ApiClient\n     */\n    public ApiClient setUserAgent(String userAgent)\n    {\n        addDefaultHeader(\"User-Agent\", userAgent);\n        return this;\n    }\n\n    /**\n     * Add a default header.\n     *\n     * @param key The header's key\n     * @param value The header's value\n     * @return ApiClient\n     */\n    public ApiClient addDefaultHeader(String key, String value)\n    {\n        defaultHeaderMap.put(key, value);\n        return this;\n    }\n\n    /**\n     * @see <a href=\"https://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/stream/JsonReader.html#setLenient(boolean)\">setLenient</a>\n     *\n     * @return True if lenientOnJson is enabled, false otherwise.\n     */\n    public boolean isLenientOnJson()\n    {\n        return lenientOnJson;\n    }\n\n    /**\n     * Set LenientOnJson\n     *\n     * @param lenient True to enable lenientOnJson\n     * @return ApiClient\n     */\n    public ApiClient setLenientOnJson(boolean lenient)\n    {\n        this.lenientOnJson = lenient;\n        return this;\n    }\n\n    /**\n     * Check that whether debugging is enabled for this API client.\n     *\n     * @return True if debugging is enabled, false otherwise.\n     */\n    public boolean isDebugging()\n    {\n        return debugging;\n    }\n\n    /**\n     * Enable/disable debugging for this API client.\n     *\n     * @param debugging To enable (true) or disable (false) debugging\n     * @return ApiClient\n     */\n    public ApiClient setDebugging(boolean debugging)\n    {\n        if (debugging != this.debugging)\n        {\n            if (debugging)\n            {\n                loggingInterceptor = new HttpLoggingInterceptor();\n                loggingInterceptor.setLevel(Level.BODY);\n                httpClient.interceptors().add(loggingInterceptor);\n            }\n            else\n            {\n                httpClient.interceptors().remove(loggingInterceptor);\n                loggingInterceptor = null;\n            }\n        }\n        this.debugging = debugging;\n        return this;\n    }\n\n    /**\n     * The path of temporary folder used to store downloaded files from endpoints\n     * with file response. The default value is <code>null</code>, i.e. using\n     * the system's default tempopary folder.\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/File.html#createTempFile\">createTempFile</a>\n     * @return Temporary folder path\n     */\n    public String getTempFolderPath()\n    {\n        return tempFolderPath;\n    }\n\n    /**\n     * Set the tempoaray folder path (for downloading files)\n     *\n     * @param tempFolderPath Temporary folder path\n     * @return ApiClient\n     */\n    public ApiClient setTempFolderPath(String tempFolderPath)\n    {\n        this.tempFolderPath = tempFolderPath;\n        return this;\n    }\n\n    /**\n     * Get connection timeout (in milliseconds).\n     *\n     * @return Timeout in milliseconds\n     */\n    public int getConnectTimeout()\n    {\n        return httpClient.getConnectTimeout();\n    }\n\n    /**\n     * Sets the connect timeout (in milliseconds).\n     * A value of 0 means no timeout, otherwise values must be between 1 and\n     *\n     * @param connectionTimeout connection timeout in milliseconds\n     * @return Api client\n     */\n    public ApiClient setConnectTimeout(int connectionTimeout)\n    {\n        httpClient.setConnectTimeout(connectionTimeout, TimeUnit.MILLISECONDS);\n        return this;\n    }\n\n    /**\n     * Format the given parameter object into string.\n     *\n     * @param param Parameter\n     * @return String representation of the parameter\n     */\n    public String parameterToString(Object param)\n    {\n        if (param == null)\n        {\n            return \"\";\n        }\n        else if (param instanceof Date)\n        {\n            return formatDatetime((Date) param);\n        }\n        else if (param instanceof Collection)\n        {\n            StringBuilder b = new StringBuilder();\n            for (Object o : (Collection)param)\n            {\n                if (b.length() > 0)\n                {\n                    b.append(\",\");\n                }\n                b.append(String.valueOf(o));\n            }\n            return b.toString();\n        }\n        else\n        {\n            return String.valueOf(param);\n        }\n    }\n\n    /**\n     * Format to {@code Pair} objects.\n     *\n     * @param collectionFormat collection format (e.g. csv, tsv)\n     * @param name Name\n     * @param value Value\n     * @return A list of Pair objects\n     */\n    public List<Pair> parameterToPairs(String collectionFormat, String name, Object value)\n    {\n        List<Pair> params = new ArrayList<Pair>();\n\n        // preconditions\n        if (name == null || name.isEmpty() || value == null) return params;\n\n        Collection valueCollection = null;\n        if (value instanceof Collection)\n        {\n            valueCollection = (Collection) value;\n        }\n        else\n        {\n            params.add(new Pair(name, parameterToString(value)));\n            return params;\n        }\n\n        if (valueCollection.isEmpty())\n        {\n            return params;\n        }\n\n        // get the collection format\n        collectionFormat = (collectionFormat == null || collectionFormat.isEmpty() ? \"csv\" : collectionFormat); // default: csv\n\n        // create the params based on the collection format\n        if (collectionFormat.equals(\"multi\"))\n        {\n            for (Object item : valueCollection)\n            {\n                params.add(new Pair(name, parameterToString(item)));\n            }\n\n            return params;\n        }\n\n        String delimiter = \",\";\n\n        if (collectionFormat.equals(\"csv\"))\n        {\n            delimiter = \",\";\n        }\n        else if (collectionFormat.equals(\"ssv\"))\n        {\n            delimiter = \" \";\n        }\n        else if (collectionFormat.equals(\"tsv\"))\n        {\n            delimiter = \"\\t\";\n        }\n        else if (collectionFormat.equals(\"pipes\"))\n        {\n            delimiter = \"|\";\n        }\n\n        StringBuilder sb = new StringBuilder() ;\n        for (Object item : valueCollection)\n        {\n            sb.append(delimiter);\n            sb.append(parameterToString(item));\n        }\n\n        params.add(new Pair(name, sb.substring(1)));\n\n        return params;\n    }\n\n    /**\n     * Sanitize filename by removing path.\n     * e.g. ../../sun.gif becomes sun.gif\n     *\n     * @param filename The filename to be sanitized\n     * @return The sanitized filename\n     */\n    public String sanitizeFilename(String filename)\n    {\n        return filename.replaceAll(\".*[/\\\\\\\\]\", \"\");\n    }\n\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *\n     * @param mime MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    public boolean isJsonMime(String mime)\n    {\n        return mime != null && mime.matches(\"(?i)application\\\\/json(;.*)?\");\n    }\n\n    /**\n     * Select the Accept header's value from the given accepts array:\n     *   if JSON exists in the given array, use it;\n     *   otherwise use all of them (joining into a string)\n     *\n     * @param accepts The accepts array to select from\n     * @return The Accept header to use. If the given array is empty,\n     *   null will be returned (not to set the Accept header explicitly).\n     */\n    public String selectHeaderAccept(String[] accepts)\n    {\n        if (accepts.length == 0)\n        {\n            return null;\n        }\n        for (String accept : accepts)\n        {\n            if (isJsonMime(accept))\n            {\n                return accept;\n            }\n        }\n        return StringUtil.join(accepts, \",\");\n    }\n\n    /**\n     * Select the Content-Type header's value from the given array:\n     *   if JSON exists in the given array, use it;\n     *   otherwise use the first one of the array.\n     *\n     * @param contentTypes The Content-Type array to select from\n     * @return The Content-Type header to use. If the given array is empty,\n     *   JSON will be used.\n     */\n    public String selectHeaderContentType(String[] contentTypes)\n    {\n        if (contentTypes.length == 0)\n        {\n            return \"application/json\";\n        }\n        for (String contentType : contentTypes)\n        {\n            if (isJsonMime(contentType))\n            {\n                return contentType;\n            }\n        }\n        return contentTypes[0];\n    }\n\n    /**\n     * Escape the given string to be used as URL query value.\n     *\n     * @param str String to be escaped\n     * @return Escaped string\n     */\n    public String escapeString(String str)\n    {\n        try\n        {\n            return URLEncoder.encode(str, \"utf8\").replaceAll(\"\\\\+\", \"%20\");\n        }\n        catch (UnsupportedEncodingException e)\n        {\n            return str;\n        }\n    }\n\n    /**\n     * Deserialize response body to Java object, according to the return type and\n     * the Content-Type response header.\n     *\n     * @param <T> Type\n     * @param response HTTP response\n     * @param returnType The type of the Java object\n     * @return The deserialized Java object\n     * @throws ApiException If fail to deserialize response body, i.e. cannot read response body\n     *   or the Content-Type of the response is not supported.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T deserialize(Response response, Type returnType) throws ApiException\n    {\n        if (response == null || returnType == null)\n        {\n            return null;\n        }\n\n        if (\"byte[]\".equals(returnType.toString()))\n        {\n            // Handle binary response (byte array).\n            try\n            {\n                return (T) response.body().bytes();\n            }\n            catch (IOException e)\n            {\n                throw new ApiException(e);\n            }\n        }\n        else if (returnType.equals(File.class))\n        {\n            // Handle file downloading.\n            return (T) downloadFileFromResponse(response);\n        }\n\n        String respBody;\n        try\n        {\n            if (response.body() != null)\n                respBody = response.body().string();\n            else\n                respBody = null;\n        }\n        catch (IOException e)\n        {\n            throw new ApiException(e);\n        }\n\n        if (respBody == null || \"\".equals(respBody))\n        {\n            return null;\n        }\n\n        String contentType = response.headers().get(\"Content-Type\");\n        if (contentType == null)\n        {\n            // ensuring a default content type\n            contentType = \"application/json\";\n        }\n        if (isJsonMime(contentType))\n        {\n            return json.deserialize(respBody, returnType);\n        }\n        else if (returnType.equals(String.class))\n        {\n            // Expecting string, return the raw response body.\n            return (T) respBody;\n        }\n        else\n        {\n            throw new ApiException(\n                \"Content type \\\"\" + contentType + \"\\\" is not supported for type: \" + returnType,\n                response.code(),\n                response.headers().toMultimap(),\n                respBody);\n        }\n    }\n\n    /**\n     * Serialize the given Java object into request body according to the object's\n     * class and the request Content-Type.\n     *\n     * @param obj The Java object\n     * @param contentType The request Content-Type\n     * @return The serialized request body\n     * @throws ApiException If fail to serialize the given object\n     */\n    public RequestBody serialize(Object obj, String contentType) throws ApiException\n    {\n        if (obj instanceof byte[])\n        {\n            // Binary (byte array) body parameter support.\n            return RequestBody.create(MediaType.parse(contentType), (byte[]) obj);\n        }\n        else if (obj instanceof File)\n        {\n            // File body parameter support.\n            return RequestBody.create(MediaType.parse(contentType), (File) obj);\n        }\n        else if (isJsonMime(contentType))\n        {\n            String content;\n            if (obj != null)\n            {\n                content = json.serialize(obj);\n            }\n            else\n            {\n                content = null;\n            }\n            return RequestBody.create(MediaType.parse(contentType), content);\n        }\n        else\n        {\n            throw new ApiException(\"Content type \\\"\" + contentType + \"\\\" is not supported\");\n        }\n    }\n\n    /**\n     * Download file from the given response.\n     *\n     * @param response An instance of the Response object\n     * @throws ApiException If fail to read file content from response and write to disk\n     * @return Downloaded file\n     */\n    public File downloadFileFromResponse(Response response) throws ApiException\n    {\n        try\n        {\n            File file = prepareDownloadFile(response);\n            BufferedSink sink = Okio.buffer(Okio.sink(file));\n            sink.writeAll(response.body().source());\n            sink.close();\n            return file;\n        }\n        catch (IOException e)\n        {\n            throw new ApiException(e);\n        }\n    }\n\n    /**\n     * Prepare file for download\n     *\n     * @param response An instance of the Response object\n     * @throws IOException If fail to prepare file for download\n     * @return Prepared file for the download\n     */\n    public File prepareDownloadFile(Response response) throws IOException\n    {\n        String filename = null;\n        String contentDisposition = response.header(\"Content-Disposition\");\n        if (contentDisposition != null && !\"\".equals(contentDisposition))\n        {\n            // Get filename from the Content-Disposition header.\n            Pattern pattern = Pattern.compile(\"filename=['\\\"]?([^'\\\"\\\\s]+)['\\\"]?\");\n            Matcher matcher = pattern.matcher(contentDisposition);\n            if (matcher.find())\n            {\n                filename = sanitizeFilename(matcher.group(1));\n            }\n        }\n\n        String prefix = null;\n        String suffix = null;\n        if (filename == null)\n        {\n            prefix = \"download-\";\n            suffix = \"\";\n        }\n        else\n        {\n            int pos = filename.lastIndexOf(\".\");\n            if (pos == -1)\n            {\n                prefix = filename + \"-\";\n            }\n            else\n            {\n                prefix = filename.substring(0, pos) + \"-\";\n                suffix = filename.substring(pos);\n            }\n            // File.createTempFile requires the prefix to be at least three characters long\n            if (prefix.length() < 3)\n                prefix = \"download-\";\n        }\n\n        if (tempFolderPath == null)\n            return File.createTempFile(prefix, suffix);\n        else\n            return File.createTempFile(prefix, suffix, new File(tempFolderPath));\n    }\n\n    /**\n     * {@link #execute(Call, Type)}\n     *\n     * @param <T> Type\n     * @param call An instance of the Call object\n     * @throws ApiException If fail to execute the call\n     * @return ApiResponse&lt;T&gt;\n     */\n    public <T> ApiResponse<T> execute(Call call) throws ApiException\n    {\n        return execute(call, null);\n    }\n\n    /**\n     * Execute HTTP call and deserialize the HTTP response body into the given return type.\n     *\n     * @param returnType The return type used to deserialize HTTP response body\n     * @param <T> The return type corresponding to (same with) returnType\n     * @param call Call\n     * @return ApiResponse object containing response status, headers and\n     *   data, which is a Java object deserialized from response body and would be null\n     *   when returnType is null.\n     * @throws ApiException If fail to execute the call\n     */\n    public <T> ApiResponse<T> execute(Call call, Type returnType) throws ApiException\n    {\n        try\n        {\n            Response response = call.execute();\n            T data = handleResponse(response, returnType);\n            return new ApiResponse<T>(response.code(), response.headers().toMultimap(), data);\n        }\n        catch (IOException e)\n        {\n            throw new ApiException(e);\n        }\n    }\n\n    /**\n     * {@link #executeAsync(Call, Type, ApiCallback)}\n     *\n     * @param <T> Type\n     * @param call An instance of the Call object\n     * @param callback ApiCallback&lt;T&gt;\n     */\n    public <T> void executeAsync(Call call, ApiCallback<T> callback)\n    {\n        executeAsync(call, null, callback);\n    }\n\n    /**\n     * Execute HTTP call asynchronously.\n     *\n     * @see #execute(Call, Type)\n     * @param <T> Type\n     * @param call The callback to be executed when the API call finishes\n     * @param returnType Return type\n     * @param callback ApiCallback\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> void executeAsync(Call call, final Type returnType, final ApiCallback<T> callback)\n    {\n        call.enqueue(new Callback()\n        {\n            @Override\n            public void onFailure(Request request, IOException e)\n            {\n                callback.onFailure(new ApiException(e), 0, null);\n            }\n\n            @Override\n            public void onResponse(Response response) throws IOException\n            {\n                T result;\n                try\n                {\n                    result = (T) handleResponse(response, returnType);\n                }\n                catch (ApiException e)\n                {\n                    callback.onFailure(e, response.code(), response.headers().toMultimap());\n                    return;\n                }\n                callback.onSuccess(result, response.code(), response.headers().toMultimap());\n            }\n        });\n    }\n\n    /**\n     * Handle the given response, return the deserialized object when the response is successful.\n     *\n     * @param <T> Type\n     * @param response Response\n     * @param returnType Return type\n     * @throws ApiException If the response has a unsuccessful status code or\n     *   fail to deserialize the response body\n     * @return Type\n     */\n\n    /**\n     * Build HTTP call with the given options.\n     *\n     * @param path The sub-path of the HTTP URL\n     * @param method The request method, one of \"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\", \"PATCH\" and \"DELETE\"\n     * @param queryParams The query parameters\n     * @param body The request body object\n     * @param headerParams The header parameters\n     * @param formParams The form parameters\n     * @param authNames The authentications to apply\n     * @param progressRequestListener Progress request listener\n     * @return The HTTP call\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        updateParamsForAuth(authNames, queryParams, headerParams);\n\n        final String url = buildUrl(path, queryParams);\n        final Request.Builder reqBuilder = new Request.Builder().url(url);\n        processHeaderParams(headerParams, reqBuilder);\n\n        String contentType = (String) headerParams.get(\"Content-Type\");\n        // ensuring a default content type\n        if (contentType == null)\n        {\n            contentType = \"application/json\";\n        }\n\n        RequestBody reqBody;\n        if (!HttpMethod.permitsRequestBody(method))\n        {\n            reqBody = null;\n        }\n        else if (\"application/x-www-form-urlencoded\".equals(contentType))\n        {\n            reqBody = buildRequestBodyFormEncoding(formParams);\n        }\n        else if (\"multipart/form-data\".equals(contentType))\n        {\n            reqBody = buildRequestBodyMultipart(formParams);\n        }\n        else if (body == null)\n        {\n            if (\"DELETE\".equals(method))\n            {\n                // allow calling DELETE without sending a request body\n                reqBody = null;\n            }\n            else\n            {\n                // use an empty request body (for POST, PUT and PATCH)\n                reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n            }\n        }\n        else\n        {\n            reqBody = serialize(body, contentType);\n        }\n\n        Request request = null;\n\n        if(progressRequestListener != null && reqBody != null)\n        {\n            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);\n            request = reqBuilder.method(method, progressRequestBody).build();\n        }\n        else\n        {\n            request = reqBuilder.method(method, reqBody).build();\n        }\n\n        return httpClient.newCall(request);\n    }\n\n    /**\n     * Build full URL by concatenating base path, the given sub path and query parameters.\n     *\n     * @param path The sub path\n     * @param queryParams The query parameters\n     * @return The full URL\n     */\n    public String buildUrl(String path, List<Pair> queryParams)\n    {\n        final StringBuilder url = new StringBuilder();\n        url.append(basePath).append(path);\n\n        if (queryParams != null && !queryParams.isEmpty())\n        {\n            // support (constant) query string in `path`, e.g. \"/posts?draft=1\"\n            String prefix = path.contains(\"?\") ? \"&\" : \"?\";\n            for (Pair param : queryParams)\n            {\n                if (param.getValue() != null)\n                {\n                    if (prefix != null)\n                    {\n                        url.append(prefix);\n                        prefix = null;\n                    }\n                    else\n                    {\n                        url.append(\"&\");\n                    }\n                    String value = parameterToString(param.getValue());\n                    url.append(escapeString(param.getName())).append(\"=\").append(escapeString(value));\n                }\n            }\n        }\n\n        return url.toString();\n    }\n\n    /**\n     * Set header parameters to the request builder, including default headers.\n     *\n     * @param headerParams Header parameters in the ofrm of Map\n     * @param reqBuilder Reqeust.Builder\n     */\n    public void processHeaderParams(Map<String, String> headerParams, Request.Builder reqBuilder)\n    {\n        for (Entry<String, String> param : headerParams.entrySet())\n        {\n            reqBuilder.header(param.getKey(), parameterToString(param.getValue()));\n        }\n        for (Entry<String, String> header : defaultHeaderMap.entrySet())\n        {\n            if (!headerParams.containsKey(header.getKey()))\n            {\n                reqBuilder.header(header.getKey(), parameterToString(header.getValue()));\n            }\n        }\n    }\n\n    /**\n     * Update query and header parameters based on authentication settings.\n     *\n     * @param authNames The authentications to apply\n     * @param queryParams  List of query parameters\n     * @param headerParams  Map of header parameters\n     */\n    public void updateParamsForAuth(String[] authNames, List<Pair> queryParams, Map<String, String> headerParams)\n    {\n        for (String authName : authNames)\n        {\n            Authentication auth = authentications.get(authName);\n            if (auth == null) throw new RuntimeException(\"Authentication undefined: \" + authName);\n            auth.applyToParams(queryParams, headerParams);\n        }\n    }\n\n    /**\n     * Build a form-encoding request body with the given form parameters.\n     *\n     * @param formParams Form parameters in the form of Map\n     * @return RequestBody\n     */\n    public RequestBody buildRequestBodyFormEncoding(Map<String, Object> formParams)\n    {\n        FormEncodingBuilder formBuilder  = new FormEncodingBuilder();\n        for (Entry<String, Object> param : formParams.entrySet())\n        {\n            formBuilder.add(param.getKey(), parameterToString(param.getValue()));\n        }\n        return formBuilder.build();\n    }\n\n    /**\n     * Build a multipart (file uploading) request body with the given form parameters,\n     * which could contain text fields and file fields.\n     *\n     * @param formParams Form parameters in the form of Map\n     * @return RequestBody\n     */\n    public RequestBody buildRequestBodyMultipart(Map<String, Object> formParams)\n    {\n        MultipartBuilder mpBuilder = new MultipartBuilder().type(MultipartBuilder.FORM);\n        for (Entry<String, Object> param : formParams.entrySet())\n        {\n            if (param.getValue() instanceof File)\n            {\n                File file = (File) param.getValue();\n                Headers partHeaders = Headers.of(\"Content-Disposition\", \"form-data; name=\\\"\" + param.getKey() + \"\\\"; filename=\\\"\" + file.getName() + \"\\\"\");\n                MediaType mediaType = MediaType.parse(guessContentTypeFromFile(file));\n                mpBuilder.addPart(partHeaders, RequestBody.create(mediaType, file));\n            }\n            else\n            {\n                Headers partHeaders = Headers.of(\"Content-Disposition\", \"form-data; name=\\\"\" + param.getKey() + \"\\\"\");\n                mpBuilder.addPart(partHeaders, RequestBody.create(null, parameterToString(param.getValue())));\n            }\n        }\n        return mpBuilder.build();\n    }\n\n    /**\n     * Guess Content-Type header from the given file (defaults to \"application/octet-stream\").\n     *\n     * @param file The given file\n     * @return The guessed Content-Type\n     */\n    public String guessContentTypeFromFile(File file)\n    {\n        String contentType = URLConnection.guessContentTypeFromName(file.getName());\n        if (contentType == null)\n        {\n            return \"application/octet-stream\";\n        }\n        else\n        {\n            return contentType;\n        }\n    }\n\n    /**\n     * Initialize datetime format according to the current environment, e.g. Java 1.7 and Android.\n     */\n    private void initDatetimeFormat()\n    {\n        String formatWithTimeZone = null;\n        if (IS_ANDROID)\n        {\n            if (ANDROID_SDK_VERSION >= 18)\n            {\n                // The time zone format \"ZZZZZ\" is available since Android 4.3 (SDK version 18)\n                formatWithTimeZone = \"yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ\";\n            }\n        }\n        else if (JAVA_VERSION >= 1.7)\n        {\n            // The time zone format \"XXX\" is available since Java 1.7\n            formatWithTimeZone = \"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\";\n        }\n        if (formatWithTimeZone != null)\n        {\n            this.datetimeFormat = new SimpleDateFormat(formatWithTimeZone);\n            // NOTE: Use the system's default time zone (mainly for datetime formatting).\n        }\n        else\n        {\n            // Use a common format that works across all systems.\n            this.datetimeFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\");\n            // Always use the UTC time zone as we are using a constant trailing \"Z\" here.\n            this.datetimeFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        }\n    }\n\n    /**\n     * Apply SSL related settings to httpClient according to the current values of\n     * verifyingSsl and sslCaCert.\n     */\n    private void applySslSettings()\n    {\n        try\n        {\n            KeyManager[] keyManagers = null;\n            TrustManager[] trustManagers = null;\n            HostnameVerifier hostnameVerifier = null;\n            if (!verifyingSsl)\n            {\n                TrustManager trustAll = new X509TrustManager()\n                {\n                    @Override\n                    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {}\n                    @Override\n                    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {}\n                    @Override\n                    public X509Certificate[] getAcceptedIssuers()\n                    {\n                        return null;\n                    }\n                };\n                SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n                trustManagers = new TrustManager[] { trustAll };\n                hostnameVerifier = new HostnameVerifier()\n                {\n                    @Override\n                    public boolean verify(String hostname, SSLSession session)\n                    {\n                        return true;\n                    }\n                };\n            }\n            else if (sslCaCert != null)\n            {\n                char[] password = null; // Any password will work.\n                CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\");\n                Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(sslCaCert);\n                if (certificates.isEmpty())\n                {\n                    throw new IllegalArgumentException(\"expected non-empty set of trusted certificates\");\n                }\n                KeyStore caKeyStore = newEmptyKeyStore(password);\n                int index = 0;\n                for (Certificate certificate : certificates)\n                {\n                    String certificateAlias = \"ca\" + Integer.toString(index++);\n                    caKeyStore.setCertificateEntry(certificateAlias, certificate);\n                }\n                TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n                trustManagerFactory.init(caKeyStore);\n                trustManagers = trustManagerFactory.getTrustManagers();\n            }\n\n            if (keyManagers != null || trustManagers != null)\n            {\n                SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n                sslContext.init(keyManagers, trustManagers, new SecureRandom());\n                httpClient.setSslSocketFactory(sslContext.getSocketFactory());\n            }\n            else\n            {\n                httpClient.setSslSocketFactory(null);\n            }\n            httpClient.setHostnameVerifier(hostnameVerifier);\n        }\n        catch (GeneralSecurityException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException\n    {\n        try\n        {\n            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n            keyStore.load(null, password);\n            return keyStore;\n        }\n        catch (IOException e)\n        {\n            throw new AssertionError(e);\n        }\n    }\n}"}
{"repo": "vnesek/nmote-iim4j", "path": "src/main/java/com/nmote/iim4j/IIMFile.java", "func_name": "IIMFile.add", "original_string": "public void add(int ds, Object value) throws SerializationException, InvalidDataSetException {\r\n\t\tif (value == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tDataSetInfo dsi = dsiFactory.create(ds);\r\n\t\tbyte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\r\n\t\tDataSet dataSet = new DefaultDataSet(dsi, data);\r\n\t\tdataSets.add(dataSet);\r\n\t}", "language": "java", "code": "public void add(int ds, Object value) throws SerializationException, InvalidDataSetException {\r\n\t\tif (value == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tDataSetInfo dsi = dsiFactory.create(ds);\r\n\t\tbyte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\r\n\t\tDataSet dataSet = new DefaultDataSet(dsi, data);\r\n\t\tdataSets.add(dataSet);\r\n\t}", "code_tokens": ["public", "void", "add", "(", "int", "ds", ",", "Object", "value", ")", "throws", "SerializationException", ",", "InvalidDataSetException", "{", "if", "(", "value", "==", "null", ")", "{", "return", ";", "}", "DataSetInfo", "dsi", "=", "dsiFactory", ".", "create", "(", "ds", ")", ";", "byte", "[", "]", "data", "=", "dsi", ".", "getSerializer", "(", ")", ".", "serialize", "(", "value", ",", "activeSerializationContext", ")", ";", "DataSet", "dataSet", "=", "new", "DefaultDataSet", "(", "dsi", ",", "data", ")", ";", "dataSets", ".", "add", "(", "dataSet", ")", ";", "}"], "docstring": "Adds a data set to IIM file.\n\n@param ds\ndata set id (see constants in IIM class)\n@param value\ndata set value. Null values are silently ignored.\n@throws SerializationException\nif value can't be serialized by data set's serializer\n@throws InvalidDataSetException\nif data set isn't defined", "docstring_tokens": ["Adds", "a", "data", "set", "to", "IIM", "file", "."], "sha": "ec55b02fc644cd722e93051ac0bdb96b00cb42a8", "url": "https://github.com/vnesek/nmote-iim4j/blob/ec55b02fc644cd722e93051ac0bdb96b00cb42a8/src/main/java/com/nmote/iim4j/IIMFile.java#L79-L88", "partition": "train", "up_fun_num": 3, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import java.io.IOException;", "import java.io.Serializable;", "import java.text.ParseException;", "import java.text.SimpleDateFormat;", "import java.util.ArrayList;", "import java.util.Date;", "import java.util.Iterator;", "import java.util.LinkedHashSet;", "import java.util.List;", "import java.util.Set;", "import com.nmote.iim4j.dataset.ConstraintViolation;", "import com.nmote.iim4j.dataset.DataSet;", "import com.nmote.iim4j.dataset.DataSetInfo;", "import com.nmote.iim4j.dataset.DataSetInfoFactory;", "import com.nmote.iim4j.dataset.DefaultDataSet;", "import com.nmote.iim4j.dataset.InvalidDataSetException;", "import com.nmote.iim4j.dataset.UnsupportedDataSetException;", "import com.nmote.iim4j.serialize.DefaultSerializationContext;", "import com.nmote.iim4j.serialize.SerializationContext;", "import com.nmote.iim4j.serialize.SerializationException;", "import com.nmote.iim4j.serialize.Serializer;"], "function": ["public class IIMFile extends DefaultSerializationContext implements Serializable, Cloneable\n", "    public void add(DataSet dataSet)\n", "    public void addDateTimeHelper(int ds, Date date) throws SerializationException, InvalidDataSetException\n", "    public void addDateTimeHelper(int dsDate, int dsTime, Date date) throws SerializationException,\n", "    public IIMFile clone()\n", "    public Object get(int dataSet) throws SerializationException\n", "    public List<Object> getAll(int dataSet) throws SerializationException\n", "    public List<DataSet> getDataSets()\n", "    public Date getDateTimeHelper(int dateDataSet, int timeDataSet) throws SerializationException\n", "    public SerializationContext getSerializationContext()\n", "    public boolean isRecoverFromIIMFormat()\n", "    public boolean isRecoverFromInvalidDataSet()\n", "    public boolean isRecoverFromUnsupportedDataSet()\n", "    public boolean isStopAfter9_10()\n", "    public void readFrom(IIMReader reader) throws IOException, InvalidDataSetException\n", "    public void readFrom(IIMReader reader, int recover) throws IOException, InvalidDataSetException\n", "    public boolean remove(int dataSet)\n", "    public boolean removeRecord(int record)\n", "    public void setDataSets(List<DataSet> dataSets)\n", "    public void setLog(LoggerAdapter log)\n", "    public void setRecoverFromIIMFormat(boolean recoverFromIIMFormat)\n", "    public void setRecoverFromInvalidDataSet(boolean recoverFromInvalidDataSet)\n", "    public void setRecoverFromUnsupportedDataSet(boolean recoverFromUnsupportedDataSet)\n", "    public void setSerializationContext(SerializationContext serializationContext)\n", "    public void setStopAfter9_10(boolean stopAfter9_10)\n", "    public String toString()\n", "    public void writeTo(IIMWriter writer) throws IOException\n", "    private Object getData(DataSet ds) throws SerializationException\n", "    public Set<ConstraintViolation> validate(DataSetInfo info)\n", "    public Set<ConstraintViolation> validate(int record)\n", "    public Set<ConstraintViolation> validate()\n"], "context": "/*\n * Copyright (c) Nmote Ltd. 2004-2015. All rights reserved.\n * See LICENSE doc in a root of project folder for additional information.\n */\n\npackage com.nmote.iim4j;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport com.nmote.iim4j.dataset.ConstraintViolation;\nimport com.nmote.iim4j.dataset.DataSet;\nimport com.nmote.iim4j.dataset.DataSetInfo;\nimport com.nmote.iim4j.dataset.DataSetInfoFactory;\nimport com.nmote.iim4j.dataset.DefaultDataSet;\nimport com.nmote.iim4j.dataset.InvalidDataSetException;\nimport com.nmote.iim4j.dataset.UnsupportedDataSetException;\nimport com.nmote.iim4j.serialize.DefaultSerializationContext;\nimport com.nmote.iim4j.serialize.SerializationContext;\nimport com.nmote.iim4j.serialize.SerializationException;\nimport com.nmote.iim4j.serialize.Serializer;\n\n/**\n * IIMFile holds a set of data set records, and supports reading and writing to\n * files/streams.\n */\npublic class IIMFile extends DefaultSerializationContext implements Serializable, Cloneable\n{\n\n    private static final long serialVersionUID = About.SERIAL_VERSION_UID;\n\n    /**\n     * Creates a new IIMFile using default (IIM version 4) data set info\n     * factory.\n     */\n    public IIMFile()\n    {\n        this(IIMDataSetInfoFactory.VERSION_4);\n    }\n\n    /**\n     * Creates a new IIMFile using passed data set info factory.\n     *\n     * @param dsiFactory\n     *            data set info factory\n     */\n    public IIMFile(DataSetInfoFactory dsiFactory)\n    {\n        this.dsiFactory = dsiFactory;\n    }\n\n    /**\n     * Adds a data set to IIM file.\n     *\n     * @param dataSet\n     *            to add\n     */\n    public void add(DataSet dataSet)\n    {\n        dataSets.add(dataSet);\n    }\n\n    /**\n     * Adds a data set to IIM file.\n     *\n     * @param ds\n     *            data set id (see constants in IIM class)\n     * @param value\n     *            data set value. Null values are silently ignored.\n     * @throws SerializationException\n     *             if value can't be serialized by data set's serializer\n     * @throws InvalidDataSetException\n     *             if data set isn't defined\n     */\n\n    /**\n     * Adds a data set with date-time value to IIM file.\n     *\n     * @param ds\n     *            data set id (see constants in IIM class)\n     * @param date\n     *            date to set. Null values are silently ignored.\n     * @throws SerializationException\n     *             if value can't be serialized by data set's serializer\n     * @throws InvalidDataSetException\n     *             if data set isn't defined\n     */\n    public void addDateTimeHelper(int ds, Date date) throws SerializationException, InvalidDataSetException\n    {\n        if (date == null)\n        {\n            return;\n        }\n\n        DataSetInfo dsi = dsiFactory.create(ds);\n\n        SimpleDateFormat df = new SimpleDateFormat(dsi.getSerializer().toString());\n        String value = df.format(date);\n        byte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\n        DataSet dataSet = new DefaultDataSet(dsi, data);\n        add(dataSet);\n    }\n\n    public void addDateTimeHelper(int dsDate, int dsTime, Date date) throws SerializationException,\n               InvalidDataSetException\n    {\n        if (date == null)\n            return;\n\n        addDateTimeHelper(dsDate, date);\n        addDateTimeHelper(dsTime, date);\n    }\n\n    /**\n     * Makes a copy of this instance.\n     *\n     * @see java.lang.Object#clone()\n     * @return IIMFile copy\n     */\n    public IIMFile clone()\n    {\n        IIMFile file = new IIMFile(dsiFactory);\n        file.dataSets = new ArrayList<DataSet>(dataSets);\n        file.serializationContext = serializationContext == this ? file : serializationContext;\n        file.activeSerializationContext = activeSerializationContext == this ? file : activeSerializationContext;\n        return file;\n    }\n\n    /**\n     * Gets a first data set value.\n     *\n     * @param dataSet\n     *            IIM record and dataset code (See constants in {@link IIM})\n     * @return data set value\n     * @throws SerializationException\n     *             if value can't be deserialized from binary representation\n     */\n    public Object get(int dataSet) throws SerializationException\n    {\n        Object result = null;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                result = getData(ds);\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets all data set values.\n     *\n     * @param dataSet\n     *            IIM record and dataset code (See constants in {@link IIM})\n     * @return data set value\n     * @throws SerializationException\n     *             if value can't be deserialized from binary representation\n     */\n    public List<Object> getAll(int dataSet) throws SerializationException\n    {\n        List<Object> result = new ArrayList<Object>();\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                result.add(getData(ds));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets all data sets in IIM file.\n     *\n     * @return Returns the dataSets\n     */\n    public List<DataSet> getDataSets()\n    {\n        return this.dataSets;\n    }\n\n    /**\n     * Gets combined date/time value from two data sets.\n     *\n     * @param dateDataSet\n     *            data set containing date value\n     * @param timeDataSet\n     *            data set containing time value\n     * @return date/time instance\n     * @throws SerializationException\n     *             if data sets can't be deserialized from binary format or\n     *             can't be parsed\n     */\n    public Date getDateTimeHelper(int dateDataSet, int timeDataSet) throws SerializationException\n    {\n        DataSet dateDS = null;\n        DataSet timeDS = null;\n        for (Iterator<DataSet> i = dataSets.iterator(); (dateDS == null || timeDS == null) && i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dateDataSet)\n            {\n                dateDS = ds;\n            }\n            else if (info.getDataSetNumber() == timeDataSet)\n            {\n                timeDS = ds;\n            }\n        }\n\n        Date result = null;\n        if (dateDS != null && timeDS != null)\n        {\n            DataSetInfo dateDSI = dateDS.getInfo();\n            DataSetInfo timeDSI = timeDS.getInfo();\n            SimpleDateFormat format = new SimpleDateFormat(dateDSI.getSerializer().toString()\n                    + timeDSI.getSerializer().toString());\n            StringBuffer date = new StringBuffer(20);\n            try\n            {\n                date.append(getData(dateDS));\n                date.append(getData(timeDS));\n                result = format.parse(date.toString());\n            }\n            catch (ParseException e)\n            {\n                throw new SerializationException(\"Failed to read date (\" + e.getMessage() + \") with format \" + date);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Gets serialization context for this IIM file instance.\n     *\n     * @return Returns the serializationContext\n     */\n    public SerializationContext getSerializationContext()\n    {\n        return this.serializationContext;\n    }\n\n    public boolean isRecoverFromIIMFormat()\n    {\n        return recoverFromIIMFormat;\n    }\n\n    public boolean isRecoverFromInvalidDataSet()\n    {\n        return recoverFromInvalidDataSet;\n    }\n\n    public boolean isRecoverFromUnsupportedDataSet()\n    {\n        return recoverFromUnsupportedDataSet;\n    }\n\n    public boolean isStopAfter9_10()\n    {\n        return stopAfter9_10;\n    }\n\n    /**\n     * Reads data sets from a passed reader and attempt to recover from as much\n     * errors as possible.\n     *\n     * @param reader\n     *            data sets source\n     * @throws IOException\n     *             if reader can't read underlying stream\n     * @throws InvalidDataSetException\n     *             if invalid/undefined data set is encountered\n     */\n    public void readFrom(IIMReader reader) throws IOException, InvalidDataSetException\n    {\n        readFrom(reader, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Reads data sets from a passed reader.\n     *\n     * @param reader\n     *            data sets source\n     * @param recover\n     *            max number of errors reading process will try to recover from.\n     *            Set to 0 to fail immediately\n     * @throws IOException\n     *             if reader can't read underlying stream\n     * @throws InvalidDataSetException\n     *             if invalid/undefined data set is encountered\n     */\n    public void readFrom(IIMReader reader, int recover) throws IOException, InvalidDataSetException\n    {\n        final boolean doLog = log != null;\n        for (;;)\n        {\n            try\n            {\n                DataSet ds = reader.read();\n                if (ds == null)\n                {\n                    break;\n                }\n\n                if (doLog)\n                {\n                    log.debug(\"Read data set \" + ds);\n                }\n\n                DataSetInfo info = ds.getInfo();\n                Serializer s = info.getSerializer();\n                if (s != null)\n                {\n                    if (info.getDataSetNumber() == IIM.DS(1, 90))\n                    {\n                        setCharacterSet((String) s.deserialize(ds.getData(), activeSerializationContext));\n                    }\n                }\n\n                dataSets.add(ds);\n\n                if (stopAfter9_10 && info.getDataSetNumber() == IIM.DS(9, 10))\n                    break;\n            }\n            catch (IIMFormatException e)\n            {\n                if (recoverFromIIMFormat && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (UnsupportedDataSetException e)\n            {\n                if (recoverFromUnsupportedDataSet && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (InvalidDataSetException e)\n            {\n                if (recoverFromInvalidDataSet && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (IOException e)\n            {\n                if (recover-- > 0 && !dataSets.isEmpty())\n                {\n                    if (doLog)\n                    {\n                        log.error(\"IOException while reading, however some data sets where recovered, \" + e);\n                    }\n                    return;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n        }\n    }\n\n    public boolean remove(int dataSet)\n    {\n        boolean result = false;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                i.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    public boolean removeRecord(int record)\n    {\n        boolean result = false;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if ((info.getDataSetNumber() >> 8) == record)\n            {\n                i.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @param dataSets\n     *            The dataSets to set.\n     */\n    public void setDataSets(List<DataSet> dataSets)\n    {\n        this.dataSets = dataSets;\n    }\n\n    /**\n     * Sets logger for this IIMFile.\n     *\n     * @param log\n     *            logger to use with this file.\n     */\n    public void setLog(LoggerAdapter log)\n    {\n        this.log = log;\n    }\n\n    /**\n     * Should we recover from the IIM format violations, default is true.\n     *\n     * @param recoverFromIIMFormat\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromIIMFormat(boolean recoverFromIIMFormat)\n    {\n        this.recoverFromIIMFormat = recoverFromIIMFormat;\n    }\n\n    /**\n     * Should we recover from the invalid data sets, default is true.\n     *\n     * @param recoverFromInvalidDataSet\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromInvalidDataSet(boolean recoverFromInvalidDataSet)\n    {\n        this.recoverFromInvalidDataSet = recoverFromInvalidDataSet;\n    }\n\n    /**\n     * Should we recover from the unsupported data sets, default is true.\n     *\n     * @param recoverFromUnsupportedDataSet\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromUnsupportedDataSet(boolean recoverFromUnsupportedDataSet)\n    {\n        this.recoverFromUnsupportedDataSet = recoverFromUnsupportedDataSet;\n    }\n\n    /**\n     * @param serializationContext\n     *            The serializationContext to set\n     */\n    public void setSerializationContext(SerializationContext serializationContext)\n    {\n        this.serializationContext = serializationContext;\n        activeSerializationContext = serializationContext != null ? serializationContext : this;\n    }\n\n    /**\n     * Controls if reading should stop after data set record 9,10. Default true.\n     *\n     * @param stopAfter9_10\n     *            true to stop reading, false to stop\n     */\n    public void setStopAfter9_10(boolean stopAfter9_10)\n    {\n        this.stopAfter9_10 = stopAfter9_10;\n    }\n\n    public String toString()\n    {\n        StringBuilder b = new StringBuilder();\n        b.append(\"IIMFile(\");\n        b.append(\"dataSets=\");\n        b.append(dataSets);\n        b.append(')');\n        return b.toString();\n    }\n\n    /**\n     * Writes this IIMFile to writer.\n     *\n     * @param writer\n     *            writer to write to\n     * @throws IOException\n     *             if file can't be written to\n     */\n    public void writeTo(IIMWriter writer) throws IOException\n    {\n        final boolean doLog = log != null;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            writer.write(ds);\n            if (doLog)\n            {\n                log.debug(\"Wrote data set \" + ds);\n            }\n        }\n    }\n\n    private Object getData(DataSet ds) throws SerializationException\n    {\n        DataSetInfo info = ds.getInfo();\n        Serializer s = info.getSerializer();\n        Object result;\n        if (s != null)\n        {\n            result = s.deserialize(ds.getData(), activeSerializationContext);\n        }\n        else\n        {\n            result = ds.getData();\n        }\n        return result;\n    }\n\n    /**\n     * Checks if data set is mandatory but missing or non repeatable but having\n     * multiple values in this IIM instance.\n     *\n     * @param info\n     *            IIM data set to check\n     * @return list of constraint violations, empty set if data set is valid\n     */\n    public Set<ConstraintViolation> validate(DataSetInfo info)\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        try\n        {\n            if (info.isMandatory() && get(info.getDataSetNumber()) == null)\n            {\n                errors.add(new ConstraintViolation(info, ConstraintViolation.MANDATORY_MISSING));\n            }\n            if (!info.isRepeatable() && getAll(info.getDataSetNumber()).size() > 1)\n            {\n                errors.add(new ConstraintViolation(info, ConstraintViolation.REPEATABLE_REPEATED));\n            }\n        }\n        catch (SerializationException e)\n        {\n            errors.add(new ConstraintViolation(info, ConstraintViolation.INVALID_VALUE));\n        }\n        return errors;\n    }\n\n    /**\n     * Checks all data sets in a given record for constraint violations.\n     *\n     * @param record\n     *            IIM record (1,2,3, ...) to check\n     *\n     * @return list of constraint violations, empty set if IIM file is valid\n     */\n    public Set<ConstraintViolation> validate(int record)\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        for (int ds = 0; ds < 250; ++ds)\n        {\n            try\n            {\n                DataSetInfo dataSetInfo = dsiFactory.create(IIM.DS(record, ds));\n                errors.addAll(validate(dataSetInfo));\n            }\n            catch (InvalidDataSetException ignored)\n            {\n                // DataSetFactory doesn't know about this ds, so will skip it\n            }\n        }\n        return errors;\n    }\n\n    /**\n     * Checks all data sets in IIM records 1, 2 and 3 for constraint violations.\n     *\n     * @return list of constraint violations, empty set if IIM file is valid\n     */\n    public Set<ConstraintViolation> validate()\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        for (int record = 1; record <= 3; ++record)\n        {\n            errors.addAll(validate(record));\n        }\n        return errors;\n    }\n\n    private SerializationContext activeSerializationContext = this;\n    private List<DataSet> dataSets = new ArrayList<DataSet>();\n    private DataSetInfoFactory dsiFactory;\n    private LoggerAdapter log;\n    private boolean recoverFromIIMFormat = true;\n    private boolean recoverFromInvalidDataSet = true;\n    private boolean recoverFromUnsupportedDataSet = true;\n    private SerializationContext serializationContext;\n    private boolean stopAfter9_10 = true;\n}"}
{"repo": "vnesek/nmote-iim4j", "path": "src/main/java/com/nmote/iim4j/IIMFile.java", "func_name": "IIMFile.addDateTimeHelper", "original_string": "public void addDateTimeHelper(int ds, Date date) throws SerializationException, InvalidDataSetException {\r\n\t\tif (date == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tDataSetInfo dsi = dsiFactory.create(ds);\r\n\r\n\t\tSimpleDateFormat df = new SimpleDateFormat(dsi.getSerializer().toString());\r\n\t\tString value = df.format(date);\r\n\t\tbyte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\r\n\t\tDataSet dataSet = new DefaultDataSet(dsi, data);\r\n\t\tadd(dataSet);\r\n\t}", "language": "java", "code": "public void addDateTimeHelper(int ds, Date date) throws SerializationException, InvalidDataSetException {\r\n\t\tif (date == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tDataSetInfo dsi = dsiFactory.create(ds);\r\n\r\n\t\tSimpleDateFormat df = new SimpleDateFormat(dsi.getSerializer().toString());\r\n\t\tString value = df.format(date);\r\n\t\tbyte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\r\n\t\tDataSet dataSet = new DefaultDataSet(dsi, data);\r\n\t\tadd(dataSet);\r\n\t}", "code_tokens": ["public", "void", "addDateTimeHelper", "(", "int", "ds", ",", "Date", "date", ")", "throws", "SerializationException", ",", "InvalidDataSetException", "{", "if", "(", "date", "==", "null", ")", "{", "return", ";", "}", "DataSetInfo", "dsi", "=", "dsiFactory", ".", "create", "(", "ds", ")", ";", "SimpleDateFormat", "df", "=", "new", "SimpleDateFormat", "(", "dsi", ".", "getSerializer", "(", ")", ".", "toString", "(", ")", ")", ";", "String", "value", "=", "df", ".", "format", "(", "date", ")", ";", "byte", "[", "]", "data", "=", "dsi", ".", "getSerializer", "(", ")", ".", "serialize", "(", "value", ",", "activeSerializationContext", ")", ";", "DataSet", "dataSet", "=", "new", "DefaultDataSet", "(", "dsi", ",", "data", ")", ";", "add", "(", "dataSet", ")", ";", "}"], "docstring": "Adds a data set with date-time value to IIM file.\n\n@param ds\ndata set id (see constants in IIM class)\n@param date\ndate to set. Null values are silently ignored.\n@throws SerializationException\nif value can't be serialized by data set's serializer\n@throws InvalidDataSetException\nif data set isn't defined", "docstring_tokens": ["Adds", "a", "data", "set", "with", "date", "-", "time", "value", "to", "IIM", "file", "."], "sha": "ec55b02fc644cd722e93051ac0bdb96b00cb42a8", "url": "https://github.com/vnesek/nmote-iim4j/blob/ec55b02fc644cd722e93051ac0bdb96b00cb42a8/src/main/java/com/nmote/iim4j/IIMFile.java#L102-L114", "partition": "train", "up_fun_num": 4, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import java.io.IOException;", "import java.io.Serializable;", "import java.text.ParseException;", "import java.text.SimpleDateFormat;", "import java.util.ArrayList;", "import java.util.Date;", "import java.util.Iterator;", "import java.util.LinkedHashSet;", "import java.util.List;", "import java.util.Set;", "import com.nmote.iim4j.dataset.ConstraintViolation;", "import com.nmote.iim4j.dataset.DataSet;", "import com.nmote.iim4j.dataset.DataSetInfo;", "import com.nmote.iim4j.dataset.DataSetInfoFactory;", "import com.nmote.iim4j.dataset.DefaultDataSet;", "import com.nmote.iim4j.dataset.InvalidDataSetException;", "import com.nmote.iim4j.dataset.UnsupportedDataSetException;", "import com.nmote.iim4j.serialize.DefaultSerializationContext;", "import com.nmote.iim4j.serialize.SerializationContext;", "import com.nmote.iim4j.serialize.SerializationException;", "import com.nmote.iim4j.serialize.Serializer;"], "function": ["public class IIMFile extends DefaultSerializationContext implements Serializable, Cloneable\n", "    public void add(DataSet dataSet)\n", "    public void add(int ds, Object value) throws SerializationException, InvalidDataSetException\n", "    public void addDateTimeHelper(int dsDate, int dsTime, Date date) throws SerializationException,\n", "    public IIMFile clone()\n", "    public Object get(int dataSet) throws SerializationException\n", "    public List<Object> getAll(int dataSet) throws SerializationException\n", "    public List<DataSet> getDataSets()\n", "    public Date getDateTimeHelper(int dateDataSet, int timeDataSet) throws SerializationException\n", "    public SerializationContext getSerializationContext()\n", "    public boolean isRecoverFromIIMFormat()\n", "    public boolean isRecoverFromInvalidDataSet()\n", "    public boolean isRecoverFromUnsupportedDataSet()\n", "    public boolean isStopAfter9_10()\n", "    public void readFrom(IIMReader reader) throws IOException, InvalidDataSetException\n", "    public void readFrom(IIMReader reader, int recover) throws IOException, InvalidDataSetException\n", "    public boolean remove(int dataSet)\n", "    public boolean removeRecord(int record)\n", "    public void setDataSets(List<DataSet> dataSets)\n", "    public void setLog(LoggerAdapter log)\n", "    public void setRecoverFromIIMFormat(boolean recoverFromIIMFormat)\n", "    public void setRecoverFromInvalidDataSet(boolean recoverFromInvalidDataSet)\n", "    public void setRecoverFromUnsupportedDataSet(boolean recoverFromUnsupportedDataSet)\n", "    public void setSerializationContext(SerializationContext serializationContext)\n", "    public void setStopAfter9_10(boolean stopAfter9_10)\n", "    public String toString()\n", "    public void writeTo(IIMWriter writer) throws IOException\n", "    private Object getData(DataSet ds) throws SerializationException\n", "    public Set<ConstraintViolation> validate(DataSetInfo info)\n", "    public Set<ConstraintViolation> validate(int record)\n", "    public Set<ConstraintViolation> validate()\n"], "context": "/*\n * Copyright (c) Nmote Ltd. 2004-2015. All rights reserved.\n * See LICENSE doc in a root of project folder for additional information.\n */\n\npackage com.nmote.iim4j;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport com.nmote.iim4j.dataset.ConstraintViolation;\nimport com.nmote.iim4j.dataset.DataSet;\nimport com.nmote.iim4j.dataset.DataSetInfo;\nimport com.nmote.iim4j.dataset.DataSetInfoFactory;\nimport com.nmote.iim4j.dataset.DefaultDataSet;\nimport com.nmote.iim4j.dataset.InvalidDataSetException;\nimport com.nmote.iim4j.dataset.UnsupportedDataSetException;\nimport com.nmote.iim4j.serialize.DefaultSerializationContext;\nimport com.nmote.iim4j.serialize.SerializationContext;\nimport com.nmote.iim4j.serialize.SerializationException;\nimport com.nmote.iim4j.serialize.Serializer;\n\n/**\n * IIMFile holds a set of data set records, and supports reading and writing to\n * files/streams.\n */\npublic class IIMFile extends DefaultSerializationContext implements Serializable, Cloneable\n{\n\n    private static final long serialVersionUID = About.SERIAL_VERSION_UID;\n\n    /**\n     * Creates a new IIMFile using default (IIM version 4) data set info\n     * factory.\n     */\n    public IIMFile()\n    {\n        this(IIMDataSetInfoFactory.VERSION_4);\n    }\n\n    /**\n     * Creates a new IIMFile using passed data set info factory.\n     *\n     * @param dsiFactory\n     *            data set info factory\n     */\n    public IIMFile(DataSetInfoFactory dsiFactory)\n    {\n        this.dsiFactory = dsiFactory;\n    }\n\n    /**\n     * Adds a data set to IIM file.\n     *\n     * @param dataSet\n     *            to add\n     */\n    public void add(DataSet dataSet)\n    {\n        dataSets.add(dataSet);\n    }\n\n    /**\n     * Adds a data set to IIM file.\n     *\n     * @param ds\n     *            data set id (see constants in IIM class)\n     * @param value\n     *            data set value. Null values are silently ignored.\n     * @throws SerializationException\n     *             if value can't be serialized by data set's serializer\n     * @throws InvalidDataSetException\n     *             if data set isn't defined\n     */\n    public void add(int ds, Object value) throws SerializationException, InvalidDataSetException\n    {\n        if (value == null)\n        {\n            return;\n        }\n\n        DataSetInfo dsi = dsiFactory.create(ds);\n        byte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\n        DataSet dataSet = new DefaultDataSet(dsi, data);\n        dataSets.add(dataSet);\n    }\n\n    /**\n     * Adds a data set with date-time value to IIM file.\n     *\n     * @param ds\n     *            data set id (see constants in IIM class)\n     * @param date\n     *            date to set. Null values are silently ignored.\n     * @throws SerializationException\n     *             if value can't be serialized by data set's serializer\n     * @throws InvalidDataSetException\n     *             if data set isn't defined\n     */\n\n    public void addDateTimeHelper(int dsDate, int dsTime, Date date) throws SerializationException,\n               InvalidDataSetException\n    {\n        if (date == null)\n            return;\n\n        addDateTimeHelper(dsDate, date);\n        addDateTimeHelper(dsTime, date);\n    }\n\n    /**\n     * Makes a copy of this instance.\n     *\n     * @see java.lang.Object#clone()\n     * @return IIMFile copy\n     */\n    public IIMFile clone()\n    {\n        IIMFile file = new IIMFile(dsiFactory);\n        file.dataSets = new ArrayList<DataSet>(dataSets);\n        file.serializationContext = serializationContext == this ? file : serializationContext;\n        file.activeSerializationContext = activeSerializationContext == this ? file : activeSerializationContext;\n        return file;\n    }\n\n    /**\n     * Gets a first data set value.\n     *\n     * @param dataSet\n     *            IIM record and dataset code (See constants in {@link IIM})\n     * @return data set value\n     * @throws SerializationException\n     *             if value can't be deserialized from binary representation\n     */\n    public Object get(int dataSet) throws SerializationException\n    {\n        Object result = null;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                result = getData(ds);\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets all data set values.\n     *\n     * @param dataSet\n     *            IIM record and dataset code (See constants in {@link IIM})\n     * @return data set value\n     * @throws SerializationException\n     *             if value can't be deserialized from binary representation\n     */\n    public List<Object> getAll(int dataSet) throws SerializationException\n    {\n        List<Object> result = new ArrayList<Object>();\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                result.add(getData(ds));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets all data sets in IIM file.\n     *\n     * @return Returns the dataSets\n     */\n    public List<DataSet> getDataSets()\n    {\n        return this.dataSets;\n    }\n\n    /**\n     * Gets combined date/time value from two data sets.\n     *\n     * @param dateDataSet\n     *            data set containing date value\n     * @param timeDataSet\n     *            data set containing time value\n     * @return date/time instance\n     * @throws SerializationException\n     *             if data sets can't be deserialized from binary format or\n     *             can't be parsed\n     */\n    public Date getDateTimeHelper(int dateDataSet, int timeDataSet) throws SerializationException\n    {\n        DataSet dateDS = null;\n        DataSet timeDS = null;\n        for (Iterator<DataSet> i = dataSets.iterator(); (dateDS == null || timeDS == null) && i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dateDataSet)\n            {\n                dateDS = ds;\n            }\n            else if (info.getDataSetNumber() == timeDataSet)\n            {\n                timeDS = ds;\n            }\n        }\n\n        Date result = null;\n        if (dateDS != null && timeDS != null)\n        {\n            DataSetInfo dateDSI = dateDS.getInfo();\n            DataSetInfo timeDSI = timeDS.getInfo();\n            SimpleDateFormat format = new SimpleDateFormat(dateDSI.getSerializer().toString()\n                    + timeDSI.getSerializer().toString());\n            StringBuffer date = new StringBuffer(20);\n            try\n            {\n                date.append(getData(dateDS));\n                date.append(getData(timeDS));\n                result = format.parse(date.toString());\n            }\n            catch (ParseException e)\n            {\n                throw new SerializationException(\"Failed to read date (\" + e.getMessage() + \") with format \" + date);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Gets serialization context for this IIM file instance.\n     *\n     * @return Returns the serializationContext\n     */\n    public SerializationContext getSerializationContext()\n    {\n        return this.serializationContext;\n    }\n\n    public boolean isRecoverFromIIMFormat()\n    {\n        return recoverFromIIMFormat;\n    }\n\n    public boolean isRecoverFromInvalidDataSet()\n    {\n        return recoverFromInvalidDataSet;\n    }\n\n    public boolean isRecoverFromUnsupportedDataSet()\n    {\n        return recoverFromUnsupportedDataSet;\n    }\n\n    public boolean isStopAfter9_10()\n    {\n        return stopAfter9_10;\n    }\n\n    /**\n     * Reads data sets from a passed reader and attempt to recover from as much\n     * errors as possible.\n     *\n     * @param reader\n     *            data sets source\n     * @throws IOException\n     *             if reader can't read underlying stream\n     * @throws InvalidDataSetException\n     *             if invalid/undefined data set is encountered\n     */\n    public void readFrom(IIMReader reader) throws IOException, InvalidDataSetException\n    {\n        readFrom(reader, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Reads data sets from a passed reader.\n     *\n     * @param reader\n     *            data sets source\n     * @param recover\n     *            max number of errors reading process will try to recover from.\n     *            Set to 0 to fail immediately\n     * @throws IOException\n     *             if reader can't read underlying stream\n     * @throws InvalidDataSetException\n     *             if invalid/undefined data set is encountered\n     */\n    public void readFrom(IIMReader reader, int recover) throws IOException, InvalidDataSetException\n    {\n        final boolean doLog = log != null;\n        for (;;)\n        {\n            try\n            {\n                DataSet ds = reader.read();\n                if (ds == null)\n                {\n                    break;\n                }\n\n                if (doLog)\n                {\n                    log.debug(\"Read data set \" + ds);\n                }\n\n                DataSetInfo info = ds.getInfo();\n                Serializer s = info.getSerializer();\n                if (s != null)\n                {\n                    if (info.getDataSetNumber() == IIM.DS(1, 90))\n                    {\n                        setCharacterSet((String) s.deserialize(ds.getData(), activeSerializationContext));\n                    }\n                }\n\n                dataSets.add(ds);\n\n                if (stopAfter9_10 && info.getDataSetNumber() == IIM.DS(9, 10))\n                    break;\n            }\n            catch (IIMFormatException e)\n            {\n                if (recoverFromIIMFormat && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (UnsupportedDataSetException e)\n            {\n                if (recoverFromUnsupportedDataSet && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (InvalidDataSetException e)\n            {\n                if (recoverFromInvalidDataSet && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (IOException e)\n            {\n                if (recover-- > 0 && !dataSets.isEmpty())\n                {\n                    if (doLog)\n                    {\n                        log.error(\"IOException while reading, however some data sets where recovered, \" + e);\n                    }\n                    return;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n        }\n    }\n\n    public boolean remove(int dataSet)\n    {\n        boolean result = false;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                i.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    public boolean removeRecord(int record)\n    {\n        boolean result = false;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if ((info.getDataSetNumber() >> 8) == record)\n            {\n                i.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @param dataSets\n     *            The dataSets to set.\n     */\n    public void setDataSets(List<DataSet> dataSets)\n    {\n        this.dataSets = dataSets;\n    }\n\n    /**\n     * Sets logger for this IIMFile.\n     *\n     * @param log\n     *            logger to use with this file.\n     */\n    public void setLog(LoggerAdapter log)\n    {\n        this.log = log;\n    }\n\n    /**\n     * Should we recover from the IIM format violations, default is true.\n     *\n     * @param recoverFromIIMFormat\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromIIMFormat(boolean recoverFromIIMFormat)\n    {\n        this.recoverFromIIMFormat = recoverFromIIMFormat;\n    }\n\n    /**\n     * Should we recover from the invalid data sets, default is true.\n     *\n     * @param recoverFromInvalidDataSet\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromInvalidDataSet(boolean recoverFromInvalidDataSet)\n    {\n        this.recoverFromInvalidDataSet = recoverFromInvalidDataSet;\n    }\n\n    /**\n     * Should we recover from the unsupported data sets, default is true.\n     *\n     * @param recoverFromUnsupportedDataSet\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromUnsupportedDataSet(boolean recoverFromUnsupportedDataSet)\n    {\n        this.recoverFromUnsupportedDataSet = recoverFromUnsupportedDataSet;\n    }\n\n    /**\n     * @param serializationContext\n     *            The serializationContext to set\n     */\n    public void setSerializationContext(SerializationContext serializationContext)\n    {\n        this.serializationContext = serializationContext;\n        activeSerializationContext = serializationContext != null ? serializationContext : this;\n    }\n\n    /**\n     * Controls if reading should stop after data set record 9,10. Default true.\n     *\n     * @param stopAfter9_10\n     *            true to stop reading, false to stop\n     */\n    public void setStopAfter9_10(boolean stopAfter9_10)\n    {\n        this.stopAfter9_10 = stopAfter9_10;\n    }\n\n    public String toString()\n    {\n        StringBuilder b = new StringBuilder();\n        b.append(\"IIMFile(\");\n        b.append(\"dataSets=\");\n        b.append(dataSets);\n        b.append(')');\n        return b.toString();\n    }\n\n    /**\n     * Writes this IIMFile to writer.\n     *\n     * @param writer\n     *            writer to write to\n     * @throws IOException\n     *             if file can't be written to\n     */\n    public void writeTo(IIMWriter writer) throws IOException\n    {\n        final boolean doLog = log != null;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            writer.write(ds);\n            if (doLog)\n            {\n                log.debug(\"Wrote data set \" + ds);\n            }\n        }\n    }\n\n    private Object getData(DataSet ds) throws SerializationException\n    {\n        DataSetInfo info = ds.getInfo();\n        Serializer s = info.getSerializer();\n        Object result;\n        if (s != null)\n        {\n            result = s.deserialize(ds.getData(), activeSerializationContext);\n        }\n        else\n        {\n            result = ds.getData();\n        }\n        return result;\n    }\n\n    /**\n     * Checks if data set is mandatory but missing or non repeatable but having\n     * multiple values in this IIM instance.\n     *\n     * @param info\n     *            IIM data set to check\n     * @return list of constraint violations, empty set if data set is valid\n     */\n    public Set<ConstraintViolation> validate(DataSetInfo info)\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        try\n        {\n            if (info.isMandatory() && get(info.getDataSetNumber()) == null)\n            {\n                errors.add(new ConstraintViolation(info, ConstraintViolation.MANDATORY_MISSING));\n            }\n            if (!info.isRepeatable() && getAll(info.getDataSetNumber()).size() > 1)\n            {\n                errors.add(new ConstraintViolation(info, ConstraintViolation.REPEATABLE_REPEATED));\n            }\n        }\n        catch (SerializationException e)\n        {\n            errors.add(new ConstraintViolation(info, ConstraintViolation.INVALID_VALUE));\n        }\n        return errors;\n    }\n\n    /**\n     * Checks all data sets in a given record for constraint violations.\n     *\n     * @param record\n     *            IIM record (1,2,3, ...) to check\n     *\n     * @return list of constraint violations, empty set if IIM file is valid\n     */\n    public Set<ConstraintViolation> validate(int record)\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        for (int ds = 0; ds < 250; ++ds)\n        {\n            try\n            {\n                DataSetInfo dataSetInfo = dsiFactory.create(IIM.DS(record, ds));\n                errors.addAll(validate(dataSetInfo));\n            }\n            catch (InvalidDataSetException ignored)\n            {\n                // DataSetFactory doesn't know about this ds, so will skip it\n            }\n        }\n        return errors;\n    }\n\n    /**\n     * Checks all data sets in IIM records 1, 2 and 3 for constraint violations.\n     *\n     * @return list of constraint violations, empty set if IIM file is valid\n     */\n    public Set<ConstraintViolation> validate()\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        for (int record = 1; record <= 3; ++record)\n        {\n            errors.addAll(validate(record));\n        }\n        return errors;\n    }\n\n    private SerializationContext activeSerializationContext = this;\n    private List<DataSet> dataSets = new ArrayList<DataSet>();\n    private DataSetInfoFactory dsiFactory;\n    private LoggerAdapter log;\n    private boolean recoverFromIIMFormat = true;\n    private boolean recoverFromInvalidDataSet = true;\n    private boolean recoverFromUnsupportedDataSet = true;\n    private SerializationContext serializationContext;\n    private boolean stopAfter9_10 = true;\n}"}
{"repo": "vnesek/nmote-iim4j", "path": "src/main/java/com/nmote/iim4j/IIMFile.java", "func_name": "IIMFile.get", "original_string": "public Object get(int dataSet) throws SerializationException {\r\n\t\tObject result = null;\r\n\t\tfor (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();) {\r\n\t\t\tDataSet ds = i.next();\r\n\t\t\tDataSetInfo info = ds.getInfo();\r\n\t\t\tif (info.getDataSetNumber() == dataSet) {\r\n\t\t\t\tresult = getData(ds);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}", "language": "java", "code": "public Object get(int dataSet) throws SerializationException {\r\n\t\tObject result = null;\r\n\t\tfor (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();) {\r\n\t\t\tDataSet ds = i.next();\r\n\t\t\tDataSetInfo info = ds.getInfo();\r\n\t\t\tif (info.getDataSetNumber() == dataSet) {\r\n\t\t\t\tresult = getData(ds);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}", "code_tokens": ["public", "Object", "get", "(", "int", "dataSet", ")", "throws", "SerializationException", "{", "Object", "result", "=", "null", ";", "for", "(", "Iterator", "<", "DataSet", ">", "i", "=", "dataSets", ".", "iterator", "(", ")", ";", "i", ".", "hasNext", "(", ")", ";", ")", "{", "DataSet", "ds", "=", "i", ".", "next", "(", ")", ";", "DataSetInfo", "info", "=", "ds", ".", "getInfo", "(", ")", ";", "if", "(", "info", ".", "getDataSetNumber", "(", ")", "==", "dataSet", ")", "{", "result", "=", "getData", "(", "ds", ")", ";", "break", ";", "}", "}", "return", "result", ";", "}"], "docstring": "Gets a first data set value.\n\n@param dataSet\nIIM record and dataset code (See constants in {@link IIM})\n@return data set value\n@throws SerializationException\nif value can't be deserialized from binary representation", "docstring_tokens": ["Gets", "a", "first", "data", "set", "value", "."], "sha": "ec55b02fc644cd722e93051ac0bdb96b00cb42a8", "url": "https://github.com/vnesek/nmote-iim4j/blob/ec55b02fc644cd722e93051ac0bdb96b00cb42a8/src/main/java/com/nmote/iim4j/IIMFile.java#L148-L159", "partition": "train", "up_fun_num": 7, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import java.io.IOException;", "import java.io.Serializable;", "import java.text.ParseException;", "import java.text.SimpleDateFormat;", "import java.util.ArrayList;", "import java.util.Date;", "import java.util.Iterator;", "import java.util.LinkedHashSet;", "import java.util.List;", "import java.util.Set;", "import com.nmote.iim4j.dataset.ConstraintViolation;", "import com.nmote.iim4j.dataset.DataSet;", "import com.nmote.iim4j.dataset.DataSetInfo;", "import com.nmote.iim4j.dataset.DataSetInfoFactory;", "import com.nmote.iim4j.dataset.DefaultDataSet;", "import com.nmote.iim4j.dataset.InvalidDataSetException;", "import com.nmote.iim4j.dataset.UnsupportedDataSetException;", "import com.nmote.iim4j.serialize.DefaultSerializationContext;", "import com.nmote.iim4j.serialize.SerializationContext;", "import com.nmote.iim4j.serialize.SerializationException;", "import com.nmote.iim4j.serialize.Serializer;"], "function": ["public class IIMFile extends DefaultSerializationContext implements Serializable, Cloneable\n", "    public void add(DataSet dataSet)\n", "    public void add(int ds, Object value) throws SerializationException, InvalidDataSetException\n", "    public void addDateTimeHelper(int ds, Date date) throws SerializationException, InvalidDataSetException\n", "    public void addDateTimeHelper(int dsDate, int dsTime, Date date) throws SerializationException,\n", "    public IIMFile clone()\n", "    public List<Object> getAll(int dataSet) throws SerializationException\n", "    public List<DataSet> getDataSets()\n", "    public Date getDateTimeHelper(int dateDataSet, int timeDataSet) throws SerializationException\n", "    public SerializationContext getSerializationContext()\n", "    public boolean isRecoverFromIIMFormat()\n", "    public boolean isRecoverFromInvalidDataSet()\n", "    public boolean isRecoverFromUnsupportedDataSet()\n", "    public boolean isStopAfter9_10()\n", "    public void readFrom(IIMReader reader) throws IOException, InvalidDataSetException\n", "    public void readFrom(IIMReader reader, int recover) throws IOException, InvalidDataSetException\n", "    public boolean remove(int dataSet)\n", "    public boolean removeRecord(int record)\n", "    public void setDataSets(List<DataSet> dataSets)\n", "    public void setLog(LoggerAdapter log)\n", "    public void setRecoverFromIIMFormat(boolean recoverFromIIMFormat)\n", "    public void setRecoverFromInvalidDataSet(boolean recoverFromInvalidDataSet)\n", "    public void setRecoverFromUnsupportedDataSet(boolean recoverFromUnsupportedDataSet)\n", "    public void setSerializationContext(SerializationContext serializationContext)\n", "    public void setStopAfter9_10(boolean stopAfter9_10)\n", "    public String toString()\n", "    public void writeTo(IIMWriter writer) throws IOException\n", "    private Object getData(DataSet ds) throws SerializationException\n", "    public Set<ConstraintViolation> validate(DataSetInfo info)\n", "    public Set<ConstraintViolation> validate(int record)\n", "    public Set<ConstraintViolation> validate()\n"], "context": "/*\n * Copyright (c) Nmote Ltd. 2004-2015. All rights reserved.\n * See LICENSE doc in a root of project folder for additional information.\n */\n\npackage com.nmote.iim4j;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport com.nmote.iim4j.dataset.ConstraintViolation;\nimport com.nmote.iim4j.dataset.DataSet;\nimport com.nmote.iim4j.dataset.DataSetInfo;\nimport com.nmote.iim4j.dataset.DataSetInfoFactory;\nimport com.nmote.iim4j.dataset.DefaultDataSet;\nimport com.nmote.iim4j.dataset.InvalidDataSetException;\nimport com.nmote.iim4j.dataset.UnsupportedDataSetException;\nimport com.nmote.iim4j.serialize.DefaultSerializationContext;\nimport com.nmote.iim4j.serialize.SerializationContext;\nimport com.nmote.iim4j.serialize.SerializationException;\nimport com.nmote.iim4j.serialize.Serializer;\n\n/**\n * IIMFile holds a set of data set records, and supports reading and writing to\n * files/streams.\n */\npublic class IIMFile extends DefaultSerializationContext implements Serializable, Cloneable\n{\n\n    private static final long serialVersionUID = About.SERIAL_VERSION_UID;\n\n    /**\n     * Creates a new IIMFile using default (IIM version 4) data set info\n     * factory.\n     */\n    public IIMFile()\n    {\n        this(IIMDataSetInfoFactory.VERSION_4);\n    }\n\n    /**\n     * Creates a new IIMFile using passed data set info factory.\n     *\n     * @param dsiFactory\n     *            data set info factory\n     */\n    public IIMFile(DataSetInfoFactory dsiFactory)\n    {\n        this.dsiFactory = dsiFactory;\n    }\n\n    /**\n     * Adds a data set to IIM file.\n     *\n     * @param dataSet\n     *            to add\n     */\n    public void add(DataSet dataSet)\n    {\n        dataSets.add(dataSet);\n    }\n\n    /**\n     * Adds a data set to IIM file.\n     *\n     * @param ds\n     *            data set id (see constants in IIM class)\n     * @param value\n     *            data set value. Null values are silently ignored.\n     * @throws SerializationException\n     *             if value can't be serialized by data set's serializer\n     * @throws InvalidDataSetException\n     *             if data set isn't defined\n     */\n    public void add(int ds, Object value) throws SerializationException, InvalidDataSetException\n    {\n        if (value == null)\n        {\n            return;\n        }\n\n        DataSetInfo dsi = dsiFactory.create(ds);\n        byte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\n        DataSet dataSet = new DefaultDataSet(dsi, data);\n        dataSets.add(dataSet);\n    }\n\n    /**\n     * Adds a data set with date-time value to IIM file.\n     *\n     * @param ds\n     *            data set id (see constants in IIM class)\n     * @param date\n     *            date to set. Null values are silently ignored.\n     * @throws SerializationException\n     *             if value can't be serialized by data set's serializer\n     * @throws InvalidDataSetException\n     *             if data set isn't defined\n     */\n    public void addDateTimeHelper(int ds, Date date) throws SerializationException, InvalidDataSetException\n    {\n        if (date == null)\n        {\n            return;\n        }\n\n        DataSetInfo dsi = dsiFactory.create(ds);\n\n        SimpleDateFormat df = new SimpleDateFormat(dsi.getSerializer().toString());\n        String value = df.format(date);\n        byte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\n        DataSet dataSet = new DefaultDataSet(dsi, data);\n        add(dataSet);\n    }\n\n    public void addDateTimeHelper(int dsDate, int dsTime, Date date) throws SerializationException,\n               InvalidDataSetException\n    {\n        if (date == null)\n            return;\n\n        addDateTimeHelper(dsDate, date);\n        addDateTimeHelper(dsTime, date);\n    }\n\n    /**\n     * Makes a copy of this instance.\n     *\n     * @see java.lang.Object#clone()\n     * @return IIMFile copy\n     */\n    public IIMFile clone()\n    {\n        IIMFile file = new IIMFile(dsiFactory);\n        file.dataSets = new ArrayList<DataSet>(dataSets);\n        file.serializationContext = serializationContext == this ? file : serializationContext;\n        file.activeSerializationContext = activeSerializationContext == this ? file : activeSerializationContext;\n        return file;\n    }\n\n    /**\n     * Gets a first data set value.\n     *\n     * @param dataSet\n     *            IIM record and dataset code (See constants in {@link IIM})\n     * @return data set value\n     * @throws SerializationException\n     *             if value can't be deserialized from binary representation\n     */\n\n    /**\n     * Gets all data set values.\n     *\n     * @param dataSet\n     *            IIM record and dataset code (See constants in {@link IIM})\n     * @return data set value\n     * @throws SerializationException\n     *             if value can't be deserialized from binary representation\n     */\n    public List<Object> getAll(int dataSet) throws SerializationException\n    {\n        List<Object> result = new ArrayList<Object>();\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                result.add(getData(ds));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets all data sets in IIM file.\n     *\n     * @return Returns the dataSets\n     */\n    public List<DataSet> getDataSets()\n    {\n        return this.dataSets;\n    }\n\n    /**\n     * Gets combined date/time value from two data sets.\n     *\n     * @param dateDataSet\n     *            data set containing date value\n     * @param timeDataSet\n     *            data set containing time value\n     * @return date/time instance\n     * @throws SerializationException\n     *             if data sets can't be deserialized from binary format or\n     *             can't be parsed\n     */\n    public Date getDateTimeHelper(int dateDataSet, int timeDataSet) throws SerializationException\n    {\n        DataSet dateDS = null;\n        DataSet timeDS = null;\n        for (Iterator<DataSet> i = dataSets.iterator(); (dateDS == null || timeDS == null) && i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dateDataSet)\n            {\n                dateDS = ds;\n            }\n            else if (info.getDataSetNumber() == timeDataSet)\n            {\n                timeDS = ds;\n            }\n        }\n\n        Date result = null;\n        if (dateDS != null && timeDS != null)\n        {\n            DataSetInfo dateDSI = dateDS.getInfo();\n            DataSetInfo timeDSI = timeDS.getInfo();\n            SimpleDateFormat format = new SimpleDateFormat(dateDSI.getSerializer().toString()\n                    + timeDSI.getSerializer().toString());\n            StringBuffer date = new StringBuffer(20);\n            try\n            {\n                date.append(getData(dateDS));\n                date.append(getData(timeDS));\n                result = format.parse(date.toString());\n            }\n            catch (ParseException e)\n            {\n                throw new SerializationException(\"Failed to read date (\" + e.getMessage() + \") with format \" + date);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Gets serialization context for this IIM file instance.\n     *\n     * @return Returns the serializationContext\n     */\n    public SerializationContext getSerializationContext()\n    {\n        return this.serializationContext;\n    }\n\n    public boolean isRecoverFromIIMFormat()\n    {\n        return recoverFromIIMFormat;\n    }\n\n    public boolean isRecoverFromInvalidDataSet()\n    {\n        return recoverFromInvalidDataSet;\n    }\n\n    public boolean isRecoverFromUnsupportedDataSet()\n    {\n        return recoverFromUnsupportedDataSet;\n    }\n\n    public boolean isStopAfter9_10()\n    {\n        return stopAfter9_10;\n    }\n\n    /**\n     * Reads data sets from a passed reader and attempt to recover from as much\n     * errors as possible.\n     *\n     * @param reader\n     *            data sets source\n     * @throws IOException\n     *             if reader can't read underlying stream\n     * @throws InvalidDataSetException\n     *             if invalid/undefined data set is encountered\n     */\n    public void readFrom(IIMReader reader) throws IOException, InvalidDataSetException\n    {\n        readFrom(reader, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Reads data sets from a passed reader.\n     *\n     * @param reader\n     *            data sets source\n     * @param recover\n     *            max number of errors reading process will try to recover from.\n     *            Set to 0 to fail immediately\n     * @throws IOException\n     *             if reader can't read underlying stream\n     * @throws InvalidDataSetException\n     *             if invalid/undefined data set is encountered\n     */\n    public void readFrom(IIMReader reader, int recover) throws IOException, InvalidDataSetException\n    {\n        final boolean doLog = log != null;\n        for (;;)\n        {\n            try\n            {\n                DataSet ds = reader.read();\n                if (ds == null)\n                {\n                    break;\n                }\n\n                if (doLog)\n                {\n                    log.debug(\"Read data set \" + ds);\n                }\n\n                DataSetInfo info = ds.getInfo();\n                Serializer s = info.getSerializer();\n                if (s != null)\n                {\n                    if (info.getDataSetNumber() == IIM.DS(1, 90))\n                    {\n                        setCharacterSet((String) s.deserialize(ds.getData(), activeSerializationContext));\n                    }\n                }\n\n                dataSets.add(ds);\n\n                if (stopAfter9_10 && info.getDataSetNumber() == IIM.DS(9, 10))\n                    break;\n            }\n            catch (IIMFormatException e)\n            {\n                if (recoverFromIIMFormat && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (UnsupportedDataSetException e)\n            {\n                if (recoverFromUnsupportedDataSet && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (InvalidDataSetException e)\n            {\n                if (recoverFromInvalidDataSet && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (IOException e)\n            {\n                if (recover-- > 0 && !dataSets.isEmpty())\n                {\n                    if (doLog)\n                    {\n                        log.error(\"IOException while reading, however some data sets where recovered, \" + e);\n                    }\n                    return;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n        }\n    }\n\n    public boolean remove(int dataSet)\n    {\n        boolean result = false;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                i.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    public boolean removeRecord(int record)\n    {\n        boolean result = false;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if ((info.getDataSetNumber() >> 8) == record)\n            {\n                i.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @param dataSets\n     *            The dataSets to set.\n     */\n    public void setDataSets(List<DataSet> dataSets)\n    {\n        this.dataSets = dataSets;\n    }\n\n    /**\n     * Sets logger for this IIMFile.\n     *\n     * @param log\n     *            logger to use with this file.\n     */\n    public void setLog(LoggerAdapter log)\n    {\n        this.log = log;\n    }\n\n    /**\n     * Should we recover from the IIM format violations, default is true.\n     *\n     * @param recoverFromIIMFormat\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromIIMFormat(boolean recoverFromIIMFormat)\n    {\n        this.recoverFromIIMFormat = recoverFromIIMFormat;\n    }\n\n    /**\n     * Should we recover from the invalid data sets, default is true.\n     *\n     * @param recoverFromInvalidDataSet\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromInvalidDataSet(boolean recoverFromInvalidDataSet)\n    {\n        this.recoverFromInvalidDataSet = recoverFromInvalidDataSet;\n    }\n\n    /**\n     * Should we recover from the unsupported data sets, default is true.\n     *\n     * @param recoverFromUnsupportedDataSet\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromUnsupportedDataSet(boolean recoverFromUnsupportedDataSet)\n    {\n        this.recoverFromUnsupportedDataSet = recoverFromUnsupportedDataSet;\n    }\n\n    /**\n     * @param serializationContext\n     *            The serializationContext to set\n     */\n    public void setSerializationContext(SerializationContext serializationContext)\n    {\n        this.serializationContext = serializationContext;\n        activeSerializationContext = serializationContext != null ? serializationContext : this;\n    }\n\n    /**\n     * Controls if reading should stop after data set record 9,10. Default true.\n     *\n     * @param stopAfter9_10\n     *            true to stop reading, false to stop\n     */\n    public void setStopAfter9_10(boolean stopAfter9_10)\n    {\n        this.stopAfter9_10 = stopAfter9_10;\n    }\n\n    public String toString()\n    {\n        StringBuilder b = new StringBuilder();\n        b.append(\"IIMFile(\");\n        b.append(\"dataSets=\");\n        b.append(dataSets);\n        b.append(')');\n        return b.toString();\n    }\n\n    /**\n     * Writes this IIMFile to writer.\n     *\n     * @param writer\n     *            writer to write to\n     * @throws IOException\n     *             if file can't be written to\n     */\n    public void writeTo(IIMWriter writer) throws IOException\n    {\n        final boolean doLog = log != null;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            writer.write(ds);\n            if (doLog)\n            {\n                log.debug(\"Wrote data set \" + ds);\n            }\n        }\n    }\n\n    private Object getData(DataSet ds) throws SerializationException\n    {\n        DataSetInfo info = ds.getInfo();\n        Serializer s = info.getSerializer();\n        Object result;\n        if (s != null)\n        {\n            result = s.deserialize(ds.getData(), activeSerializationContext);\n        }\n        else\n        {\n            result = ds.getData();\n        }\n        return result;\n    }\n\n    /**\n     * Checks if data set is mandatory but missing or non repeatable but having\n     * multiple values in this IIM instance.\n     *\n     * @param info\n     *            IIM data set to check\n     * @return list of constraint violations, empty set if data set is valid\n     */\n    public Set<ConstraintViolation> validate(DataSetInfo info)\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        try\n        {\n            if (info.isMandatory() && get(info.getDataSetNumber()) == null)\n            {\n                errors.add(new ConstraintViolation(info, ConstraintViolation.MANDATORY_MISSING));\n            }\n            if (!info.isRepeatable() && getAll(info.getDataSetNumber()).size() > 1)\n            {\n                errors.add(new ConstraintViolation(info, ConstraintViolation.REPEATABLE_REPEATED));\n            }\n        }\n        catch (SerializationException e)\n        {\n            errors.add(new ConstraintViolation(info, ConstraintViolation.INVALID_VALUE));\n        }\n        return errors;\n    }\n\n    /**\n     * Checks all data sets in a given record for constraint violations.\n     *\n     * @param record\n     *            IIM record (1,2,3, ...) to check\n     *\n     * @return list of constraint violations, empty set if IIM file is valid\n     */\n    public Set<ConstraintViolation> validate(int record)\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        for (int ds = 0; ds < 250; ++ds)\n        {\n            try\n            {\n                DataSetInfo dataSetInfo = dsiFactory.create(IIM.DS(record, ds));\n                errors.addAll(validate(dataSetInfo));\n            }\n            catch (InvalidDataSetException ignored)\n            {\n                // DataSetFactory doesn't know about this ds, so will skip it\n            }\n        }\n        return errors;\n    }\n\n    /**\n     * Checks all data sets in IIM records 1, 2 and 3 for constraint violations.\n     *\n     * @return list of constraint violations, empty set if IIM file is valid\n     */\n    public Set<ConstraintViolation> validate()\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        for (int record = 1; record <= 3; ++record)\n        {\n            errors.addAll(validate(record));\n        }\n        return errors;\n    }\n\n    private SerializationContext activeSerializationContext = this;\n    private List<DataSet> dataSets = new ArrayList<DataSet>();\n    private DataSetInfoFactory dsiFactory;\n    private LoggerAdapter log;\n    private boolean recoverFromIIMFormat = true;\n    private boolean recoverFromInvalidDataSet = true;\n    private boolean recoverFromUnsupportedDataSet = true;\n    private SerializationContext serializationContext;\n    private boolean stopAfter9_10 = true;\n}"}
{"repo": "vnesek/nmote-iim4j", "path": "src/main/java/com/nmote/iim4j/IIMFile.java", "func_name": "IIMFile.getAll", "original_string": "public List<Object> getAll(int dataSet) throws SerializationException {\r\n\t\tList<Object> result = new ArrayList<Object>();\r\n\t\tfor (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();) {\r\n\t\t\tDataSet ds = i.next();\r\n\t\t\tDataSetInfo info = ds.getInfo();\r\n\t\t\tif (info.getDataSetNumber() == dataSet) {\r\n\t\t\t\tresult.add(getData(ds));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}", "language": "java", "code": "public List<Object> getAll(int dataSet) throws SerializationException {\r\n\t\tList<Object> result = new ArrayList<Object>();\r\n\t\tfor (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();) {\r\n\t\t\tDataSet ds = i.next();\r\n\t\t\tDataSetInfo info = ds.getInfo();\r\n\t\t\tif (info.getDataSetNumber() == dataSet) {\r\n\t\t\t\tresult.add(getData(ds));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}", "code_tokens": ["public", "List", "<", "Object", ">", "getAll", "(", "int", "dataSet", ")", "throws", "SerializationException", "{", "List", "<", "Object", ">", "result", "=", "new", "ArrayList", "<", "Object", ">", "(", ")", ";", "for", "(", "Iterator", "<", "DataSet", ">", "i", "=", "dataSets", ".", "iterator", "(", ")", ";", "i", ".", "hasNext", "(", ")", ";", ")", "{", "DataSet", "ds", "=", "i", ".", "next", "(", ")", ";", "DataSetInfo", "info", "=", "ds", ".", "getInfo", "(", ")", ";", "if", "(", "info", ".", "getDataSetNumber", "(", ")", "==", "dataSet", ")", "{", "result", ".", "add", "(", "getData", "(", "ds", ")", ")", ";", "}", "}", "return", "result", ";", "}"], "docstring": "Gets all data set values.\n\n@param dataSet\nIIM record and dataset code (See constants in {@link IIM})\n@return data set value\n@throws SerializationException\nif value can't be deserialized from binary representation", "docstring_tokens": ["Gets", "all", "data", "set", "values", "."], "sha": "ec55b02fc644cd722e93051ac0bdb96b00cb42a8", "url": "https://github.com/vnesek/nmote-iim4j/blob/ec55b02fc644cd722e93051ac0bdb96b00cb42a8/src/main/java/com/nmote/iim4j/IIMFile.java#L170-L180", "partition": "train", "up_fun_num": 8, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import java.io.IOException;", "import java.io.Serializable;", "import java.text.ParseException;", "import java.text.SimpleDateFormat;", "import java.util.ArrayList;", "import java.util.Date;", "import java.util.Iterator;", "import java.util.LinkedHashSet;", "import java.util.List;", "import java.util.Set;", "import com.nmote.iim4j.dataset.ConstraintViolation;", "import com.nmote.iim4j.dataset.DataSet;", "import com.nmote.iim4j.dataset.DataSetInfo;", "import com.nmote.iim4j.dataset.DataSetInfoFactory;", "import com.nmote.iim4j.dataset.DefaultDataSet;", "import com.nmote.iim4j.dataset.InvalidDataSetException;", "import com.nmote.iim4j.dataset.UnsupportedDataSetException;", "import com.nmote.iim4j.serialize.DefaultSerializationContext;", "import com.nmote.iim4j.serialize.SerializationContext;", "import com.nmote.iim4j.serialize.SerializationException;", "import com.nmote.iim4j.serialize.Serializer;"], "function": ["public class IIMFile extends DefaultSerializationContext implements Serializable, Cloneable\n", "    public void add(DataSet dataSet)\n", "    public void add(int ds, Object value) throws SerializationException, InvalidDataSetException\n", "    public void addDateTimeHelper(int ds, Date date) throws SerializationException, InvalidDataSetException\n", "    public void addDateTimeHelper(int dsDate, int dsTime, Date date) throws SerializationException,\n", "    public IIMFile clone()\n", "    public Object get(int dataSet) throws SerializationException\n", "    public List<DataSet> getDataSets()\n", "    public Date getDateTimeHelper(int dateDataSet, int timeDataSet) throws SerializationException\n", "    public SerializationContext getSerializationContext()\n", "    public boolean isRecoverFromIIMFormat()\n", "    public boolean isRecoverFromInvalidDataSet()\n", "    public boolean isRecoverFromUnsupportedDataSet()\n", "    public boolean isStopAfter9_10()\n", "    public void readFrom(IIMReader reader) throws IOException, InvalidDataSetException\n", "    public void readFrom(IIMReader reader, int recover) throws IOException, InvalidDataSetException\n", "    public boolean remove(int dataSet)\n", "    public boolean removeRecord(int record)\n", "    public void setDataSets(List<DataSet> dataSets)\n", "    public void setLog(LoggerAdapter log)\n", "    public void setRecoverFromIIMFormat(boolean recoverFromIIMFormat)\n", "    public void setRecoverFromInvalidDataSet(boolean recoverFromInvalidDataSet)\n", "    public void setRecoverFromUnsupportedDataSet(boolean recoverFromUnsupportedDataSet)\n", "    public void setSerializationContext(SerializationContext serializationContext)\n", "    public void setStopAfter9_10(boolean stopAfter9_10)\n", "    public String toString()\n", "    public void writeTo(IIMWriter writer) throws IOException\n", "    private Object getData(DataSet ds) throws SerializationException\n", "    public Set<ConstraintViolation> validate(DataSetInfo info)\n", "    public Set<ConstraintViolation> validate(int record)\n", "    public Set<ConstraintViolation> validate()\n"], "context": "/*\n * Copyright (c) Nmote Ltd. 2004-2015. All rights reserved.\n * See LICENSE doc in a root of project folder for additional information.\n */\n\npackage com.nmote.iim4j;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport com.nmote.iim4j.dataset.ConstraintViolation;\nimport com.nmote.iim4j.dataset.DataSet;\nimport com.nmote.iim4j.dataset.DataSetInfo;\nimport com.nmote.iim4j.dataset.DataSetInfoFactory;\nimport com.nmote.iim4j.dataset.DefaultDataSet;\nimport com.nmote.iim4j.dataset.InvalidDataSetException;\nimport com.nmote.iim4j.dataset.UnsupportedDataSetException;\nimport com.nmote.iim4j.serialize.DefaultSerializationContext;\nimport com.nmote.iim4j.serialize.SerializationContext;\nimport com.nmote.iim4j.serialize.SerializationException;\nimport com.nmote.iim4j.serialize.Serializer;\n\n/**\n * IIMFile holds a set of data set records, and supports reading and writing to\n * files/streams.\n */\npublic class IIMFile extends DefaultSerializationContext implements Serializable, Cloneable\n{\n\n    private static final long serialVersionUID = About.SERIAL_VERSION_UID;\n\n    /**\n     * Creates a new IIMFile using default (IIM version 4) data set info\n     * factory.\n     */\n    public IIMFile()\n    {\n        this(IIMDataSetInfoFactory.VERSION_4);\n    }\n\n    /**\n     * Creates a new IIMFile using passed data set info factory.\n     *\n     * @param dsiFactory\n     *            data set info factory\n     */\n    public IIMFile(DataSetInfoFactory dsiFactory)\n    {\n        this.dsiFactory = dsiFactory;\n    }\n\n    /**\n     * Adds a data set to IIM file.\n     *\n     * @param dataSet\n     *            to add\n     */\n    public void add(DataSet dataSet)\n    {\n        dataSets.add(dataSet);\n    }\n\n    /**\n     * Adds a data set to IIM file.\n     *\n     * @param ds\n     *            data set id (see constants in IIM class)\n     * @param value\n     *            data set value. Null values are silently ignored.\n     * @throws SerializationException\n     *             if value can't be serialized by data set's serializer\n     * @throws InvalidDataSetException\n     *             if data set isn't defined\n     */\n    public void add(int ds, Object value) throws SerializationException, InvalidDataSetException\n    {\n        if (value == null)\n        {\n            return;\n        }\n\n        DataSetInfo dsi = dsiFactory.create(ds);\n        byte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\n        DataSet dataSet = new DefaultDataSet(dsi, data);\n        dataSets.add(dataSet);\n    }\n\n    /**\n     * Adds a data set with date-time value to IIM file.\n     *\n     * @param ds\n     *            data set id (see constants in IIM class)\n     * @param date\n     *            date to set. Null values are silently ignored.\n     * @throws SerializationException\n     *             if value can't be serialized by data set's serializer\n     * @throws InvalidDataSetException\n     *             if data set isn't defined\n     */\n    public void addDateTimeHelper(int ds, Date date) throws SerializationException, InvalidDataSetException\n    {\n        if (date == null)\n        {\n            return;\n        }\n\n        DataSetInfo dsi = dsiFactory.create(ds);\n\n        SimpleDateFormat df = new SimpleDateFormat(dsi.getSerializer().toString());\n        String value = df.format(date);\n        byte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\n        DataSet dataSet = new DefaultDataSet(dsi, data);\n        add(dataSet);\n    }\n\n    public void addDateTimeHelper(int dsDate, int dsTime, Date date) throws SerializationException,\n               InvalidDataSetException\n    {\n        if (date == null)\n            return;\n\n        addDateTimeHelper(dsDate, date);\n        addDateTimeHelper(dsTime, date);\n    }\n\n    /**\n     * Makes a copy of this instance.\n     *\n     * @see java.lang.Object#clone()\n     * @return IIMFile copy\n     */\n    public IIMFile clone()\n    {\n        IIMFile file = new IIMFile(dsiFactory);\n        file.dataSets = new ArrayList<DataSet>(dataSets);\n        file.serializationContext = serializationContext == this ? file : serializationContext;\n        file.activeSerializationContext = activeSerializationContext == this ? file : activeSerializationContext;\n        return file;\n    }\n\n    /**\n     * Gets a first data set value.\n     *\n     * @param dataSet\n     *            IIM record and dataset code (See constants in {@link IIM})\n     * @return data set value\n     * @throws SerializationException\n     *             if value can't be deserialized from binary representation\n     */\n    public Object get(int dataSet) throws SerializationException\n    {\n        Object result = null;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                result = getData(ds);\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets all data set values.\n     *\n     * @param dataSet\n     *            IIM record and dataset code (See constants in {@link IIM})\n     * @return data set value\n     * @throws SerializationException\n     *             if value can't be deserialized from binary representation\n     */\n\n    /**\n     * Gets all data sets in IIM file.\n     *\n     * @return Returns the dataSets\n     */\n    public List<DataSet> getDataSets()\n    {\n        return this.dataSets;\n    }\n\n    /**\n     * Gets combined date/time value from two data sets.\n     *\n     * @param dateDataSet\n     *            data set containing date value\n     * @param timeDataSet\n     *            data set containing time value\n     * @return date/time instance\n     * @throws SerializationException\n     *             if data sets can't be deserialized from binary format or\n     *             can't be parsed\n     */\n    public Date getDateTimeHelper(int dateDataSet, int timeDataSet) throws SerializationException\n    {\n        DataSet dateDS = null;\n        DataSet timeDS = null;\n        for (Iterator<DataSet> i = dataSets.iterator(); (dateDS == null || timeDS == null) && i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dateDataSet)\n            {\n                dateDS = ds;\n            }\n            else if (info.getDataSetNumber() == timeDataSet)\n            {\n                timeDS = ds;\n            }\n        }\n\n        Date result = null;\n        if (dateDS != null && timeDS != null)\n        {\n            DataSetInfo dateDSI = dateDS.getInfo();\n            DataSetInfo timeDSI = timeDS.getInfo();\n            SimpleDateFormat format = new SimpleDateFormat(dateDSI.getSerializer().toString()\n                    + timeDSI.getSerializer().toString());\n            StringBuffer date = new StringBuffer(20);\n            try\n            {\n                date.append(getData(dateDS));\n                date.append(getData(timeDS));\n                result = format.parse(date.toString());\n            }\n            catch (ParseException e)\n            {\n                throw new SerializationException(\"Failed to read date (\" + e.getMessage() + \") with format \" + date);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Gets serialization context for this IIM file instance.\n     *\n     * @return Returns the serializationContext\n     */\n    public SerializationContext getSerializationContext()\n    {\n        return this.serializationContext;\n    }\n\n    public boolean isRecoverFromIIMFormat()\n    {\n        return recoverFromIIMFormat;\n    }\n\n    public boolean isRecoverFromInvalidDataSet()\n    {\n        return recoverFromInvalidDataSet;\n    }\n\n    public boolean isRecoverFromUnsupportedDataSet()\n    {\n        return recoverFromUnsupportedDataSet;\n    }\n\n    public boolean isStopAfter9_10()\n    {\n        return stopAfter9_10;\n    }\n\n    /**\n     * Reads data sets from a passed reader and attempt to recover from as much\n     * errors as possible.\n     *\n     * @param reader\n     *            data sets source\n     * @throws IOException\n     *             if reader can't read underlying stream\n     * @throws InvalidDataSetException\n     *             if invalid/undefined data set is encountered\n     */\n    public void readFrom(IIMReader reader) throws IOException, InvalidDataSetException\n    {\n        readFrom(reader, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Reads data sets from a passed reader.\n     *\n     * @param reader\n     *            data sets source\n     * @param recover\n     *            max number of errors reading process will try to recover from.\n     *            Set to 0 to fail immediately\n     * @throws IOException\n     *             if reader can't read underlying stream\n     * @throws InvalidDataSetException\n     *             if invalid/undefined data set is encountered\n     */\n    public void readFrom(IIMReader reader, int recover) throws IOException, InvalidDataSetException\n    {\n        final boolean doLog = log != null;\n        for (;;)\n        {\n            try\n            {\n                DataSet ds = reader.read();\n                if (ds == null)\n                {\n                    break;\n                }\n\n                if (doLog)\n                {\n                    log.debug(\"Read data set \" + ds);\n                }\n\n                DataSetInfo info = ds.getInfo();\n                Serializer s = info.getSerializer();\n                if (s != null)\n                {\n                    if (info.getDataSetNumber() == IIM.DS(1, 90))\n                    {\n                        setCharacterSet((String) s.deserialize(ds.getData(), activeSerializationContext));\n                    }\n                }\n\n                dataSets.add(ds);\n\n                if (stopAfter9_10 && info.getDataSetNumber() == IIM.DS(9, 10))\n                    break;\n            }\n            catch (IIMFormatException e)\n            {\n                if (recoverFromIIMFormat && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (UnsupportedDataSetException e)\n            {\n                if (recoverFromUnsupportedDataSet && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (InvalidDataSetException e)\n            {\n                if (recoverFromInvalidDataSet && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (IOException e)\n            {\n                if (recover-- > 0 && !dataSets.isEmpty())\n                {\n                    if (doLog)\n                    {\n                        log.error(\"IOException while reading, however some data sets where recovered, \" + e);\n                    }\n                    return;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n        }\n    }\n\n    public boolean remove(int dataSet)\n    {\n        boolean result = false;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                i.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    public boolean removeRecord(int record)\n    {\n        boolean result = false;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if ((info.getDataSetNumber() >> 8) == record)\n            {\n                i.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @param dataSets\n     *            The dataSets to set.\n     */\n    public void setDataSets(List<DataSet> dataSets)\n    {\n        this.dataSets = dataSets;\n    }\n\n    /**\n     * Sets logger for this IIMFile.\n     *\n     * @param log\n     *            logger to use with this file.\n     */\n    public void setLog(LoggerAdapter log)\n    {\n        this.log = log;\n    }\n\n    /**\n     * Should we recover from the IIM format violations, default is true.\n     *\n     * @param recoverFromIIMFormat\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromIIMFormat(boolean recoverFromIIMFormat)\n    {\n        this.recoverFromIIMFormat = recoverFromIIMFormat;\n    }\n\n    /**\n     * Should we recover from the invalid data sets, default is true.\n     *\n     * @param recoverFromInvalidDataSet\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromInvalidDataSet(boolean recoverFromInvalidDataSet)\n    {\n        this.recoverFromInvalidDataSet = recoverFromInvalidDataSet;\n    }\n\n    /**\n     * Should we recover from the unsupported data sets, default is true.\n     *\n     * @param recoverFromUnsupportedDataSet\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromUnsupportedDataSet(boolean recoverFromUnsupportedDataSet)\n    {\n        this.recoverFromUnsupportedDataSet = recoverFromUnsupportedDataSet;\n    }\n\n    /**\n     * @param serializationContext\n     *            The serializationContext to set\n     */\n    public void setSerializationContext(SerializationContext serializationContext)\n    {\n        this.serializationContext = serializationContext;\n        activeSerializationContext = serializationContext != null ? serializationContext : this;\n    }\n\n    /**\n     * Controls if reading should stop after data set record 9,10. Default true.\n     *\n     * @param stopAfter9_10\n     *            true to stop reading, false to stop\n     */\n    public void setStopAfter9_10(boolean stopAfter9_10)\n    {\n        this.stopAfter9_10 = stopAfter9_10;\n    }\n\n    public String toString()\n    {\n        StringBuilder b = new StringBuilder();\n        b.append(\"IIMFile(\");\n        b.append(\"dataSets=\");\n        b.append(dataSets);\n        b.append(')');\n        return b.toString();\n    }\n\n    /**\n     * Writes this IIMFile to writer.\n     *\n     * @param writer\n     *            writer to write to\n     * @throws IOException\n     *             if file can't be written to\n     */\n    public void writeTo(IIMWriter writer) throws IOException\n    {\n        final boolean doLog = log != null;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            writer.write(ds);\n            if (doLog)\n            {\n                log.debug(\"Wrote data set \" + ds);\n            }\n        }\n    }\n\n    private Object getData(DataSet ds) throws SerializationException\n    {\n        DataSetInfo info = ds.getInfo();\n        Serializer s = info.getSerializer();\n        Object result;\n        if (s != null)\n        {\n            result = s.deserialize(ds.getData(), activeSerializationContext);\n        }\n        else\n        {\n            result = ds.getData();\n        }\n        return result;\n    }\n\n    /**\n     * Checks if data set is mandatory but missing or non repeatable but having\n     * multiple values in this IIM instance.\n     *\n     * @param info\n     *            IIM data set to check\n     * @return list of constraint violations, empty set if data set is valid\n     */\n    public Set<ConstraintViolation> validate(DataSetInfo info)\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        try\n        {\n            if (info.isMandatory() && get(info.getDataSetNumber()) == null)\n            {\n                errors.add(new ConstraintViolation(info, ConstraintViolation.MANDATORY_MISSING));\n            }\n            if (!info.isRepeatable() && getAll(info.getDataSetNumber()).size() > 1)\n            {\n                errors.add(new ConstraintViolation(info, ConstraintViolation.REPEATABLE_REPEATED));\n            }\n        }\n        catch (SerializationException e)\n        {\n            errors.add(new ConstraintViolation(info, ConstraintViolation.INVALID_VALUE));\n        }\n        return errors;\n    }\n\n    /**\n     * Checks all data sets in a given record for constraint violations.\n     *\n     * @param record\n     *            IIM record (1,2,3, ...) to check\n     *\n     * @return list of constraint violations, empty set if IIM file is valid\n     */\n    public Set<ConstraintViolation> validate(int record)\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        for (int ds = 0; ds < 250; ++ds)\n        {\n            try\n            {\n                DataSetInfo dataSetInfo = dsiFactory.create(IIM.DS(record, ds));\n                errors.addAll(validate(dataSetInfo));\n            }\n            catch (InvalidDataSetException ignored)\n            {\n                // DataSetFactory doesn't know about this ds, so will skip it\n            }\n        }\n        return errors;\n    }\n\n    /**\n     * Checks all data sets in IIM records 1, 2 and 3 for constraint violations.\n     *\n     * @return list of constraint violations, empty set if IIM file is valid\n     */\n    public Set<ConstraintViolation> validate()\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        for (int record = 1; record <= 3; ++record)\n        {\n            errors.addAll(validate(record));\n        }\n        return errors;\n    }\n\n    private SerializationContext activeSerializationContext = this;\n    private List<DataSet> dataSets = new ArrayList<DataSet>();\n    private DataSetInfoFactory dsiFactory;\n    private LoggerAdapter log;\n    private boolean recoverFromIIMFormat = true;\n    private boolean recoverFromInvalidDataSet = true;\n    private boolean recoverFromUnsupportedDataSet = true;\n    private SerializationContext serializationContext;\n    private boolean stopAfter9_10 = true;\n}"}
{"repo": "vnesek/nmote-iim4j", "path": "src/main/java/com/nmote/iim4j/IIMFile.java", "func_name": "IIMFile.readFrom", "original_string": "public void readFrom(IIMReader reader, int recover) throws IOException, InvalidDataSetException {\r\n\t\tfinal boolean doLog = log != null;\r\n\t\tfor (;;) {\r\n\t\t\ttry {\r\n\t\t\t\tDataSet ds = reader.read();\r\n\t\t\t\tif (ds == null) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (doLog) {\r\n\t\t\t\t\tlog.debug(\"Read data set \" + ds);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tDataSetInfo info = ds.getInfo();\r\n\t\t\t\tSerializer s = info.getSerializer();\r\n\t\t\t\tif (s != null) {\r\n\t\t\t\t\tif (info.getDataSetNumber() == IIM.DS(1, 90)) {\r\n\t\t\t\t\t\tsetCharacterSet((String) s.deserialize(ds.getData(), activeSerializationContext));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdataSets.add(ds);\r\n\r\n\t\t\t\tif (stopAfter9_10 && info.getDataSetNumber() == IIM.DS(9, 10))\r\n\t\t\t\t\tbreak;\r\n\t\t\t} catch (IIMFormatException e) {\r\n\t\t\t\tif (recoverFromIIMFormat && recover-- > 0) {\r\n\t\t\t\t\tboolean r = reader.recover();\r\n\t\t\t\t\tif (doLog) {\r\n\t\t\t\t\t\tlog.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!r)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t}\r\n\t\t\t} catch (UnsupportedDataSetException e) {\r\n\t\t\t\tif (recoverFromUnsupportedDataSet && recover-- > 0) {\r\n\t\t\t\t\tboolean r = reader.recover();\r\n\t\t\t\t\tif (doLog) {\r\n\t\t\t\t\t\tlog.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!r)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t}\r\n\t\t\t} catch (InvalidDataSetException e) {\r\n\t\t\t\tif (recoverFromInvalidDataSet && recover-- > 0) {\r\n\t\t\t\t\tboolean r = reader.recover();\r\n\t\t\t\t\tif (doLog) {\r\n\t\t\t\t\t\tlog.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!r)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t}\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\tif (recover-- > 0 && !dataSets.isEmpty()) {\r\n\t\t\t\t\tif (doLog) {\r\n\t\t\t\t\t\tlog.error(\"IOException while reading, however some data sets where recovered, \" + e);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}", "language": "java", "code": "public void readFrom(IIMReader reader, int recover) throws IOException, InvalidDataSetException {\r\n\t\tfinal boolean doLog = log != null;\r\n\t\tfor (;;) {\r\n\t\t\ttry {\r\n\t\t\t\tDataSet ds = reader.read();\r\n\t\t\t\tif (ds == null) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (doLog) {\r\n\t\t\t\t\tlog.debug(\"Read data set \" + ds);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tDataSetInfo info = ds.getInfo();\r\n\t\t\t\tSerializer s = info.getSerializer();\r\n\t\t\t\tif (s != null) {\r\n\t\t\t\t\tif (info.getDataSetNumber() == IIM.DS(1, 90)) {\r\n\t\t\t\t\t\tsetCharacterSet((String) s.deserialize(ds.getData(), activeSerializationContext));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdataSets.add(ds);\r\n\r\n\t\t\t\tif (stopAfter9_10 && info.getDataSetNumber() == IIM.DS(9, 10))\r\n\t\t\t\t\tbreak;\r\n\t\t\t} catch (IIMFormatException e) {\r\n\t\t\t\tif (recoverFromIIMFormat && recover-- > 0) {\r\n\t\t\t\t\tboolean r = reader.recover();\r\n\t\t\t\t\tif (doLog) {\r\n\t\t\t\t\t\tlog.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!r)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t}\r\n\t\t\t} catch (UnsupportedDataSetException e) {\r\n\t\t\t\tif (recoverFromUnsupportedDataSet && recover-- > 0) {\r\n\t\t\t\t\tboolean r = reader.recover();\r\n\t\t\t\t\tif (doLog) {\r\n\t\t\t\t\t\tlog.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!r)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t}\r\n\t\t\t} catch (InvalidDataSetException e) {\r\n\t\t\t\tif (recoverFromInvalidDataSet && recover-- > 0) {\r\n\t\t\t\t\tboolean r = reader.recover();\r\n\t\t\t\t\tif (doLog) {\r\n\t\t\t\t\t\tlog.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!r)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t}\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\tif (recover-- > 0 && !dataSets.isEmpty()) {\r\n\t\t\t\t\tif (doLog) {\r\n\t\t\t\t\t\tlog.error(\"IOException while reading, however some data sets where recovered, \" + e);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}", "code_tokens": ["public", "void", "readFrom", "(", "IIMReader", "reader", ",", "int", "recover", ")", "throws", "IOException", ",", "InvalidDataSetException", "{", "final", "boolean", "doLog", "=", "log", "!=", "null", ";", "for", "(", ";", ";", ")", "{", "try", "{", "DataSet", "ds", "=", "reader", ".", "read", "(", ")", ";", "if", "(", "ds", "==", "null", ")", "{", "break", ";", "}", "if", "(", "doLog", ")", "{", "log", ".", "debug", "(", "\"Read data set \"", "+", "ds", ")", ";", "}", "DataSetInfo", "info", "=", "ds", ".", "getInfo", "(", ")", ";", "Serializer", "s", "=", "info", ".", "getSerializer", "(", ")", ";", "if", "(", "s", "!=", "null", ")", "{", "if", "(", "info", ".", "getDataSetNumber", "(", ")", "==", "IIM", ".", "DS", "(", "1", ",", "90", ")", ")", "{", "setCharacterSet", "(", "(", "String", ")", "s", ".", "deserialize", "(", "ds", ".", "getData", "(", ")", ",", "activeSerializationContext", ")", ")", ";", "}", "}", "dataSets", ".", "add", "(", "ds", ")", ";", "if", "(", "stopAfter9_10", "&&", "info", ".", "getDataSetNumber", "(", ")", "==", "IIM", ".", "DS", "(", "9", ",", "10", ")", ")", "break", ";", "}", "catch", "(", "IIMFormatException", "e", ")", "{", "if", "(", "recoverFromIIMFormat", "&&", "recover", "--", ">", "0", ")", "{", "boolean", "r", "=", "reader", ".", "recover", "(", ")", ";", "if", "(", "doLog", ")", "{", "log", ".", "debug", "(", "r", "?", "\"Recoved from \"", "+", "e", ":", "\"Failed to recover from \"", "+", "e", ")", ";", "}", "if", "(", "!", "r", ")", "break", ";", "}", "else", "{", "throw", "e", ";", "}", "}", "catch", "(", "UnsupportedDataSetException", "e", ")", "{", "if", "(", "recoverFromUnsupportedDataSet", "&&", "recover", "--", ">", "0", ")", "{", "boolean", "r", "=", "reader", ".", "recover", "(", ")", ";", "if", "(", "doLog", ")", "{", "log", ".", "debug", "(", "r", "?", "\"Recoved from \"", "+", "e", ":", "\"Failed to recover from \"", "+", "e", ")", ";", "}", "if", "(", "!", "r", ")", "break", ";", "}", "else", "{", "throw", "e", ";", "}", "}", "catch", "(", "InvalidDataSetException", "e", ")", "{", "if", "(", "recoverFromInvalidDataSet", "&&", "recover", "--", ">", "0", ")", "{", "boolean", "r", "=", "reader", ".", "recover", "(", ")", ";", "if", "(", "doLog", ")", "{", "log", ".", "debug", "(", "r", "?", "\"Recoved from \"", "+", "e", ":", "\"Failed to recover from \"", "+", "e", ")", ";", "}", "if", "(", "!", "r", ")", "break", ";", "}", "else", "{", "throw", "e", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "if", "(", "recover", "--", ">", "0", "&&", "!", "dataSets", ".", "isEmpty", "(", ")", ")", "{", "if", "(", "doLog", ")", "{", "log", ".", "error", "(", "\"IOException while reading, however some data sets where recovered, \"", "+", "e", ")", ";", "}", "return", ";", "}", "else", "{", "throw", "e", ";", "}", "}", "}", "}"], "docstring": "Reads data sets from a passed reader.\n\n@param reader\ndata sets source\n@param recover\nmax number of errors reading process will try to recover from.\nSet to 0 to fail immediately\n@throws IOException\nif reader can't read underlying stream\n@throws InvalidDataSetException\nif invalid/undefined data set is encountered", "docstring_tokens": ["Reads", "data", "sets", "from", "a", "passed", "reader", "."], "sha": "ec55b02fc644cd722e93051ac0bdb96b00cb42a8", "url": "https://github.com/vnesek/nmote-iim4j/blob/ec55b02fc644cd722e93051ac0bdb96b00cb42a8/src/main/java/com/nmote/iim4j/IIMFile.java#L288-L357", "partition": "train", "up_fun_num": 17, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import java.io.IOException;", "import java.io.Serializable;", "import java.text.ParseException;", "import java.text.SimpleDateFormat;", "import java.util.ArrayList;", "import java.util.Date;", "import java.util.Iterator;", "import java.util.LinkedHashSet;", "import java.util.List;", "import java.util.Set;", "import com.nmote.iim4j.dataset.ConstraintViolation;", "import com.nmote.iim4j.dataset.DataSet;", "import com.nmote.iim4j.dataset.DataSetInfo;", "import com.nmote.iim4j.dataset.DataSetInfoFactory;", "import com.nmote.iim4j.dataset.DefaultDataSet;", "import com.nmote.iim4j.dataset.InvalidDataSetException;", "import com.nmote.iim4j.dataset.UnsupportedDataSetException;", "import com.nmote.iim4j.serialize.DefaultSerializationContext;", "import com.nmote.iim4j.serialize.SerializationContext;", "import com.nmote.iim4j.serialize.SerializationException;", "import com.nmote.iim4j.serialize.Serializer;"], "function": ["public class IIMFile extends DefaultSerializationContext implements Serializable, Cloneable\n", "    public void add(DataSet dataSet)\n", "    public void add(int ds, Object value) throws SerializationException, InvalidDataSetException\n", "    public void addDateTimeHelper(int ds, Date date) throws SerializationException, InvalidDataSetException\n", "    public void addDateTimeHelper(int dsDate, int dsTime, Date date) throws SerializationException,\n", "    public IIMFile clone()\n", "    public Object get(int dataSet) throws SerializationException\n", "    public List<Object> getAll(int dataSet) throws SerializationException\n", "    public List<DataSet> getDataSets()\n", "    public Date getDateTimeHelper(int dateDataSet, int timeDataSet) throws SerializationException\n", "    public SerializationContext getSerializationContext()\n", "    public boolean isRecoverFromIIMFormat()\n", "    public boolean isRecoverFromInvalidDataSet()\n", "    public boolean isRecoverFromUnsupportedDataSet()\n", "    public boolean isStopAfter9_10()\n", "    public void readFrom(IIMReader reader) throws IOException, InvalidDataSetException\n", "    public boolean remove(int dataSet)\n", "    public boolean removeRecord(int record)\n", "    public void setDataSets(List<DataSet> dataSets)\n", "    public void setLog(LoggerAdapter log)\n", "    public void setRecoverFromIIMFormat(boolean recoverFromIIMFormat)\n", "    public void setRecoverFromInvalidDataSet(boolean recoverFromInvalidDataSet)\n", "    public void setRecoverFromUnsupportedDataSet(boolean recoverFromUnsupportedDataSet)\n", "    public void setSerializationContext(SerializationContext serializationContext)\n", "    public void setStopAfter9_10(boolean stopAfter9_10)\n", "    public String toString()\n", "    public void writeTo(IIMWriter writer) throws IOException\n", "    private Object getData(DataSet ds) throws SerializationException\n", "    public Set<ConstraintViolation> validate(DataSetInfo info)\n", "    public Set<ConstraintViolation> validate(int record)\n", "    public Set<ConstraintViolation> validate()\n"], "context": "/*\n * Copyright (c) Nmote Ltd. 2004-2015. All rights reserved.\n * See LICENSE doc in a root of project folder for additional information.\n */\n\npackage com.nmote.iim4j;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport com.nmote.iim4j.dataset.ConstraintViolation;\nimport com.nmote.iim4j.dataset.DataSet;\nimport com.nmote.iim4j.dataset.DataSetInfo;\nimport com.nmote.iim4j.dataset.DataSetInfoFactory;\nimport com.nmote.iim4j.dataset.DefaultDataSet;\nimport com.nmote.iim4j.dataset.InvalidDataSetException;\nimport com.nmote.iim4j.dataset.UnsupportedDataSetException;\nimport com.nmote.iim4j.serialize.DefaultSerializationContext;\nimport com.nmote.iim4j.serialize.SerializationContext;\nimport com.nmote.iim4j.serialize.SerializationException;\nimport com.nmote.iim4j.serialize.Serializer;\n\n/**\n * IIMFile holds a set of data set records, and supports reading and writing to\n * files/streams.\n */\npublic class IIMFile extends DefaultSerializationContext implements Serializable, Cloneable\n{\n\n    private static final long serialVersionUID = About.SERIAL_VERSION_UID;\n\n    /**\n     * Creates a new IIMFile using default (IIM version 4) data set info\n     * factory.\n     */\n    public IIMFile()\n    {\n        this(IIMDataSetInfoFactory.VERSION_4);\n    }\n\n    /**\n     * Creates a new IIMFile using passed data set info factory.\n     *\n     * @param dsiFactory\n     *            data set info factory\n     */\n    public IIMFile(DataSetInfoFactory dsiFactory)\n    {\n        this.dsiFactory = dsiFactory;\n    }\n\n    /**\n     * Adds a data set to IIM file.\n     *\n     * @param dataSet\n     *            to add\n     */\n    public void add(DataSet dataSet)\n    {\n        dataSets.add(dataSet);\n    }\n\n    /**\n     * Adds a data set to IIM file.\n     *\n     * @param ds\n     *            data set id (see constants in IIM class)\n     * @param value\n     *            data set value. Null values are silently ignored.\n     * @throws SerializationException\n     *             if value can't be serialized by data set's serializer\n     * @throws InvalidDataSetException\n     *             if data set isn't defined\n     */\n    public void add(int ds, Object value) throws SerializationException, InvalidDataSetException\n    {\n        if (value == null)\n        {\n            return;\n        }\n\n        DataSetInfo dsi = dsiFactory.create(ds);\n        byte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\n        DataSet dataSet = new DefaultDataSet(dsi, data);\n        dataSets.add(dataSet);\n    }\n\n    /**\n     * Adds a data set with date-time value to IIM file.\n     *\n     * @param ds\n     *            data set id (see constants in IIM class)\n     * @param date\n     *            date to set. Null values are silently ignored.\n     * @throws SerializationException\n     *             if value can't be serialized by data set's serializer\n     * @throws InvalidDataSetException\n     *             if data set isn't defined\n     */\n    public void addDateTimeHelper(int ds, Date date) throws SerializationException, InvalidDataSetException\n    {\n        if (date == null)\n        {\n            return;\n        }\n\n        DataSetInfo dsi = dsiFactory.create(ds);\n\n        SimpleDateFormat df = new SimpleDateFormat(dsi.getSerializer().toString());\n        String value = df.format(date);\n        byte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\n        DataSet dataSet = new DefaultDataSet(dsi, data);\n        add(dataSet);\n    }\n\n    public void addDateTimeHelper(int dsDate, int dsTime, Date date) throws SerializationException,\n               InvalidDataSetException\n    {\n        if (date == null)\n            return;\n\n        addDateTimeHelper(dsDate, date);\n        addDateTimeHelper(dsTime, date);\n    }\n\n    /**\n     * Makes a copy of this instance.\n     *\n     * @see java.lang.Object#clone()\n     * @return IIMFile copy\n     */\n    public IIMFile clone()\n    {\n        IIMFile file = new IIMFile(dsiFactory);\n        file.dataSets = new ArrayList<DataSet>(dataSets);\n        file.serializationContext = serializationContext == this ? file : serializationContext;\n        file.activeSerializationContext = activeSerializationContext == this ? file : activeSerializationContext;\n        return file;\n    }\n\n    /**\n     * Gets a first data set value.\n     *\n     * @param dataSet\n     *            IIM record and dataset code (See constants in {@link IIM})\n     * @return data set value\n     * @throws SerializationException\n     *             if value can't be deserialized from binary representation\n     */\n    public Object get(int dataSet) throws SerializationException\n    {\n        Object result = null;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                result = getData(ds);\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets all data set values.\n     *\n     * @param dataSet\n     *            IIM record and dataset code (See constants in {@link IIM})\n     * @return data set value\n     * @throws SerializationException\n     *             if value can't be deserialized from binary representation\n     */\n    public List<Object> getAll(int dataSet) throws SerializationException\n    {\n        List<Object> result = new ArrayList<Object>();\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                result.add(getData(ds));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets all data sets in IIM file.\n     *\n     * @return Returns the dataSets\n     */\n    public List<DataSet> getDataSets()\n    {\n        return this.dataSets;\n    }\n\n    /**\n     * Gets combined date/time value from two data sets.\n     *\n     * @param dateDataSet\n     *            data set containing date value\n     * @param timeDataSet\n     *            data set containing time value\n     * @return date/time instance\n     * @throws SerializationException\n     *             if data sets can't be deserialized from binary format or\n     *             can't be parsed\n     */\n    public Date getDateTimeHelper(int dateDataSet, int timeDataSet) throws SerializationException\n    {\n        DataSet dateDS = null;\n        DataSet timeDS = null;\n        for (Iterator<DataSet> i = dataSets.iterator(); (dateDS == null || timeDS == null) && i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dateDataSet)\n            {\n                dateDS = ds;\n            }\n            else if (info.getDataSetNumber() == timeDataSet)\n            {\n                timeDS = ds;\n            }\n        }\n\n        Date result = null;\n        if (dateDS != null && timeDS != null)\n        {\n            DataSetInfo dateDSI = dateDS.getInfo();\n            DataSetInfo timeDSI = timeDS.getInfo();\n            SimpleDateFormat format = new SimpleDateFormat(dateDSI.getSerializer().toString()\n                    + timeDSI.getSerializer().toString());\n            StringBuffer date = new StringBuffer(20);\n            try\n            {\n                date.append(getData(dateDS));\n                date.append(getData(timeDS));\n                result = format.parse(date.toString());\n            }\n            catch (ParseException e)\n            {\n                throw new SerializationException(\"Failed to read date (\" + e.getMessage() + \") with format \" + date);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Gets serialization context for this IIM file instance.\n     *\n     * @return Returns the serializationContext\n     */\n    public SerializationContext getSerializationContext()\n    {\n        return this.serializationContext;\n    }\n\n    public boolean isRecoverFromIIMFormat()\n    {\n        return recoverFromIIMFormat;\n    }\n\n    public boolean isRecoverFromInvalidDataSet()\n    {\n        return recoverFromInvalidDataSet;\n    }\n\n    public boolean isRecoverFromUnsupportedDataSet()\n    {\n        return recoverFromUnsupportedDataSet;\n    }\n\n    public boolean isStopAfter9_10()\n    {\n        return stopAfter9_10;\n    }\n\n    /**\n     * Reads data sets from a passed reader and attempt to recover from as much\n     * errors as possible.\n     *\n     * @param reader\n     *            data sets source\n     * @throws IOException\n     *             if reader can't read underlying stream\n     * @throws InvalidDataSetException\n     *             if invalid/undefined data set is encountered\n     */\n    public void readFrom(IIMReader reader) throws IOException, InvalidDataSetException\n    {\n        readFrom(reader, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Reads data sets from a passed reader.\n     *\n     * @param reader\n     *            data sets source\n     * @param recover\n     *            max number of errors reading process will try to recover from.\n     *            Set to 0 to fail immediately\n     * @throws IOException\n     *             if reader can't read underlying stream\n     * @throws InvalidDataSetException\n     *             if invalid/undefined data set is encountered\n     */\n\n    public boolean remove(int dataSet)\n    {\n        boolean result = false;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                i.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    public boolean removeRecord(int record)\n    {\n        boolean result = false;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if ((info.getDataSetNumber() >> 8) == record)\n            {\n                i.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @param dataSets\n     *            The dataSets to set.\n     */\n    public void setDataSets(List<DataSet> dataSets)\n    {\n        this.dataSets = dataSets;\n    }\n\n    /**\n     * Sets logger for this IIMFile.\n     *\n     * @param log\n     *            logger to use with this file.\n     */\n    public void setLog(LoggerAdapter log)\n    {\n        this.log = log;\n    }\n\n    /**\n     * Should we recover from the IIM format violations, default is true.\n     *\n     * @param recoverFromIIMFormat\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromIIMFormat(boolean recoverFromIIMFormat)\n    {\n        this.recoverFromIIMFormat = recoverFromIIMFormat;\n    }\n\n    /**\n     * Should we recover from the invalid data sets, default is true.\n     *\n     * @param recoverFromInvalidDataSet\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromInvalidDataSet(boolean recoverFromInvalidDataSet)\n    {\n        this.recoverFromInvalidDataSet = recoverFromInvalidDataSet;\n    }\n\n    /**\n     * Should we recover from the unsupported data sets, default is true.\n     *\n     * @param recoverFromUnsupportedDataSet\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromUnsupportedDataSet(boolean recoverFromUnsupportedDataSet)\n    {\n        this.recoverFromUnsupportedDataSet = recoverFromUnsupportedDataSet;\n    }\n\n    /**\n     * @param serializationContext\n     *            The serializationContext to set\n     */\n    public void setSerializationContext(SerializationContext serializationContext)\n    {\n        this.serializationContext = serializationContext;\n        activeSerializationContext = serializationContext != null ? serializationContext : this;\n    }\n\n    /**\n     * Controls if reading should stop after data set record 9,10. Default true.\n     *\n     * @param stopAfter9_10\n     *            true to stop reading, false to stop\n     */\n    public void setStopAfter9_10(boolean stopAfter9_10)\n    {\n        this.stopAfter9_10 = stopAfter9_10;\n    }\n\n    public String toString()\n    {\n        StringBuilder b = new StringBuilder();\n        b.append(\"IIMFile(\");\n        b.append(\"dataSets=\");\n        b.append(dataSets);\n        b.append(')');\n        return b.toString();\n    }\n\n    /**\n     * Writes this IIMFile to writer.\n     *\n     * @param writer\n     *            writer to write to\n     * @throws IOException\n     *             if file can't be written to\n     */\n    public void writeTo(IIMWriter writer) throws IOException\n    {\n        final boolean doLog = log != null;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            writer.write(ds);\n            if (doLog)\n            {\n                log.debug(\"Wrote data set \" + ds);\n            }\n        }\n    }\n\n    private Object getData(DataSet ds) throws SerializationException\n    {\n        DataSetInfo info = ds.getInfo();\n        Serializer s = info.getSerializer();\n        Object result;\n        if (s != null)\n        {\n            result = s.deserialize(ds.getData(), activeSerializationContext);\n        }\n        else\n        {\n            result = ds.getData();\n        }\n        return result;\n    }\n\n    /**\n     * Checks if data set is mandatory but missing or non repeatable but having\n     * multiple values in this IIM instance.\n     *\n     * @param info\n     *            IIM data set to check\n     * @return list of constraint violations, empty set if data set is valid\n     */\n    public Set<ConstraintViolation> validate(DataSetInfo info)\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        try\n        {\n            if (info.isMandatory() && get(info.getDataSetNumber()) == null)\n            {\n                errors.add(new ConstraintViolation(info, ConstraintViolation.MANDATORY_MISSING));\n            }\n            if (!info.isRepeatable() && getAll(info.getDataSetNumber()).size() > 1)\n            {\n                errors.add(new ConstraintViolation(info, ConstraintViolation.REPEATABLE_REPEATED));\n            }\n        }\n        catch (SerializationException e)\n        {\n            errors.add(new ConstraintViolation(info, ConstraintViolation.INVALID_VALUE));\n        }\n        return errors;\n    }\n\n    /**\n     * Checks all data sets in a given record for constraint violations.\n     *\n     * @param record\n     *            IIM record (1,2,3, ...) to check\n     *\n     * @return list of constraint violations, empty set if IIM file is valid\n     */\n    public Set<ConstraintViolation> validate(int record)\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        for (int ds = 0; ds < 250; ++ds)\n        {\n            try\n            {\n                DataSetInfo dataSetInfo = dsiFactory.create(IIM.DS(record, ds));\n                errors.addAll(validate(dataSetInfo));\n            }\n            catch (InvalidDataSetException ignored)\n            {\n                // DataSetFactory doesn't know about this ds, so will skip it\n            }\n        }\n        return errors;\n    }\n\n    /**\n     * Checks all data sets in IIM records 1, 2 and 3 for constraint violations.\n     *\n     * @return list of constraint violations, empty set if IIM file is valid\n     */\n    public Set<ConstraintViolation> validate()\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        for (int record = 1; record <= 3; ++record)\n        {\n            errors.addAll(validate(record));\n        }\n        return errors;\n    }\n\n    private SerializationContext activeSerializationContext = this;\n    private List<DataSet> dataSets = new ArrayList<DataSet>();\n    private DataSetInfoFactory dsiFactory;\n    private LoggerAdapter log;\n    private boolean recoverFromIIMFormat = true;\n    private boolean recoverFromInvalidDataSet = true;\n    private boolean recoverFromUnsupportedDataSet = true;\n    private SerializationContext serializationContext;\n    private boolean stopAfter9_10 = true;\n}"}
{"repo": "vnesek/nmote-iim4j", "path": "src/main/java/com/nmote/iim4j/IIMFile.java", "func_name": "IIMFile.writeTo", "original_string": "public void writeTo(IIMWriter writer) throws IOException {\r\n\t\tfinal boolean doLog = log != null;\r\n\t\tfor (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();) {\r\n\t\t\tDataSet ds = i.next();\r\n\t\t\twriter.write(ds);\r\n\t\t\tif (doLog) {\r\n\t\t\t\tlog.debug(\"Wrote data set \" + ds);\r\n\t\t\t}\r\n\t\t}\r\n\t}", "language": "java", "code": "public void writeTo(IIMWriter writer) throws IOException {\r\n\t\tfinal boolean doLog = log != null;\r\n\t\tfor (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();) {\r\n\t\t\tDataSet ds = i.next();\r\n\t\t\twriter.write(ds);\r\n\t\t\tif (doLog) {\r\n\t\t\t\tlog.debug(\"Wrote data set \" + ds);\r\n\t\t\t}\r\n\t\t}\r\n\t}", "code_tokens": ["public", "void", "writeTo", "(", "IIMWriter", "writer", ")", "throws", "IOException", "{", "final", "boolean", "doLog", "=", "log", "!=", "null", ";", "for", "(", "Iterator", "<", "DataSet", ">", "i", "=", "dataSets", ".", "iterator", "(", ")", ";", "i", ".", "hasNext", "(", ")", ";", ")", "{", "DataSet", "ds", "=", "i", ".", "next", "(", ")", ";", "writer", ".", "write", "(", "ds", ")", ";", "if", "(", "doLog", ")", "{", "log", ".", "debug", "(", "\"Wrote data set \"", "+", "ds", ")", ";", "}", "}", "}"], "docstring": "Writes this IIMFile to writer.\n\n@param writer\nwriter to write to\n@throws IOException\nif file can't be written to", "docstring_tokens": ["Writes", "this", "IIMFile", "to", "writer", "."], "sha": "ec55b02fc644cd722e93051ac0bdb96b00cb42a8", "url": "https://github.com/vnesek/nmote-iim4j/blob/ec55b02fc644cd722e93051ac0bdb96b00cb42a8/src/main/java/com/nmote/iim4j/IIMFile.java#L469-L478", "partition": "train", "up_fun_num": 28, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import java.io.IOException;", "import java.io.Serializable;", "import java.text.ParseException;", "import java.text.SimpleDateFormat;", "import java.util.ArrayList;", "import java.util.Date;", "import java.util.Iterator;", "import java.util.LinkedHashSet;", "import java.util.List;", "import java.util.Set;", "import com.nmote.iim4j.dataset.ConstraintViolation;", "import com.nmote.iim4j.dataset.DataSet;", "import com.nmote.iim4j.dataset.DataSetInfo;", "import com.nmote.iim4j.dataset.DataSetInfoFactory;", "import com.nmote.iim4j.dataset.DefaultDataSet;", "import com.nmote.iim4j.dataset.InvalidDataSetException;", "import com.nmote.iim4j.dataset.UnsupportedDataSetException;", "import com.nmote.iim4j.serialize.DefaultSerializationContext;", "import com.nmote.iim4j.serialize.SerializationContext;", "import com.nmote.iim4j.serialize.SerializationException;", "import com.nmote.iim4j.serialize.Serializer;"], "function": ["public class IIMFile extends DefaultSerializationContext implements Serializable, Cloneable\n", "    public void add(DataSet dataSet)\n", "    public void add(int ds, Object value) throws SerializationException, InvalidDataSetException\n", "    public void addDateTimeHelper(int ds, Date date) throws SerializationException, InvalidDataSetException\n", "    public void addDateTimeHelper(int dsDate, int dsTime, Date date) throws SerializationException,\n", "    public IIMFile clone()\n", "    public Object get(int dataSet) throws SerializationException\n", "    public List<Object> getAll(int dataSet) throws SerializationException\n", "    public List<DataSet> getDataSets()\n", "    public Date getDateTimeHelper(int dateDataSet, int timeDataSet) throws SerializationException\n", "    public SerializationContext getSerializationContext()\n", "    public boolean isRecoverFromIIMFormat()\n", "    public boolean isRecoverFromInvalidDataSet()\n", "    public boolean isRecoverFromUnsupportedDataSet()\n", "    public boolean isStopAfter9_10()\n", "    public void readFrom(IIMReader reader) throws IOException, InvalidDataSetException\n", "    public void readFrom(IIMReader reader, int recover) throws IOException, InvalidDataSetException\n", "    public boolean remove(int dataSet)\n", "    public boolean removeRecord(int record)\n", "    public void setDataSets(List<DataSet> dataSets)\n", "    public void setLog(LoggerAdapter log)\n", "    public void setRecoverFromIIMFormat(boolean recoverFromIIMFormat)\n", "    public void setRecoverFromInvalidDataSet(boolean recoverFromInvalidDataSet)\n", "    public void setRecoverFromUnsupportedDataSet(boolean recoverFromUnsupportedDataSet)\n", "    public void setSerializationContext(SerializationContext serializationContext)\n", "    public void setStopAfter9_10(boolean stopAfter9_10)\n", "    public String toString()\n", "    private Object getData(DataSet ds) throws SerializationException\n", "    public Set<ConstraintViolation> validate(DataSetInfo info)\n", "    public Set<ConstraintViolation> validate(int record)\n", "    public Set<ConstraintViolation> validate()\n"], "context": "/*\n * Copyright (c) Nmote Ltd. 2004-2015. All rights reserved.\n * See LICENSE doc in a root of project folder for additional information.\n */\n\npackage com.nmote.iim4j;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport com.nmote.iim4j.dataset.ConstraintViolation;\nimport com.nmote.iim4j.dataset.DataSet;\nimport com.nmote.iim4j.dataset.DataSetInfo;\nimport com.nmote.iim4j.dataset.DataSetInfoFactory;\nimport com.nmote.iim4j.dataset.DefaultDataSet;\nimport com.nmote.iim4j.dataset.InvalidDataSetException;\nimport com.nmote.iim4j.dataset.UnsupportedDataSetException;\nimport com.nmote.iim4j.serialize.DefaultSerializationContext;\nimport com.nmote.iim4j.serialize.SerializationContext;\nimport com.nmote.iim4j.serialize.SerializationException;\nimport com.nmote.iim4j.serialize.Serializer;\n\n/**\n * IIMFile holds a set of data set records, and supports reading and writing to\n * files/streams.\n */\npublic class IIMFile extends DefaultSerializationContext implements Serializable, Cloneable\n{\n\n    private static final long serialVersionUID = About.SERIAL_VERSION_UID;\n\n    /**\n     * Creates a new IIMFile using default (IIM version 4) data set info\n     * factory.\n     */\n    public IIMFile()\n    {\n        this(IIMDataSetInfoFactory.VERSION_4);\n    }\n\n    /**\n     * Creates a new IIMFile using passed data set info factory.\n     *\n     * @param dsiFactory\n     *            data set info factory\n     */\n    public IIMFile(DataSetInfoFactory dsiFactory)\n    {\n        this.dsiFactory = dsiFactory;\n    }\n\n    /**\n     * Adds a data set to IIM file.\n     *\n     * @param dataSet\n     *            to add\n     */\n    public void add(DataSet dataSet)\n    {\n        dataSets.add(dataSet);\n    }\n\n    /**\n     * Adds a data set to IIM file.\n     *\n     * @param ds\n     *            data set id (see constants in IIM class)\n     * @param value\n     *            data set value. Null values are silently ignored.\n     * @throws SerializationException\n     *             if value can't be serialized by data set's serializer\n     * @throws InvalidDataSetException\n     *             if data set isn't defined\n     */\n    public void add(int ds, Object value) throws SerializationException, InvalidDataSetException\n    {\n        if (value == null)\n        {\n            return;\n        }\n\n        DataSetInfo dsi = dsiFactory.create(ds);\n        byte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\n        DataSet dataSet = new DefaultDataSet(dsi, data);\n        dataSets.add(dataSet);\n    }\n\n    /**\n     * Adds a data set with date-time value to IIM file.\n     *\n     * @param ds\n     *            data set id (see constants in IIM class)\n     * @param date\n     *            date to set. Null values are silently ignored.\n     * @throws SerializationException\n     *             if value can't be serialized by data set's serializer\n     * @throws InvalidDataSetException\n     *             if data set isn't defined\n     */\n    public void addDateTimeHelper(int ds, Date date) throws SerializationException, InvalidDataSetException\n    {\n        if (date == null)\n        {\n            return;\n        }\n\n        DataSetInfo dsi = dsiFactory.create(ds);\n\n        SimpleDateFormat df = new SimpleDateFormat(dsi.getSerializer().toString());\n        String value = df.format(date);\n        byte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\n        DataSet dataSet = new DefaultDataSet(dsi, data);\n        add(dataSet);\n    }\n\n    public void addDateTimeHelper(int dsDate, int dsTime, Date date) throws SerializationException,\n               InvalidDataSetException\n    {\n        if (date == null)\n            return;\n\n        addDateTimeHelper(dsDate, date);\n        addDateTimeHelper(dsTime, date);\n    }\n\n    /**\n     * Makes a copy of this instance.\n     *\n     * @see java.lang.Object#clone()\n     * @return IIMFile copy\n     */\n    public IIMFile clone()\n    {\n        IIMFile file = new IIMFile(dsiFactory);\n        file.dataSets = new ArrayList<DataSet>(dataSets);\n        file.serializationContext = serializationContext == this ? file : serializationContext;\n        file.activeSerializationContext = activeSerializationContext == this ? file : activeSerializationContext;\n        return file;\n    }\n\n    /**\n     * Gets a first data set value.\n     *\n     * @param dataSet\n     *            IIM record and dataset code (See constants in {@link IIM})\n     * @return data set value\n     * @throws SerializationException\n     *             if value can't be deserialized from binary representation\n     */\n    public Object get(int dataSet) throws SerializationException\n    {\n        Object result = null;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                result = getData(ds);\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets all data set values.\n     *\n     * @param dataSet\n     *            IIM record and dataset code (See constants in {@link IIM})\n     * @return data set value\n     * @throws SerializationException\n     *             if value can't be deserialized from binary representation\n     */\n    public List<Object> getAll(int dataSet) throws SerializationException\n    {\n        List<Object> result = new ArrayList<Object>();\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                result.add(getData(ds));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets all data sets in IIM file.\n     *\n     * @return Returns the dataSets\n     */\n    public List<DataSet> getDataSets()\n    {\n        return this.dataSets;\n    }\n\n    /**\n     * Gets combined date/time value from two data sets.\n     *\n     * @param dateDataSet\n     *            data set containing date value\n     * @param timeDataSet\n     *            data set containing time value\n     * @return date/time instance\n     * @throws SerializationException\n     *             if data sets can't be deserialized from binary format or\n     *             can't be parsed\n     */\n    public Date getDateTimeHelper(int dateDataSet, int timeDataSet) throws SerializationException\n    {\n        DataSet dateDS = null;\n        DataSet timeDS = null;\n        for (Iterator<DataSet> i = dataSets.iterator(); (dateDS == null || timeDS == null) && i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dateDataSet)\n            {\n                dateDS = ds;\n            }\n            else if (info.getDataSetNumber() == timeDataSet)\n            {\n                timeDS = ds;\n            }\n        }\n\n        Date result = null;\n        if (dateDS != null && timeDS != null)\n        {\n            DataSetInfo dateDSI = dateDS.getInfo();\n            DataSetInfo timeDSI = timeDS.getInfo();\n            SimpleDateFormat format = new SimpleDateFormat(dateDSI.getSerializer().toString()\n                    + timeDSI.getSerializer().toString());\n            StringBuffer date = new StringBuffer(20);\n            try\n            {\n                date.append(getData(dateDS));\n                date.append(getData(timeDS));\n                result = format.parse(date.toString());\n            }\n            catch (ParseException e)\n            {\n                throw new SerializationException(\"Failed to read date (\" + e.getMessage() + \") with format \" + date);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Gets serialization context for this IIM file instance.\n     *\n     * @return Returns the serializationContext\n     */\n    public SerializationContext getSerializationContext()\n    {\n        return this.serializationContext;\n    }\n\n    public boolean isRecoverFromIIMFormat()\n    {\n        return recoverFromIIMFormat;\n    }\n\n    public boolean isRecoverFromInvalidDataSet()\n    {\n        return recoverFromInvalidDataSet;\n    }\n\n    public boolean isRecoverFromUnsupportedDataSet()\n    {\n        return recoverFromUnsupportedDataSet;\n    }\n\n    public boolean isStopAfter9_10()\n    {\n        return stopAfter9_10;\n    }\n\n    /**\n     * Reads data sets from a passed reader and attempt to recover from as much\n     * errors as possible.\n     *\n     * @param reader\n     *            data sets source\n     * @throws IOException\n     *             if reader can't read underlying stream\n     * @throws InvalidDataSetException\n     *             if invalid/undefined data set is encountered\n     */\n    public void readFrom(IIMReader reader) throws IOException, InvalidDataSetException\n    {\n        readFrom(reader, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Reads data sets from a passed reader.\n     *\n     * @param reader\n     *            data sets source\n     * @param recover\n     *            max number of errors reading process will try to recover from.\n     *            Set to 0 to fail immediately\n     * @throws IOException\n     *             if reader can't read underlying stream\n     * @throws InvalidDataSetException\n     *             if invalid/undefined data set is encountered\n     */\n    public void readFrom(IIMReader reader, int recover) throws IOException, InvalidDataSetException\n    {\n        final boolean doLog = log != null;\n        for (;;)\n        {\n            try\n            {\n                DataSet ds = reader.read();\n                if (ds == null)\n                {\n                    break;\n                }\n\n                if (doLog)\n                {\n                    log.debug(\"Read data set \" + ds);\n                }\n\n                DataSetInfo info = ds.getInfo();\n                Serializer s = info.getSerializer();\n                if (s != null)\n                {\n                    if (info.getDataSetNumber() == IIM.DS(1, 90))\n                    {\n                        setCharacterSet((String) s.deserialize(ds.getData(), activeSerializationContext));\n                    }\n                }\n\n                dataSets.add(ds);\n\n                if (stopAfter9_10 && info.getDataSetNumber() == IIM.DS(9, 10))\n                    break;\n            }\n            catch (IIMFormatException e)\n            {\n                if (recoverFromIIMFormat && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (UnsupportedDataSetException e)\n            {\n                if (recoverFromUnsupportedDataSet && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (InvalidDataSetException e)\n            {\n                if (recoverFromInvalidDataSet && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (IOException e)\n            {\n                if (recover-- > 0 && !dataSets.isEmpty())\n                {\n                    if (doLog)\n                    {\n                        log.error(\"IOException while reading, however some data sets where recovered, \" + e);\n                    }\n                    return;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n        }\n    }\n\n    public boolean remove(int dataSet)\n    {\n        boolean result = false;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                i.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    public boolean removeRecord(int record)\n    {\n        boolean result = false;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if ((info.getDataSetNumber() >> 8) == record)\n            {\n                i.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @param dataSets\n     *            The dataSets to set.\n     */\n    public void setDataSets(List<DataSet> dataSets)\n    {\n        this.dataSets = dataSets;\n    }\n\n    /**\n     * Sets logger for this IIMFile.\n     *\n     * @param log\n     *            logger to use with this file.\n     */\n    public void setLog(LoggerAdapter log)\n    {\n        this.log = log;\n    }\n\n    /**\n     * Should we recover from the IIM format violations, default is true.\n     *\n     * @param recoverFromIIMFormat\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromIIMFormat(boolean recoverFromIIMFormat)\n    {\n        this.recoverFromIIMFormat = recoverFromIIMFormat;\n    }\n\n    /**\n     * Should we recover from the invalid data sets, default is true.\n     *\n     * @param recoverFromInvalidDataSet\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromInvalidDataSet(boolean recoverFromInvalidDataSet)\n    {\n        this.recoverFromInvalidDataSet = recoverFromInvalidDataSet;\n    }\n\n    /**\n     * Should we recover from the unsupported data sets, default is true.\n     *\n     * @param recoverFromUnsupportedDataSet\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromUnsupportedDataSet(boolean recoverFromUnsupportedDataSet)\n    {\n        this.recoverFromUnsupportedDataSet = recoverFromUnsupportedDataSet;\n    }\n\n    /**\n     * @param serializationContext\n     *            The serializationContext to set\n     */\n    public void setSerializationContext(SerializationContext serializationContext)\n    {\n        this.serializationContext = serializationContext;\n        activeSerializationContext = serializationContext != null ? serializationContext : this;\n    }\n\n    /**\n     * Controls if reading should stop after data set record 9,10. Default true.\n     *\n     * @param stopAfter9_10\n     *            true to stop reading, false to stop\n     */\n    public void setStopAfter9_10(boolean stopAfter9_10)\n    {\n        this.stopAfter9_10 = stopAfter9_10;\n    }\n\n    public String toString()\n    {\n        StringBuilder b = new StringBuilder();\n        b.append(\"IIMFile(\");\n        b.append(\"dataSets=\");\n        b.append(dataSets);\n        b.append(')');\n        return b.toString();\n    }\n\n    /**\n     * Writes this IIMFile to writer.\n     *\n     * @param writer\n     *            writer to write to\n     * @throws IOException\n     *             if file can't be written to\n     */\n\n    private Object getData(DataSet ds) throws SerializationException\n    {\n        DataSetInfo info = ds.getInfo();\n        Serializer s = info.getSerializer();\n        Object result;\n        if (s != null)\n        {\n            result = s.deserialize(ds.getData(), activeSerializationContext);\n        }\n        else\n        {\n            result = ds.getData();\n        }\n        return result;\n    }\n\n    /**\n     * Checks if data set is mandatory but missing or non repeatable but having\n     * multiple values in this IIM instance.\n     *\n     * @param info\n     *            IIM data set to check\n     * @return list of constraint violations, empty set if data set is valid\n     */\n    public Set<ConstraintViolation> validate(DataSetInfo info)\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        try\n        {\n            if (info.isMandatory() && get(info.getDataSetNumber()) == null)\n            {\n                errors.add(new ConstraintViolation(info, ConstraintViolation.MANDATORY_MISSING));\n            }\n            if (!info.isRepeatable() && getAll(info.getDataSetNumber()).size() > 1)\n            {\n                errors.add(new ConstraintViolation(info, ConstraintViolation.REPEATABLE_REPEATED));\n            }\n        }\n        catch (SerializationException e)\n        {\n            errors.add(new ConstraintViolation(info, ConstraintViolation.INVALID_VALUE));\n        }\n        return errors;\n    }\n\n    /**\n     * Checks all data sets in a given record for constraint violations.\n     *\n     * @param record\n     *            IIM record (1,2,3, ...) to check\n     *\n     * @return list of constraint violations, empty set if IIM file is valid\n     */\n    public Set<ConstraintViolation> validate(int record)\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        for (int ds = 0; ds < 250; ++ds)\n        {\n            try\n            {\n                DataSetInfo dataSetInfo = dsiFactory.create(IIM.DS(record, ds));\n                errors.addAll(validate(dataSetInfo));\n            }\n            catch (InvalidDataSetException ignored)\n            {\n                // DataSetFactory doesn't know about this ds, so will skip it\n            }\n        }\n        return errors;\n    }\n\n    /**\n     * Checks all data sets in IIM records 1, 2 and 3 for constraint violations.\n     *\n     * @return list of constraint violations, empty set if IIM file is valid\n     */\n    public Set<ConstraintViolation> validate()\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        for (int record = 1; record <= 3; ++record)\n        {\n            errors.addAll(validate(record));\n        }\n        return errors;\n    }\n\n    private SerializationContext activeSerializationContext = this;\n    private List<DataSet> dataSets = new ArrayList<DataSet>();\n    private DataSetInfoFactory dsiFactory;\n    private LoggerAdapter log;\n    private boolean recoverFromIIMFormat = true;\n    private boolean recoverFromInvalidDataSet = true;\n    private boolean recoverFromUnsupportedDataSet = true;\n    private SerializationContext serializationContext;\n    private boolean stopAfter9_10 = true;\n}"}
{"repo": "vnesek/nmote-iim4j", "path": "src/main/java/com/nmote/iim4j/IIMFile.java", "func_name": "IIMFile.validate", "original_string": "public Set<ConstraintViolation> validate(DataSetInfo info) {\r\n\t\tSet<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\r\n\t\ttry {\r\n\t\t\tif (info.isMandatory() && get(info.getDataSetNumber()) == null) {\r\n\t\t\t\terrors.add(new ConstraintViolation(info, ConstraintViolation.MANDATORY_MISSING));\r\n\t\t\t}\r\n\t\t\tif (!info.isRepeatable() && getAll(info.getDataSetNumber()).size() > 1) {\r\n\t\t\t\terrors.add(new ConstraintViolation(info, ConstraintViolation.REPEATABLE_REPEATED));\r\n\t\t\t}\r\n\t\t} catch (SerializationException e) {\r\n\t\t\terrors.add(new ConstraintViolation(info, ConstraintViolation.INVALID_VALUE));\r\n\t\t}\r\n\t\treturn errors;\r\n\t}", "language": "java", "code": "public Set<ConstraintViolation> validate(DataSetInfo info) {\r\n\t\tSet<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\r\n\t\ttry {\r\n\t\t\tif (info.isMandatory() && get(info.getDataSetNumber()) == null) {\r\n\t\t\t\terrors.add(new ConstraintViolation(info, ConstraintViolation.MANDATORY_MISSING));\r\n\t\t\t}\r\n\t\t\tif (!info.isRepeatable() && getAll(info.getDataSetNumber()).size() > 1) {\r\n\t\t\t\terrors.add(new ConstraintViolation(info, ConstraintViolation.REPEATABLE_REPEATED));\r\n\t\t\t}\r\n\t\t} catch (SerializationException e) {\r\n\t\t\terrors.add(new ConstraintViolation(info, ConstraintViolation.INVALID_VALUE));\r\n\t\t}\r\n\t\treturn errors;\r\n\t}", "code_tokens": ["public", "Set", "<", "ConstraintViolation", ">", "validate", "(", "DataSetInfo", "info", ")", "{", "Set", "<", "ConstraintViolation", ">", "errors", "=", "new", "LinkedHashSet", "<", "ConstraintViolation", ">", "(", ")", ";", "try", "{", "if", "(", "info", ".", "isMandatory", "(", ")", "&&", "get", "(", "info", ".", "getDataSetNumber", "(", ")", ")", "==", "null", ")", "{", "errors", ".", "add", "(", "new", "ConstraintViolation", "(", "info", ",", "ConstraintViolation", ".", "MANDATORY_MISSING", ")", ")", ";", "}", "if", "(", "!", "info", ".", "isRepeatable", "(", ")", "&&", "getAll", "(", "info", ".", "getDataSetNumber", "(", ")", ")", ".", "size", "(", ")", ">", "1", ")", "{", "errors", ".", "add", "(", "new", "ConstraintViolation", "(", "info", ",", "ConstraintViolation", ".", "REPEATABLE_REPEATED", ")", ")", ";", "}", "}", "catch", "(", "SerializationException", "e", ")", "{", "errors", ".", "add", "(", "new", "ConstraintViolation", "(", "info", ",", "ConstraintViolation", ".", "INVALID_VALUE", ")", ")", ";", "}", "return", "errors", ";", "}"], "docstring": "Checks if data set is mandatory but missing or non repeatable but having\nmultiple values in this IIM instance.\n\n@param info\nIIM data set to check\n@return list of constraint violations, empty set if data set is valid", "docstring_tokens": ["Checks", "if", "data", "set", "is", "mandatory", "but", "missing", "or", "non", "repeatable", "but", "having", "multiple", "values", "in", "this", "IIM", "instance", "."], "sha": "ec55b02fc644cd722e93051ac0bdb96b00cb42a8", "url": "https://github.com/vnesek/nmote-iim4j/blob/ec55b02fc644cd722e93051ac0bdb96b00cb42a8/src/main/java/com/nmote/iim4j/IIMFile.java#L500-L513", "partition": "train", "up_fun_num": 30, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import java.io.IOException;", "import java.io.Serializable;", "import java.text.ParseException;", "import java.text.SimpleDateFormat;", "import java.util.ArrayList;", "import java.util.Date;", "import java.util.Iterator;", "import java.util.LinkedHashSet;", "import java.util.List;", "import java.util.Set;", "import com.nmote.iim4j.dataset.ConstraintViolation;", "import com.nmote.iim4j.dataset.DataSet;", "import com.nmote.iim4j.dataset.DataSetInfo;", "import com.nmote.iim4j.dataset.DataSetInfoFactory;", "import com.nmote.iim4j.dataset.DefaultDataSet;", "import com.nmote.iim4j.dataset.InvalidDataSetException;", "import com.nmote.iim4j.dataset.UnsupportedDataSetException;", "import com.nmote.iim4j.serialize.DefaultSerializationContext;", "import com.nmote.iim4j.serialize.SerializationContext;", "import com.nmote.iim4j.serialize.SerializationException;", "import com.nmote.iim4j.serialize.Serializer;"], "function": ["public class IIMFile extends DefaultSerializationContext implements Serializable, Cloneable\n", "    public void add(DataSet dataSet)\n", "    public void add(int ds, Object value) throws SerializationException, InvalidDataSetException\n", "    public void addDateTimeHelper(int ds, Date date) throws SerializationException, InvalidDataSetException\n", "    public void addDateTimeHelper(int dsDate, int dsTime, Date date) throws SerializationException,\n", "    public IIMFile clone()\n", "    public Object get(int dataSet) throws SerializationException\n", "    public List<Object> getAll(int dataSet) throws SerializationException\n", "    public List<DataSet> getDataSets()\n", "    public Date getDateTimeHelper(int dateDataSet, int timeDataSet) throws SerializationException\n", "    public SerializationContext getSerializationContext()\n", "    public boolean isRecoverFromIIMFormat()\n", "    public boolean isRecoverFromInvalidDataSet()\n", "    public boolean isRecoverFromUnsupportedDataSet()\n", "    public boolean isStopAfter9_10()\n", "    public void readFrom(IIMReader reader) throws IOException, InvalidDataSetException\n", "    public void readFrom(IIMReader reader, int recover) throws IOException, InvalidDataSetException\n", "    public boolean remove(int dataSet)\n", "    public boolean removeRecord(int record)\n", "    public void setDataSets(List<DataSet> dataSets)\n", "    public void setLog(LoggerAdapter log)\n", "    public void setRecoverFromIIMFormat(boolean recoverFromIIMFormat)\n", "    public void setRecoverFromInvalidDataSet(boolean recoverFromInvalidDataSet)\n", "    public void setRecoverFromUnsupportedDataSet(boolean recoverFromUnsupportedDataSet)\n", "    public void setSerializationContext(SerializationContext serializationContext)\n", "    public void setStopAfter9_10(boolean stopAfter9_10)\n", "    public String toString()\n", "    public void writeTo(IIMWriter writer) throws IOException\n", "    private Object getData(DataSet ds) throws SerializationException\n", "    public Set<ConstraintViolation> validate(int record)\n", "    public Set<ConstraintViolation> validate()\n"], "context": "/*\n * Copyright (c) Nmote Ltd. 2004-2015. All rights reserved.\n * See LICENSE doc in a root of project folder for additional information.\n */\n\npackage com.nmote.iim4j;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport com.nmote.iim4j.dataset.ConstraintViolation;\nimport com.nmote.iim4j.dataset.DataSet;\nimport com.nmote.iim4j.dataset.DataSetInfo;\nimport com.nmote.iim4j.dataset.DataSetInfoFactory;\nimport com.nmote.iim4j.dataset.DefaultDataSet;\nimport com.nmote.iim4j.dataset.InvalidDataSetException;\nimport com.nmote.iim4j.dataset.UnsupportedDataSetException;\nimport com.nmote.iim4j.serialize.DefaultSerializationContext;\nimport com.nmote.iim4j.serialize.SerializationContext;\nimport com.nmote.iim4j.serialize.SerializationException;\nimport com.nmote.iim4j.serialize.Serializer;\n\n/**\n * IIMFile holds a set of data set records, and supports reading and writing to\n * files/streams.\n */\npublic class IIMFile extends DefaultSerializationContext implements Serializable, Cloneable\n{\n\n    private static final long serialVersionUID = About.SERIAL_VERSION_UID;\n\n    /**\n     * Creates a new IIMFile using default (IIM version 4) data set info\n     * factory.\n     */\n    public IIMFile()\n    {\n        this(IIMDataSetInfoFactory.VERSION_4);\n    }\n\n    /**\n     * Creates a new IIMFile using passed data set info factory.\n     *\n     * @param dsiFactory\n     *            data set info factory\n     */\n    public IIMFile(DataSetInfoFactory dsiFactory)\n    {\n        this.dsiFactory = dsiFactory;\n    }\n\n    /**\n     * Adds a data set to IIM file.\n     *\n     * @param dataSet\n     *            to add\n     */\n    public void add(DataSet dataSet)\n    {\n        dataSets.add(dataSet);\n    }\n\n    /**\n     * Adds a data set to IIM file.\n     *\n     * @param ds\n     *            data set id (see constants in IIM class)\n     * @param value\n     *            data set value. Null values are silently ignored.\n     * @throws SerializationException\n     *             if value can't be serialized by data set's serializer\n     * @throws InvalidDataSetException\n     *             if data set isn't defined\n     */\n    public void add(int ds, Object value) throws SerializationException, InvalidDataSetException\n    {\n        if (value == null)\n        {\n            return;\n        }\n\n        DataSetInfo dsi = dsiFactory.create(ds);\n        byte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\n        DataSet dataSet = new DefaultDataSet(dsi, data);\n        dataSets.add(dataSet);\n    }\n\n    /**\n     * Adds a data set with date-time value to IIM file.\n     *\n     * @param ds\n     *            data set id (see constants in IIM class)\n     * @param date\n     *            date to set. Null values are silently ignored.\n     * @throws SerializationException\n     *             if value can't be serialized by data set's serializer\n     * @throws InvalidDataSetException\n     *             if data set isn't defined\n     */\n    public void addDateTimeHelper(int ds, Date date) throws SerializationException, InvalidDataSetException\n    {\n        if (date == null)\n        {\n            return;\n        }\n\n        DataSetInfo dsi = dsiFactory.create(ds);\n\n        SimpleDateFormat df = new SimpleDateFormat(dsi.getSerializer().toString());\n        String value = df.format(date);\n        byte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\n        DataSet dataSet = new DefaultDataSet(dsi, data);\n        add(dataSet);\n    }\n\n    public void addDateTimeHelper(int dsDate, int dsTime, Date date) throws SerializationException,\n               InvalidDataSetException\n    {\n        if (date == null)\n            return;\n\n        addDateTimeHelper(dsDate, date);\n        addDateTimeHelper(dsTime, date);\n    }\n\n    /**\n     * Makes a copy of this instance.\n     *\n     * @see java.lang.Object#clone()\n     * @return IIMFile copy\n     */\n    public IIMFile clone()\n    {\n        IIMFile file = new IIMFile(dsiFactory);\n        file.dataSets = new ArrayList<DataSet>(dataSets);\n        file.serializationContext = serializationContext == this ? file : serializationContext;\n        file.activeSerializationContext = activeSerializationContext == this ? file : activeSerializationContext;\n        return file;\n    }\n\n    /**\n     * Gets a first data set value.\n     *\n     * @param dataSet\n     *            IIM record and dataset code (See constants in {@link IIM})\n     * @return data set value\n     * @throws SerializationException\n     *             if value can't be deserialized from binary representation\n     */\n    public Object get(int dataSet) throws SerializationException\n    {\n        Object result = null;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                result = getData(ds);\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets all data set values.\n     *\n     * @param dataSet\n     *            IIM record and dataset code (See constants in {@link IIM})\n     * @return data set value\n     * @throws SerializationException\n     *             if value can't be deserialized from binary representation\n     */\n    public List<Object> getAll(int dataSet) throws SerializationException\n    {\n        List<Object> result = new ArrayList<Object>();\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                result.add(getData(ds));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets all data sets in IIM file.\n     *\n     * @return Returns the dataSets\n     */\n    public List<DataSet> getDataSets()\n    {\n        return this.dataSets;\n    }\n\n    /**\n     * Gets combined date/time value from two data sets.\n     *\n     * @param dateDataSet\n     *            data set containing date value\n     * @param timeDataSet\n     *            data set containing time value\n     * @return date/time instance\n     * @throws SerializationException\n     *             if data sets can't be deserialized from binary format or\n     *             can't be parsed\n     */\n    public Date getDateTimeHelper(int dateDataSet, int timeDataSet) throws SerializationException\n    {\n        DataSet dateDS = null;\n        DataSet timeDS = null;\n        for (Iterator<DataSet> i = dataSets.iterator(); (dateDS == null || timeDS == null) && i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dateDataSet)\n            {\n                dateDS = ds;\n            }\n            else if (info.getDataSetNumber() == timeDataSet)\n            {\n                timeDS = ds;\n            }\n        }\n\n        Date result = null;\n        if (dateDS != null && timeDS != null)\n        {\n            DataSetInfo dateDSI = dateDS.getInfo();\n            DataSetInfo timeDSI = timeDS.getInfo();\n            SimpleDateFormat format = new SimpleDateFormat(dateDSI.getSerializer().toString()\n                    + timeDSI.getSerializer().toString());\n            StringBuffer date = new StringBuffer(20);\n            try\n            {\n                date.append(getData(dateDS));\n                date.append(getData(timeDS));\n                result = format.parse(date.toString());\n            }\n            catch (ParseException e)\n            {\n                throw new SerializationException(\"Failed to read date (\" + e.getMessage() + \") with format \" + date);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Gets serialization context for this IIM file instance.\n     *\n     * @return Returns the serializationContext\n     */\n    public SerializationContext getSerializationContext()\n    {\n        return this.serializationContext;\n    }\n\n    public boolean isRecoverFromIIMFormat()\n    {\n        return recoverFromIIMFormat;\n    }\n\n    public boolean isRecoverFromInvalidDataSet()\n    {\n        return recoverFromInvalidDataSet;\n    }\n\n    public boolean isRecoverFromUnsupportedDataSet()\n    {\n        return recoverFromUnsupportedDataSet;\n    }\n\n    public boolean isStopAfter9_10()\n    {\n        return stopAfter9_10;\n    }\n\n    /**\n     * Reads data sets from a passed reader and attempt to recover from as much\n     * errors as possible.\n     *\n     * @param reader\n     *            data sets source\n     * @throws IOException\n     *             if reader can't read underlying stream\n     * @throws InvalidDataSetException\n     *             if invalid/undefined data set is encountered\n     */\n    public void readFrom(IIMReader reader) throws IOException, InvalidDataSetException\n    {\n        readFrom(reader, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Reads data sets from a passed reader.\n     *\n     * @param reader\n     *            data sets source\n     * @param recover\n     *            max number of errors reading process will try to recover from.\n     *            Set to 0 to fail immediately\n     * @throws IOException\n     *             if reader can't read underlying stream\n     * @throws InvalidDataSetException\n     *             if invalid/undefined data set is encountered\n     */\n    public void readFrom(IIMReader reader, int recover) throws IOException, InvalidDataSetException\n    {\n        final boolean doLog = log != null;\n        for (;;)\n        {\n            try\n            {\n                DataSet ds = reader.read();\n                if (ds == null)\n                {\n                    break;\n                }\n\n                if (doLog)\n                {\n                    log.debug(\"Read data set \" + ds);\n                }\n\n                DataSetInfo info = ds.getInfo();\n                Serializer s = info.getSerializer();\n                if (s != null)\n                {\n                    if (info.getDataSetNumber() == IIM.DS(1, 90))\n                    {\n                        setCharacterSet((String) s.deserialize(ds.getData(), activeSerializationContext));\n                    }\n                }\n\n                dataSets.add(ds);\n\n                if (stopAfter9_10 && info.getDataSetNumber() == IIM.DS(9, 10))\n                    break;\n            }\n            catch (IIMFormatException e)\n            {\n                if (recoverFromIIMFormat && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (UnsupportedDataSetException e)\n            {\n                if (recoverFromUnsupportedDataSet && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (InvalidDataSetException e)\n            {\n                if (recoverFromInvalidDataSet && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (IOException e)\n            {\n                if (recover-- > 0 && !dataSets.isEmpty())\n                {\n                    if (doLog)\n                    {\n                        log.error(\"IOException while reading, however some data sets where recovered, \" + e);\n                    }\n                    return;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n        }\n    }\n\n    public boolean remove(int dataSet)\n    {\n        boolean result = false;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                i.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    public boolean removeRecord(int record)\n    {\n        boolean result = false;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if ((info.getDataSetNumber() >> 8) == record)\n            {\n                i.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @param dataSets\n     *            The dataSets to set.\n     */\n    public void setDataSets(List<DataSet> dataSets)\n    {\n        this.dataSets = dataSets;\n    }\n\n    /**\n     * Sets logger for this IIMFile.\n     *\n     * @param log\n     *            logger to use with this file.\n     */\n    public void setLog(LoggerAdapter log)\n    {\n        this.log = log;\n    }\n\n    /**\n     * Should we recover from the IIM format violations, default is true.\n     *\n     * @param recoverFromIIMFormat\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromIIMFormat(boolean recoverFromIIMFormat)\n    {\n        this.recoverFromIIMFormat = recoverFromIIMFormat;\n    }\n\n    /**\n     * Should we recover from the invalid data sets, default is true.\n     *\n     * @param recoverFromInvalidDataSet\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromInvalidDataSet(boolean recoverFromInvalidDataSet)\n    {\n        this.recoverFromInvalidDataSet = recoverFromInvalidDataSet;\n    }\n\n    /**\n     * Should we recover from the unsupported data sets, default is true.\n     *\n     * @param recoverFromUnsupportedDataSet\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromUnsupportedDataSet(boolean recoverFromUnsupportedDataSet)\n    {\n        this.recoverFromUnsupportedDataSet = recoverFromUnsupportedDataSet;\n    }\n\n    /**\n     * @param serializationContext\n     *            The serializationContext to set\n     */\n    public void setSerializationContext(SerializationContext serializationContext)\n    {\n        this.serializationContext = serializationContext;\n        activeSerializationContext = serializationContext != null ? serializationContext : this;\n    }\n\n    /**\n     * Controls if reading should stop after data set record 9,10. Default true.\n     *\n     * @param stopAfter9_10\n     *            true to stop reading, false to stop\n     */\n    public void setStopAfter9_10(boolean stopAfter9_10)\n    {\n        this.stopAfter9_10 = stopAfter9_10;\n    }\n\n    public String toString()\n    {\n        StringBuilder b = new StringBuilder();\n        b.append(\"IIMFile(\");\n        b.append(\"dataSets=\");\n        b.append(dataSets);\n        b.append(')');\n        return b.toString();\n    }\n\n    /**\n     * Writes this IIMFile to writer.\n     *\n     * @param writer\n     *            writer to write to\n     * @throws IOException\n     *             if file can't be written to\n     */\n    public void writeTo(IIMWriter writer) throws IOException\n    {\n        final boolean doLog = log != null;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            writer.write(ds);\n            if (doLog)\n            {\n                log.debug(\"Wrote data set \" + ds);\n            }\n        }\n    }\n\n    private Object getData(DataSet ds) throws SerializationException\n    {\n        DataSetInfo info = ds.getInfo();\n        Serializer s = info.getSerializer();\n        Object result;\n        if (s != null)\n        {\n            result = s.deserialize(ds.getData(), activeSerializationContext);\n        }\n        else\n        {\n            result = ds.getData();\n        }\n        return result;\n    }\n\n    /**\n     * Checks if data set is mandatory but missing or non repeatable but having\n     * multiple values in this IIM instance.\n     *\n     * @param info\n     *            IIM data set to check\n     * @return list of constraint violations, empty set if data set is valid\n     */\n\n    /**\n     * Checks all data sets in a given record for constraint violations.\n     *\n     * @param record\n     *            IIM record (1,2,3, ...) to check\n     *\n     * @return list of constraint violations, empty set if IIM file is valid\n     */\n    public Set<ConstraintViolation> validate(int record)\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        for (int ds = 0; ds < 250; ++ds)\n        {\n            try\n            {\n                DataSetInfo dataSetInfo = dsiFactory.create(IIM.DS(record, ds));\n                errors.addAll(validate(dataSetInfo));\n            }\n            catch (InvalidDataSetException ignored)\n            {\n                // DataSetFactory doesn't know about this ds, so will skip it\n            }\n        }\n        return errors;\n    }\n\n    /**\n     * Checks all data sets in IIM records 1, 2 and 3 for constraint violations.\n     *\n     * @return list of constraint violations, empty set if IIM file is valid\n     */\n    public Set<ConstraintViolation> validate()\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        for (int record = 1; record <= 3; ++record)\n        {\n            errors.addAll(validate(record));\n        }\n        return errors;\n    }\n\n    private SerializationContext activeSerializationContext = this;\n    private List<DataSet> dataSets = new ArrayList<DataSet>();\n    private DataSetInfoFactory dsiFactory;\n    private LoggerAdapter log;\n    private boolean recoverFromIIMFormat = true;\n    private boolean recoverFromInvalidDataSet = true;\n    private boolean recoverFromUnsupportedDataSet = true;\n    private SerializationContext serializationContext;\n    private boolean stopAfter9_10 = true;\n}"}
{"repo": "vnesek/nmote-iim4j", "path": "src/main/java/com/nmote/iim4j/IIMFile.java", "func_name": "IIMFile.validate", "original_string": "public Set<ConstraintViolation> validate(int record) {\r\n\t\tSet<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\r\n\t\tfor (int ds = 0; ds < 250; ++ds) {\r\n\t\t\ttry {\r\n\t\t\t\tDataSetInfo dataSetInfo = dsiFactory.create(IIM.DS(record, ds));\r\n\t\t\t\terrors.addAll(validate(dataSetInfo));\r\n\t\t\t} catch (InvalidDataSetException ignored) {\r\n\t\t\t\t// DataSetFactory doesn't know about this ds, so will skip it\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn errors;\r\n\t}", "language": "java", "code": "public Set<ConstraintViolation> validate(int record) {\r\n\t\tSet<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\r\n\t\tfor (int ds = 0; ds < 250; ++ds) {\r\n\t\t\ttry {\r\n\t\t\t\tDataSetInfo dataSetInfo = dsiFactory.create(IIM.DS(record, ds));\r\n\t\t\t\terrors.addAll(validate(dataSetInfo));\r\n\t\t\t} catch (InvalidDataSetException ignored) {\r\n\t\t\t\t// DataSetFactory doesn't know about this ds, so will skip it\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn errors;\r\n\t}", "code_tokens": ["public", "Set", "<", "ConstraintViolation", ">", "validate", "(", "int", "record", ")", "{", "Set", "<", "ConstraintViolation", ">", "errors", "=", "new", "LinkedHashSet", "<", "ConstraintViolation", ">", "(", ")", ";", "for", "(", "int", "ds", "=", "0", ";", "ds", "<", "250", ";", "++", "ds", ")", "{", "try", "{", "DataSetInfo", "dataSetInfo", "=", "dsiFactory", ".", "create", "(", "IIM", ".", "DS", "(", "record", ",", "ds", ")", ")", ";", "errors", ".", "addAll", "(", "validate", "(", "dataSetInfo", ")", ")", ";", "}", "catch", "(", "InvalidDataSetException", "ignored", ")", "{", "// DataSetFactory doesn't know about this ds, so will skip it\r", "}", "}", "return", "errors", ";", "}"], "docstring": "Checks all data sets in a given record for constraint violations.\n\n@param record\nIIM record (1,2,3, ...) to check\n\n@return list of constraint violations, empty set if IIM file is valid", "docstring_tokens": ["Checks", "all", "data", "sets", "in", "a", "given", "record", "for", "constraint", "violations", "."], "sha": "ec55b02fc644cd722e93051ac0bdb96b00cb42a8", "url": "https://github.com/vnesek/nmote-iim4j/blob/ec55b02fc644cd722e93051ac0bdb96b00cb42a8/src/main/java/com/nmote/iim4j/IIMFile.java#L523-L534", "partition": "train", "up_fun_num": 31, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import java.io.IOException;", "import java.io.Serializable;", "import java.text.ParseException;", "import java.text.SimpleDateFormat;", "import java.util.ArrayList;", "import java.util.Date;", "import java.util.Iterator;", "import java.util.LinkedHashSet;", "import java.util.List;", "import java.util.Set;", "import com.nmote.iim4j.dataset.ConstraintViolation;", "import com.nmote.iim4j.dataset.DataSet;", "import com.nmote.iim4j.dataset.DataSetInfo;", "import com.nmote.iim4j.dataset.DataSetInfoFactory;", "import com.nmote.iim4j.dataset.DefaultDataSet;", "import com.nmote.iim4j.dataset.InvalidDataSetException;", "import com.nmote.iim4j.dataset.UnsupportedDataSetException;", "import com.nmote.iim4j.serialize.DefaultSerializationContext;", "import com.nmote.iim4j.serialize.SerializationContext;", "import com.nmote.iim4j.serialize.SerializationException;", "import com.nmote.iim4j.serialize.Serializer;"], "function": ["public class IIMFile extends DefaultSerializationContext implements Serializable, Cloneable\n", "    public void add(DataSet dataSet)\n", "    public void add(int ds, Object value) throws SerializationException, InvalidDataSetException\n", "    public void addDateTimeHelper(int ds, Date date) throws SerializationException, InvalidDataSetException\n", "    public void addDateTimeHelper(int dsDate, int dsTime, Date date) throws SerializationException,\n", "    public IIMFile clone()\n", "    public Object get(int dataSet) throws SerializationException\n", "    public List<Object> getAll(int dataSet) throws SerializationException\n", "    public List<DataSet> getDataSets()\n", "    public Date getDateTimeHelper(int dateDataSet, int timeDataSet) throws SerializationException\n", "    public SerializationContext getSerializationContext()\n", "    public boolean isRecoverFromIIMFormat()\n", "    public boolean isRecoverFromInvalidDataSet()\n", "    public boolean isRecoverFromUnsupportedDataSet()\n", "    public boolean isStopAfter9_10()\n", "    public void readFrom(IIMReader reader) throws IOException, InvalidDataSetException\n", "    public void readFrom(IIMReader reader, int recover) throws IOException, InvalidDataSetException\n", "    public boolean remove(int dataSet)\n", "    public boolean removeRecord(int record)\n", "    public void setDataSets(List<DataSet> dataSets)\n", "    public void setLog(LoggerAdapter log)\n", "    public void setRecoverFromIIMFormat(boolean recoverFromIIMFormat)\n", "    public void setRecoverFromInvalidDataSet(boolean recoverFromInvalidDataSet)\n", "    public void setRecoverFromUnsupportedDataSet(boolean recoverFromUnsupportedDataSet)\n", "    public void setSerializationContext(SerializationContext serializationContext)\n", "    public void setStopAfter9_10(boolean stopAfter9_10)\n", "    public String toString()\n", "    public void writeTo(IIMWriter writer) throws IOException\n", "    private Object getData(DataSet ds) throws SerializationException\n", "    public Set<ConstraintViolation> validate(DataSetInfo info)\n", "    public Set<ConstraintViolation> validate()\n"], "context": "/*\n * Copyright (c) Nmote Ltd. 2004-2015. All rights reserved.\n * See LICENSE doc in a root of project folder for additional information.\n */\n\npackage com.nmote.iim4j;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport com.nmote.iim4j.dataset.ConstraintViolation;\nimport com.nmote.iim4j.dataset.DataSet;\nimport com.nmote.iim4j.dataset.DataSetInfo;\nimport com.nmote.iim4j.dataset.DataSetInfoFactory;\nimport com.nmote.iim4j.dataset.DefaultDataSet;\nimport com.nmote.iim4j.dataset.InvalidDataSetException;\nimport com.nmote.iim4j.dataset.UnsupportedDataSetException;\nimport com.nmote.iim4j.serialize.DefaultSerializationContext;\nimport com.nmote.iim4j.serialize.SerializationContext;\nimport com.nmote.iim4j.serialize.SerializationException;\nimport com.nmote.iim4j.serialize.Serializer;\n\n/**\n * IIMFile holds a set of data set records, and supports reading and writing to\n * files/streams.\n */\npublic class IIMFile extends DefaultSerializationContext implements Serializable, Cloneable\n{\n\n    private static final long serialVersionUID = About.SERIAL_VERSION_UID;\n\n    /**\n     * Creates a new IIMFile using default (IIM version 4) data set info\n     * factory.\n     */\n    public IIMFile()\n    {\n        this(IIMDataSetInfoFactory.VERSION_4);\n    }\n\n    /**\n     * Creates a new IIMFile using passed data set info factory.\n     *\n     * @param dsiFactory\n     *            data set info factory\n     */\n    public IIMFile(DataSetInfoFactory dsiFactory)\n    {\n        this.dsiFactory = dsiFactory;\n    }\n\n    /**\n     * Adds a data set to IIM file.\n     *\n     * @param dataSet\n     *            to add\n     */\n    public void add(DataSet dataSet)\n    {\n        dataSets.add(dataSet);\n    }\n\n    /**\n     * Adds a data set to IIM file.\n     *\n     * @param ds\n     *            data set id (see constants in IIM class)\n     * @param value\n     *            data set value. Null values are silently ignored.\n     * @throws SerializationException\n     *             if value can't be serialized by data set's serializer\n     * @throws InvalidDataSetException\n     *             if data set isn't defined\n     */\n    public void add(int ds, Object value) throws SerializationException, InvalidDataSetException\n    {\n        if (value == null)\n        {\n            return;\n        }\n\n        DataSetInfo dsi = dsiFactory.create(ds);\n        byte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\n        DataSet dataSet = new DefaultDataSet(dsi, data);\n        dataSets.add(dataSet);\n    }\n\n    /**\n     * Adds a data set with date-time value to IIM file.\n     *\n     * @param ds\n     *            data set id (see constants in IIM class)\n     * @param date\n     *            date to set. Null values are silently ignored.\n     * @throws SerializationException\n     *             if value can't be serialized by data set's serializer\n     * @throws InvalidDataSetException\n     *             if data set isn't defined\n     */\n    public void addDateTimeHelper(int ds, Date date) throws SerializationException, InvalidDataSetException\n    {\n        if (date == null)\n        {\n            return;\n        }\n\n        DataSetInfo dsi = dsiFactory.create(ds);\n\n        SimpleDateFormat df = new SimpleDateFormat(dsi.getSerializer().toString());\n        String value = df.format(date);\n        byte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\n        DataSet dataSet = new DefaultDataSet(dsi, data);\n        add(dataSet);\n    }\n\n    public void addDateTimeHelper(int dsDate, int dsTime, Date date) throws SerializationException,\n               InvalidDataSetException\n    {\n        if (date == null)\n            return;\n\n        addDateTimeHelper(dsDate, date);\n        addDateTimeHelper(dsTime, date);\n    }\n\n    /**\n     * Makes a copy of this instance.\n     *\n     * @see java.lang.Object#clone()\n     * @return IIMFile copy\n     */\n    public IIMFile clone()\n    {\n        IIMFile file = new IIMFile(dsiFactory);\n        file.dataSets = new ArrayList<DataSet>(dataSets);\n        file.serializationContext = serializationContext == this ? file : serializationContext;\n        file.activeSerializationContext = activeSerializationContext == this ? file : activeSerializationContext;\n        return file;\n    }\n\n    /**\n     * Gets a first data set value.\n     *\n     * @param dataSet\n     *            IIM record and dataset code (See constants in {@link IIM})\n     * @return data set value\n     * @throws SerializationException\n     *             if value can't be deserialized from binary representation\n     */\n    public Object get(int dataSet) throws SerializationException\n    {\n        Object result = null;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                result = getData(ds);\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets all data set values.\n     *\n     * @param dataSet\n     *            IIM record and dataset code (See constants in {@link IIM})\n     * @return data set value\n     * @throws SerializationException\n     *             if value can't be deserialized from binary representation\n     */\n    public List<Object> getAll(int dataSet) throws SerializationException\n    {\n        List<Object> result = new ArrayList<Object>();\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                result.add(getData(ds));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets all data sets in IIM file.\n     *\n     * @return Returns the dataSets\n     */\n    public List<DataSet> getDataSets()\n    {\n        return this.dataSets;\n    }\n\n    /**\n     * Gets combined date/time value from two data sets.\n     *\n     * @param dateDataSet\n     *            data set containing date value\n     * @param timeDataSet\n     *            data set containing time value\n     * @return date/time instance\n     * @throws SerializationException\n     *             if data sets can't be deserialized from binary format or\n     *             can't be parsed\n     */\n    public Date getDateTimeHelper(int dateDataSet, int timeDataSet) throws SerializationException\n    {\n        DataSet dateDS = null;\n        DataSet timeDS = null;\n        for (Iterator<DataSet> i = dataSets.iterator(); (dateDS == null || timeDS == null) && i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dateDataSet)\n            {\n                dateDS = ds;\n            }\n            else if (info.getDataSetNumber() == timeDataSet)\n            {\n                timeDS = ds;\n            }\n        }\n\n        Date result = null;\n        if (dateDS != null && timeDS != null)\n        {\n            DataSetInfo dateDSI = dateDS.getInfo();\n            DataSetInfo timeDSI = timeDS.getInfo();\n            SimpleDateFormat format = new SimpleDateFormat(dateDSI.getSerializer().toString()\n                    + timeDSI.getSerializer().toString());\n            StringBuffer date = new StringBuffer(20);\n            try\n            {\n                date.append(getData(dateDS));\n                date.append(getData(timeDS));\n                result = format.parse(date.toString());\n            }\n            catch (ParseException e)\n            {\n                throw new SerializationException(\"Failed to read date (\" + e.getMessage() + \") with format \" + date);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Gets serialization context for this IIM file instance.\n     *\n     * @return Returns the serializationContext\n     */\n    public SerializationContext getSerializationContext()\n    {\n        return this.serializationContext;\n    }\n\n    public boolean isRecoverFromIIMFormat()\n    {\n        return recoverFromIIMFormat;\n    }\n\n    public boolean isRecoverFromInvalidDataSet()\n    {\n        return recoverFromInvalidDataSet;\n    }\n\n    public boolean isRecoverFromUnsupportedDataSet()\n    {\n        return recoverFromUnsupportedDataSet;\n    }\n\n    public boolean isStopAfter9_10()\n    {\n        return stopAfter9_10;\n    }\n\n    /**\n     * Reads data sets from a passed reader and attempt to recover from as much\n     * errors as possible.\n     *\n     * @param reader\n     *            data sets source\n     * @throws IOException\n     *             if reader can't read underlying stream\n     * @throws InvalidDataSetException\n     *             if invalid/undefined data set is encountered\n     */\n    public void readFrom(IIMReader reader) throws IOException, InvalidDataSetException\n    {\n        readFrom(reader, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Reads data sets from a passed reader.\n     *\n     * @param reader\n     *            data sets source\n     * @param recover\n     *            max number of errors reading process will try to recover from.\n     *            Set to 0 to fail immediately\n     * @throws IOException\n     *             if reader can't read underlying stream\n     * @throws InvalidDataSetException\n     *             if invalid/undefined data set is encountered\n     */\n    public void readFrom(IIMReader reader, int recover) throws IOException, InvalidDataSetException\n    {\n        final boolean doLog = log != null;\n        for (;;)\n        {\n            try\n            {\n                DataSet ds = reader.read();\n                if (ds == null)\n                {\n                    break;\n                }\n\n                if (doLog)\n                {\n                    log.debug(\"Read data set \" + ds);\n                }\n\n                DataSetInfo info = ds.getInfo();\n                Serializer s = info.getSerializer();\n                if (s != null)\n                {\n                    if (info.getDataSetNumber() == IIM.DS(1, 90))\n                    {\n                        setCharacterSet((String) s.deserialize(ds.getData(), activeSerializationContext));\n                    }\n                }\n\n                dataSets.add(ds);\n\n                if (stopAfter9_10 && info.getDataSetNumber() == IIM.DS(9, 10))\n                    break;\n            }\n            catch (IIMFormatException e)\n            {\n                if (recoverFromIIMFormat && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (UnsupportedDataSetException e)\n            {\n                if (recoverFromUnsupportedDataSet && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (InvalidDataSetException e)\n            {\n                if (recoverFromInvalidDataSet && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (IOException e)\n            {\n                if (recover-- > 0 && !dataSets.isEmpty())\n                {\n                    if (doLog)\n                    {\n                        log.error(\"IOException while reading, however some data sets where recovered, \" + e);\n                    }\n                    return;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n        }\n    }\n\n    public boolean remove(int dataSet)\n    {\n        boolean result = false;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                i.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    public boolean removeRecord(int record)\n    {\n        boolean result = false;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if ((info.getDataSetNumber() >> 8) == record)\n            {\n                i.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @param dataSets\n     *            The dataSets to set.\n     */\n    public void setDataSets(List<DataSet> dataSets)\n    {\n        this.dataSets = dataSets;\n    }\n\n    /**\n     * Sets logger for this IIMFile.\n     *\n     * @param log\n     *            logger to use with this file.\n     */\n    public void setLog(LoggerAdapter log)\n    {\n        this.log = log;\n    }\n\n    /**\n     * Should we recover from the IIM format violations, default is true.\n     *\n     * @param recoverFromIIMFormat\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromIIMFormat(boolean recoverFromIIMFormat)\n    {\n        this.recoverFromIIMFormat = recoverFromIIMFormat;\n    }\n\n    /**\n     * Should we recover from the invalid data sets, default is true.\n     *\n     * @param recoverFromInvalidDataSet\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromInvalidDataSet(boolean recoverFromInvalidDataSet)\n    {\n        this.recoverFromInvalidDataSet = recoverFromInvalidDataSet;\n    }\n\n    /**\n     * Should we recover from the unsupported data sets, default is true.\n     *\n     * @param recoverFromUnsupportedDataSet\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromUnsupportedDataSet(boolean recoverFromUnsupportedDataSet)\n    {\n        this.recoverFromUnsupportedDataSet = recoverFromUnsupportedDataSet;\n    }\n\n    /**\n     * @param serializationContext\n     *            The serializationContext to set\n     */\n    public void setSerializationContext(SerializationContext serializationContext)\n    {\n        this.serializationContext = serializationContext;\n        activeSerializationContext = serializationContext != null ? serializationContext : this;\n    }\n\n    /**\n     * Controls if reading should stop after data set record 9,10. Default true.\n     *\n     * @param stopAfter9_10\n     *            true to stop reading, false to stop\n     */\n    public void setStopAfter9_10(boolean stopAfter9_10)\n    {\n        this.stopAfter9_10 = stopAfter9_10;\n    }\n\n    public String toString()\n    {\n        StringBuilder b = new StringBuilder();\n        b.append(\"IIMFile(\");\n        b.append(\"dataSets=\");\n        b.append(dataSets);\n        b.append(')');\n        return b.toString();\n    }\n\n    /**\n     * Writes this IIMFile to writer.\n     *\n     * @param writer\n     *            writer to write to\n     * @throws IOException\n     *             if file can't be written to\n     */\n    public void writeTo(IIMWriter writer) throws IOException\n    {\n        final boolean doLog = log != null;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            writer.write(ds);\n            if (doLog)\n            {\n                log.debug(\"Wrote data set \" + ds);\n            }\n        }\n    }\n\n    private Object getData(DataSet ds) throws SerializationException\n    {\n        DataSetInfo info = ds.getInfo();\n        Serializer s = info.getSerializer();\n        Object result;\n        if (s != null)\n        {\n            result = s.deserialize(ds.getData(), activeSerializationContext);\n        }\n        else\n        {\n            result = ds.getData();\n        }\n        return result;\n    }\n\n    /**\n     * Checks if data set is mandatory but missing or non repeatable but having\n     * multiple values in this IIM instance.\n     *\n     * @param info\n     *            IIM data set to check\n     * @return list of constraint violations, empty set if data set is valid\n     */\n    public Set<ConstraintViolation> validate(DataSetInfo info)\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        try\n        {\n            if (info.isMandatory() && get(info.getDataSetNumber()) == null)\n            {\n                errors.add(new ConstraintViolation(info, ConstraintViolation.MANDATORY_MISSING));\n            }\n            if (!info.isRepeatable() && getAll(info.getDataSetNumber()).size() > 1)\n            {\n                errors.add(new ConstraintViolation(info, ConstraintViolation.REPEATABLE_REPEATED));\n            }\n        }\n        catch (SerializationException e)\n        {\n            errors.add(new ConstraintViolation(info, ConstraintViolation.INVALID_VALUE));\n        }\n        return errors;\n    }\n\n    /**\n     * Checks all data sets in a given record for constraint violations.\n     *\n     * @param record\n     *            IIM record (1,2,3, ...) to check\n     *\n     * @return list of constraint violations, empty set if IIM file is valid\n     */\n\n    /**\n     * Checks all data sets in IIM records 1, 2 and 3 for constraint violations.\n     *\n     * @return list of constraint violations, empty set if IIM file is valid\n     */\n    public Set<ConstraintViolation> validate()\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        for (int record = 1; record <= 3; ++record)\n        {\n            errors.addAll(validate(record));\n        }\n        return errors;\n    }\n\n    private SerializationContext activeSerializationContext = this;\n    private List<DataSet> dataSets = new ArrayList<DataSet>();\n    private DataSetInfoFactory dsiFactory;\n    private LoggerAdapter log;\n    private boolean recoverFromIIMFormat = true;\n    private boolean recoverFromInvalidDataSet = true;\n    private boolean recoverFromUnsupportedDataSet = true;\n    private SerializationContext serializationContext;\n    private boolean stopAfter9_10 = true;\n}"}
{"repo": "vnesek/nmote-iim4j", "path": "src/main/java/com/nmote/iim4j/IIMFile.java", "func_name": "IIMFile.validate", "original_string": "public Set<ConstraintViolation> validate() {\r\n\t\tSet<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\r\n\t\tfor (int record = 1; record <= 3; ++record) {\r\n\t\t\terrors.addAll(validate(record));\r\n\t\t}\r\n\t\treturn errors;\r\n\t}", "language": "java", "code": "public Set<ConstraintViolation> validate() {\r\n\t\tSet<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\r\n\t\tfor (int record = 1; record <= 3; ++record) {\r\n\t\t\terrors.addAll(validate(record));\r\n\t\t}\r\n\t\treturn errors;\r\n\t}", "code_tokens": ["public", "Set", "<", "ConstraintViolation", ">", "validate", "(", ")", "{", "Set", "<", "ConstraintViolation", ">", "errors", "=", "new", "LinkedHashSet", "<", "ConstraintViolation", ">", "(", ")", ";", "for", "(", "int", "record", "=", "1", ";", "record", "<=", "3", ";", "++", "record", ")", "{", "errors", ".", "addAll", "(", "validate", "(", "record", ")", ")", ";", "}", "return", "errors", ";", "}"], "docstring": "Checks all data sets in IIM records 1, 2 and 3 for constraint violations.\n\n@return list of constraint violations, empty set if IIM file is valid", "docstring_tokens": ["Checks", "all", "data", "sets", "in", "IIM", "records", "1", "2", "and", "3", "for", "constraint", "violations", "."], "sha": "ec55b02fc644cd722e93051ac0bdb96b00cb42a8", "url": "https://github.com/vnesek/nmote-iim4j/blob/ec55b02fc644cd722e93051ac0bdb96b00cb42a8/src/main/java/com/nmote/iim4j/IIMFile.java#L541-L547", "partition": "train", "up_fun_num": 31, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import java.io.IOException;", "import java.io.Serializable;", "import java.text.ParseException;", "import java.text.SimpleDateFormat;", "import java.util.ArrayList;", "import java.util.Date;", "import java.util.Iterator;", "import java.util.LinkedHashSet;", "import java.util.List;", "import java.util.Set;", "import com.nmote.iim4j.dataset.ConstraintViolation;", "import com.nmote.iim4j.dataset.DataSet;", "import com.nmote.iim4j.dataset.DataSetInfo;", "import com.nmote.iim4j.dataset.DataSetInfoFactory;", "import com.nmote.iim4j.dataset.DefaultDataSet;", "import com.nmote.iim4j.dataset.InvalidDataSetException;", "import com.nmote.iim4j.dataset.UnsupportedDataSetException;", "import com.nmote.iim4j.serialize.DefaultSerializationContext;", "import com.nmote.iim4j.serialize.SerializationContext;", "import com.nmote.iim4j.serialize.SerializationException;", "import com.nmote.iim4j.serialize.Serializer;"], "function": ["public class IIMFile extends DefaultSerializationContext implements Serializable, Cloneable\n", "    public void add(DataSet dataSet)\n", "    public void add(int ds, Object value) throws SerializationException, InvalidDataSetException\n", "    public void addDateTimeHelper(int ds, Date date) throws SerializationException, InvalidDataSetException\n", "    public void addDateTimeHelper(int dsDate, int dsTime, Date date) throws SerializationException,\n", "    public IIMFile clone()\n", "    public Object get(int dataSet) throws SerializationException\n", "    public List<Object> getAll(int dataSet) throws SerializationException\n", "    public List<DataSet> getDataSets()\n", "    public Date getDateTimeHelper(int dateDataSet, int timeDataSet) throws SerializationException\n", "    public SerializationContext getSerializationContext()\n", "    public boolean isRecoverFromIIMFormat()\n", "    public boolean isRecoverFromInvalidDataSet()\n", "    public boolean isRecoverFromUnsupportedDataSet()\n", "    public boolean isStopAfter9_10()\n", "    public void readFrom(IIMReader reader) throws IOException, InvalidDataSetException\n", "    public void readFrom(IIMReader reader, int recover) throws IOException, InvalidDataSetException\n", "    public boolean remove(int dataSet)\n", "    public boolean removeRecord(int record)\n", "    public void setDataSets(List<DataSet> dataSets)\n", "    public void setLog(LoggerAdapter log)\n", "    public void setRecoverFromIIMFormat(boolean recoverFromIIMFormat)\n", "    public void setRecoverFromInvalidDataSet(boolean recoverFromInvalidDataSet)\n", "    public void setRecoverFromUnsupportedDataSet(boolean recoverFromUnsupportedDataSet)\n", "    public void setSerializationContext(SerializationContext serializationContext)\n", "    public void setStopAfter9_10(boolean stopAfter9_10)\n", "    public String toString()\n", "    public void writeTo(IIMWriter writer) throws IOException\n", "    private Object getData(DataSet ds) throws SerializationException\n", "    public Set<ConstraintViolation> validate(DataSetInfo info)\n", "    public Set<ConstraintViolation> validate(int record)\n"], "context": "/*\n * Copyright (c) Nmote Ltd. 2004-2015. All rights reserved.\n * See LICENSE doc in a root of project folder for additional information.\n */\n\npackage com.nmote.iim4j;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport com.nmote.iim4j.dataset.ConstraintViolation;\nimport com.nmote.iim4j.dataset.DataSet;\nimport com.nmote.iim4j.dataset.DataSetInfo;\nimport com.nmote.iim4j.dataset.DataSetInfoFactory;\nimport com.nmote.iim4j.dataset.DefaultDataSet;\nimport com.nmote.iim4j.dataset.InvalidDataSetException;\nimport com.nmote.iim4j.dataset.UnsupportedDataSetException;\nimport com.nmote.iim4j.serialize.DefaultSerializationContext;\nimport com.nmote.iim4j.serialize.SerializationContext;\nimport com.nmote.iim4j.serialize.SerializationException;\nimport com.nmote.iim4j.serialize.Serializer;\n\n/**\n * IIMFile holds a set of data set records, and supports reading and writing to\n * files/streams.\n */\npublic class IIMFile extends DefaultSerializationContext implements Serializable, Cloneable\n{\n\n    private static final long serialVersionUID = About.SERIAL_VERSION_UID;\n\n    /**\n     * Creates a new IIMFile using default (IIM version 4) data set info\n     * factory.\n     */\n    public IIMFile()\n    {\n        this(IIMDataSetInfoFactory.VERSION_4);\n    }\n\n    /**\n     * Creates a new IIMFile using passed data set info factory.\n     *\n     * @param dsiFactory\n     *            data set info factory\n     */\n    public IIMFile(DataSetInfoFactory dsiFactory)\n    {\n        this.dsiFactory = dsiFactory;\n    }\n\n    /**\n     * Adds a data set to IIM file.\n     *\n     * @param dataSet\n     *            to add\n     */\n    public void add(DataSet dataSet)\n    {\n        dataSets.add(dataSet);\n    }\n\n    /**\n     * Adds a data set to IIM file.\n     *\n     * @param ds\n     *            data set id (see constants in IIM class)\n     * @param value\n     *            data set value. Null values are silently ignored.\n     * @throws SerializationException\n     *             if value can't be serialized by data set's serializer\n     * @throws InvalidDataSetException\n     *             if data set isn't defined\n     */\n    public void add(int ds, Object value) throws SerializationException, InvalidDataSetException\n    {\n        if (value == null)\n        {\n            return;\n        }\n\n        DataSetInfo dsi = dsiFactory.create(ds);\n        byte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\n        DataSet dataSet = new DefaultDataSet(dsi, data);\n        dataSets.add(dataSet);\n    }\n\n    /**\n     * Adds a data set with date-time value to IIM file.\n     *\n     * @param ds\n     *            data set id (see constants in IIM class)\n     * @param date\n     *            date to set. Null values are silently ignored.\n     * @throws SerializationException\n     *             if value can't be serialized by data set's serializer\n     * @throws InvalidDataSetException\n     *             if data set isn't defined\n     */\n    public void addDateTimeHelper(int ds, Date date) throws SerializationException, InvalidDataSetException\n    {\n        if (date == null)\n        {\n            return;\n        }\n\n        DataSetInfo dsi = dsiFactory.create(ds);\n\n        SimpleDateFormat df = new SimpleDateFormat(dsi.getSerializer().toString());\n        String value = df.format(date);\n        byte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\n        DataSet dataSet = new DefaultDataSet(dsi, data);\n        add(dataSet);\n    }\n\n    public void addDateTimeHelper(int dsDate, int dsTime, Date date) throws SerializationException,\n               InvalidDataSetException\n    {\n        if (date == null)\n            return;\n\n        addDateTimeHelper(dsDate, date);\n        addDateTimeHelper(dsTime, date);\n    }\n\n    /**\n     * Makes a copy of this instance.\n     *\n     * @see java.lang.Object#clone()\n     * @return IIMFile copy\n     */\n    public IIMFile clone()\n    {\n        IIMFile file = new IIMFile(dsiFactory);\n        file.dataSets = new ArrayList<DataSet>(dataSets);\n        file.serializationContext = serializationContext == this ? file : serializationContext;\n        file.activeSerializationContext = activeSerializationContext == this ? file : activeSerializationContext;\n        return file;\n    }\n\n    /**\n     * Gets a first data set value.\n     *\n     * @param dataSet\n     *            IIM record and dataset code (See constants in {@link IIM})\n     * @return data set value\n     * @throws SerializationException\n     *             if value can't be deserialized from binary representation\n     */\n    public Object get(int dataSet) throws SerializationException\n    {\n        Object result = null;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                result = getData(ds);\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets all data set values.\n     *\n     * @param dataSet\n     *            IIM record and dataset code (See constants in {@link IIM})\n     * @return data set value\n     * @throws SerializationException\n     *             if value can't be deserialized from binary representation\n     */\n    public List<Object> getAll(int dataSet) throws SerializationException\n    {\n        List<Object> result = new ArrayList<Object>();\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                result.add(getData(ds));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets all data sets in IIM file.\n     *\n     * @return Returns the dataSets\n     */\n    public List<DataSet> getDataSets()\n    {\n        return this.dataSets;\n    }\n\n    /**\n     * Gets combined date/time value from two data sets.\n     *\n     * @param dateDataSet\n     *            data set containing date value\n     * @param timeDataSet\n     *            data set containing time value\n     * @return date/time instance\n     * @throws SerializationException\n     *             if data sets can't be deserialized from binary format or\n     *             can't be parsed\n     */\n    public Date getDateTimeHelper(int dateDataSet, int timeDataSet) throws SerializationException\n    {\n        DataSet dateDS = null;\n        DataSet timeDS = null;\n        for (Iterator<DataSet> i = dataSets.iterator(); (dateDS == null || timeDS == null) && i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dateDataSet)\n            {\n                dateDS = ds;\n            }\n            else if (info.getDataSetNumber() == timeDataSet)\n            {\n                timeDS = ds;\n            }\n        }\n\n        Date result = null;\n        if (dateDS != null && timeDS != null)\n        {\n            DataSetInfo dateDSI = dateDS.getInfo();\n            DataSetInfo timeDSI = timeDS.getInfo();\n            SimpleDateFormat format = new SimpleDateFormat(dateDSI.getSerializer().toString()\n                    + timeDSI.getSerializer().toString());\n            StringBuffer date = new StringBuffer(20);\n            try\n            {\n                date.append(getData(dateDS));\n                date.append(getData(timeDS));\n                result = format.parse(date.toString());\n            }\n            catch (ParseException e)\n            {\n                throw new SerializationException(\"Failed to read date (\" + e.getMessage() + \") with format \" + date);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Gets serialization context for this IIM file instance.\n     *\n     * @return Returns the serializationContext\n     */\n    public SerializationContext getSerializationContext()\n    {\n        return this.serializationContext;\n    }\n\n    public boolean isRecoverFromIIMFormat()\n    {\n        return recoverFromIIMFormat;\n    }\n\n    public boolean isRecoverFromInvalidDataSet()\n    {\n        return recoverFromInvalidDataSet;\n    }\n\n    public boolean isRecoverFromUnsupportedDataSet()\n    {\n        return recoverFromUnsupportedDataSet;\n    }\n\n    public boolean isStopAfter9_10()\n    {\n        return stopAfter9_10;\n    }\n\n    /**\n     * Reads data sets from a passed reader and attempt to recover from as much\n     * errors as possible.\n     *\n     * @param reader\n     *            data sets source\n     * @throws IOException\n     *             if reader can't read underlying stream\n     * @throws InvalidDataSetException\n     *             if invalid/undefined data set is encountered\n     */\n    public void readFrom(IIMReader reader) throws IOException, InvalidDataSetException\n    {\n        readFrom(reader, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Reads data sets from a passed reader.\n     *\n     * @param reader\n     *            data sets source\n     * @param recover\n     *            max number of errors reading process will try to recover from.\n     *            Set to 0 to fail immediately\n     * @throws IOException\n     *             if reader can't read underlying stream\n     * @throws InvalidDataSetException\n     *             if invalid/undefined data set is encountered\n     */\n    public void readFrom(IIMReader reader, int recover) throws IOException, InvalidDataSetException\n    {\n        final boolean doLog = log != null;\n        for (;;)\n        {\n            try\n            {\n                DataSet ds = reader.read();\n                if (ds == null)\n                {\n                    break;\n                }\n\n                if (doLog)\n                {\n                    log.debug(\"Read data set \" + ds);\n                }\n\n                DataSetInfo info = ds.getInfo();\n                Serializer s = info.getSerializer();\n                if (s != null)\n                {\n                    if (info.getDataSetNumber() == IIM.DS(1, 90))\n                    {\n                        setCharacterSet((String) s.deserialize(ds.getData(), activeSerializationContext));\n                    }\n                }\n\n                dataSets.add(ds);\n\n                if (stopAfter9_10 && info.getDataSetNumber() == IIM.DS(9, 10))\n                    break;\n            }\n            catch (IIMFormatException e)\n            {\n                if (recoverFromIIMFormat && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (UnsupportedDataSetException e)\n            {\n                if (recoverFromUnsupportedDataSet && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (InvalidDataSetException e)\n            {\n                if (recoverFromInvalidDataSet && recover-- > 0)\n                {\n                    boolean r = reader.recover();\n                    if (doLog)\n                    {\n                        log.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\n                    }\n                    if (!r)\n                        break;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch (IOException e)\n            {\n                if (recover-- > 0 && !dataSets.isEmpty())\n                {\n                    if (doLog)\n                    {\n                        log.error(\"IOException while reading, however some data sets where recovered, \" + e);\n                    }\n                    return;\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n        }\n    }\n\n    public boolean remove(int dataSet)\n    {\n        boolean result = false;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if (info.getDataSetNumber() == dataSet)\n            {\n                i.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    public boolean removeRecord(int record)\n    {\n        boolean result = false;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            DataSetInfo info = ds.getInfo();\n            if ((info.getDataSetNumber() >> 8) == record)\n            {\n                i.remove();\n                result = true;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @param dataSets\n     *            The dataSets to set.\n     */\n    public void setDataSets(List<DataSet> dataSets)\n    {\n        this.dataSets = dataSets;\n    }\n\n    /**\n     * Sets logger for this IIMFile.\n     *\n     * @param log\n     *            logger to use with this file.\n     */\n    public void setLog(LoggerAdapter log)\n    {\n        this.log = log;\n    }\n\n    /**\n     * Should we recover from the IIM format violations, default is true.\n     *\n     * @param recoverFromIIMFormat\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromIIMFormat(boolean recoverFromIIMFormat)\n    {\n        this.recoverFromIIMFormat = recoverFromIIMFormat;\n    }\n\n    /**\n     * Should we recover from the invalid data sets, default is true.\n     *\n     * @param recoverFromInvalidDataSet\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromInvalidDataSet(boolean recoverFromInvalidDataSet)\n    {\n        this.recoverFromInvalidDataSet = recoverFromInvalidDataSet;\n    }\n\n    /**\n     * Should we recover from the unsupported data sets, default is true.\n     *\n     * @param recoverFromUnsupportedDataSet\n     *            true to recover, false to fail\n     */\n    public void setRecoverFromUnsupportedDataSet(boolean recoverFromUnsupportedDataSet)\n    {\n        this.recoverFromUnsupportedDataSet = recoverFromUnsupportedDataSet;\n    }\n\n    /**\n     * @param serializationContext\n     *            The serializationContext to set\n     */\n    public void setSerializationContext(SerializationContext serializationContext)\n    {\n        this.serializationContext = serializationContext;\n        activeSerializationContext = serializationContext != null ? serializationContext : this;\n    }\n\n    /**\n     * Controls if reading should stop after data set record 9,10. Default true.\n     *\n     * @param stopAfter9_10\n     *            true to stop reading, false to stop\n     */\n    public void setStopAfter9_10(boolean stopAfter9_10)\n    {\n        this.stopAfter9_10 = stopAfter9_10;\n    }\n\n    public String toString()\n    {\n        StringBuilder b = new StringBuilder();\n        b.append(\"IIMFile(\");\n        b.append(\"dataSets=\");\n        b.append(dataSets);\n        b.append(')');\n        return b.toString();\n    }\n\n    /**\n     * Writes this IIMFile to writer.\n     *\n     * @param writer\n     *            writer to write to\n     * @throws IOException\n     *             if file can't be written to\n     */\n    public void writeTo(IIMWriter writer) throws IOException\n    {\n        final boolean doLog = log != null;\n        for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();)\n        {\n            DataSet ds = i.next();\n            writer.write(ds);\n            if (doLog)\n            {\n                log.debug(\"Wrote data set \" + ds);\n            }\n        }\n    }\n\n    private Object getData(DataSet ds) throws SerializationException\n    {\n        DataSetInfo info = ds.getInfo();\n        Serializer s = info.getSerializer();\n        Object result;\n        if (s != null)\n        {\n            result = s.deserialize(ds.getData(), activeSerializationContext);\n        }\n        else\n        {\n            result = ds.getData();\n        }\n        return result;\n    }\n\n    /**\n     * Checks if data set is mandatory but missing or non repeatable but having\n     * multiple values in this IIM instance.\n     *\n     * @param info\n     *            IIM data set to check\n     * @return list of constraint violations, empty set if data set is valid\n     */\n    public Set<ConstraintViolation> validate(DataSetInfo info)\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        try\n        {\n            if (info.isMandatory() && get(info.getDataSetNumber()) == null)\n            {\n                errors.add(new ConstraintViolation(info, ConstraintViolation.MANDATORY_MISSING));\n            }\n            if (!info.isRepeatable() && getAll(info.getDataSetNumber()).size() > 1)\n            {\n                errors.add(new ConstraintViolation(info, ConstraintViolation.REPEATABLE_REPEATED));\n            }\n        }\n        catch (SerializationException e)\n        {\n            errors.add(new ConstraintViolation(info, ConstraintViolation.INVALID_VALUE));\n        }\n        return errors;\n    }\n\n    /**\n     * Checks all data sets in a given record for constraint violations.\n     *\n     * @param record\n     *            IIM record (1,2,3, ...) to check\n     *\n     * @return list of constraint violations, empty set if IIM file is valid\n     */\n    public Set<ConstraintViolation> validate(int record)\n    {\n        Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\n        for (int ds = 0; ds < 250; ++ds)\n        {\n            try\n            {\n                DataSetInfo dataSetInfo = dsiFactory.create(IIM.DS(record, ds));\n                errors.addAll(validate(dataSetInfo));\n            }\n            catch (InvalidDataSetException ignored)\n            {\n                // DataSetFactory doesn't know about this ds, so will skip it\n            }\n        }\n        return errors;\n    }\n\n    /**\n     * Checks all data sets in IIM records 1, 2 and 3 for constraint violations.\n     *\n     * @return list of constraint violations, empty set if IIM file is valid\n     */\n\n    private SerializationContext activeSerializationContext = this;\n    private List<DataSet> dataSets = new ArrayList<DataSet>();\n    private DataSetInfoFactory dsiFactory;\n    private LoggerAdapter log;\n    private boolean recoverFromIIMFormat = true;\n    private boolean recoverFromInvalidDataSet = true;\n    private boolean recoverFromUnsupportedDataSet = true;\n    private SerializationContext serializationContext;\n    private boolean stopAfter9_10 = true;\n}"}
{"repo": "Harium/keel", "path": "src/main/java/jdt/triangulation/PointComparator.java", "func_name": "PointComparator.compare", "original_string": "public int compare(Vector3 o1, Vector3 o2) {\n\t\tint ans = 0;\n\n\t\tif (o1 != null && o2 != null) {\n\t\t\tVector3 d1 = o1;\n\t\t\tVector3 d2 = o2;\n\n\t\t\tif (d1.x > d2.x)\n\t\t\t\treturn 1;\n\t\t\tif (d1.x < d2.x)\n\t\t\t\treturn -1;\n\t\t\t// x1 == x2\n\t\t\tif (d1.y > d2.y)\n\t\t\t\treturn 1;\n\t\t\tif (d1.y < d2.y)\n\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tif (o1 == null && o2 == null)\n\t\t\t\treturn 0;\n\t\t\tif (o1 == null && o2 != null)\n\t\t\t\treturn 1;\n\t\t\tif (o1 != null && o2 == null)\n\t\t\t\treturn -1;\n\t\t}\n\t\t\n\t\treturn ans;\n\t}", "language": "java", "code": "public int compare(Vector3 o1, Vector3 o2) {\n\t\tint ans = 0;\n\n\t\tif (o1 != null && o2 != null) {\n\t\t\tVector3 d1 = o1;\n\t\t\tVector3 d2 = o2;\n\n\t\t\tif (d1.x > d2.x)\n\t\t\t\treturn 1;\n\t\t\tif (d1.x < d2.x)\n\t\t\t\treturn -1;\n\t\t\t// x1 == x2\n\t\t\tif (d1.y > d2.y)\n\t\t\t\treturn 1;\n\t\t\tif (d1.y < d2.y)\n\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tif (o1 == null && o2 == null)\n\t\t\t\treturn 0;\n\t\t\tif (o1 == null && o2 != null)\n\t\t\t\treturn 1;\n\t\t\tif (o1 != null && o2 == null)\n\t\t\t\treturn -1;\n\t\t}\n\t\t\n\t\treturn ans;\n\t}", "code_tokens": ["public", "int", "compare", "(", "Vector3", "o1", ",", "Vector3", "o2", ")", "{", "int", "ans", "=", "0", ";", "if", "(", "o1", "!=", "null", "&&", "o2", "!=", "null", ")", "{", "Vector3", "d1", "=", "o1", ";", "Vector3", "d2", "=", "o2", ";", "if", "(", "d1", ".", "x", ">", "d2", ".", "x", ")", "return", "1", ";", "if", "(", "d1", ".", "x", "<", "d2", ".", "x", ")", "return", "-", "1", ";", "// x1 == x2", "if", "(", "d1", ".", "y", ">", "d2", ".", "y", ")", "return", "1", ";", "if", "(", "d1", ".", "y", "<", "d2", ".", "y", ")", "return", "-", "1", ";", "}", "else", "{", "if", "(", "o1", "==", "null", "&&", "o2", "==", "null", ")", "return", "0", ";", "if", "(", "o1", "==", "null", "&&", "o2", "!=", "null", ")", "return", "1", ";", "if", "(", "o1", "!=", "null", "&&", "o2", "==", "null", ")", "return", "-", "1", ";", "}", "return", "ans", ";", "}"], "docstring": "compare between two points.", "docstring_tokens": ["compare", "between", "two", "points", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/jdt/triangulation/PointComparator.java#L15-L41", "partition": "train", "up_fun_num": 2, "levels": [0, 1, 1, 1], "package": ["import com.badlogic.gdx.math.Vector3;", "import com.harium.etyl.geometry.Point3D;", "import java.util.Comparator;"], "function": ["public class PointComparator implements Comparator<Vector3>\n", "    public boolean equals(Point3D ob)\n", "    public static boolean isLess(Vector3 a, Vector3 b)\n", "    public static boolean isGreater(Vector3 a, Vector3 b)\n"], "context": "package jdt.triangulation;\n\nimport com.badlogic.gdx.math.Vector3;\nimport com.harium.etyl.geometry.Point3D;\n\nimport java.util.Comparator;\n\npublic class PointComparator implements Comparator<Vector3>\n{\n\n    public PointComparator()\n    {\n        super();\n    }\n\n    /** compare between two points. */\n\n    public boolean equals(Point3D ob)\n    {\n        return false;\n    }\n\n    public static boolean isLess(Vector3 a, Vector3 b)\n    {\n        return (a.x < b.x) || ((a.x == b.x) && (a.y < b.y));\n    }\n\n    public static boolean isGreater(Vector3 a, Vector3 b)\n    {\n        return (a.x > b.x) || ((a.x == b.x) && (a.y > b.y));\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/random/Random.java", "func_name": "Random.nextDouble", "original_string": "public double nextDouble(double lo, double hi) {\n        if (lo < 0) {\n            if (nextInt(2) == 0)\n                return -nextDouble(0, -lo);\n            else\n                return nextDouble(0, hi);\n        } else {\n            return (lo + (hi - lo) * nextDouble());\n        }\n    }", "language": "java", "code": "public double nextDouble(double lo, double hi) {\n        if (lo < 0) {\n            if (nextInt(2) == 0)\n                return -nextDouble(0, -lo);\n            else\n                return nextDouble(0, hi);\n        } else {\n            return (lo + (hi - lo) * nextDouble());\n        }\n    }", "code_tokens": ["public", "double", "nextDouble", "(", "double", "lo", ",", "double", "hi", ")", "{", "if", "(", "lo", "<", "0", ")", "{", "if", "(", "nextInt", "(", "2", ")", "==", "0", ")", "return", "-", "nextDouble", "(", "0", ",", "-", "lo", ")", ";", "else", "return", "nextDouble", "(", "0", ",", "hi", ")", ";", "}", "else", "{", "return", "(", "lo", "+", "(", "hi", "-", "lo", ")", "*", "nextDouble", "(", ")", ")", ";", "}", "}"], "docstring": "Generate a uniform random number in the range [lo, hi)\n\n@param lo lower limit of range\n@param hi upper limit of range\n@return a uniform random real in the range [lo, hi)", "docstring_tokens": ["Generate", "a", "uniform", "random", "number", "in", "the", "range", "[", "lo", "hi", ")"], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/random/Random.java#L92-L101", "partition": "train", "up_fun_num": 6, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": [], "function": ["public class Random\n", "    public long getSeed()\n", "    public void setSeed(long seed)\n", "    public double nextDouble()\n", "    public void nextDoubles(double[] d)\n", "    public void nextDoubles(double[] d, double lo, double hi)\n", "    public int nextInt()\n", "    public int nextInt(int n)\n", "    public long nextLong()\n", "    public int[] permutate(int n)\n", "    public void permutate(int[] x)\n", "    public void permutate(float[] x)\n", "    public void permutate(double[] x)\n", "    public void permutate(Object[] x)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright 2015 Diego Catalano\n// diego.catalano at live.com\n//\n// Copyright 2015 Haifeng Li\n// haifeng.hli at gmail.com\n//\n// Based on Smile (Statistical Machine Intelligence & Learning Engine)\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage com.harium.keel.catalano.math.random;\n\n/**\n * This is a high quality random number generator as a replacement of\n * the standard Random class of Java system.\n *\n * @author Haifeng Li\n */\npublic class Random\n{\n\n    private IRandomNumberGenerator rng;\n    private long seed;\n\n    public long getSeed()\n    {\n        return seed;\n    }\n\n    public void setSeed(long seed)\n    {\n        this.seed = seed;\n    }\n\n    /**\n     * Initialize with default random number generator engine.\n     */\n    public Random()\n    {\n        this(new UniversalGenerator());\n    }\n\n    /**\n     * Initialize with given seed for default random number generator engine.\n     */\n    public Random(long seed)\n    {\n        this(new UniversalGenerator(seed));\n    }\n\n    /**\n     * Initialize with given random number generator engine.\n     */\n    public Random(IRandomNumberGenerator rng)\n    {\n        this.rng = rng;\n    }\n\n    /**\n     * Generator a random number uniformly distributed in [0, 1).\n     *\n     * @return a pseudo random number\n     */\n    public double nextDouble()\n    {\n        return rng.nextDouble();\n    }\n\n    /**\n     * Generate n uniform random numbers in the range [0, 1)\n     *\n     * @param d array of random numbers to be generated\n     */\n    public void nextDoubles(double[] d)\n    {\n        rng.nextDoubles(d);\n    }\n\n    /**\n     * Generate a uniform random number in the range [lo, hi)\n     *\n     * @param lo lower limit of range\n     * @param hi upper limit of range\n     * @return a uniform random real in the range [lo, hi)\n     */\n\n    /**\n     * Generate n uniform random numbers in the range [lo, hi)\n     *\n     * @param lo lower limit of range\n     * @param hi upper limit of range\n     * @param d  array of random numbers to be generated\n     */\n    public void nextDoubles(double[] d, double lo, double hi)\n    {\n        rng.nextDoubles(d);\n\n        double l = hi - lo;\n        int n = d.length;\n        for (int i = 0; i < n; i++)\n        {\n            d[i] = lo + l * d[i];\n        }\n    }\n\n    /**\n     * Returns a random integer.\n     */\n    public int nextInt()\n    {\n        return rng.nextInt();\n    }\n\n    /**\n     * Returns a random integer in [0, n).\n     */\n    public int nextInt(int n)\n    {\n        return rng.nextInt(n);\n    }\n\n    public long nextLong()\n    {\n        return rng.nextLong();\n    }\n\n    /**\n     * Generates a permutation of 0, 1, 2, ..., n-1, which is useful for\n     * sampling without replacement.\n     */\n    public int[] permutate(int n)\n    {\n        int[] x = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            x[i] = i;\n        }\n\n        permutate(x);\n\n        return x;\n    }\n\n    /**\n     * Generates a permutation of given array.\n     */\n    public void permutate(int[] x)\n    {\n        for (int i = 0; i < x.length; i++)\n        {\n            int j = i + nextInt(x.length - i);\n            int s = x[i];\n            x[i] = x[j];\n            x[j] = s;\n        }\n    }\n\n    /**\n     * Generates a permutation of given array.\n     */\n    public void permutate(float[] x)\n    {\n        for (int i = 0; i < x.length; i++)\n        {\n            int j = i + nextInt(x.length - i);\n            float s = x[i];\n            x[i] = x[j];\n            x[j] = s;\n        }\n    }\n\n    /**\n     * Generates a permutation of given array.\n     */\n    public void permutate(double[] x)\n    {\n        for (int i = 0; i < x.length; i++)\n        {\n            int j = i + nextInt(x.length - i);\n            double s = x[i];\n            x[i] = x[j];\n            x[j] = s;\n        }\n    }\n\n    /**\n     * Generates a permutation of given array.\n     */\n    public void permutate(Object[] x)\n    {\n        for (int i = 0; i < x.length; i++)\n        {\n            int j = i + nextInt(x.length - i);\n            Object s = x[i];\n            x[i] = x[j];\n            x[j] = s;\n        }\n    }\n}"}
{"repo": "artikcloud/artikcloud-java", "path": "src/main/java/cloud/artik/api/TagsApi.java", "func_name": "TagsApi.getTagCategoriesWithHttpInfo", "original_string": "public ApiResponse<TagsEnvelope> getTagCategoriesWithHttpInfo() throws ApiException {\n        com.squareup.okhttp.Call call = getTagCategoriesValidateBeforeCall(null, null);\n        Type localVarReturnType = new TypeToken<TagsEnvelope>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }", "language": "java", "code": "public ApiResponse<TagsEnvelope> getTagCategoriesWithHttpInfo() throws ApiException {\n        com.squareup.okhttp.Call call = getTagCategoriesValidateBeforeCall(null, null);\n        Type localVarReturnType = new TypeToken<TagsEnvelope>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }", "code_tokens": ["public", "ApiResponse", "<", "TagsEnvelope", ">", "getTagCategoriesWithHttpInfo", "(", ")", "throws", "ApiException", "{", "com", ".", "squareup", ".", "okhttp", ".", "Call", "call", "=", "getTagCategoriesValidateBeforeCall", "(", "null", ",", "null", ")", ";", "Type", "localVarReturnType", "=", "new", "TypeToken", "<", "TagsEnvelope", ">", "(", ")", "{", "}", ".", "getType", "(", ")", ";", "return", "apiClient", ".", "execute", "(", "call", ",", "localVarReturnType", ")", ";", "}"], "docstring": "Get all categories\nGet all tags marked as categories\n@return ApiResponse&lt;TagsEnvelope&gt;\n@throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body", "docstring_tokens": ["Get", "all", "categories", "Get", "all", "tags", "marked", "as", "categories"], "sha": "412f447573e7796ab4f685c0bdd5eb76185a365c", "url": "https://github.com/artikcloud/artikcloud-java/blob/412f447573e7796ab4f685c0bdd5eb76185a365c/src/main/java/cloud/artik/api/TagsApi.java#L128-L132", "partition": "train", "up_fun_num": 7, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import cloud.artik.client.ApiCallback;", "import cloud.artik.client.ApiClient;", "import cloud.artik.client.ApiException;", "import cloud.artik.client.ApiResponse;", "import cloud.artik.client.Configuration;", "import cloud.artik.client.Pair;", "import cloud.artik.client.ProgressRequestBody;", "import cloud.artik.client.ProgressResponseBody;", "import com.google.gson.reflect.TypeToken;", "import java.io.IOException;", "import cloud.artik.model.TagsEnvelope;", "import java.lang.reflect.Type;", "import java.util.ArrayList;", "import java.util.HashMap;", "import java.util.List;", "import java.util.Map;"], "function": ["public class TagsApi\n", "    public ApiClient getApiClient()\n", "    public void setApiClient(ApiClient apiClient)\n", "    private com.squareup.okhttp.Call getTagCategoriesCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call getTagCategoriesValidateBeforeCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public TagsEnvelope getTagCategories() throws ApiException\n", "    public com.squareup.okhttp.Call getTagCategoriesAsync(final ApiCallback<TagsEnvelope> callback) throws ApiException\n", "    private com.squareup.okhttp.Call getTagSuggestionsCall(String entityType, String tags, String name, Integer count, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call getTagSuggestionsValidateBeforeCall(String entityType, String tags, String name, Integer count, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public TagsEnvelope getTagSuggestions(String entityType, String tags, String name, Integer count) throws ApiException\n", "    public ApiResponse<TagsEnvelope> getTagSuggestionsWithHttpInfo(String entityType, String tags, String name, Integer count) throws ApiException\n", "    public com.squareup.okhttp.Call getTagSuggestionsAsync(String entityType, String tags, String name, Integer count, final ApiCallback<TagsEnvelope> callback) throws ApiException\n", "    private com.squareup.okhttp.Call getTagsByCategoriesCall(String categories, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call getTagsByCategoriesValidateBeforeCall(String categories, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public TagsEnvelope getTagsByCategories(String categories) throws ApiException\n", "    public ApiResponse<TagsEnvelope> getTagsByCategoriesWithHttpInfo(String categories) throws ApiException\n", "    public com.squareup.okhttp.Call getTagsByCategoriesAsync(String categories, final ApiCallback<TagsEnvelope> callback) throws ApiException\n"], "context": "/*\n * ARTIK Cloud API\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 2.0.0\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n\npackage cloud.artik.api;\n\nimport cloud.artik.client.ApiCallback;\nimport cloud.artik.client.ApiClient;\nimport cloud.artik.client.ApiException;\nimport cloud.artik.client.ApiResponse;\nimport cloud.artik.client.Configuration;\nimport cloud.artik.client.Pair;\nimport cloud.artik.client.ProgressRequestBody;\nimport cloud.artik.client.ProgressResponseBody;\n\nimport com.google.gson.reflect.TypeToken;\n\nimport java.io.IOException;\n\n\nimport cloud.artik.model.TagsEnvelope;\n\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class TagsApi\n{\n    private ApiClient apiClient;\n\n    public TagsApi()\n    {\n        this(Configuration.getDefaultApiClient());\n    }\n\n    public TagsApi(ApiClient apiClient)\n    {\n        this.apiClient = apiClient;\n    }\n\n    public ApiClient getApiClient()\n    {\n        return apiClient;\n    }\n\n    public void setApiClient(ApiClient apiClient)\n    {\n        this.apiClient = apiClient;\n    }\n\n    /* Build call for getTagCategories */\n    private com.squareup.okhttp.Call getTagCategoriesCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/tags/categories\".replaceAll(\"\\\\{format\\\\}\", \"json\");\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call getTagCategoriesValidateBeforeCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n\n        com.squareup.okhttp.Call call = getTagCategoriesCall(progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Get all categories\n     * Get all tags marked as categories\n     * @return TagsEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public TagsEnvelope getTagCategories() throws ApiException\n    {\n        ApiResponse<TagsEnvelope> resp = getTagCategoriesWithHttpInfo();\n        return resp.getData();\n    }\n\n    /**\n     * Get all categories\n     * Get all tags marked as categories\n     * @return ApiResponse&lt;TagsEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n\n    /**\n     * Get all categories (asynchronously)\n     * Get all tags marked as categories\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call getTagCategoriesAsync(final ApiCallback<TagsEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = getTagCategoriesValidateBeforeCall(progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<TagsEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /* Build call for getTagSuggestions */\n    private com.squareup.okhttp.Call getTagSuggestionsCall(String entityType, String tags, String name, Integer count, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/tags/suggestions\".replaceAll(\"\\\\{format\\\\}\", \"json\");\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        if (entityType != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"entity_type\", entityType));\n        if (tags != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"tags\", tags));\n        if (name != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"name\", name));\n        if (count != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"count\", count));\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call getTagSuggestionsValidateBeforeCall(String entityType, String tags, String name, Integer count, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n\n        com.squareup.okhttp.Call call = getTagSuggestionsCall(entityType, tags, name, count, progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Get tag suggestions\n     * Get tag suggestions for applications, device types that have been most used with a group of tags.\n     * @param entityType Entity type name. (optional)\n     * @param tags Comma separated list of tags. (optional)\n     * @param name Name of tags used for type ahead. (optional)\n     * @param count Number of results to return. Max 10. (optional)\n     * @return TagsEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public TagsEnvelope getTagSuggestions(String entityType, String tags, String name, Integer count) throws ApiException\n    {\n        ApiResponse<TagsEnvelope> resp = getTagSuggestionsWithHttpInfo(entityType, tags, name, count);\n        return resp.getData();\n    }\n\n    /**\n     * Get tag suggestions\n     * Get tag suggestions for applications, device types that have been most used with a group of tags.\n     * @param entityType Entity type name. (optional)\n     * @param tags Comma separated list of tags. (optional)\n     * @param name Name of tags used for type ahead. (optional)\n     * @param count Number of results to return. Max 10. (optional)\n     * @return ApiResponse&lt;TagsEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<TagsEnvelope> getTagSuggestionsWithHttpInfo(String entityType, String tags, String name, Integer count) throws ApiException\n    {\n        com.squareup.okhttp.Call call = getTagSuggestionsValidateBeforeCall(entityType, tags, name, count, null, null);\n        Type localVarReturnType = new TypeToken<TagsEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Get tag suggestions (asynchronously)\n     * Get tag suggestions for applications, device types that have been most used with a group of tags.\n     * @param entityType Entity type name. (optional)\n     * @param tags Comma separated list of tags. (optional)\n     * @param name Name of tags used for type ahead. (optional)\n     * @param count Number of results to return. Max 10. (optional)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call getTagSuggestionsAsync(String entityType, String tags, String name, Integer count, final ApiCallback<TagsEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = getTagSuggestionsValidateBeforeCall(entityType, tags, name, count, progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<TagsEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /* Build call for getTagsByCategories */\n    private com.squareup.okhttp.Call getTagsByCategoriesCall(String categories, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/tags\".replaceAll(\"\\\\{format\\\\}\", \"json\");\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        if (categories != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"categories\", categories));\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call getTagsByCategoriesValidateBeforeCall(String categories, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n\n        com.squareup.okhttp.Call call = getTagsByCategoriesCall(categories, progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Get all tags of categories\n     * Get all tags related to the list of categories\n     * @param categories Comma separated list of categories. (optional)\n     * @return TagsEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public TagsEnvelope getTagsByCategories(String categories) throws ApiException\n    {\n        ApiResponse<TagsEnvelope> resp = getTagsByCategoriesWithHttpInfo(categories);\n        return resp.getData();\n    }\n\n    /**\n     * Get all tags of categories\n     * Get all tags related to the list of categories\n     * @param categories Comma separated list of categories. (optional)\n     * @return ApiResponse&lt;TagsEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<TagsEnvelope> getTagsByCategoriesWithHttpInfo(String categories) throws ApiException\n    {\n        com.squareup.okhttp.Call call = getTagsByCategoriesValidateBeforeCall(categories, null, null);\n        Type localVarReturnType = new TypeToken<TagsEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Get all tags of categories (asynchronously)\n     * Get all tags related to the list of categories\n     * @param categories Comma separated list of categories. (optional)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call getTagsByCategoriesAsync(String categories, final ApiCallback<TagsEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = getTagsByCategoriesValidateBeforeCall(categories, progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<TagsEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n}"}
{"repo": "artikcloud/artikcloud-java", "path": "src/main/java/cloud/artik/api/RulesApi.java", "func_name": "RulesApi.getRule", "original_string": "public RuleEnvelope getRule(String ruleId) throws ApiException {\n        ApiResponse<RuleEnvelope> resp = getRuleWithHttpInfo(ruleId);\n        return resp.getData();\n    }", "language": "java", "code": "public RuleEnvelope getRule(String ruleId) throws ApiException {\n        ApiResponse<RuleEnvelope> resp = getRuleWithHttpInfo(ruleId);\n        return resp.getData();\n    }", "code_tokens": ["public", "RuleEnvelope", "getRule", "(", "String", "ruleId", ")", "throws", "ApiException", "{", "ApiResponse", "<", "RuleEnvelope", ">", "resp", "=", "getRuleWithHttpInfo", "(", "ruleId", ")", ";", "return", "resp", ".", "getData", "(", ")", ";", "}"], "docstring": "Get Rule\nGet a rule using the Rule ID\n@param ruleId Rule ID. (required)\n@return RuleEnvelope\n@throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body", "docstring_tokens": ["Get", "Rule", "Get", "a", "rule", "using", "the", "Rule", "ID"], "sha": "412f447573e7796ab4f685c0bdd5eb76185a365c", "url": "https://github.com/artikcloud/artikcloud-java/blob/412f447573e7796ab4f685c0bdd5eb76185a365c/src/main/java/cloud/artik/api/RulesApi.java#L373-L376", "partition": "train", "up_fun_num": 16, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import cloud.artik.client.ApiCallback;", "import cloud.artik.client.ApiClient;", "import cloud.artik.client.ApiException;", "import cloud.artik.client.ApiResponse;", "import cloud.artik.client.Configuration;", "import cloud.artik.client.Pair;", "import cloud.artik.client.ProgressRequestBody;", "import cloud.artik.client.ProgressResponseBody;", "import com.google.gson.reflect.TypeToken;", "import java.io.IOException;", "import cloud.artik.model.RuleCreationInfo;", "import cloud.artik.model.RuleEnvelope;", "import cloud.artik.model.RuleUpdateInfo;", "import java.lang.reflect.Type;", "import java.util.ArrayList;", "import java.util.HashMap;", "import java.util.List;", "import java.util.Map;"], "function": ["public class RulesApi\n", "    public ApiClient getApiClient()\n", "    public void setApiClient(ApiClient apiClient)\n", "    private com.squareup.okhttp.Call createRuleCall(RuleCreationInfo ruleInfo, String userId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call createRuleValidateBeforeCall(RuleCreationInfo ruleInfo, String userId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public RuleEnvelope createRule(RuleCreationInfo ruleInfo, String userId) throws ApiException\n", "    public ApiResponse<RuleEnvelope> createRuleWithHttpInfo(RuleCreationInfo ruleInfo, String userId) throws ApiException\n", "    public com.squareup.okhttp.Call createRuleAsync(RuleCreationInfo ruleInfo, String userId, final ApiCallback<RuleEnvelope> callback) throws ApiException\n", "    private com.squareup.okhttp.Call deleteRuleCall(String ruleId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call deleteRuleValidateBeforeCall(String ruleId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public RuleEnvelope deleteRule(String ruleId) throws ApiException\n", "    public ApiResponse<RuleEnvelope> deleteRuleWithHttpInfo(String ruleId) throws ApiException\n", "    public com.squareup.okhttp.Call deleteRuleAsync(String ruleId, final ApiCallback<RuleEnvelope> callback) throws ApiException\n", "    private com.squareup.okhttp.Call getRuleCall(String ruleId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call getRuleValidateBeforeCall(String ruleId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public ApiResponse<RuleEnvelope> getRuleWithHttpInfo(String ruleId) throws ApiException\n", "    public com.squareup.okhttp.Call getRuleAsync(String ruleId, final ApiCallback<RuleEnvelope> callback) throws ApiException\n", "    private com.squareup.okhttp.Call updateRuleCall(String ruleId, RuleUpdateInfo ruleInfo, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call updateRuleValidateBeforeCall(String ruleId, RuleUpdateInfo ruleInfo, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public RuleEnvelope updateRule(String ruleId, RuleUpdateInfo ruleInfo) throws ApiException\n", "    public ApiResponse<RuleEnvelope> updateRuleWithHttpInfo(String ruleId, RuleUpdateInfo ruleInfo) throws ApiException\n", "    public com.squareup.okhttp.Call updateRuleAsync(String ruleId, RuleUpdateInfo ruleInfo, final ApiCallback<RuleEnvelope> callback) throws ApiException\n"], "context": "/*\n * ARTIK Cloud API\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 2.0.0\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n\npackage cloud.artik.api;\n\nimport cloud.artik.client.ApiCallback;\nimport cloud.artik.client.ApiClient;\nimport cloud.artik.client.ApiException;\nimport cloud.artik.client.ApiResponse;\nimport cloud.artik.client.Configuration;\nimport cloud.artik.client.Pair;\nimport cloud.artik.client.ProgressRequestBody;\nimport cloud.artik.client.ProgressResponseBody;\n\nimport com.google.gson.reflect.TypeToken;\n\nimport java.io.IOException;\n\n\nimport cloud.artik.model.RuleCreationInfo;\nimport cloud.artik.model.RuleEnvelope;\nimport cloud.artik.model.RuleUpdateInfo;\n\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class RulesApi\n{\n    private ApiClient apiClient;\n\n    public RulesApi()\n    {\n        this(Configuration.getDefaultApiClient());\n    }\n\n    public RulesApi(ApiClient apiClient)\n    {\n        this.apiClient = apiClient;\n    }\n\n    public ApiClient getApiClient()\n    {\n        return apiClient;\n    }\n\n    public void setApiClient(ApiClient apiClient)\n    {\n        this.apiClient = apiClient;\n    }\n\n    /* Build call for createRule */\n    private com.squareup.okhttp.Call createRuleCall(RuleCreationInfo ruleInfo, String userId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = ruleInfo;\n\n        // create path and map variables\n        String localVarPath = \"/rules\".replaceAll(\"\\\\{format\\\\}\", \"json\");\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        if (userId != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"userId\", userId));\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call createRuleValidateBeforeCall(RuleCreationInfo ruleInfo, String userId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n        // verify the required parameter 'ruleInfo' is set\n        if (ruleInfo == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'ruleInfo' when calling createRule(Async)\");\n        }\n\n        // verify the required parameter 'userId' is set\n        if (userId == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'userId' when calling createRule(Async)\");\n        }\n\n\n        com.squareup.okhttp.Call call = createRuleCall(ruleInfo, userId, progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Create Rule\n     * Create a new Rule\n     * @param ruleInfo Rule object that needs to be added (required)\n     * @param userId User ID (required)\n     * @return RuleEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public RuleEnvelope createRule(RuleCreationInfo ruleInfo, String userId) throws ApiException\n    {\n        ApiResponse<RuleEnvelope> resp = createRuleWithHttpInfo(ruleInfo, userId);\n        return resp.getData();\n    }\n\n    /**\n     * Create Rule\n     * Create a new Rule\n     * @param ruleInfo Rule object that needs to be added (required)\n     * @param userId User ID (required)\n     * @return ApiResponse&lt;RuleEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<RuleEnvelope> createRuleWithHttpInfo(RuleCreationInfo ruleInfo, String userId) throws ApiException\n    {\n        com.squareup.okhttp.Call call = createRuleValidateBeforeCall(ruleInfo, userId, null, null);\n        Type localVarReturnType = new TypeToken<RuleEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Create Rule (asynchronously)\n     * Create a new Rule\n     * @param ruleInfo Rule object that needs to be added (required)\n     * @param userId User ID (required)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call createRuleAsync(RuleCreationInfo ruleInfo, String userId, final ApiCallback<RuleEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = createRuleValidateBeforeCall(ruleInfo, userId, progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<RuleEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /* Build call for deleteRule */\n    private com.squareup.okhttp.Call deleteRuleCall(String ruleId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/rules/{ruleId}\".replaceAll(\"\\\\{format\\\\}\", \"json\")\n                              .replaceAll(\"\\\\{\" + \"ruleId\" + \"\\\\}\", apiClient.escapeString(ruleId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"DELETE\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call deleteRuleValidateBeforeCall(String ruleId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n        // verify the required parameter 'ruleId' is set\n        if (ruleId == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'ruleId' when calling deleteRule(Async)\");\n        }\n\n\n        com.squareup.okhttp.Call call = deleteRuleCall(ruleId, progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Delete Rule\n     * Delete a Rule\n     * @param ruleId Rule ID. (required)\n     * @return RuleEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public RuleEnvelope deleteRule(String ruleId) throws ApiException\n    {\n        ApiResponse<RuleEnvelope> resp = deleteRuleWithHttpInfo(ruleId);\n        return resp.getData();\n    }\n\n    /**\n     * Delete Rule\n     * Delete a Rule\n     * @param ruleId Rule ID. (required)\n     * @return ApiResponse&lt;RuleEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<RuleEnvelope> deleteRuleWithHttpInfo(String ruleId) throws ApiException\n    {\n        com.squareup.okhttp.Call call = deleteRuleValidateBeforeCall(ruleId, null, null);\n        Type localVarReturnType = new TypeToken<RuleEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Delete Rule (asynchronously)\n     * Delete a Rule\n     * @param ruleId Rule ID. (required)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call deleteRuleAsync(String ruleId, final ApiCallback<RuleEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = deleteRuleValidateBeforeCall(ruleId, progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<RuleEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /* Build call for getRule */\n    private com.squareup.okhttp.Call getRuleCall(String ruleId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/rules/{ruleId}\".replaceAll(\"\\\\{format\\\\}\", \"json\")\n                              .replaceAll(\"\\\\{\" + \"ruleId\" + \"\\\\}\", apiClient.escapeString(ruleId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call getRuleValidateBeforeCall(String ruleId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n        // verify the required parameter 'ruleId' is set\n        if (ruleId == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'ruleId' when calling getRule(Async)\");\n        }\n\n\n        com.squareup.okhttp.Call call = getRuleCall(ruleId, progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Get Rule\n     * Get a rule using the Rule ID\n     * @param ruleId Rule ID. (required)\n     * @return RuleEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n\n    /**\n     * Get Rule\n     * Get a rule using the Rule ID\n     * @param ruleId Rule ID. (required)\n     * @return ApiResponse&lt;RuleEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<RuleEnvelope> getRuleWithHttpInfo(String ruleId) throws ApiException\n    {\n        com.squareup.okhttp.Call call = getRuleValidateBeforeCall(ruleId, null, null);\n        Type localVarReturnType = new TypeToken<RuleEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Get Rule (asynchronously)\n     * Get a rule using the Rule ID\n     * @param ruleId Rule ID. (required)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call getRuleAsync(String ruleId, final ApiCallback<RuleEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = getRuleValidateBeforeCall(ruleId, progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<RuleEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /* Build call for updateRule */\n    private com.squareup.okhttp.Call updateRuleCall(String ruleId, RuleUpdateInfo ruleInfo, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = ruleInfo;\n\n        // create path and map variables\n        String localVarPath = \"/rules/{ruleId}\".replaceAll(\"\\\\{format\\\\}\", \"json\")\n                              .replaceAll(\"\\\\{\" + \"ruleId\" + \"\\\\}\", apiClient.escapeString(ruleId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"PUT\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call updateRuleValidateBeforeCall(String ruleId, RuleUpdateInfo ruleInfo, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n        // verify the required parameter 'ruleId' is set\n        if (ruleId == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'ruleId' when calling updateRule(Async)\");\n        }\n\n        // verify the required parameter 'ruleInfo' is set\n        if (ruleInfo == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'ruleInfo' when calling updateRule(Async)\");\n        }\n\n\n        com.squareup.okhttp.Call call = updateRuleCall(ruleId, ruleInfo, progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Update Rule\n     * Update an existing Rule\n     * @param ruleId Rule ID. (required)\n     * @param ruleInfo Rule object that needs to be updated (required)\n     * @return RuleEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public RuleEnvelope updateRule(String ruleId, RuleUpdateInfo ruleInfo) throws ApiException\n    {\n        ApiResponse<RuleEnvelope> resp = updateRuleWithHttpInfo(ruleId, ruleInfo);\n        return resp.getData();\n    }\n\n    /**\n     * Update Rule\n     * Update an existing Rule\n     * @param ruleId Rule ID. (required)\n     * @param ruleInfo Rule object that needs to be updated (required)\n     * @return ApiResponse&lt;RuleEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<RuleEnvelope> updateRuleWithHttpInfo(String ruleId, RuleUpdateInfo ruleInfo) throws ApiException\n    {\n        com.squareup.okhttp.Call call = updateRuleValidateBeforeCall(ruleId, ruleInfo, null, null);\n        Type localVarReturnType = new TypeToken<RuleEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Update Rule (asynchronously)\n     * Update an existing Rule\n     * @param ruleId Rule ID. (required)\n     * @param ruleInfo Rule object that needs to be updated (required)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call updateRuleAsync(String ruleId, RuleUpdateInfo ruleInfo, final ApiCallback<RuleEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = updateRuleValidateBeforeCall(ruleId, ruleInfo, progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<RuleEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/filter/search/flood/FloodFillSearch.java", "func_name": "FloodFillSearch.addNeighbor", "original_string": "protected void addNeighbor(Queue<ColorPoint> queue, int px, int py, int color, Feature component) {\n        if (!inBoundary(px, py, component)) {\n            return;\n        }\n\n        if (!mask.isTouched(px, py)) {\n            queue.add(new ColorPoint(px, py, color));\n        }\n    }", "language": "java", "code": "protected void addNeighbor(Queue<ColorPoint> queue, int px, int py, int color, Feature component) {\n        if (!inBoundary(px, py, component)) {\n            return;\n        }\n\n        if (!mask.isTouched(px, py)) {\n            queue.add(new ColorPoint(px, py, color));\n        }\n    }", "code_tokens": ["protected", "void", "addNeighbor", "(", "Queue", "<", "ColorPoint", ">", "queue", ",", "int", "px", ",", "int", "py", ",", "int", "color", ",", "Feature", "component", ")", "{", "if", "(", "!", "inBoundary", "(", "px", ",", "py", ",", "component", ")", ")", "{", "return", ";", "}", "if", "(", "!", "mask", ".", "isTouched", "(", "px", ",", "py", ")", ")", "{", "queue", ".", "add", "(", "new", "ColorPoint", "(", "px", ",", "py", ",", "color", ")", ")", ";", "}", "}"], "docstring": "May have to be changed to let multiple touch", "docstring_tokens": ["May", "have", "to", "be", "changed", "to", "let", "multiple", "touch"], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/filter/search/flood/FloodFillSearch.java#L137-L145", "partition": "train", "up_fun_num": 9, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.etyl.geometry.Point2D;", "import com.harium.keel.core.model.ColorPoint;", "import com.harium.keel.filter.ComponentFilter;", "import com.harium.keel.core.mask.DynamicArrayMask;", "import com.harium.keel.core.mask.DynamicMask;", "import com.harium.keel.core.source.ImageSource;", "import com.harium.keel.feature.Feature;", "import com.harium.keel.feature.PointFeature;", "import com.harium.keel.filter.color.RGBColorStrategy;", "import java.util.LinkedList;", "import java.util.Queue;"], "function": ["public class FloodFillSearch extends ComponentFilter\n", "    public void setup(ImageSource source, Feature feature)\n", "    protected void updateMask(int w, int h, ImageSource source)\n", "    public boolean filterFirst(int x, int y, int width, int height, ImageSource source, Feature component)\n", "    public boolean filter(int x, int y, int width, int height, ImageSource source, Feature component)\n", "    protected boolean verifyNext(Point2D p, int x, int y, int width,\n", "    protected void addPoint(PointFeature component, ColorPoint p)\n", "    protected void addNeighbors(Queue<ColorPoint> queue, ColorPoint p, Feature component)\n", "    protected boolean verifyPixel(int px, int py, int rgb, ImageSource source, Feature component)\n", "    protected boolean verifySinglePixel(int px, int py, int rgb)\n", "    protected boolean verifyNeighbors(int px, int py, ImageSource source, Feature component)\n", "    protected boolean inBoundary(int x, int y, Feature component)\n", "    public int getMinNeighbors()\n", "    public void setMinNeighbors(int minNeighbors)\n", "    public int getMaxNeighbors()\n", "    public void setMaxNeighbors(int maxNeighbors)\n"], "context": "package com.harium.keel.filter.search.flood;\n\nimport com.harium.etyl.geometry.Point2D;\nimport com.harium.keel.core.model.ColorPoint;\nimport com.harium.keel.filter.ComponentFilter;\nimport com.harium.keel.core.mask.DynamicArrayMask;\nimport com.harium.keel.core.mask.DynamicMask;\nimport com.harium.keel.core.source.ImageSource;\nimport com.harium.keel.feature.Feature;\nimport com.harium.keel.feature.PointFeature;\nimport com.harium.keel.filter.color.RGBColorStrategy;\n\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class FloodFillSearch extends ComponentFilter\n{\n\n    protected int minNeighbors = 1;\n    protected int maxNeighbors = 9;\n\n    protected DynamicMask mask;\n\n    public FloodFillSearch(int w, int h)\n    {\n        super(w, h, new RGBColorStrategy());\n\n        mask = new DynamicArrayMask(w, h);\n    }\n\n    public FloodFillSearch(int w, int h, int minNeighbors)\n    {\n        super(w, h, new RGBColorStrategy());\n\n        mask = new DynamicArrayMask(w, h);\n\n        this.minNeighbors = minNeighbors;\n    }\n\n    public FloodFillSearch(int w, int h, int minNeighbors, int maxNeighbors)\n    {\n        super(w, h, new RGBColorStrategy());\n\n        this.minNeighbors = minNeighbors;\n        this.maxNeighbors = maxNeighbors;\n    }\n\n    public void setup(ImageSource source, Feature feature)\n    {\n        super.setup(source, feature);\n\n        int w = feature.getWidth();\n        int h = feature.getHeight();\n        updateMask(w, h, source);\n    }\n\n    protected void updateMask(int w, int h, ImageSource source)\n    {\n        if (mask.getW() != w || mask.getH() != h)\n        {\n            mask.init(w, h);\n        }\n\n        mask.update(source);\n    }\n\n    @Override\n    public boolean filterFirst(int x, int y, int width, int height, ImageSource source, Feature component)\n    {\n        return filter(x, y, width, height, source, component);\n    }\n\n    @Override\n    public boolean filter(int x, int y, int width, int height, ImageSource source, Feature component)\n    {\n        int rgb = source.getRGB(x, y);\n\n        if (verifySinglePixel(x, y, rgb))\n        {\n\n            //Clear Queue\n            Queue<ColorPoint> queue = new LinkedList<>();\n            PointFeature found = new PointFeature();\n\n            ColorPoint firstPoint = new ColorPoint(x, y, rgb);\n\n            //Mark as touched\n            addPoint(found, firstPoint);\n            addNeighbors(queue, firstPoint, component);\n\n            //For each neighbor\n            while (!queue.isEmpty())\n            {\n\n                //Queue.pop();\n                ColorPoint p = queue.remove();\n\n                if (verifyNext(p, x, y, width, height, source, component))\n                {\n                    addPoint(found, p);\n                    addNeighbors(queue, p, component);\n                }\n                else\n                {\n                    mask.setTouched(x, y);\n                }\n            }\n\n            if (this.validate(found))\n            {\n                results.add(componentModifierStrategy.modifyComponent(found));\n            }\n        }\n        else\n        {\n            mask.setTouched(x, y);\n        }\n\n        return false;\n    }\n\n    protected boolean verifyNext(Point2D p, int x, int y, int width,\n                                 int height, ImageSource source, Feature component)\n    {\n\n        int px = (int) p.x;\n        int py = (int) p.y;\n\n        int rgb = source.getRGB(px, py);\n\n        if ((px >= x) && (px < x + width &&\n                          (py >= y) && (py < y + height)))\n        {\n\n            if (verifyPixel(px, py, rgb, source, component))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    protected void addPoint(PointFeature component, ColorPoint p)\n    {\n        mask.setTouched((int) p.x, (int) p.y);\n        component.add(p);\n    }\n\n    protected void addNeighbors(Queue<ColorPoint> queue, ColorPoint p, Feature component)\n    {\n        addNeighbor(queue, (int) p.x + step, (int) p.y, p.getColor(), component);\n        addNeighbor(queue, (int) p.x - step, (int) p.y, p.getColor(), component);\n        addNeighbor(queue, (int) p.x, (int) p.y + step, p.getColor(), component);\n        addNeighbor(queue, (int) p.x, (int) p.y - step, p.getColor(), component);\n    }\n\n    //It also prevents same pixel be included in a better list of neighbors\n    //May have to be changed to let multiple touch\n\n    protected boolean verifyPixel(int px, int py, int rgb, ImageSource source, Feature component)\n    {\n        if (verifySinglePixel(px, py, rgb))\n        {\n            if (!verifyNeighbors(px, py, source, component))\n            {\n                return false;\n            }\n            return true;\n        }\n\n        return false;\n\n    }\n\n    protected boolean verifySinglePixel(int px, int py, int rgb)\n    {\n\n        if (mask.isUnknown(px, py))\n        {\n            if (selectionStrategy.validateColor(rgb, px, py))\n            {\n                mask.setValid(px, py);\n            }\n            else\n            {\n                mask.setInvalid(px, py);\n            }\n        }\n\n        return (!mask.isTouched(px, py) && mask.isValid(px, py));\n    }\n\n    protected boolean verifyNeighbors(int px, int py, ImageSource source, Feature component)\n    {\n        int count = 0;\n\n        for (int y = py - step; y <= py + step; y += step)\n        {\n            for (int x = px - step; x <= px + step; x += step)\n            {\n                if (!inBoundary(x, y, component))\n                {\n                    continue;\n                }\n\n                if (mask.isValid(x, y))\n                {\n                    count++;\n                }\n                else if (selectionStrategy.validateColor(source.getRGB(x, y), x, y))\n                {\n                    count++;\n                }\n            }\n        }\n\n        return count >= minNeighbors && count <= maxNeighbors;\n    }\n\n    protected boolean inBoundary(int x, int y, Feature component)\n    {\n        return component.contains(x, y);\n    }\n\n    public int getMinNeighbors()\n    {\n        return minNeighbors;\n    }\n\n    public void setMinNeighbors(int minNeighbors)\n    {\n        this.minNeighbors = minNeighbors;\n    }\n\n    public int getMaxNeighbors()\n    {\n        return maxNeighbors;\n    }\n\n    public void setMaxNeighbors(int maxNeighbors)\n    {\n        this.maxNeighbors = maxNeighbors;\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/function/Gaussian.java", "func_name": "Gaussian.Function1D", "original_string": "public double Function1D(double x) {\n        return Math.exp(x * x / (-2 * sqrSigma)) / (Math.sqrt(2 * Math.PI) * sigma);\n    }", "language": "java", "code": "public double Function1D(double x) {\n        return Math.exp(x * x / (-2 * sqrSigma)) / (Math.sqrt(2 * Math.PI) * sigma);\n    }", "code_tokens": ["public", "double", "Function1D", "(", "double", "x", ")", "{", "return", "Math", ".", "exp", "(", "x", "*", "x", "/", "(", "-", "2", "*", "sqrSigma", ")", ")", "/", "(", "Math", ".", "sqrt", "(", "2", "*", "Math", ".", "PI", ")", "*", "sigma", ")", ";", "}"], "docstring": "1-D Gaussian function.\n\n@param x value.\n@return Function's value at point x.", "docstring_tokens": ["1", "-", "D", "Gaussian", "function", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/function/Gaussian.java#L80-L82", "partition": "train", "up_fun_num": 4, "levels": [0, 1, 1, 1, 1, 1], "package": [], "function": ["public class Gaussian\n", "    public double getSigma()\n", "    public void setSigma(double sigma)\n", "    public double Function2D(double x, double y)\n", "    public double[] Kernel1D(int size)\n", "    public double[][] Kernel2D(int size)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2007-2008\n// andrew.kirillov at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.function;\n\n/**\n * Gaussian function.\n * <br /> The class is used to calculate 1D and 2D Gaussian functions for specified Sigma (s) value:\n * <br />\n * <code lang = \"none\">\n * <br /> 1-D: f(x) = exp( x * x / ( -2 * s * s ) ) / ( s * sqrt( 2 * PI ) )\n * <br />\n * <br /> 2-D: f(x, y) = exp( x * x + y * y / ( -2 * s * s ) ) / ( s * s * 2 * PI )\n * </code>\n *\n * @author Diego Catalano\n */\npublic class Gaussian\n{\n\n    private double sigma = 1.0;\n    private double sqrSigma = 1.0;\n\n    /**\n     * Initializes a new instance of the Gaussian class.\n     *\n     * @param sigma Sigma value.\n     */\n    public Gaussian(double sigma)\n    {\n        setSigma(sigma);\n    }\n\n    /**\n     * Sigma value.\n     *\n     * @return Sigma value.\n     */\n    public double getSigma()\n    {\n        return sigma;\n    }\n\n    /**\n     * Sigma value.\n     * <br /> Default value is set to 1. Minimum allowed value is 0.00000001.\n     *\n     * @param sigma Sigma value.\n     */\n    public void setSigma(double sigma)\n    {\n\n        this.sigma = Math.max(0.00000001, sigma);\n        this.sqrSigma = sigma * sigma;\n    }\n\n    /**\n     * 1-D Gaussian function.\n     *\n     * @param x value.\n     * @return Function's value at point x.\n     */\n\n    /**\n     * 2-D Gaussian function.\n     *\n     * @param x value.\n     * @param y value.\n     * @return Function's value at point (x,y).\n     */\n    public double Function2D(double x, double y)\n    {\n        return Math.exp(-(x * x + y * y) / (2 * sqrSigma)) / (2 * Math.PI * sqrSigma);\n    }\n\n    /**\n     * 1-D Gaussian kernel.\n     *\n     * @param size Kernel size (should be odd), [3, 101].\n     * @return Returns 1-D Gaussian kernel of the specified size.\n     */\n    public double[] Kernel1D(int size)\n    {\n        if (((size % 2) == 0) || (size < 3) || (size > 101))\n        {\n            try\n            {\n                throw new Exception(\"Wrong size\");\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n            }\n        }\n        int r = size / 2;\n        // kernel\n        double[] kernel = new double[size];\n\n        // compute kernel\n        for (int x = -r, i = 0; i < size; x++, i++)\n        {\n            kernel[i] = Function1D(x);\n        }\n\n        return kernel;\n    }\n\n    /**\n     * 2-D Gaussian kernel.\n     *\n     * @param size Kernel size (should be odd), [3, 101].\n     * @return Returns 2-D Gaussian kernel of specified size.\n     */\n    public double[][] Kernel2D(int size)\n    {\n        if (((size % 2) == 0) || (size < 3) || (size > 101))\n        {\n            try\n            {\n                throw new Exception(\"Wrong size\");\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n            }\n        }\n\n        int r = size / 2;\n        double[][] kernel = new double[size][size];\n\n        // compute kernel\n        double sum = 0;\n        for (int y = -r, i = 0; i < size; y++, i++)\n        {\n            for (int x = -r, j = 0; j < size; x++, j++)\n            {\n                kernel[i][j] = Function2D(x, y);\n                sum += kernel[i][j];\n            }\n        }\n\n        for (int i = 0; i < kernel.length; i++)\n        {\n            for (int j = 0; j < kernel[0].length; j++)\n            {\n                kernel[i][j] /= sum;\n            }\n        }\n\n        return kernel;\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/function/Gaussian.java", "func_name": "Gaussian.Function2D", "original_string": "public double Function2D(double x, double y) {\n        return Math.exp(-(x * x + y * y) / (2 * sqrSigma)) / (2 * Math.PI * sqrSigma);\n    }", "language": "java", "code": "public double Function2D(double x, double y) {\n        return Math.exp(-(x * x + y * y) / (2 * sqrSigma)) / (2 * Math.PI * sqrSigma);\n    }", "code_tokens": ["public", "double", "Function2D", "(", "double", "x", ",", "double", "y", ")", "{", "return", "Math", ".", "exp", "(", "-", "(", "x", "*", "x", "+", "y", "*", "y", ")", "/", "(", "2", "*", "sqrSigma", ")", ")", "/", "(", "2", "*", "Math", ".", "PI", "*", "sqrSigma", ")", ";", "}"], "docstring": "2-D Gaussian function.\n\n@param x value.\n@param y value.\n@return Function's value at point (x,y).", "docstring_tokens": ["2", "-", "D", "Gaussian", "function", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/function/Gaussian.java#L91-L93", "partition": "train", "up_fun_num": 5, "levels": [0, 1, 1, 1, 1, 1], "package": [], "function": ["public class Gaussian\n", "    public double getSigma()\n", "    public void setSigma(double sigma)\n", "    public double Function1D(double x)\n", "    public double[] Kernel1D(int size)\n", "    public double[][] Kernel2D(int size)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2007-2008\n// andrew.kirillov at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.function;\n\n/**\n * Gaussian function.\n * <br /> The class is used to calculate 1D and 2D Gaussian functions for specified Sigma (s) value:\n * <br />\n * <code lang = \"none\">\n * <br /> 1-D: f(x) = exp( x * x / ( -2 * s * s ) ) / ( s * sqrt( 2 * PI ) )\n * <br />\n * <br /> 2-D: f(x, y) = exp( x * x + y * y / ( -2 * s * s ) ) / ( s * s * 2 * PI )\n * </code>\n *\n * @author Diego Catalano\n */\npublic class Gaussian\n{\n\n    private double sigma = 1.0;\n    private double sqrSigma = 1.0;\n\n    /**\n     * Initializes a new instance of the Gaussian class.\n     *\n     * @param sigma Sigma value.\n     */\n    public Gaussian(double sigma)\n    {\n        setSigma(sigma);\n    }\n\n    /**\n     * Sigma value.\n     *\n     * @return Sigma value.\n     */\n    public double getSigma()\n    {\n        return sigma;\n    }\n\n    /**\n     * Sigma value.\n     * <br /> Default value is set to 1. Minimum allowed value is 0.00000001.\n     *\n     * @param sigma Sigma value.\n     */\n    public void setSigma(double sigma)\n    {\n\n        this.sigma = Math.max(0.00000001, sigma);\n        this.sqrSigma = sigma * sigma;\n    }\n\n    /**\n     * 1-D Gaussian function.\n     *\n     * @param x value.\n     * @return Function's value at point x.\n     */\n    public double Function1D(double x)\n    {\n        return Math.exp(x * x / (-2 * sqrSigma)) / (Math.sqrt(2 * Math.PI) * sigma);\n    }\n\n    /**\n     * 2-D Gaussian function.\n     *\n     * @param x value.\n     * @param y value.\n     * @return Function's value at point (x,y).\n     */\n\n    /**\n     * 1-D Gaussian kernel.\n     *\n     * @param size Kernel size (should be odd), [3, 101].\n     * @return Returns 1-D Gaussian kernel of the specified size.\n     */\n    public double[] Kernel1D(int size)\n    {\n        if (((size % 2) == 0) || (size < 3) || (size > 101))\n        {\n            try\n            {\n                throw new Exception(\"Wrong size\");\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n            }\n        }\n        int r = size / 2;\n        // kernel\n        double[] kernel = new double[size];\n\n        // compute kernel\n        for (int x = -r, i = 0; i < size; x++, i++)\n        {\n            kernel[i] = Function1D(x);\n        }\n\n        return kernel;\n    }\n\n    /**\n     * 2-D Gaussian kernel.\n     *\n     * @param size Kernel size (should be odd), [3, 101].\n     * @return Returns 2-D Gaussian kernel of specified size.\n     */\n    public double[][] Kernel2D(int size)\n    {\n        if (((size % 2) == 0) || (size < 3) || (size > 101))\n        {\n            try\n            {\n                throw new Exception(\"Wrong size\");\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n            }\n        }\n\n        int r = size / 2;\n        double[][] kernel = new double[size][size];\n\n        // compute kernel\n        double sum = 0;\n        for (int y = -r, i = 0; i < size; y++, i++)\n        {\n            for (int x = -r, j = 0; j < size; x++, j++)\n            {\n                kernel[i][j] = Function2D(x, y);\n                sum += kernel[i][j];\n            }\n        }\n\n        for (int i = 0; i < kernel.length; i++)\n        {\n            for (int j = 0; j < kernel[0].length; j++)\n            {\n                kernel[i][j] /= sum;\n            }\n        }\n\n        return kernel;\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/function/Gaussian.java", "func_name": "Gaussian.Kernel1D", "original_string": "public double[] Kernel1D(int size) {\n        if (((size % 2) == 0) || (size < 3) || (size > 101)) {\n            try {\n                throw new Exception(\"Wrong size\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        int r = size / 2;\n        // kernel\n        double[] kernel = new double[size];\n\n        // compute kernel\n        for (int x = -r, i = 0; i < size; x++, i++) {\n            kernel[i] = Function1D(x);\n        }\n\n        return kernel;\n    }", "language": "java", "code": "public double[] Kernel1D(int size) {\n        if (((size % 2) == 0) || (size < 3) || (size > 101)) {\n            try {\n                throw new Exception(\"Wrong size\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        int r = size / 2;\n        // kernel\n        double[] kernel = new double[size];\n\n        // compute kernel\n        for (int x = -r, i = 0; i < size; x++, i++) {\n            kernel[i] = Function1D(x);\n        }\n\n        return kernel;\n    }", "code_tokens": ["public", "double", "[", "]", "Kernel1D", "(", "int", "size", ")", "{", "if", "(", "(", "(", "size", "%", "2", ")", "==", "0", ")", "||", "(", "size", "<", "3", ")", "||", "(", "size", ">", "101", ")", ")", "{", "try", "{", "throw", "new", "Exception", "(", "\"Wrong size\"", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "}", "}", "int", "r", "=", "size", "/", "2", ";", "// kernel", "double", "[", "]", "kernel", "=", "new", "double", "[", "size", "]", ";", "// compute kernel", "for", "(", "int", "x", "=", "-", "r", ",", "i", "=", "0", ";", "i", "<", "size", ";", "x", "++", ",", "i", "++", ")", "{", "kernel", "[", "i", "]", "=", "Function1D", "(", "x", ")", ";", "}", "return", "kernel", ";", "}"], "docstring": "1-D Gaussian kernel.\n\n@param size Kernel size (should be odd), [3, 101].\n@return Returns 1-D Gaussian kernel of the specified size.", "docstring_tokens": ["1", "-", "D", "Gaussian", "kernel", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/function/Gaussian.java#L101-L119", "partition": "train", "up_fun_num": 6, "levels": [0, 1, 1, 1, 1, 1], "package": [], "function": ["public class Gaussian\n", "    public double getSigma()\n", "    public void setSigma(double sigma)\n", "    public double Function1D(double x)\n", "    public double Function2D(double x, double y)\n", "    public double[][] Kernel2D(int size)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2007-2008\n// andrew.kirillov at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.function;\n\n/**\n * Gaussian function.\n * <br /> The class is used to calculate 1D and 2D Gaussian functions for specified Sigma (s) value:\n * <br />\n * <code lang = \"none\">\n * <br /> 1-D: f(x) = exp( x * x / ( -2 * s * s ) ) / ( s * sqrt( 2 * PI ) )\n * <br />\n * <br /> 2-D: f(x, y) = exp( x * x + y * y / ( -2 * s * s ) ) / ( s * s * 2 * PI )\n * </code>\n *\n * @author Diego Catalano\n */\npublic class Gaussian\n{\n\n    private double sigma = 1.0;\n    private double sqrSigma = 1.0;\n\n    /**\n     * Initializes a new instance of the Gaussian class.\n     *\n     * @param sigma Sigma value.\n     */\n    public Gaussian(double sigma)\n    {\n        setSigma(sigma);\n    }\n\n    /**\n     * Sigma value.\n     *\n     * @return Sigma value.\n     */\n    public double getSigma()\n    {\n        return sigma;\n    }\n\n    /**\n     * Sigma value.\n     * <br /> Default value is set to 1. Minimum allowed value is 0.00000001.\n     *\n     * @param sigma Sigma value.\n     */\n    public void setSigma(double sigma)\n    {\n\n        this.sigma = Math.max(0.00000001, sigma);\n        this.sqrSigma = sigma * sigma;\n    }\n\n    /**\n     * 1-D Gaussian function.\n     *\n     * @param x value.\n     * @return Function's value at point x.\n     */\n    public double Function1D(double x)\n    {\n        return Math.exp(x * x / (-2 * sqrSigma)) / (Math.sqrt(2 * Math.PI) * sigma);\n    }\n\n    /**\n     * 2-D Gaussian function.\n     *\n     * @param x value.\n     * @param y value.\n     * @return Function's value at point (x,y).\n     */\n    public double Function2D(double x, double y)\n    {\n        return Math.exp(-(x * x + y * y) / (2 * sqrSigma)) / (2 * Math.PI * sqrSigma);\n    }\n\n    /**\n     * 1-D Gaussian kernel.\n     *\n     * @param size Kernel size (should be odd), [3, 101].\n     * @return Returns 1-D Gaussian kernel of the specified size.\n     */\n\n    /**\n     * 2-D Gaussian kernel.\n     *\n     * @param size Kernel size (should be odd), [3, 101].\n     * @return Returns 2-D Gaussian kernel of specified size.\n     */\n    public double[][] Kernel2D(int size)\n    {\n        if (((size % 2) == 0) || (size < 3) || (size > 101))\n        {\n            try\n            {\n                throw new Exception(\"Wrong size\");\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n            }\n        }\n\n        int r = size / 2;\n        double[][] kernel = new double[size][size];\n\n        // compute kernel\n        double sum = 0;\n        for (int y = -r, i = 0; i < size; y++, i++)\n        {\n            for (int x = -r, j = 0; j < size; x++, j++)\n            {\n                kernel[i][j] = Function2D(x, y);\n                sum += kernel[i][j];\n            }\n        }\n\n        for (int i = 0; i < kernel.length; i++)\n        {\n            for (int j = 0; j < kernel[0].length; j++)\n            {\n                kernel[i][j] /= sum;\n            }\n        }\n\n        return kernel;\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/function/Gaussian.java", "func_name": "Gaussian.Kernel2D", "original_string": "public double[][] Kernel2D(int size) {\n        if (((size % 2) == 0) || (size < 3) || (size > 101)) {\n            try {\n                throw new Exception(\"Wrong size\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        int r = size / 2;\n        double[][] kernel = new double[size][size];\n\n        // compute kernel\n        double sum = 0;\n        for (int y = -r, i = 0; i < size; y++, i++) {\n            for (int x = -r, j = 0; j < size; x++, j++) {\n                kernel[i][j] = Function2D(x, y);\n                sum += kernel[i][j];\n            }\n        }\n\n        for (int i = 0; i < kernel.length; i++) {\n            for (int j = 0; j < kernel[0].length; j++) {\n                kernel[i][j] /= sum;\n            }\n        }\n\n        return kernel;\n    }", "language": "java", "code": "public double[][] Kernel2D(int size) {\n        if (((size % 2) == 0) || (size < 3) || (size > 101)) {\n            try {\n                throw new Exception(\"Wrong size\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        int r = size / 2;\n        double[][] kernel = new double[size][size];\n\n        // compute kernel\n        double sum = 0;\n        for (int y = -r, i = 0; i < size; y++, i++) {\n            for (int x = -r, j = 0; j < size; x++, j++) {\n                kernel[i][j] = Function2D(x, y);\n                sum += kernel[i][j];\n            }\n        }\n\n        for (int i = 0; i < kernel.length; i++) {\n            for (int j = 0; j < kernel[0].length; j++) {\n                kernel[i][j] /= sum;\n            }\n        }\n\n        return kernel;\n    }", "code_tokens": ["public", "double", "[", "]", "[", "]", "Kernel2D", "(", "int", "size", ")", "{", "if", "(", "(", "(", "size", "%", "2", ")", "==", "0", ")", "||", "(", "size", "<", "3", ")", "||", "(", "size", ">", "101", ")", ")", "{", "try", "{", "throw", "new", "Exception", "(", "\"Wrong size\"", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "}", "}", "int", "r", "=", "size", "/", "2", ";", "double", "[", "]", "[", "]", "kernel", "=", "new", "double", "[", "size", "]", "[", "size", "]", ";", "// compute kernel", "double", "sum", "=", "0", ";", "for", "(", "int", "y", "=", "-", "r", ",", "i", "=", "0", ";", "i", "<", "size", ";", "y", "++", ",", "i", "++", ")", "{", "for", "(", "int", "x", "=", "-", "r", ",", "j", "=", "0", ";", "j", "<", "size", ";", "x", "++", ",", "j", "++", ")", "{", "kernel", "[", "i", "]", "[", "j", "]", "=", "Function2D", "(", "x", ",", "y", ")", ";", "sum", "+=", "kernel", "[", "i", "]", "[", "j", "]", ";", "}", "}", "for", "(", "int", "i", "=", "0", ";", "i", "<", "kernel", ".", "length", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "0", ";", "j", "<", "kernel", "[", "0", "]", ".", "length", ";", "j", "++", ")", "{", "kernel", "[", "i", "]", "[", "j", "]", "/=", "sum", ";", "}", "}", "return", "kernel", ";", "}"], "docstring": "2-D Gaussian kernel.\n\n@param size Kernel size (should be odd), [3, 101].\n@return Returns 2-D Gaussian kernel of specified size.", "docstring_tokens": ["2", "-", "D", "Gaussian", "kernel", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/function/Gaussian.java#L127-L155", "partition": "train", "up_fun_num": 6, "levels": [0, 1, 1, 1, 1, 1], "package": [], "function": ["public class Gaussian\n", "    public double getSigma()\n", "    public void setSigma(double sigma)\n", "    public double Function1D(double x)\n", "    public double Function2D(double x, double y)\n", "    public double[] Kernel1D(int size)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n// Copyright ? Andrew Kirillov, 2007-2008\n// andrew.kirillov at gmail.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.function;\n\n/**\n * Gaussian function.\n * <br /> The class is used to calculate 1D and 2D Gaussian functions for specified Sigma (s) value:\n * <br />\n * <code lang = \"none\">\n * <br /> 1-D: f(x) = exp( x * x / ( -2 * s * s ) ) / ( s * sqrt( 2 * PI ) )\n * <br />\n * <br /> 2-D: f(x, y) = exp( x * x + y * y / ( -2 * s * s ) ) / ( s * s * 2 * PI )\n * </code>\n *\n * @author Diego Catalano\n */\npublic class Gaussian\n{\n\n    private double sigma = 1.0;\n    private double sqrSigma = 1.0;\n\n    /**\n     * Initializes a new instance of the Gaussian class.\n     *\n     * @param sigma Sigma value.\n     */\n    public Gaussian(double sigma)\n    {\n        setSigma(sigma);\n    }\n\n    /**\n     * Sigma value.\n     *\n     * @return Sigma value.\n     */\n    public double getSigma()\n    {\n        return sigma;\n    }\n\n    /**\n     * Sigma value.\n     * <br /> Default value is set to 1. Minimum allowed value is 0.00000001.\n     *\n     * @param sigma Sigma value.\n     */\n    public void setSigma(double sigma)\n    {\n\n        this.sigma = Math.max(0.00000001, sigma);\n        this.sqrSigma = sigma * sigma;\n    }\n\n    /**\n     * 1-D Gaussian function.\n     *\n     * @param x value.\n     * @return Function's value at point x.\n     */\n    public double Function1D(double x)\n    {\n        return Math.exp(x * x / (-2 * sqrSigma)) / (Math.sqrt(2 * Math.PI) * sigma);\n    }\n\n    /**\n     * 2-D Gaussian function.\n     *\n     * @param x value.\n     * @param y value.\n     * @return Function's value at point (x,y).\n     */\n    public double Function2D(double x, double y)\n    {\n        return Math.exp(-(x * x + y * y) / (2 * sqrSigma)) / (2 * Math.PI * sqrSigma);\n    }\n\n    /**\n     * 1-D Gaussian kernel.\n     *\n     * @param size Kernel size (should be odd), [3, 101].\n     * @return Returns 1-D Gaussian kernel of the specified size.\n     */\n    public double[] Kernel1D(int size)\n    {\n        if (((size % 2) == 0) || (size < 3) || (size > 101))\n        {\n            try\n            {\n                throw new Exception(\"Wrong size\");\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n            }\n        }\n        int r = size / 2;\n        // kernel\n        double[] kernel = new double[size];\n\n        // compute kernel\n        for (int x = -r, i = 0; i < size; x++, i++)\n        {\n            kernel[i] = Function1D(x);\n        }\n\n        return kernel;\n    }\n\n    /**\n     * 2-D Gaussian kernel.\n     *\n     * @param size Kernel size (should be odd), [3, 101].\n     * @return Returns 2-D Gaussian kernel of specified size.\n     */\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/effect/ExtractBoundary.java", "func_name": "ExtractBoundary.process", "original_string": "public ArrayList<IntPoint> process(ImageSource fastBitmap) {\r\n        //FastBitmap l = new FastBitmap(fastBitmap);\r\n        if (points == null) {\r\n            apply(fastBitmap);\r\n        }\r\n\r\n        int width = fastBitmap.getWidth();\r\n        int height = fastBitmap.getHeight();\r\n        points = new ArrayList<IntPoint>();\r\n\r\n        if (fastBitmap.isGrayscale()) {\r\n            for (int x = 0; x < height; x++) {\r\n                for (int y = 0; y < width; y++) {\r\n                    if (fastBitmap.getRGB(y, x) == 255) points.add(new IntPoint(y, x));\r\n                }\r\n            }\r\n        } else {\r\n            for (int x = 0; x < height; x++) {\r\n                for (int y = 0; y < width; y++) {\r\n                    // TODO Check for green and blue?\r\n                    if (fastBitmap.getR(y, x) == 255) points.add(new IntPoint(y, x));\r\n                }\r\n            }\r\n        }\r\n\r\n        return points;\r\n    }", "language": "java", "code": "public ArrayList<IntPoint> process(ImageSource fastBitmap) {\r\n        //FastBitmap l = new FastBitmap(fastBitmap);\r\n        if (points == null) {\r\n            apply(fastBitmap);\r\n        }\r\n\r\n        int width = fastBitmap.getWidth();\r\n        int height = fastBitmap.getHeight();\r\n        points = new ArrayList<IntPoint>();\r\n\r\n        if (fastBitmap.isGrayscale()) {\r\n            for (int x = 0; x < height; x++) {\r\n                for (int y = 0; y < width; y++) {\r\n                    if (fastBitmap.getRGB(y, x) == 255) points.add(new IntPoint(y, x));\r\n                }\r\n            }\r\n        } else {\r\n            for (int x = 0; x < height; x++) {\r\n                for (int y = 0; y < width; y++) {\r\n                    // TODO Check for green and blue?\r\n                    if (fastBitmap.getR(y, x) == 255) points.add(new IntPoint(y, x));\r\n                }\r\n            }\r\n        }\r\n\r\n        return points;\r\n    }", "code_tokens": ["public", "ArrayList", "<", "IntPoint", ">", "process", "(", "ImageSource", "fastBitmap", ")", "{", "//FastBitmap l = new FastBitmap(fastBitmap);\r", "if", "(", "points", "==", "null", ")", "{", "apply", "(", "fastBitmap", ")", ";", "}", "int", "width", "=", "fastBitmap", ".", "getWidth", "(", ")", ";", "int", "height", "=", "fastBitmap", ".", "getHeight", "(", ")", ";", "points", "=", "new", "ArrayList", "<", "IntPoint", ">", "(", ")", ";", "if", "(", "fastBitmap", ".", "isGrayscale", "(", ")", ")", "{", "for", "(", "int", "x", "=", "0", ";", "x", "<", "height", ";", "x", "++", ")", "{", "for", "(", "int", "y", "=", "0", ";", "y", "<", "width", ";", "y", "++", ")", "{", "if", "(", "fastBitmap", ".", "getRGB", "(", "y", ",", "x", ")", "==", "255", ")", "points", ".", "add", "(", "new", "IntPoint", "(", "y", ",", "x", ")", ")", ";", "}", "}", "}", "else", "{", "for", "(", "int", "x", "=", "0", ";", "x", "<", "height", ";", "x", "++", ")", "{", "for", "(", "int", "y", "=", "0", ";", "y", "<", "width", ";", "y", "++", ")", "{", "// TODO Check for green and blue?\r", "if", "(", "fastBitmap", ".", "getR", "(", "y", ",", "x", ")", "==", "255", ")", "points", ".", "add", "(", "new", "IntPoint", "(", "y", ",", "x", ")", ")", ";", "}", "}", "}", "return", "points", ";", "}"], "docstring": "Get points after extract boundary.\n\n@param fastBitmap Image to be processed.\n@return List of points.", "docstring_tokens": ["Get", "points", "after", "extract", "boundary", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/effect/ExtractBoundary.java#L94-L120", "partition": "train", "up_fun_num": 2, "levels": [0, 1], "package": ["import com.harium.keel.catalano.core.IntPoint;", "import com.harium.keel.core.Effect;", "import com.harium.keel.core.source.ImageSource;", "import com.harium.keel.filter.process.ProcessFilter;", "import java.util.ArrayList;"], "function": ["public class ExtractBoundary implements Effect, ProcessFilter<ArrayList<IntPoint>>\n", "    public ImageSource apply(ImageSource fastBitmap)\n"], "context": "// Catalano Imaging Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\npackage com.harium.keel.effect;\n\nimport com.harium.keel.catalano.core.IntPoint;\nimport com.harium.keel.core.Effect;\nimport com.harium.keel.core.source.ImageSource;\nimport com.harium.keel.filter.process.ProcessFilter;\n\nimport java.util.ArrayList;\n\n/**\n * Extract Boundary using approach with morphology operators.\n *\n * @author Diego Catalano\n */\npublic class ExtractBoundary implements Effect, ProcessFilter<ArrayList<IntPoint>>\n{\n\n    /**\n     * Morphology operators.\n     */\n    public enum Algorithm\n    {\n\n        /**\n         * Erosion.\n         */\n        Erosion,\n        /**\n         * Dilatation.\n         */\n        Dilatation\n    }\n\n    ;\n    private Algorithm algorithm = Algorithm.Erosion;\n    private ArrayList<IntPoint> points;\n\n    /**\n     * Initialize a new instance of the ExtractBoundary class.\n     */\n    public ExtractBoundary()\n    {\n    }\n\n    /**\n     * Initialize a new instance of the ExtractBoundary class.\n     *\n     * @param algorithm Morphology algotithm.\n     */\n    public ExtractBoundary(Algorithm algorithm)\n    {\n        this.algorithm = algorithm;\n    }\n\n    @Override\n    public ImageSource apply(ImageSource fastBitmap)\n    {\n\n        if (algorithm == Algorithm.Erosion)\n        {\n            BinaryErosion ero = new BinaryErosion();\n            ero.apply(fastBitmap);\n        }\n        else\n        {\n            BinaryDilatation dil = new BinaryDilatation();\n            dil.apply(fastBitmap);\n        }\n\n        Difference dif = new Difference(fastBitmap);\n        dif.apply(fastBitmap);\n\n        return fastBitmap;\n    }\n\n    /**\n     * Get points after extract boundary.\n     *\n     * @param fastBitmap Image to be processed.\n     * @return List of points.\n     */\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/transform/DiscreteHartleyTransform.java", "func_name": "DiscreteHartleyTransform.Forward", "original_string": "public static void Forward(double[] data) {\n        double[] result = new double[data.length];\n\n        for (int k = 0; k < result.length; k++) {\n            double sum = 0;\n            for (int n = 0; n < data.length; n++) {\n                double theta = ((2.0 * Math.PI) / data.length) * k * n;\n                sum += data[n] * cas(theta);\n            }\n            result[k] = (1.0 / Math.sqrt(data.length)) * sum;\n        }\n\n        for (int i = 0; i < result.length; i++) {\n            data[i] = result[i];\n        }\n\n    }", "language": "java", "code": "public static void Forward(double[] data) {\n        double[] result = new double[data.length];\n\n        for (int k = 0; k < result.length; k++) {\n            double sum = 0;\n            for (int n = 0; n < data.length; n++) {\n                double theta = ((2.0 * Math.PI) / data.length) * k * n;\n                sum += data[n] * cas(theta);\n            }\n            result[k] = (1.0 / Math.sqrt(data.length)) * sum;\n        }\n\n        for (int i = 0; i < result.length; i++) {\n            data[i] = result[i];\n        }\n\n    }", "code_tokens": ["public", "static", "void", "Forward", "(", "double", "[", "]", "data", ")", "{", "double", "[", "]", "result", "=", "new", "double", "[", "data", ".", "length", "]", ";", "for", "(", "int", "k", "=", "0", ";", "k", "<", "result", ".", "length", ";", "k", "++", ")", "{", "double", "sum", "=", "0", ";", "for", "(", "int", "n", "=", "0", ";", "n", "<", "data", ".", "length", ";", "n", "++", ")", "{", "double", "theta", "=", "(", "(", "2.0", "*", "Math", ".", "PI", ")", "/", "data", ".", "length", ")", "*", "k", "*", "n", ";", "sum", "+=", "data", "[", "n", "]", "*", "cas", "(", "theta", ")", ";", "}", "result", "[", "k", "]", "=", "(", "1.0", "/", "Math", ".", "sqrt", "(", "data", ".", "length", ")", ")", "*", "sum", ";", "}", "for", "(", "int", "i", "=", "0", ";", "i", "<", "result", ".", "length", ";", "i", "++", ")", "{", "data", "[", "i", "]", "=", "result", "[", "i", "]", ";", "}", "}"], "docstring": "1-D Forward Discrete Hartley Transform.\n\n@param data Data.", "docstring_tokens": ["1", "-", "D", "Forward", "Discrete", "Hartley", "Transform", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/transform/DiscreteHartleyTransform.java#L46-L62", "partition": "train", "up_fun_num": 2, "levels": [0, 1, 1, 1, 1], "package": [], "function": ["public final class DiscreteHartleyTransform\n", "    public static void Backward(double[] data)\n", "    public static void Forward(double[][] data)\n", "    public static void Backward(double[][] data)\n", "    private static double cas(double theta)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.transform;\n\n/**\n * Hartley Transform.\n * In 1942, Hartley introduced a continuous integral transform as an alternative to the Fourier Transform.\n *\n * @author Diego Catalano\n * @link http://dsp-book.narod.ru/HFTSP/8579ch14.pdf\n * @see Digital Image Processing - Kenneth R. Castleman - Chapter 13 - p.289 (2-D)\n * @see Poularikas A.D. \"The Hartley Transform\" - p.15 (1-D)\n */\npublic final class DiscreteHartleyTransform\n{\n\n    /**\n     * Don't let anyone instantiate this class.\n     */\n    private DiscreteHartleyTransform()\n    {\n    }\n\n    /**\n     * 1-D Forward Discrete Hartley Transform.\n     *\n     * @param data Data.\n     */\n\n    /**\n     * 1-D Backward Discrete Hartley Transform.\n     *\n     * @param data Data.\n     */\n    public static void Backward(double[] data)\n    {\n        Forward(data);\n    }\n\n    /**\n     * 2-D Forward Discrete Hartley Transform.\n     *\n     * @param data Data.\n     */\n    public static void Forward(double[][] data)\n    {\n        double[][] result = new double[data.length][data[0].length];\n\n        for (int m = 0; m < data.length; m++)\n        {\n            for (int n = 0; n < data[0].length; n++)\n            {\n                double sum = 0;\n                for (int i = 0; i < result.length; i++)\n                {\n                    for (int k = 0; k < data.length; k++)\n                    {\n                        sum += data[i][k] * cas(((2.0 * Math.PI) / data.length) * (i * m + k * n));\n                    }\n                    result[m][n] = (1.0 / data.length) * sum;\n                }\n            }\n        }\n\n        for (int i = 0; i < data.length; i++)\n        {\n            for (int j = 0; j < data[0].length; j++)\n            {\n                data[i][j] = result[i][j];\n            }\n        }\n    }\n\n    /**\n     * 2-D Forward Discrete Hartley Transform.\n     *\n     * @param data Data.\n     */\n    public static void Backward(double[][] data)\n    {\n        Forward(data);\n    }\n\n    /**\n     * Basis function.\n     * The cas can be computed following two ways.\n     * 1: Math.cos(theta) + Math.sin(theta)\n     * 2: sqrt(2) * Math.cos(theta - Math.PI / 4)\n     *\n     * @param theta Theta.\n     * @return Result.\n     */\n    private static double cas(double theta)\n    {\n        //return Math.cos(theta) + Math.sin(theta);\n\n        // sqrt(2) = 1.4142135623730950488016887242097\n        // PI / 4 = 0.78539816339744830961566084581988\n        return 1.4142135623730950488016887242097 * Math.cos(theta - 0.78539816339744830961566084581988);\n    }\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/transform/DiscreteHartleyTransform.java", "func_name": "DiscreteHartleyTransform.Forward", "original_string": "public static void Forward(double[][] data) {\n        double[][] result = new double[data.length][data[0].length];\n\n        for (int m = 0; m < data.length; m++) {\n            for (int n = 0; n < data[0].length; n++) {\n                double sum = 0;\n                for (int i = 0; i < result.length; i++) {\n                    for (int k = 0; k < data.length; k++) {\n                        sum += data[i][k] * cas(((2.0 * Math.PI) / data.length) * (i * m + k * n));\n                    }\n                    result[m][n] = (1.0 / data.length) * sum;\n                }\n            }\n        }\n\n        for (int i = 0; i < data.length; i++) {\n            for (int j = 0; j < data[0].length; j++) {\n                data[i][j] = result[i][j];\n            }\n        }\n    }", "language": "java", "code": "public static void Forward(double[][] data) {\n        double[][] result = new double[data.length][data[0].length];\n\n        for (int m = 0; m < data.length; m++) {\n            for (int n = 0; n < data[0].length; n++) {\n                double sum = 0;\n                for (int i = 0; i < result.length; i++) {\n                    for (int k = 0; k < data.length; k++) {\n                        sum += data[i][k] * cas(((2.0 * Math.PI) / data.length) * (i * m + k * n));\n                    }\n                    result[m][n] = (1.0 / data.length) * sum;\n                }\n            }\n        }\n\n        for (int i = 0; i < data.length; i++) {\n            for (int j = 0; j < data[0].length; j++) {\n                data[i][j] = result[i][j];\n            }\n        }\n    }", "code_tokens": ["public", "static", "void", "Forward", "(", "double", "[", "]", "[", "]", "data", ")", "{", "double", "[", "]", "[", "]", "result", "=", "new", "double", "[", "data", ".", "length", "]", "[", "data", "[", "0", "]", ".", "length", "]", ";", "for", "(", "int", "m", "=", "0", ";", "m", "<", "data", ".", "length", ";", "m", "++", ")", "{", "for", "(", "int", "n", "=", "0", ";", "n", "<", "data", "[", "0", "]", ".", "length", ";", "n", "++", ")", "{", "double", "sum", "=", "0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "result", ".", "length", ";", "i", "++", ")", "{", "for", "(", "int", "k", "=", "0", ";", "k", "<", "data", ".", "length", ";", "k", "++", ")", "{", "sum", "+=", "data", "[", "i", "]", "[", "k", "]", "*", "cas", "(", "(", "(", "2.0", "*", "Math", ".", "PI", ")", "/", "data", ".", "length", ")", "*", "(", "i", "*", "m", "+", "k", "*", "n", ")", ")", ";", "}", "result", "[", "m", "]", "[", "n", "]", "=", "(", "1.0", "/", "data", ".", "length", ")", "*", "sum", ";", "}", "}", "}", "for", "(", "int", "i", "=", "0", ";", "i", "<", "data", ".", "length", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "0", ";", "j", "<", "data", "[", "0", "]", ".", "length", ";", "j", "++", ")", "{", "data", "[", "i", "]", "[", "j", "]", "=", "result", "[", "i", "]", "[", "j", "]", ";", "}", "}", "}"], "docstring": "2-D Forward Discrete Hartley Transform.\n\n@param data Data.", "docstring_tokens": ["2", "-", "D", "Forward", "Discrete", "Hartley", "Transform", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/transform/DiscreteHartleyTransform.java#L78-L98", "partition": "train", "up_fun_num": 4, "levels": [0, 1, 1, 1, 1], "package": [], "function": ["public final class DiscreteHartleyTransform\n", "    public static void Forward(double[] data)\n", "    public static void Backward(double[] data)\n", "    public static void Backward(double[][] data)\n", "    private static double cas(double theta)\n"], "context": "// Catalano Math Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n//    This library is free software; you can redistribute it and/or\n//    apply it under the terms of the GNU Lesser General Public\n//    License as published by the Free Software Foundation; either\n//    version 2.1 of the License, or (at your option) any later version.\n//\n//    This library is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//    Lesser General Public License for more details.\n//\n//    You should have received a copy of the GNU Lesser General Public\n//    License along with this library; if not, write to the Free Software\n//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\n\npackage com.harium.keel.catalano.math.transform;\n\n/**\n * Hartley Transform.\n * In 1942, Hartley introduced a continuous integral transform as an alternative to the Fourier Transform.\n *\n * @author Diego Catalano\n * @link http://dsp-book.narod.ru/HFTSP/8579ch14.pdf\n * @see Digital Image Processing - Kenneth R. Castleman - Chapter 13 - p.289 (2-D)\n * @see Poularikas A.D. \"The Hartley Transform\" - p.15 (1-D)\n */\npublic final class DiscreteHartleyTransform\n{\n\n    /**\n     * Don't let anyone instantiate this class.\n     */\n    private DiscreteHartleyTransform()\n    {\n    }\n\n    /**\n     * 1-D Forward Discrete Hartley Transform.\n     *\n     * @param data Data.\n     */\n    public static void Forward(double[] data)\n    {\n        double[] result = new double[data.length];\n\n        for (int k = 0; k < result.length; k++)\n        {\n            double sum = 0;\n            for (int n = 0; n < data.length; n++)\n            {\n                double theta = ((2.0 * Math.PI) / data.length) * k * n;\n                sum += data[n] * cas(theta);\n            }\n            result[k] = (1.0 / Math.sqrt(data.length)) * sum;\n        }\n\n        for (int i = 0; i < result.length; i++)\n        {\n            data[i] = result[i];\n        }\n\n    }\n\n    /**\n     * 1-D Backward Discrete Hartley Transform.\n     *\n     * @param data Data.\n     */\n    public static void Backward(double[] data)\n    {\n        Forward(data);\n    }\n\n    /**\n     * 2-D Forward Discrete Hartley Transform.\n     *\n     * @param data Data.\n     */\n\n    /**\n     * 2-D Forward Discrete Hartley Transform.\n     *\n     * @param data Data.\n     */\n    public static void Backward(double[][] data)\n    {\n        Forward(data);\n    }\n\n    /**\n     * Basis function.\n     * The cas can be computed following two ways.\n     * 1: Math.cos(theta) + Math.sin(theta)\n     * 2: sqrt(2) * Math.cos(theta - Math.PI / 4)\n     *\n     * @param theta Theta.\n     * @return Result.\n     */\n    private static double cas(double theta)\n    {\n        //return Math.cos(theta) + Math.sin(theta);\n\n        // sqrt(2) = 1.4142135623730950488016887242097\n        // PI / 4 = 0.78539816339744830961566084581988\n        return 1.4142135623730950488016887242097 * Math.cos(theta - 0.78539816339744830961566084581988);\n    }\n\n}"}
{"repo": "artikcloud/artikcloud-java", "path": "src/main/java/cloud/artik/api/UsersApi.java", "func_name": "UsersApi.createUserProperties", "original_string": "public PropertiesEnvelope createUserProperties(String userId, AppProperties properties, String aid) throws ApiException {\n        ApiResponse<PropertiesEnvelope> resp = createUserPropertiesWithHttpInfo(userId, properties, aid);\n        return resp.getData();\n    }", "language": "java", "code": "public PropertiesEnvelope createUserProperties(String userId, AppProperties properties, String aid) throws ApiException {\n        ApiResponse<PropertiesEnvelope> resp = createUserPropertiesWithHttpInfo(userId, properties, aid);\n        return resp.getData();\n    }", "code_tokens": ["public", "PropertiesEnvelope", "createUserProperties", "(", "String", "userId", ",", "AppProperties", "properties", ",", "String", "aid", ")", "throws", "ApiException", "{", "ApiResponse", "<", "PropertiesEnvelope", ">", "resp", "=", "createUserPropertiesWithHttpInfo", "(", "userId", ",", "properties", ",", "aid", ")", ";", "return", "resp", ".", "getData", "(", ")", ";", "}"], "docstring": "Create User Application Properties\nCreate application properties for a user\n@param userId User Id (required)\n@param properties Properties to be updated (required)\n@param aid Application ID (optional)\n@return PropertiesEnvelope\n@throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body", "docstring_tokens": ["Create", "User", "Application", "Properties", "Create", "application", "properties", "for", "a", "user"], "sha": "412f447573e7796ab4f685c0bdd5eb76185a365c", "url": "https://github.com/artikcloud/artikcloud-java/blob/412f447573e7796ab4f685c0bdd5eb76185a365c/src/main/java/cloud/artik/api/UsersApi.java#L139-L142", "partition": "train", "up_fun_num": 6, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import cloud.artik.client.ApiCallback;", "import cloud.artik.client.ApiClient;", "import cloud.artik.client.ApiException;", "import cloud.artik.client.ApiResponse;", "import cloud.artik.client.Configuration;", "import cloud.artik.client.Pair;", "import cloud.artik.client.ProgressRequestBody;", "import cloud.artik.client.ProgressResponseBody;", "import com.google.gson.reflect.TypeToken;", "import java.io.IOException;", "import cloud.artik.model.AppProperties;", "import cloud.artik.model.DeviceSharingEnvelope;", "import cloud.artik.model.DeviceTypesEnvelope;", "import cloud.artik.model.DevicesEnvelope;", "import cloud.artik.model.PropertiesEnvelope;", "import cloud.artik.model.RulesEnvelope;", "import cloud.artik.model.UserEnvelope;", "import java.lang.reflect.Type;", "import java.util.ArrayList;", "import java.util.HashMap;", "import java.util.List;", "import java.util.Map;"], "function": ["public class UsersApi\n", "    public ApiClient getApiClient()\n", "    public void setApiClient(ApiClient apiClient)\n", "    private com.squareup.okhttp.Call createUserPropertiesCall(String userId, AppProperties properties, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call createUserPropertiesValidateBeforeCall(String userId, AppProperties properties, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public ApiResponse<PropertiesEnvelope> createUserPropertiesWithHttpInfo(String userId, AppProperties properties, String aid) throws ApiException\n", "    public com.squareup.okhttp.Call createUserPropertiesAsync(String userId, AppProperties properties, String aid, final ApiCallback<PropertiesEnvelope> callback) throws ApiException\n", "    private com.squareup.okhttp.Call deleteUserPropertiesCall(String userId, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call deleteUserPropertiesValidateBeforeCall(String userId, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public PropertiesEnvelope deleteUserProperties(String userId, String aid) throws ApiException\n", "    public ApiResponse<PropertiesEnvelope> deleteUserPropertiesWithHttpInfo(String userId, String aid) throws ApiException\n", "    public com.squareup.okhttp.Call deleteUserPropertiesAsync(String userId, String aid, final ApiCallback<PropertiesEnvelope> callback) throws ApiException\n", "    private com.squareup.okhttp.Call getSelfCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call getSelfValidateBeforeCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public UserEnvelope getSelf() throws ApiException\n", "    public ApiResponse<UserEnvelope> getSelfWithHttpInfo() throws ApiException\n", "    public com.squareup.okhttp.Call getSelfAsync(final ApiCallback<UserEnvelope> callback) throws ApiException\n", "    private com.squareup.okhttp.Call getUserDeviceTypesCall(String userId, Integer offset, Integer count, Boolean includeShared, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call getUserDeviceTypesValidateBeforeCall(String userId, Integer offset, Integer count, Boolean includeShared, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public DeviceTypesEnvelope getUserDeviceTypes(String userId, Integer offset, Integer count, Boolean includeShared) throws ApiException\n", "    public ApiResponse<DeviceTypesEnvelope> getUserDeviceTypesWithHttpInfo(String userId, Integer offset, Integer count, Boolean includeShared) throws ApiException\n", "    public com.squareup.okhttp.Call getUserDeviceTypesAsync(String userId, Integer offset, Integer count, Boolean includeShared, final ApiCallback<DeviceTypesEnvelope> callback) throws ApiException\n", "    private com.squareup.okhttp.Call getUserDevicesCall(String userId, Integer offset, Integer count, Boolean includeProperties, String owner, Boolean includeShareInfo, String dtid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call getUserDevicesValidateBeforeCall(String userId, Integer offset, Integer count, Boolean includeProperties, String owner, Boolean includeShareInfo, String dtid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public DevicesEnvelope getUserDevices(String userId, Integer offset, Integer count, Boolean includeProperties, String owner, Boolean includeShareInfo, String dtid) throws ApiException\n", "    public ApiResponse<DevicesEnvelope> getUserDevicesWithHttpInfo(String userId, Integer offset, Integer count, Boolean includeProperties, String owner, Boolean includeShareInfo, String dtid) throws ApiException\n", "    public com.squareup.okhttp.Call getUserDevicesAsync(String userId, Integer offset, Integer count, Boolean includeProperties, String owner, Boolean includeShareInfo, String dtid, final ApiCallback<DevicesEnvelope> callback) throws ApiException\n", "    private com.squareup.okhttp.Call getUserPropertiesCall(String userId, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call getUserPropertiesValidateBeforeCall(String userId, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public PropertiesEnvelope getUserProperties(String userId, String aid) throws ApiException\n", "    public ApiResponse<PropertiesEnvelope> getUserPropertiesWithHttpInfo(String userId, String aid) throws ApiException\n", "    public com.squareup.okhttp.Call getUserPropertiesAsync(String userId, String aid, final ApiCallback<PropertiesEnvelope> callback) throws ApiException\n", "    private com.squareup.okhttp.Call getUserRulesCall(String userId, Boolean excludeDisabled, Integer count, Integer offset, String owner, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call getUserRulesValidateBeforeCall(String userId, Boolean excludeDisabled, Integer count, Integer offset, String owner, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public RulesEnvelope getUserRules(String userId, Boolean excludeDisabled, Integer count, Integer offset, String owner) throws ApiException\n", "    public ApiResponse<RulesEnvelope> getUserRulesWithHttpInfo(String userId, Boolean excludeDisabled, Integer count, Integer offset, String owner) throws ApiException\n", "    public com.squareup.okhttp.Call getUserRulesAsync(String userId, Boolean excludeDisabled, Integer count, Integer offset, String owner, final ApiCallback<RulesEnvelope> callback) throws ApiException\n", "    private com.squareup.okhttp.Call listAllSharesForUserCall(String userId, String filter, Integer count, Integer offset, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call listAllSharesForUserValidateBeforeCall(String userId, String filter, Integer count, Integer offset, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public DeviceSharingEnvelope listAllSharesForUser(String userId, String filter, Integer count, Integer offset) throws ApiException\n", "    public ApiResponse<DeviceSharingEnvelope> listAllSharesForUserWithHttpInfo(String userId, String filter, Integer count, Integer offset) throws ApiException\n", "    public com.squareup.okhttp.Call listAllSharesForUserAsync(String userId, String filter, Integer count, Integer offset, final ApiCallback<DeviceSharingEnvelope> callback) throws ApiException\n", "    private com.squareup.okhttp.Call updateUserPropertiesCall(String userId, AppProperties properties, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call updateUserPropertiesValidateBeforeCall(String userId, AppProperties properties, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public PropertiesEnvelope updateUserProperties(String userId, AppProperties properties, String aid) throws ApiException\n", "    public ApiResponse<PropertiesEnvelope> updateUserPropertiesWithHttpInfo(String userId, AppProperties properties, String aid) throws ApiException\n", "    public com.squareup.okhttp.Call updateUserPropertiesAsync(String userId, AppProperties properties, String aid, final ApiCallback<PropertiesEnvelope> callback) throws ApiException\n"], "context": "/*\n * ARTIK Cloud API\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 2.0.0\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n\npackage cloud.artik.api;\n\nimport cloud.artik.client.ApiCallback;\nimport cloud.artik.client.ApiClient;\nimport cloud.artik.client.ApiException;\nimport cloud.artik.client.ApiResponse;\nimport cloud.artik.client.Configuration;\nimport cloud.artik.client.Pair;\nimport cloud.artik.client.ProgressRequestBody;\nimport cloud.artik.client.ProgressResponseBody;\n\nimport com.google.gson.reflect.TypeToken;\n\nimport java.io.IOException;\n\n\nimport cloud.artik.model.AppProperties;\nimport cloud.artik.model.DeviceSharingEnvelope;\nimport cloud.artik.model.DeviceTypesEnvelope;\nimport cloud.artik.model.DevicesEnvelope;\nimport cloud.artik.model.PropertiesEnvelope;\nimport cloud.artik.model.RulesEnvelope;\nimport cloud.artik.model.UserEnvelope;\n\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class UsersApi\n{\n    private ApiClient apiClient;\n\n    public UsersApi()\n    {\n        this(Configuration.getDefaultApiClient());\n    }\n\n    public UsersApi(ApiClient apiClient)\n    {\n        this.apiClient = apiClient;\n    }\n\n    public ApiClient getApiClient()\n    {\n        return apiClient;\n    }\n\n    public void setApiClient(ApiClient apiClient)\n    {\n        this.apiClient = apiClient;\n    }\n\n    /* Build call for createUserProperties */\n    private com.squareup.okhttp.Call createUserPropertiesCall(String userId, AppProperties properties, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = properties;\n\n        // create path and map variables\n        String localVarPath = \"/users/{userId}/properties\".replaceAll(\"\\\\{format\\\\}\", \"json\")\n                              .replaceAll(\"\\\\{\" + \"userId\" + \"\\\\}\", apiClient.escapeString(userId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        if (aid != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"aid\", aid));\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n            \"application/json\"\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call createUserPropertiesValidateBeforeCall(String userId, AppProperties properties, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n        // verify the required parameter 'userId' is set\n        if (userId == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'userId' when calling createUserProperties(Async)\");\n        }\n\n        // verify the required parameter 'properties' is set\n        if (properties == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'properties' when calling createUserProperties(Async)\");\n        }\n\n\n        com.squareup.okhttp.Call call = createUserPropertiesCall(userId, properties, aid, progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Create User Application Properties\n     * Create application properties for a user\n     * @param userId User Id (required)\n     * @param properties Properties to be updated (required)\n     * @param aid Application ID (optional)\n     * @return PropertiesEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n\n    /**\n     * Create User Application Properties\n     * Create application properties for a user\n     * @param userId User Id (required)\n     * @param properties Properties to be updated (required)\n     * @param aid Application ID (optional)\n     * @return ApiResponse&lt;PropertiesEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PropertiesEnvelope> createUserPropertiesWithHttpInfo(String userId, AppProperties properties, String aid) throws ApiException\n    {\n        com.squareup.okhttp.Call call = createUserPropertiesValidateBeforeCall(userId, properties, aid, null, null);\n        Type localVarReturnType = new TypeToken<PropertiesEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Create User Application Properties (asynchronously)\n     * Create application properties for a user\n     * @param userId User Id (required)\n     * @param properties Properties to be updated (required)\n     * @param aid Application ID (optional)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call createUserPropertiesAsync(String userId, AppProperties properties, String aid, final ApiCallback<PropertiesEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = createUserPropertiesValidateBeforeCall(userId, properties, aid, progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<PropertiesEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /* Build call for deleteUserProperties */\n    private com.squareup.okhttp.Call deleteUserPropertiesCall(String userId, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/users/{userId}/properties\".replaceAll(\"\\\\{format\\\\}\", \"json\")\n                              .replaceAll(\"\\\\{\" + \"userId\" + \"\\\\}\", apiClient.escapeString(userId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        if (aid != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"aid\", aid));\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"DELETE\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call deleteUserPropertiesValidateBeforeCall(String userId, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n        // verify the required parameter 'userId' is set\n        if (userId == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'userId' when calling deleteUserProperties(Async)\");\n        }\n\n\n        com.squareup.okhttp.Call call = deleteUserPropertiesCall(userId, aid, progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Delete User Application Properties\n     * Deletes a user&#39;s application properties\n     * @param userId User Id (required)\n     * @param aid Application ID (optional)\n     * @return PropertiesEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PropertiesEnvelope deleteUserProperties(String userId, String aid) throws ApiException\n    {\n        ApiResponse<PropertiesEnvelope> resp = deleteUserPropertiesWithHttpInfo(userId, aid);\n        return resp.getData();\n    }\n\n    /**\n     * Delete User Application Properties\n     * Deletes a user&#39;s application properties\n     * @param userId User Id (required)\n     * @param aid Application ID (optional)\n     * @return ApiResponse&lt;PropertiesEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PropertiesEnvelope> deleteUserPropertiesWithHttpInfo(String userId, String aid) throws ApiException\n    {\n        com.squareup.okhttp.Call call = deleteUserPropertiesValidateBeforeCall(userId, aid, null, null);\n        Type localVarReturnType = new TypeToken<PropertiesEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Delete User Application Properties (asynchronously)\n     * Deletes a user&#39;s application properties\n     * @param userId User Id (required)\n     * @param aid Application ID (optional)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call deleteUserPropertiesAsync(String userId, String aid, final ApiCallback<PropertiesEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = deleteUserPropertiesValidateBeforeCall(userId, aid, progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<PropertiesEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /* Build call for getSelf */\n    private com.squareup.okhttp.Call getSelfCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/users/self\".replaceAll(\"\\\\{format\\\\}\", \"json\");\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call getSelfValidateBeforeCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n\n        com.squareup.okhttp.Call call = getSelfCall(progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Get Current User Profile\n     * Get&#39;s the current user&#39;s profile\n     * @return UserEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public UserEnvelope getSelf() throws ApiException\n    {\n        ApiResponse<UserEnvelope> resp = getSelfWithHttpInfo();\n        return resp.getData();\n    }\n\n    /**\n     * Get Current User Profile\n     * Get&#39;s the current user&#39;s profile\n     * @return ApiResponse&lt;UserEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<UserEnvelope> getSelfWithHttpInfo() throws ApiException\n    {\n        com.squareup.okhttp.Call call = getSelfValidateBeforeCall(null, null);\n        Type localVarReturnType = new TypeToken<UserEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Get Current User Profile (asynchronously)\n     * Get&#39;s the current user&#39;s profile\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call getSelfAsync(final ApiCallback<UserEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = getSelfValidateBeforeCall(progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<UserEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /* Build call for getUserDeviceTypes */\n    private com.squareup.okhttp.Call getUserDeviceTypesCall(String userId, Integer offset, Integer count, Boolean includeShared, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/users/{userId}/devicetypes\".replaceAll(\"\\\\{format\\\\}\", \"json\")\n                              .replaceAll(\"\\\\{\" + \"userId\" + \"\\\\}\", apiClient.escapeString(userId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        if (offset != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"offset\", offset));\n        if (count != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"count\", count));\n        if (includeShared != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"includeShared\", includeShared));\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call getUserDeviceTypesValidateBeforeCall(String userId, Integer offset, Integer count, Boolean includeShared, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n        // verify the required parameter 'userId' is set\n        if (userId == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'userId' when calling getUserDeviceTypes(Async)\");\n        }\n\n\n        com.squareup.okhttp.Call call = getUserDeviceTypesCall(userId, offset, count, includeShared, progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Get User Device Types\n     * Retrieve User&#39;s Device Types\n     * @param userId User ID. (required)\n     * @param offset Offset for pagination. (optional)\n     * @param count Desired count of items in the result set (optional)\n     * @param includeShared Optional. Boolean (true/false) - If false, only return the user&#39;s device types. If true, also return device types shared by other users. (optional)\n     * @return DeviceTypesEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public DeviceTypesEnvelope getUserDeviceTypes(String userId, Integer offset, Integer count, Boolean includeShared) throws ApiException\n    {\n        ApiResponse<DeviceTypesEnvelope> resp = getUserDeviceTypesWithHttpInfo(userId, offset, count, includeShared);\n        return resp.getData();\n    }\n\n    /**\n     * Get User Device Types\n     * Retrieve User&#39;s Device Types\n     * @param userId User ID. (required)\n     * @param offset Offset for pagination. (optional)\n     * @param count Desired count of items in the result set (optional)\n     * @param includeShared Optional. Boolean (true/false) - If false, only return the user&#39;s device types. If true, also return device types shared by other users. (optional)\n     * @return ApiResponse&lt;DeviceTypesEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<DeviceTypesEnvelope> getUserDeviceTypesWithHttpInfo(String userId, Integer offset, Integer count, Boolean includeShared) throws ApiException\n    {\n        com.squareup.okhttp.Call call = getUserDeviceTypesValidateBeforeCall(userId, offset, count, includeShared, null, null);\n        Type localVarReturnType = new TypeToken<DeviceTypesEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Get User Device Types (asynchronously)\n     * Retrieve User&#39;s Device Types\n     * @param userId User ID. (required)\n     * @param offset Offset for pagination. (optional)\n     * @param count Desired count of items in the result set (optional)\n     * @param includeShared Optional. Boolean (true/false) - If false, only return the user&#39;s device types. If true, also return device types shared by other users. (optional)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call getUserDeviceTypesAsync(String userId, Integer offset, Integer count, Boolean includeShared, final ApiCallback<DeviceTypesEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = getUserDeviceTypesValidateBeforeCall(userId, offset, count, includeShared, progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<DeviceTypesEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /* Build call for getUserDevices */\n    private com.squareup.okhttp.Call getUserDevicesCall(String userId, Integer offset, Integer count, Boolean includeProperties, String owner, Boolean includeShareInfo, String dtid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/users/{userId}/devices\".replaceAll(\"\\\\{format\\\\}\", \"json\")\n                              .replaceAll(\"\\\\{\" + \"userId\" + \"\\\\}\", apiClient.escapeString(userId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        if (offset != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"offset\", offset));\n        if (count != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"count\", count));\n        if (includeProperties != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"includeProperties\", includeProperties));\n        if (owner != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"owner\", owner));\n        if (includeShareInfo != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"includeShareInfo\", includeShareInfo));\n        if (dtid != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"dtid\", dtid));\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call getUserDevicesValidateBeforeCall(String userId, Integer offset, Integer count, Boolean includeProperties, String owner, Boolean includeShareInfo, String dtid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n        // verify the required parameter 'userId' is set\n        if (userId == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'userId' when calling getUserDevices(Async)\");\n        }\n\n\n        com.squareup.okhttp.Call call = getUserDevicesCall(userId, offset, count, includeProperties, owner, includeShareInfo, dtid, progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Get User Devices\n     * Retrieve User&#39;s Devices\n     * @param userId User ID (required)\n     * @param offset Offset for pagination. (optional)\n     * @param count Desired count of items in the result set (optional)\n     * @param includeProperties Optional. Boolean (true/false) - If false, only return the user&#39;s device types. If true, also return device types shared by other users. (optional)\n     * @param owner Return owned and/or shared devices. Default to ALL. (optional)\n     * @param includeShareInfo Include share info (optional)\n     * @param dtid Return only devices of this device type. If empty, assumes all device types allowed by the authorization. (optional)\n     * @return DevicesEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public DevicesEnvelope getUserDevices(String userId, Integer offset, Integer count, Boolean includeProperties, String owner, Boolean includeShareInfo, String dtid) throws ApiException\n    {\n        ApiResponse<DevicesEnvelope> resp = getUserDevicesWithHttpInfo(userId, offset, count, includeProperties, owner, includeShareInfo, dtid);\n        return resp.getData();\n    }\n\n    /**\n     * Get User Devices\n     * Retrieve User&#39;s Devices\n     * @param userId User ID (required)\n     * @param offset Offset for pagination. (optional)\n     * @param count Desired count of items in the result set (optional)\n     * @param includeProperties Optional. Boolean (true/false) - If false, only return the user&#39;s device types. If true, also return device types shared by other users. (optional)\n     * @param owner Return owned and/or shared devices. Default to ALL. (optional)\n     * @param includeShareInfo Include share info (optional)\n     * @param dtid Return only devices of this device type. If empty, assumes all device types allowed by the authorization. (optional)\n     * @return ApiResponse&lt;DevicesEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<DevicesEnvelope> getUserDevicesWithHttpInfo(String userId, Integer offset, Integer count, Boolean includeProperties, String owner, Boolean includeShareInfo, String dtid) throws ApiException\n    {\n        com.squareup.okhttp.Call call = getUserDevicesValidateBeforeCall(userId, offset, count, includeProperties, owner, includeShareInfo, dtid, null, null);\n        Type localVarReturnType = new TypeToken<DevicesEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Get User Devices (asynchronously)\n     * Retrieve User&#39;s Devices\n     * @param userId User ID (required)\n     * @param offset Offset for pagination. (optional)\n     * @param count Desired count of items in the result set (optional)\n     * @param includeProperties Optional. Boolean (true/false) - If false, only return the user&#39;s device types. If true, also return device types shared by other users. (optional)\n     * @param owner Return owned and/or shared devices. Default to ALL. (optional)\n     * @param includeShareInfo Include share info (optional)\n     * @param dtid Return only devices of this device type. If empty, assumes all device types allowed by the authorization. (optional)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call getUserDevicesAsync(String userId, Integer offset, Integer count, Boolean includeProperties, String owner, Boolean includeShareInfo, String dtid, final ApiCallback<DevicesEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = getUserDevicesValidateBeforeCall(userId, offset, count, includeProperties, owner, includeShareInfo, dtid, progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<DevicesEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /* Build call for getUserProperties */\n    private com.squareup.okhttp.Call getUserPropertiesCall(String userId, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/users/{userId}/properties\".replaceAll(\"\\\\{format\\\\}\", \"json\")\n                              .replaceAll(\"\\\\{\" + \"userId\" + \"\\\\}\", apiClient.escapeString(userId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        if (aid != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"aid\", aid));\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call getUserPropertiesValidateBeforeCall(String userId, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n        // verify the required parameter 'userId' is set\n        if (userId == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'userId' when calling getUserProperties(Async)\");\n        }\n\n\n        com.squareup.okhttp.Call call = getUserPropertiesCall(userId, aid, progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Get User application properties\n     * Get application properties of a user\n     * @param userId User Id (required)\n     * @param aid Application ID (optional)\n     * @return PropertiesEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PropertiesEnvelope getUserProperties(String userId, String aid) throws ApiException\n    {\n        ApiResponse<PropertiesEnvelope> resp = getUserPropertiesWithHttpInfo(userId, aid);\n        return resp.getData();\n    }\n\n    /**\n     * Get User application properties\n     * Get application properties of a user\n     * @param userId User Id (required)\n     * @param aid Application ID (optional)\n     * @return ApiResponse&lt;PropertiesEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PropertiesEnvelope> getUserPropertiesWithHttpInfo(String userId, String aid) throws ApiException\n    {\n        com.squareup.okhttp.Call call = getUserPropertiesValidateBeforeCall(userId, aid, null, null);\n        Type localVarReturnType = new TypeToken<PropertiesEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Get User application properties (asynchronously)\n     * Get application properties of a user\n     * @param userId User Id (required)\n     * @param aid Application ID (optional)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call getUserPropertiesAsync(String userId, String aid, final ApiCallback<PropertiesEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = getUserPropertiesValidateBeforeCall(userId, aid, progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<PropertiesEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /* Build call for getUserRules */\n    private com.squareup.okhttp.Call getUserRulesCall(String userId, Boolean excludeDisabled, Integer count, Integer offset, String owner, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/users/{userId}/rules\".replaceAll(\"\\\\{format\\\\}\", \"json\")\n                              .replaceAll(\"\\\\{\" + \"userId\" + \"\\\\}\", apiClient.escapeString(userId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        if (excludeDisabled != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"excludeDisabled\", excludeDisabled));\n        if (count != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"count\", count));\n        if (offset != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"offset\", offset));\n        if (owner != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"owner\", owner));\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call getUserRulesValidateBeforeCall(String userId, Boolean excludeDisabled, Integer count, Integer offset, String owner, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n        // verify the required parameter 'userId' is set\n        if (userId == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'userId' when calling getUserRules(Async)\");\n        }\n\n\n        com.squareup.okhttp.Call call = getUserRulesCall(userId, excludeDisabled, count, offset, owner, progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Get User Rules\n     * Retrieve User&#39;s Rules\n     * @param userId User ID. (required)\n     * @param excludeDisabled Exclude disabled rules in the result. (optional)\n     * @param count Desired count of items in the result set. (optional)\n     * @param offset Offset for pagination. (optional)\n     * @param owner Rule owner (optional)\n     * @return RulesEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public RulesEnvelope getUserRules(String userId, Boolean excludeDisabled, Integer count, Integer offset, String owner) throws ApiException\n    {\n        ApiResponse<RulesEnvelope> resp = getUserRulesWithHttpInfo(userId, excludeDisabled, count, offset, owner);\n        return resp.getData();\n    }\n\n    /**\n     * Get User Rules\n     * Retrieve User&#39;s Rules\n     * @param userId User ID. (required)\n     * @param excludeDisabled Exclude disabled rules in the result. (optional)\n     * @param count Desired count of items in the result set. (optional)\n     * @param offset Offset for pagination. (optional)\n     * @param owner Rule owner (optional)\n     * @return ApiResponse&lt;RulesEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<RulesEnvelope> getUserRulesWithHttpInfo(String userId, Boolean excludeDisabled, Integer count, Integer offset, String owner) throws ApiException\n    {\n        com.squareup.okhttp.Call call = getUserRulesValidateBeforeCall(userId, excludeDisabled, count, offset, owner, null, null);\n        Type localVarReturnType = new TypeToken<RulesEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Get User Rules (asynchronously)\n     * Retrieve User&#39;s Rules\n     * @param userId User ID. (required)\n     * @param excludeDisabled Exclude disabled rules in the result. (optional)\n     * @param count Desired count of items in the result set. (optional)\n     * @param offset Offset for pagination. (optional)\n     * @param owner Rule owner (optional)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call getUserRulesAsync(String userId, Boolean excludeDisabled, Integer count, Integer offset, String owner, final ApiCallback<RulesEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = getUserRulesValidateBeforeCall(userId, excludeDisabled, count, offset, owner, progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<RulesEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /* Build call for listAllSharesForUser */\n    private com.squareup.okhttp.Call listAllSharesForUserCall(String userId, String filter, Integer count, Integer offset, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/users/{userId}/shares\".replaceAll(\"\\\\{format\\\\}\", \"json\")\n                              .replaceAll(\"\\\\{\" + \"userId\" + \"\\\\}\", apiClient.escapeString(userId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        if (filter != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"filter\", filter));\n        if (count != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"count\", count));\n        if (offset != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"offset\", offset));\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call listAllSharesForUserValidateBeforeCall(String userId, String filter, Integer count, Integer offset, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n        // verify the required parameter 'userId' is set\n        if (userId == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'userId' when calling listAllSharesForUser(Async)\");\n        }\n\n        // verify the required parameter 'filter' is set\n        if (filter == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'filter' when calling listAllSharesForUser(Async)\");\n        }\n\n\n        com.squareup.okhttp.Call call = listAllSharesForUserCall(userId, filter, count, offset, progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Get User shares\n     * Get User shares\n     * @param userId User ID. (required)\n     * @param filter filter (required)\n     * @param count Desired count of items in the result set. (optional)\n     * @param offset Offset for pagination. (optional)\n     * @return DeviceSharingEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public DeviceSharingEnvelope listAllSharesForUser(String userId, String filter, Integer count, Integer offset) throws ApiException\n    {\n        ApiResponse<DeviceSharingEnvelope> resp = listAllSharesForUserWithHttpInfo(userId, filter, count, offset);\n        return resp.getData();\n    }\n\n    /**\n     * Get User shares\n     * Get User shares\n     * @param userId User ID. (required)\n     * @param filter filter (required)\n     * @param count Desired count of items in the result set. (optional)\n     * @param offset Offset for pagination. (optional)\n     * @return ApiResponse&lt;DeviceSharingEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<DeviceSharingEnvelope> listAllSharesForUserWithHttpInfo(String userId, String filter, Integer count, Integer offset) throws ApiException\n    {\n        com.squareup.okhttp.Call call = listAllSharesForUserValidateBeforeCall(userId, filter, count, offset, null, null);\n        Type localVarReturnType = new TypeToken<DeviceSharingEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Get User shares (asynchronously)\n     * Get User shares\n     * @param userId User ID. (required)\n     * @param filter filter (required)\n     * @param count Desired count of items in the result set. (optional)\n     * @param offset Offset for pagination. (optional)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call listAllSharesForUserAsync(String userId, String filter, Integer count, Integer offset, final ApiCallback<DeviceSharingEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = listAllSharesForUserValidateBeforeCall(userId, filter, count, offset, progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<DeviceSharingEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /* Build call for updateUserProperties */\n    private com.squareup.okhttp.Call updateUserPropertiesCall(String userId, AppProperties properties, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = properties;\n\n        // create path and map variables\n        String localVarPath = \"/users/{userId}/properties\".replaceAll(\"\\\\{format\\\\}\", \"json\")\n                              .replaceAll(\"\\\\{\" + \"userId\" + \"\\\\}\", apiClient.escapeString(userId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        if (aid != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"aid\", aid));\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n            \"application/json\"\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"PUT\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call updateUserPropertiesValidateBeforeCall(String userId, AppProperties properties, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n        // verify the required parameter 'userId' is set\n        if (userId == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'userId' when calling updateUserProperties(Async)\");\n        }\n\n        // verify the required parameter 'properties' is set\n        if (properties == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'properties' when calling updateUserProperties(Async)\");\n        }\n\n\n        com.squareup.okhttp.Call call = updateUserPropertiesCall(userId, properties, aid, progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Update User Application Properties\n     * Updates application properties of a user\n     * @param userId User Id (required)\n     * @param properties Properties to be updated (required)\n     * @param aid Application ID (optional)\n     * @return PropertiesEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PropertiesEnvelope updateUserProperties(String userId, AppProperties properties, String aid) throws ApiException\n    {\n        ApiResponse<PropertiesEnvelope> resp = updateUserPropertiesWithHttpInfo(userId, properties, aid);\n        return resp.getData();\n    }\n\n    /**\n     * Update User Application Properties\n     * Updates application properties of a user\n     * @param userId User Id (required)\n     * @param properties Properties to be updated (required)\n     * @param aid Application ID (optional)\n     * @return ApiResponse&lt;PropertiesEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PropertiesEnvelope> updateUserPropertiesWithHttpInfo(String userId, AppProperties properties, String aid) throws ApiException\n    {\n        com.squareup.okhttp.Call call = updateUserPropertiesValidateBeforeCall(userId, properties, aid, null, null);\n        Type localVarReturnType = new TypeToken<PropertiesEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Update User Application Properties (asynchronously)\n     * Updates application properties of a user\n     * @param userId User Id (required)\n     * @param properties Properties to be updated (required)\n     * @param aid Application ID (optional)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call updateUserPropertiesAsync(String userId, AppProperties properties, String aid, final ApiCallback<PropertiesEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = updateUserPropertiesValidateBeforeCall(userId, properties, aid, progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<PropertiesEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n}"}
{"repo": "artikcloud/artikcloud-java", "path": "src/main/java/cloud/artik/api/UsersApi.java", "func_name": "UsersApi.getUserProperties", "original_string": "public PropertiesEnvelope getUserProperties(String userId, String aid) throws ApiException {\n        ApiResponse<PropertiesEnvelope> resp = getUserPropertiesWithHttpInfo(userId, aid);\n        return resp.getData();\n    }", "language": "java", "code": "public PropertiesEnvelope getUserProperties(String userId, String aid) throws ApiException {\n        ApiResponse<PropertiesEnvelope> resp = getUserPropertiesWithHttpInfo(userId, aid);\n        return resp.getData();\n    }", "code_tokens": ["public", "PropertiesEnvelope", "getUserProperties", "(", "String", "userId", ",", "String", "aid", ")", "throws", "ApiException", "{", "ApiResponse", "<", "PropertiesEnvelope", ">", "resp", "=", "getUserPropertiesWithHttpInfo", "(", "userId", ",", "aid", ")", ";", "return", "resp", ".", "getData", "(", ")", ";", "}"], "docstring": "Get User application properties\nGet application properties of a user\n@param userId User Id (required)\n@param aid Application ID (optional)\n@return PropertiesEnvelope\n@throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body", "docstring_tokens": ["Get", "User", "application", "properties", "Get", "application", "properties", "of", "a", "user"], "sha": "412f447573e7796ab4f685c0bdd5eb76185a365c", "url": "https://github.com/artikcloud/artikcloud-java/blob/412f447573e7796ab4f685c0bdd5eb76185a365c/src/main/java/cloud/artik/api/UsersApi.java#L782-L785", "partition": "train", "up_fun_num": 31, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import cloud.artik.client.ApiCallback;", "import cloud.artik.client.ApiClient;", "import cloud.artik.client.ApiException;", "import cloud.artik.client.ApiResponse;", "import cloud.artik.client.Configuration;", "import cloud.artik.client.Pair;", "import cloud.artik.client.ProgressRequestBody;", "import cloud.artik.client.ProgressResponseBody;", "import com.google.gson.reflect.TypeToken;", "import java.io.IOException;", "import cloud.artik.model.AppProperties;", "import cloud.artik.model.DeviceSharingEnvelope;", "import cloud.artik.model.DeviceTypesEnvelope;", "import cloud.artik.model.DevicesEnvelope;", "import cloud.artik.model.PropertiesEnvelope;", "import cloud.artik.model.RulesEnvelope;", "import cloud.artik.model.UserEnvelope;", "import java.lang.reflect.Type;", "import java.util.ArrayList;", "import java.util.HashMap;", "import java.util.List;", "import java.util.Map;"], "function": ["public class UsersApi\n", "    public ApiClient getApiClient()\n", "    public void setApiClient(ApiClient apiClient)\n", "    private com.squareup.okhttp.Call createUserPropertiesCall(String userId, AppProperties properties, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call createUserPropertiesValidateBeforeCall(String userId, AppProperties properties, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public PropertiesEnvelope createUserProperties(String userId, AppProperties properties, String aid) throws ApiException\n", "    public ApiResponse<PropertiesEnvelope> createUserPropertiesWithHttpInfo(String userId, AppProperties properties, String aid) throws ApiException\n", "    public com.squareup.okhttp.Call createUserPropertiesAsync(String userId, AppProperties properties, String aid, final ApiCallback<PropertiesEnvelope> callback) throws ApiException\n", "    private com.squareup.okhttp.Call deleteUserPropertiesCall(String userId, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call deleteUserPropertiesValidateBeforeCall(String userId, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public PropertiesEnvelope deleteUserProperties(String userId, String aid) throws ApiException\n", "    public ApiResponse<PropertiesEnvelope> deleteUserPropertiesWithHttpInfo(String userId, String aid) throws ApiException\n", "    public com.squareup.okhttp.Call deleteUserPropertiesAsync(String userId, String aid, final ApiCallback<PropertiesEnvelope> callback) throws ApiException\n", "    private com.squareup.okhttp.Call getSelfCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call getSelfValidateBeforeCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public UserEnvelope getSelf() throws ApiException\n", "    public ApiResponse<UserEnvelope> getSelfWithHttpInfo() throws ApiException\n", "    public com.squareup.okhttp.Call getSelfAsync(final ApiCallback<UserEnvelope> callback) throws ApiException\n", "    private com.squareup.okhttp.Call getUserDeviceTypesCall(String userId, Integer offset, Integer count, Boolean includeShared, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call getUserDeviceTypesValidateBeforeCall(String userId, Integer offset, Integer count, Boolean includeShared, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public DeviceTypesEnvelope getUserDeviceTypes(String userId, Integer offset, Integer count, Boolean includeShared) throws ApiException\n", "    public ApiResponse<DeviceTypesEnvelope> getUserDeviceTypesWithHttpInfo(String userId, Integer offset, Integer count, Boolean includeShared) throws ApiException\n", "    public com.squareup.okhttp.Call getUserDeviceTypesAsync(String userId, Integer offset, Integer count, Boolean includeShared, final ApiCallback<DeviceTypesEnvelope> callback) throws ApiException\n", "    private com.squareup.okhttp.Call getUserDevicesCall(String userId, Integer offset, Integer count, Boolean includeProperties, String owner, Boolean includeShareInfo, String dtid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call getUserDevicesValidateBeforeCall(String userId, Integer offset, Integer count, Boolean includeProperties, String owner, Boolean includeShareInfo, String dtid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public DevicesEnvelope getUserDevices(String userId, Integer offset, Integer count, Boolean includeProperties, String owner, Boolean includeShareInfo, String dtid) throws ApiException\n", "    public ApiResponse<DevicesEnvelope> getUserDevicesWithHttpInfo(String userId, Integer offset, Integer count, Boolean includeProperties, String owner, Boolean includeShareInfo, String dtid) throws ApiException\n", "    public com.squareup.okhttp.Call getUserDevicesAsync(String userId, Integer offset, Integer count, Boolean includeProperties, String owner, Boolean includeShareInfo, String dtid, final ApiCallback<DevicesEnvelope> callback) throws ApiException\n", "    private com.squareup.okhttp.Call getUserPropertiesCall(String userId, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call getUserPropertiesValidateBeforeCall(String userId, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public ApiResponse<PropertiesEnvelope> getUserPropertiesWithHttpInfo(String userId, String aid) throws ApiException\n", "    public com.squareup.okhttp.Call getUserPropertiesAsync(String userId, String aid, final ApiCallback<PropertiesEnvelope> callback) throws ApiException\n", "    private com.squareup.okhttp.Call getUserRulesCall(String userId, Boolean excludeDisabled, Integer count, Integer offset, String owner, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call getUserRulesValidateBeforeCall(String userId, Boolean excludeDisabled, Integer count, Integer offset, String owner, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public RulesEnvelope getUserRules(String userId, Boolean excludeDisabled, Integer count, Integer offset, String owner) throws ApiException\n", "    public ApiResponse<RulesEnvelope> getUserRulesWithHttpInfo(String userId, Boolean excludeDisabled, Integer count, Integer offset, String owner) throws ApiException\n", "    public com.squareup.okhttp.Call getUserRulesAsync(String userId, Boolean excludeDisabled, Integer count, Integer offset, String owner, final ApiCallback<RulesEnvelope> callback) throws ApiException\n", "    private com.squareup.okhttp.Call listAllSharesForUserCall(String userId, String filter, Integer count, Integer offset, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call listAllSharesForUserValidateBeforeCall(String userId, String filter, Integer count, Integer offset, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public DeviceSharingEnvelope listAllSharesForUser(String userId, String filter, Integer count, Integer offset) throws ApiException\n", "    public ApiResponse<DeviceSharingEnvelope> listAllSharesForUserWithHttpInfo(String userId, String filter, Integer count, Integer offset) throws ApiException\n", "    public com.squareup.okhttp.Call listAllSharesForUserAsync(String userId, String filter, Integer count, Integer offset, final ApiCallback<DeviceSharingEnvelope> callback) throws ApiException\n", "    private com.squareup.okhttp.Call updateUserPropertiesCall(String userId, AppProperties properties, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    private com.squareup.okhttp.Call updateUserPropertiesValidateBeforeCall(String userId, AppProperties properties, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n", "    public PropertiesEnvelope updateUserProperties(String userId, AppProperties properties, String aid) throws ApiException\n", "    public ApiResponse<PropertiesEnvelope> updateUserPropertiesWithHttpInfo(String userId, AppProperties properties, String aid) throws ApiException\n", "    public com.squareup.okhttp.Call updateUserPropertiesAsync(String userId, AppProperties properties, String aid, final ApiCallback<PropertiesEnvelope> callback) throws ApiException\n"], "context": "/*\n * ARTIK Cloud API\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 2.0.0\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n\npackage cloud.artik.api;\n\nimport cloud.artik.client.ApiCallback;\nimport cloud.artik.client.ApiClient;\nimport cloud.artik.client.ApiException;\nimport cloud.artik.client.ApiResponse;\nimport cloud.artik.client.Configuration;\nimport cloud.artik.client.Pair;\nimport cloud.artik.client.ProgressRequestBody;\nimport cloud.artik.client.ProgressResponseBody;\n\nimport com.google.gson.reflect.TypeToken;\n\nimport java.io.IOException;\n\n\nimport cloud.artik.model.AppProperties;\nimport cloud.artik.model.DeviceSharingEnvelope;\nimport cloud.artik.model.DeviceTypesEnvelope;\nimport cloud.artik.model.DevicesEnvelope;\nimport cloud.artik.model.PropertiesEnvelope;\nimport cloud.artik.model.RulesEnvelope;\nimport cloud.artik.model.UserEnvelope;\n\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class UsersApi\n{\n    private ApiClient apiClient;\n\n    public UsersApi()\n    {\n        this(Configuration.getDefaultApiClient());\n    }\n\n    public UsersApi(ApiClient apiClient)\n    {\n        this.apiClient = apiClient;\n    }\n\n    public ApiClient getApiClient()\n    {\n        return apiClient;\n    }\n\n    public void setApiClient(ApiClient apiClient)\n    {\n        this.apiClient = apiClient;\n    }\n\n    /* Build call for createUserProperties */\n    private com.squareup.okhttp.Call createUserPropertiesCall(String userId, AppProperties properties, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = properties;\n\n        // create path and map variables\n        String localVarPath = \"/users/{userId}/properties\".replaceAll(\"\\\\{format\\\\}\", \"json\")\n                              .replaceAll(\"\\\\{\" + \"userId\" + \"\\\\}\", apiClient.escapeString(userId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        if (aid != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"aid\", aid));\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n            \"application/json\"\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call createUserPropertiesValidateBeforeCall(String userId, AppProperties properties, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n        // verify the required parameter 'userId' is set\n        if (userId == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'userId' when calling createUserProperties(Async)\");\n        }\n\n        // verify the required parameter 'properties' is set\n        if (properties == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'properties' when calling createUserProperties(Async)\");\n        }\n\n\n        com.squareup.okhttp.Call call = createUserPropertiesCall(userId, properties, aid, progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Create User Application Properties\n     * Create application properties for a user\n     * @param userId User Id (required)\n     * @param properties Properties to be updated (required)\n     * @param aid Application ID (optional)\n     * @return PropertiesEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PropertiesEnvelope createUserProperties(String userId, AppProperties properties, String aid) throws ApiException\n    {\n        ApiResponse<PropertiesEnvelope> resp = createUserPropertiesWithHttpInfo(userId, properties, aid);\n        return resp.getData();\n    }\n\n    /**\n     * Create User Application Properties\n     * Create application properties for a user\n     * @param userId User Id (required)\n     * @param properties Properties to be updated (required)\n     * @param aid Application ID (optional)\n     * @return ApiResponse&lt;PropertiesEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PropertiesEnvelope> createUserPropertiesWithHttpInfo(String userId, AppProperties properties, String aid) throws ApiException\n    {\n        com.squareup.okhttp.Call call = createUserPropertiesValidateBeforeCall(userId, properties, aid, null, null);\n        Type localVarReturnType = new TypeToken<PropertiesEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Create User Application Properties (asynchronously)\n     * Create application properties for a user\n     * @param userId User Id (required)\n     * @param properties Properties to be updated (required)\n     * @param aid Application ID (optional)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call createUserPropertiesAsync(String userId, AppProperties properties, String aid, final ApiCallback<PropertiesEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = createUserPropertiesValidateBeforeCall(userId, properties, aid, progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<PropertiesEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /* Build call for deleteUserProperties */\n    private com.squareup.okhttp.Call deleteUserPropertiesCall(String userId, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/users/{userId}/properties\".replaceAll(\"\\\\{format\\\\}\", \"json\")\n                              .replaceAll(\"\\\\{\" + \"userId\" + \"\\\\}\", apiClient.escapeString(userId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        if (aid != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"aid\", aid));\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"DELETE\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call deleteUserPropertiesValidateBeforeCall(String userId, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n        // verify the required parameter 'userId' is set\n        if (userId == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'userId' when calling deleteUserProperties(Async)\");\n        }\n\n\n        com.squareup.okhttp.Call call = deleteUserPropertiesCall(userId, aid, progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Delete User Application Properties\n     * Deletes a user&#39;s application properties\n     * @param userId User Id (required)\n     * @param aid Application ID (optional)\n     * @return PropertiesEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PropertiesEnvelope deleteUserProperties(String userId, String aid) throws ApiException\n    {\n        ApiResponse<PropertiesEnvelope> resp = deleteUserPropertiesWithHttpInfo(userId, aid);\n        return resp.getData();\n    }\n\n    /**\n     * Delete User Application Properties\n     * Deletes a user&#39;s application properties\n     * @param userId User Id (required)\n     * @param aid Application ID (optional)\n     * @return ApiResponse&lt;PropertiesEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PropertiesEnvelope> deleteUserPropertiesWithHttpInfo(String userId, String aid) throws ApiException\n    {\n        com.squareup.okhttp.Call call = deleteUserPropertiesValidateBeforeCall(userId, aid, null, null);\n        Type localVarReturnType = new TypeToken<PropertiesEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Delete User Application Properties (asynchronously)\n     * Deletes a user&#39;s application properties\n     * @param userId User Id (required)\n     * @param aid Application ID (optional)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call deleteUserPropertiesAsync(String userId, String aid, final ApiCallback<PropertiesEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = deleteUserPropertiesValidateBeforeCall(userId, aid, progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<PropertiesEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /* Build call for getSelf */\n    private com.squareup.okhttp.Call getSelfCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/users/self\".replaceAll(\"\\\\{format\\\\}\", \"json\");\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call getSelfValidateBeforeCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n\n        com.squareup.okhttp.Call call = getSelfCall(progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Get Current User Profile\n     * Get&#39;s the current user&#39;s profile\n     * @return UserEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public UserEnvelope getSelf() throws ApiException\n    {\n        ApiResponse<UserEnvelope> resp = getSelfWithHttpInfo();\n        return resp.getData();\n    }\n\n    /**\n     * Get Current User Profile\n     * Get&#39;s the current user&#39;s profile\n     * @return ApiResponse&lt;UserEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<UserEnvelope> getSelfWithHttpInfo() throws ApiException\n    {\n        com.squareup.okhttp.Call call = getSelfValidateBeforeCall(null, null);\n        Type localVarReturnType = new TypeToken<UserEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Get Current User Profile (asynchronously)\n     * Get&#39;s the current user&#39;s profile\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call getSelfAsync(final ApiCallback<UserEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = getSelfValidateBeforeCall(progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<UserEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /* Build call for getUserDeviceTypes */\n    private com.squareup.okhttp.Call getUserDeviceTypesCall(String userId, Integer offset, Integer count, Boolean includeShared, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/users/{userId}/devicetypes\".replaceAll(\"\\\\{format\\\\}\", \"json\")\n                              .replaceAll(\"\\\\{\" + \"userId\" + \"\\\\}\", apiClient.escapeString(userId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        if (offset != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"offset\", offset));\n        if (count != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"count\", count));\n        if (includeShared != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"includeShared\", includeShared));\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call getUserDeviceTypesValidateBeforeCall(String userId, Integer offset, Integer count, Boolean includeShared, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n        // verify the required parameter 'userId' is set\n        if (userId == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'userId' when calling getUserDeviceTypes(Async)\");\n        }\n\n\n        com.squareup.okhttp.Call call = getUserDeviceTypesCall(userId, offset, count, includeShared, progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Get User Device Types\n     * Retrieve User&#39;s Device Types\n     * @param userId User ID. (required)\n     * @param offset Offset for pagination. (optional)\n     * @param count Desired count of items in the result set (optional)\n     * @param includeShared Optional. Boolean (true/false) - If false, only return the user&#39;s device types. If true, also return device types shared by other users. (optional)\n     * @return DeviceTypesEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public DeviceTypesEnvelope getUserDeviceTypes(String userId, Integer offset, Integer count, Boolean includeShared) throws ApiException\n    {\n        ApiResponse<DeviceTypesEnvelope> resp = getUserDeviceTypesWithHttpInfo(userId, offset, count, includeShared);\n        return resp.getData();\n    }\n\n    /**\n     * Get User Device Types\n     * Retrieve User&#39;s Device Types\n     * @param userId User ID. (required)\n     * @param offset Offset for pagination. (optional)\n     * @param count Desired count of items in the result set (optional)\n     * @param includeShared Optional. Boolean (true/false) - If false, only return the user&#39;s device types. If true, also return device types shared by other users. (optional)\n     * @return ApiResponse&lt;DeviceTypesEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<DeviceTypesEnvelope> getUserDeviceTypesWithHttpInfo(String userId, Integer offset, Integer count, Boolean includeShared) throws ApiException\n    {\n        com.squareup.okhttp.Call call = getUserDeviceTypesValidateBeforeCall(userId, offset, count, includeShared, null, null);\n        Type localVarReturnType = new TypeToken<DeviceTypesEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Get User Device Types (asynchronously)\n     * Retrieve User&#39;s Device Types\n     * @param userId User ID. (required)\n     * @param offset Offset for pagination. (optional)\n     * @param count Desired count of items in the result set (optional)\n     * @param includeShared Optional. Boolean (true/false) - If false, only return the user&#39;s device types. If true, also return device types shared by other users. (optional)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call getUserDeviceTypesAsync(String userId, Integer offset, Integer count, Boolean includeShared, final ApiCallback<DeviceTypesEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = getUserDeviceTypesValidateBeforeCall(userId, offset, count, includeShared, progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<DeviceTypesEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /* Build call for getUserDevices */\n    private com.squareup.okhttp.Call getUserDevicesCall(String userId, Integer offset, Integer count, Boolean includeProperties, String owner, Boolean includeShareInfo, String dtid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/users/{userId}/devices\".replaceAll(\"\\\\{format\\\\}\", \"json\")\n                              .replaceAll(\"\\\\{\" + \"userId\" + \"\\\\}\", apiClient.escapeString(userId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        if (offset != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"offset\", offset));\n        if (count != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"count\", count));\n        if (includeProperties != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"includeProperties\", includeProperties));\n        if (owner != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"owner\", owner));\n        if (includeShareInfo != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"includeShareInfo\", includeShareInfo));\n        if (dtid != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"dtid\", dtid));\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call getUserDevicesValidateBeforeCall(String userId, Integer offset, Integer count, Boolean includeProperties, String owner, Boolean includeShareInfo, String dtid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n        // verify the required parameter 'userId' is set\n        if (userId == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'userId' when calling getUserDevices(Async)\");\n        }\n\n\n        com.squareup.okhttp.Call call = getUserDevicesCall(userId, offset, count, includeProperties, owner, includeShareInfo, dtid, progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Get User Devices\n     * Retrieve User&#39;s Devices\n     * @param userId User ID (required)\n     * @param offset Offset for pagination. (optional)\n     * @param count Desired count of items in the result set (optional)\n     * @param includeProperties Optional. Boolean (true/false) - If false, only return the user&#39;s device types. If true, also return device types shared by other users. (optional)\n     * @param owner Return owned and/or shared devices. Default to ALL. (optional)\n     * @param includeShareInfo Include share info (optional)\n     * @param dtid Return only devices of this device type. If empty, assumes all device types allowed by the authorization. (optional)\n     * @return DevicesEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public DevicesEnvelope getUserDevices(String userId, Integer offset, Integer count, Boolean includeProperties, String owner, Boolean includeShareInfo, String dtid) throws ApiException\n    {\n        ApiResponse<DevicesEnvelope> resp = getUserDevicesWithHttpInfo(userId, offset, count, includeProperties, owner, includeShareInfo, dtid);\n        return resp.getData();\n    }\n\n    /**\n     * Get User Devices\n     * Retrieve User&#39;s Devices\n     * @param userId User ID (required)\n     * @param offset Offset for pagination. (optional)\n     * @param count Desired count of items in the result set (optional)\n     * @param includeProperties Optional. Boolean (true/false) - If false, only return the user&#39;s device types. If true, also return device types shared by other users. (optional)\n     * @param owner Return owned and/or shared devices. Default to ALL. (optional)\n     * @param includeShareInfo Include share info (optional)\n     * @param dtid Return only devices of this device type. If empty, assumes all device types allowed by the authorization. (optional)\n     * @return ApiResponse&lt;DevicesEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<DevicesEnvelope> getUserDevicesWithHttpInfo(String userId, Integer offset, Integer count, Boolean includeProperties, String owner, Boolean includeShareInfo, String dtid) throws ApiException\n    {\n        com.squareup.okhttp.Call call = getUserDevicesValidateBeforeCall(userId, offset, count, includeProperties, owner, includeShareInfo, dtid, null, null);\n        Type localVarReturnType = new TypeToken<DevicesEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Get User Devices (asynchronously)\n     * Retrieve User&#39;s Devices\n     * @param userId User ID (required)\n     * @param offset Offset for pagination. (optional)\n     * @param count Desired count of items in the result set (optional)\n     * @param includeProperties Optional. Boolean (true/false) - If false, only return the user&#39;s device types. If true, also return device types shared by other users. (optional)\n     * @param owner Return owned and/or shared devices. Default to ALL. (optional)\n     * @param includeShareInfo Include share info (optional)\n     * @param dtid Return only devices of this device type. If empty, assumes all device types allowed by the authorization. (optional)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call getUserDevicesAsync(String userId, Integer offset, Integer count, Boolean includeProperties, String owner, Boolean includeShareInfo, String dtid, final ApiCallback<DevicesEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = getUserDevicesValidateBeforeCall(userId, offset, count, includeProperties, owner, includeShareInfo, dtid, progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<DevicesEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /* Build call for getUserProperties */\n    private com.squareup.okhttp.Call getUserPropertiesCall(String userId, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/users/{userId}/properties\".replaceAll(\"\\\\{format\\\\}\", \"json\")\n                              .replaceAll(\"\\\\{\" + \"userId\" + \"\\\\}\", apiClient.escapeString(userId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        if (aid != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"aid\", aid));\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call getUserPropertiesValidateBeforeCall(String userId, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n        // verify the required parameter 'userId' is set\n        if (userId == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'userId' when calling getUserProperties(Async)\");\n        }\n\n\n        com.squareup.okhttp.Call call = getUserPropertiesCall(userId, aid, progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Get User application properties\n     * Get application properties of a user\n     * @param userId User Id (required)\n     * @param aid Application ID (optional)\n     * @return PropertiesEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n\n    /**\n     * Get User application properties\n     * Get application properties of a user\n     * @param userId User Id (required)\n     * @param aid Application ID (optional)\n     * @return ApiResponse&lt;PropertiesEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PropertiesEnvelope> getUserPropertiesWithHttpInfo(String userId, String aid) throws ApiException\n    {\n        com.squareup.okhttp.Call call = getUserPropertiesValidateBeforeCall(userId, aid, null, null);\n        Type localVarReturnType = new TypeToken<PropertiesEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Get User application properties (asynchronously)\n     * Get application properties of a user\n     * @param userId User Id (required)\n     * @param aid Application ID (optional)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call getUserPropertiesAsync(String userId, String aid, final ApiCallback<PropertiesEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = getUserPropertiesValidateBeforeCall(userId, aid, progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<PropertiesEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /* Build call for getUserRules */\n    private com.squareup.okhttp.Call getUserRulesCall(String userId, Boolean excludeDisabled, Integer count, Integer offset, String owner, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/users/{userId}/rules\".replaceAll(\"\\\\{format\\\\}\", \"json\")\n                              .replaceAll(\"\\\\{\" + \"userId\" + \"\\\\}\", apiClient.escapeString(userId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        if (excludeDisabled != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"excludeDisabled\", excludeDisabled));\n        if (count != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"count\", count));\n        if (offset != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"offset\", offset));\n        if (owner != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"owner\", owner));\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call getUserRulesValidateBeforeCall(String userId, Boolean excludeDisabled, Integer count, Integer offset, String owner, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n        // verify the required parameter 'userId' is set\n        if (userId == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'userId' when calling getUserRules(Async)\");\n        }\n\n\n        com.squareup.okhttp.Call call = getUserRulesCall(userId, excludeDisabled, count, offset, owner, progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Get User Rules\n     * Retrieve User&#39;s Rules\n     * @param userId User ID. (required)\n     * @param excludeDisabled Exclude disabled rules in the result. (optional)\n     * @param count Desired count of items in the result set. (optional)\n     * @param offset Offset for pagination. (optional)\n     * @param owner Rule owner (optional)\n     * @return RulesEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public RulesEnvelope getUserRules(String userId, Boolean excludeDisabled, Integer count, Integer offset, String owner) throws ApiException\n    {\n        ApiResponse<RulesEnvelope> resp = getUserRulesWithHttpInfo(userId, excludeDisabled, count, offset, owner);\n        return resp.getData();\n    }\n\n    /**\n     * Get User Rules\n     * Retrieve User&#39;s Rules\n     * @param userId User ID. (required)\n     * @param excludeDisabled Exclude disabled rules in the result. (optional)\n     * @param count Desired count of items in the result set. (optional)\n     * @param offset Offset for pagination. (optional)\n     * @param owner Rule owner (optional)\n     * @return ApiResponse&lt;RulesEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<RulesEnvelope> getUserRulesWithHttpInfo(String userId, Boolean excludeDisabled, Integer count, Integer offset, String owner) throws ApiException\n    {\n        com.squareup.okhttp.Call call = getUserRulesValidateBeforeCall(userId, excludeDisabled, count, offset, owner, null, null);\n        Type localVarReturnType = new TypeToken<RulesEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Get User Rules (asynchronously)\n     * Retrieve User&#39;s Rules\n     * @param userId User ID. (required)\n     * @param excludeDisabled Exclude disabled rules in the result. (optional)\n     * @param count Desired count of items in the result set. (optional)\n     * @param offset Offset for pagination. (optional)\n     * @param owner Rule owner (optional)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call getUserRulesAsync(String userId, Boolean excludeDisabled, Integer count, Integer offset, String owner, final ApiCallback<RulesEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = getUserRulesValidateBeforeCall(userId, excludeDisabled, count, offset, owner, progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<RulesEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /* Build call for listAllSharesForUser */\n    private com.squareup.okhttp.Call listAllSharesForUserCall(String userId, String filter, Integer count, Integer offset, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/users/{userId}/shares\".replaceAll(\"\\\\{format\\\\}\", \"json\")\n                              .replaceAll(\"\\\\{\" + \"userId\" + \"\\\\}\", apiClient.escapeString(userId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        if (filter != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"filter\", filter));\n        if (count != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"count\", count));\n        if (offset != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"offset\", offset));\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call listAllSharesForUserValidateBeforeCall(String userId, String filter, Integer count, Integer offset, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n        // verify the required parameter 'userId' is set\n        if (userId == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'userId' when calling listAllSharesForUser(Async)\");\n        }\n\n        // verify the required parameter 'filter' is set\n        if (filter == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'filter' when calling listAllSharesForUser(Async)\");\n        }\n\n\n        com.squareup.okhttp.Call call = listAllSharesForUserCall(userId, filter, count, offset, progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Get User shares\n     * Get User shares\n     * @param userId User ID. (required)\n     * @param filter filter (required)\n     * @param count Desired count of items in the result set. (optional)\n     * @param offset Offset for pagination. (optional)\n     * @return DeviceSharingEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public DeviceSharingEnvelope listAllSharesForUser(String userId, String filter, Integer count, Integer offset) throws ApiException\n    {\n        ApiResponse<DeviceSharingEnvelope> resp = listAllSharesForUserWithHttpInfo(userId, filter, count, offset);\n        return resp.getData();\n    }\n\n    /**\n     * Get User shares\n     * Get User shares\n     * @param userId User ID. (required)\n     * @param filter filter (required)\n     * @param count Desired count of items in the result set. (optional)\n     * @param offset Offset for pagination. (optional)\n     * @return ApiResponse&lt;DeviceSharingEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<DeviceSharingEnvelope> listAllSharesForUserWithHttpInfo(String userId, String filter, Integer count, Integer offset) throws ApiException\n    {\n        com.squareup.okhttp.Call call = listAllSharesForUserValidateBeforeCall(userId, filter, count, offset, null, null);\n        Type localVarReturnType = new TypeToken<DeviceSharingEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Get User shares (asynchronously)\n     * Get User shares\n     * @param userId User ID. (required)\n     * @param filter filter (required)\n     * @param count Desired count of items in the result set. (optional)\n     * @param offset Offset for pagination. (optional)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call listAllSharesForUserAsync(String userId, String filter, Integer count, Integer offset, final ApiCallback<DeviceSharingEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = listAllSharesForUserValidateBeforeCall(userId, filter, count, offset, progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<DeviceSharingEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /* Build call for updateUserProperties */\n    private com.squareup.okhttp.Call updateUserPropertiesCall(String userId, AppProperties properties, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n        Object localVarPostBody = properties;\n\n        // create path and map variables\n        String localVarPath = \"/users/{userId}/properties\".replaceAll(\"\\\\{format\\\\}\", \"json\")\n                              .replaceAll(\"\\\\{\" + \"userId\" + \"\\\\}\", apiClient.escapeString(userId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        if (aid != null)\n            localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"aid\", aid));\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts =\n        {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes =\n        {\n            \"application/json\"\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        if(progressListener != null)\n        {\n            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor()\n            {\n                @Override\n                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException\n                {\n                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());\n                    return originalResponse.newBuilder()\n                           .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                           .build();\n                }\n            });\n        }\n\n        String[] localVarAuthNames = new String[] { \"artikcloud_oauth\" };\n        return apiClient.buildCall(localVarPath, \"PUT\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private com.squareup.okhttp.Call updateUserPropertiesValidateBeforeCall(String userId, AppProperties properties, String aid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException\n    {\n\n        // verify the required parameter 'userId' is set\n        if (userId == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'userId' when calling updateUserProperties(Async)\");\n        }\n\n        // verify the required parameter 'properties' is set\n        if (properties == null)\n        {\n            throw new ApiException(\"Missing the required parameter 'properties' when calling updateUserProperties(Async)\");\n        }\n\n\n        com.squareup.okhttp.Call call = updateUserPropertiesCall(userId, properties, aid, progressListener, progressRequestListener);\n        return call;\n\n\n\n\n\n    }\n\n    /**\n     * Update User Application Properties\n     * Updates application properties of a user\n     * @param userId User Id (required)\n     * @param properties Properties to be updated (required)\n     * @param aid Application ID (optional)\n     * @return PropertiesEnvelope\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PropertiesEnvelope updateUserProperties(String userId, AppProperties properties, String aid) throws ApiException\n    {\n        ApiResponse<PropertiesEnvelope> resp = updateUserPropertiesWithHttpInfo(userId, properties, aid);\n        return resp.getData();\n    }\n\n    /**\n     * Update User Application Properties\n     * Updates application properties of a user\n     * @param userId User Id (required)\n     * @param properties Properties to be updated (required)\n     * @param aid Application ID (optional)\n     * @return ApiResponse&lt;PropertiesEnvelope&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PropertiesEnvelope> updateUserPropertiesWithHttpInfo(String userId, AppProperties properties, String aid) throws ApiException\n    {\n        com.squareup.okhttp.Call call = updateUserPropertiesValidateBeforeCall(userId, properties, aid, null, null);\n        Type localVarReturnType = new TypeToken<PropertiesEnvelope>() {} .getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * Update User Application Properties (asynchronously)\n     * Updates application properties of a user\n     * @param userId User Id (required)\n     * @param properties Properties to be updated (required)\n     * @param aid Application ID (optional)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public com.squareup.okhttp.Call updateUserPropertiesAsync(String userId, AppProperties properties, String aid, final ApiCallback<PropertiesEnvelope> callback) throws ApiException\n    {\n\n        ProgressResponseBody.ProgressListener progressListener = null;\n        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n        if (callback != null)\n        {\n            progressListener = new ProgressResponseBody.ProgressListener()\n            {\n                @Override\n                public void update(long bytesRead, long contentLength, boolean done)\n                {\n                    callback.onDownloadProgress(bytesRead, contentLength, done);\n                }\n            };\n\n            progressRequestListener = new ProgressRequestBody.ProgressRequestListener()\n            {\n                @Override\n                public void onRequestProgress(long bytesWritten, long contentLength, boolean done)\n                {\n                    callback.onUploadProgress(bytesWritten, contentLength, done);\n                }\n            };\n        }\n\n        com.squareup.okhttp.Call call = updateUserPropertiesValidateBeforeCall(userId, properties, aid, progressListener, progressRequestListener);\n        Type localVarReturnType = new TypeToken<PropertiesEnvelope>() {} .getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n}"}
{"repo": "skuzzle/jeve", "path": "jeve/src/main/java/de/skuzzle/jeve/stores/AbstractListenerStore.java", "func_name": "AbstractListenerStore.copyList", "original_string": "protected <T extends Listener> Collection<T> copyList(Class<T> listenerClass,\n            Stream<Object> listeners, int sizeHint) {\n        if (sizeHint == 0) {\n            return Collections.emptyList();\n        }\n        return listeners\n                .map(listenerClass::cast)\n                .collect(Collectors.toCollection(() -> new ArrayList<>(sizeHint)));\n    }", "language": "java", "code": "protected <T extends Listener> Collection<T> copyList(Class<T> listenerClass,\n            Stream<Object> listeners, int sizeHint) {\n        if (sizeHint == 0) {\n            return Collections.emptyList();\n        }\n        return listeners\n                .map(listenerClass::cast)\n                .collect(Collectors.toCollection(() -> new ArrayList<>(sizeHint)));\n    }", "code_tokens": ["protected", "<", "T", "extends", "Listener", ">", "Collection", "<", "T", ">", "copyList", "(", "Class", "<", "T", ">", "listenerClass", ",", "Stream", "<", "Object", ">", "listeners", ",", "int", "sizeHint", ")", "{", "if", "(", "sizeHint", "==", "0", ")", "{", "return", "Collections", ".", "emptyList", "(", ")", ";", "}", "return", "listeners", ".", "map", "(", "listenerClass", "::", "cast", ")", ".", "collect", "(", "Collectors", ".", "toCollection", "(", "(", ")", "->", "new", "ArrayList", "<>", "(", "sizeHint", ")", ")", ")", ";", "}"], "docstring": "Creates a collection from the given stream, casting each object to the\nprovided listener class. The returned collection must not necessarily be\nmutable.\n\n@param <T> Type of the listeners in the given list.\n@param listenerClass The class of the objects in the provided list.\n@param listeners The stream to obtain the listeners for the resulting\ncollection from.\n@param sizeHint Expected size of the input stream.\n@return A typed copy of the list.", "docstring_tokens": ["Creates", "a", "collection", "from", "the", "given", "stream", "casting", "each", "object", "to", "the", "provided", "listener", "class", ".", "The", "returned", "collection", "must", "not", "necessarily", "be", "mutable", "."], "sha": "42cc18947c9c8596c34410336e4e375e9fcd7c47", "url": "https://github.com/skuzzle/jeve/blob/42cc18947c9c8596c34410336e4e375e9fcd7c47/jeve/src/main/java/de/skuzzle/jeve/stores/AbstractListenerStore.java#L66-L74", "partition": "train", "up_fun_num": 4, "levels": [0, 1, 1, 1, 1, 1, 1], "package": ["import java.util.ArrayList;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.HashSet;", "import java.util.List;", "import java.util.Set;", "import java.util.stream.Collectors;", "import java.util.stream.Stream;", "import org.slf4j.Logger;", "import org.slf4j.LoggerFactory;", "import de.skuzzle.jeve.Listener;", "import de.skuzzle.jeve.ListenerStore;", "import de.skuzzle.jeve.annotation.ListenerInterface;", "import de.skuzzle.jeve.annotation.ListenerKind;"], "function": ["public abstract class AbstractListenerStore implements ListenerStore\n", "    protected abstract <T> List<T> createListenerList(int sizeHint);\n", "    protected final <T> List<T> createListenerList()\n", "    public <T extends Listener> void add(T listener)\n", "    public <T extends Listener> void remove(T listener)\n", "    private void handleClass(Class<?> cls, Collection<Class<? extends Listener>> result)\n", "    private boolean shouldAdd(Class<?> cls)\n"], "context": "package de.skuzzle.jeve.stores;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport de.skuzzle.jeve.Listener;\nimport de.skuzzle.jeve.ListenerStore;\nimport de.skuzzle.jeve.annotation.ListenerInterface;\nimport de.skuzzle.jeve.annotation.ListenerKind;\n\n/**\n * Abstract helper class for implementing your own {@link ListenerStore\n * ListenerStores}.\n *\n * @author Simon Taddiken\n * @since 3.0.0\n */\npublic abstract class AbstractListenerStore implements ListenerStore\n{\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(\n            AbstractListenerStore.class);\n\n    /** The default size hint for {@link #createListenerList()} */\n    protected static final int DEFAULT_SIZE_HINT = 8;\n\n    /**\n     * Returns the List object to store listeners in.\n     *\n     * @param <T> Type of the resulting List.\n     * @param sizeHint The expected initial size of the list to create.\n     * @return A new List instance.\n     */\n    protected abstract <T> List<T> createListenerList(int sizeHint);\n\n    /**\n     * Returns the List object to store listeners in.\n     *\n     * @param <T> Type of the resulting List.\n     * @return A new List instance.\n     */\n    protected final <T> List<T> createListenerList()\n    {\n        return createListenerList(DEFAULT_SIZE_HINT);\n    }\n\n    /**\n     * Creates a collection from the given stream, casting each object to the\n     * provided listener class. The returned collection must not necessarily be\n     * mutable.\n     *\n     * @param <T> Type of the listeners in the given list.\n     * @param listenerClass The class of the objects in the provided list.\n     * @param listeners The stream to obtain the listeners for the resulting\n     *            collection from.\n     * @param sizeHint Expected size of the input stream.\n     * @return A typed copy of the list.\n     */\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends Listener> void add(T listener)\n    {\n        final Set<Class<? extends Listener>> toAdd = new HashSet<>();\n        handleClass(listener.getClass(), toAdd);\n        LOGGER.debug(\"{} will be registered for {}\", toAdd);\n        toAdd.forEach(listenerClass -> add((Class<T>) listenerClass, listener));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends Listener> void remove(T listener)\n    {\n        final List<Class<? extends Listener>> toRemove = new ArrayList<>();\n        handleClass(listener.getClass(), toRemove);\n        toRemove.forEach(listenerClass -> remove((Class<T>) listenerClass, listener));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void handleClass(Class<?> cls, Collection<Class<? extends Listener>> result)\n    {\n        if (cls == null)\n        {\n            return;\n        }\n        for (final Class<?> interf : cls.getInterfaces())\n        {\n            if (shouldAdd(interf))\n            {\n                result.add((Class<? extends Listener>) interf);\n            }\n            else\n            {\n                handleClass(interf, result);\n            }\n        }\n        handleClass(cls.getSuperclass(), result);\n    }\n\n    private boolean shouldAdd(Class<?> cls)\n    {\n        if (cls.isAnnotationPresent(ListenerInterface.class))\n        {\n            final ListenerInterface li = cls.getAnnotation(ListenerInterface.class);\n            if (li.value() == ListenerKind.TAGGING)\n            {\n                return false;\n            }\n        }\n        return cls != Listener.class && Listener.class.isAssignableFrom(cls);\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/cluster/DBScan.java", "func_name": "DBScan.cluster", "original_string": "public List<Cluster> cluster(final Collection<Point2D> points) {\n    \tfinal List<Cluster> clusters = new ArrayList<Cluster>();\n        final Map<Point2D, PointStatus> visited = new HashMap<Point2D, DBScan.PointStatus>();\n\n        KDTree<Point2D> tree = new KDTree<Point2D>(2);\n        \n        // Populate the kdTree\n        for (final Point2D point : points) {\n        \tdouble[] key = {point.x, point.y};\n        \ttree.insert(key, point);\n        }\n                \n        for (final Point2D point : points) {\n            if (visited.get(point) != null) {\n                continue;\n            }\n            final List<Point2D> neighbors = getNeighbors(point, tree);\n            if (neighbors.size() >= minPoints) {\n                // DBSCAN does not care about center points\n                final Cluster cluster = new Cluster(clusters.size());\n                clusters.add(expandCluster(cluster, point, neighbors, tree, visited));\n            } else {\n                visited.put(point, PointStatus.NOISE);\n            }\n        }\n\n        for (Cluster cluster : clusters) {\n        \tcluster.calculateCentroid();\n        }\n        \n        return clusters;\n    }", "language": "java", "code": "public List<Cluster> cluster(final Collection<Point2D> points) {\n    \tfinal List<Cluster> clusters = new ArrayList<Cluster>();\n        final Map<Point2D, PointStatus> visited = new HashMap<Point2D, DBScan.PointStatus>();\n\n        KDTree<Point2D> tree = new KDTree<Point2D>(2);\n        \n        // Populate the kdTree\n        for (final Point2D point : points) {\n        \tdouble[] key = {point.x, point.y};\n        \ttree.insert(key, point);\n        }\n                \n        for (final Point2D point : points) {\n            if (visited.get(point) != null) {\n                continue;\n            }\n            final List<Point2D> neighbors = getNeighbors(point, tree);\n            if (neighbors.size() >= minPoints) {\n                // DBSCAN does not care about center points\n                final Cluster cluster = new Cluster(clusters.size());\n                clusters.add(expandCluster(cluster, point, neighbors, tree, visited));\n            } else {\n                visited.put(point, PointStatus.NOISE);\n            }\n        }\n\n        for (Cluster cluster : clusters) {\n        \tcluster.calculateCentroid();\n        }\n        \n        return clusters;\n    }", "code_tokens": ["public", "List", "<", "Cluster", ">", "cluster", "(", "final", "Collection", "<", "Point2D", ">", "points", ")", "{", "final", "List", "<", "Cluster", ">", "clusters", "=", "new", "ArrayList", "<", "Cluster", ">", "(", ")", ";", "final", "Map", "<", "Point2D", ",", "PointStatus", ">", "visited", "=", "new", "HashMap", "<", "Point2D", ",", "DBScan", ".", "PointStatus", ">", "(", ")", ";", "KDTree", "<", "Point2D", ">", "tree", "=", "new", "KDTree", "<", "Point2D", ">", "(", "2", ")", ";", "// Populate the kdTree", "for", "(", "final", "Point2D", "point", ":", "points", ")", "{", "double", "[", "]", "key", "=", "{", "point", ".", "x", ",", "point", ".", "y", "}", ";", "tree", ".", "insert", "(", "key", ",", "point", ")", ";", "}", "for", "(", "final", "Point2D", "point", ":", "points", ")", "{", "if", "(", "visited", ".", "get", "(", "point", ")", "!=", "null", ")", "{", "continue", ";", "}", "final", "List", "<", "Point2D", ">", "neighbors", "=", "getNeighbors", "(", "point", ",", "tree", ")", ";", "if", "(", "neighbors", ".", "size", "(", ")", ">=", "minPoints", ")", "{", "// DBSCAN does not care about center points", "final", "Cluster", "cluster", "=", "new", "Cluster", "(", "clusters", ".", "size", "(", ")", ")", ";", "clusters", ".", "add", "(", "expandCluster", "(", "cluster", ",", "point", ",", "neighbors", ",", "tree", ",", "visited", ")", ")", ";", "}", "else", "{", "visited", ".", "put", "(", "point", ",", "PointStatus", ".", "NOISE", ")", ";", "}", "}", "for", "(", "Cluster", "cluster", ":", "clusters", ")", "{", "cluster", ".", "calculateCentroid", "(", ")", ";", "}", "return", "clusters", ";", "}"], "docstring": "Performs DBSCAN cluster analysis.\n\n@param points the points to cluster\n@return the list of clusters\n@throws NullArgumentException if the data points are null", "docstring_tokens": ["Performs", "DBSCAN", "cluster", "analysis", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/cluster/DBScan.java#L71-L102", "partition": "train", "up_fun_num": 4, "levels": [0, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.etyl.geometry.Point2D;", "import com.harium.storage.kdtree.KDTree;", "import java.util.ArrayList;", "import java.util.Collection;", "import java.util.HashMap;", "import java.util.HashSet;", "import java.util.List;", "import java.util.Map;", "import java.util.Set;"], "function": ["public class DBScan\n", "    public double getEps()\n", "    public int getMinPoints()\n", "    private Cluster expandCluster(final Cluster cluster,\n", "    private List<Point2D> getNeighbors(final Point2D point, KDTree<Point2D> points)\n", "    private List<Point2D> merge(final List<Point2D> one, final List<Point2D> two)\n", "    public void setEps(double eps)\n", "    public void setMinPoints(int minPoints)\n"], "context": "package com.harium.keel.cluster;\n\nimport com.harium.etyl.geometry.Point2D;\nimport com.harium.storage.kdtree.KDTree;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Forked from: http://alvinalexander.com/java/jwarehouse/commons-math3-3.6.1/src/main/java/org/apache/commons/math3/ml/clustering/DBSCANClusterer.java.shtml\n *\n */\npublic class DBScan\n{\n\n    /** Maximum radius of the neighborhood to be considered. */\n    private double eps;\n\n    /** Minimum number of points needed for a cluster. */\n    private int minPoints;\n\n    /** Status of a point during the clustering process. */\n    private enum PointStatus\n    {\n        /** The point has is considered to be noise. */\n        NOISE,\n        /** The point is already part of a cluster. */\n        PART_OF_CLUSTER\n    }\n\n    /**\n     * Creates a new instance of a DBSCANClusterer.\n     *\n     * @param eps maximum radius of the neighborhood to be considered\n     * @param minPts minimum number of points needed for a cluster\n     * @param measure the distance measure to use\n     */\n    public DBScan(final double eps, final int minPoints)\n    {\n        super();\n\n        this.eps = eps;\n        this.minPoints = minPoints;\n    }\n\n    /**\n     * Returns the maximum radius of the neighborhood to be considered.\n     * @return maximum radius of the neighborhood\n     */\n    public double getEps()\n    {\n        return eps;\n    }\n\n    /**\n     * Returns the minimum number of points needed for a cluster.\n     * @return minimum number of points needed for a cluster\n     */\n    public int getMinPoints()\n    {\n        return minPoints;\n    }\n\n    /**\n     * Performs DBSCAN cluster analysis.\n     *\n     * @param points the points to cluster\n     * @return the list of clusters\n     * @throws NullArgumentException if the data points are null\n     */\n\n    /**\n     * Expands the cluster to include density-reachable items.\n     *\n     * @param cluster Cluster to expand\n     * @param point Point to add to cluster\n     * @param neighbors List of neighbors\n     * @param points the data set\n     * @param visited the set of already visited points\n     * @return the expanded cluster\n     */\n    private Cluster expandCluster(final Cluster cluster,\n                                  final Point2D point,\n                                  final List<Point2D> neighbors,\n                                  final KDTree<Point2D> points,\n                                  final Map<Point2D, PointStatus> visited)\n    {\n        cluster.addPoint(point);\n        visited.put(point, PointStatus.PART_OF_CLUSTER);\n\n        List<Point2D> seeds = new ArrayList<Point2D>(neighbors);\n        int index = 0;\n        while (index < seeds.size())\n        {\n            Point2D current = seeds.get(index);\n            PointStatus pStatus = visited.get(current);\n            // only check non-visited points\n            if (pStatus == null)\n            {\n                final List<Point2D> currentNeighbors = getNeighbors(current, points);\n                if (currentNeighbors.size() >= minPoints)\n                {\n                    seeds = merge(seeds, currentNeighbors);\n                }\n            }\n\n            if (pStatus != PointStatus.PART_OF_CLUSTER)\n            {\n                visited.put(current, PointStatus.PART_OF_CLUSTER);\n                cluster.addPoint(current);\n            }\n\n            index++;\n        }\n        return cluster;\n    }\n\n    /**\n     * Returns a list of density-reachable neighbors of a {@code point}.\n     *\n     * @param point the point to look for\n     * @param points possible neighbors\n     * @return the List of neighbors\n     */\n    private List<Point2D> getNeighbors(final Point2D point, KDTree<Point2D> points)\n    {\n        double[] key = {point.x, point.y};\n        final List<Point2D> neighbors = new ArrayList<Point2D>();\n\n        neighbors.addAll(points.nearestEuclidean(key, eps));\n\n        return neighbors;\n    }\n\n    /**\n        * Merges two lists together.\n        *\n        * @param one first list\n        * @param two second list\n        * @return merged lists\n        */\n    private List<Point2D> merge(final List<Point2D> one, final List<Point2D> two)\n    {\n        final Set<Point2D> oneSet = new HashSet<Point2D>(one);\n        for (Point2D item : two)\n        {\n            if (!oneSet.contains(item))\n            {\n                one.add(item);\n            }\n        }\n        return one;\n    }\n\n    public void setEps(double eps)\n    {\n        this.eps = eps;\n    }\n\n    public void setMinPoints(int minPoints)\n    {\n        this.minPoints = minPoints;\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/cluster/DBScan.java", "func_name": "DBScan.expandCluster", "original_string": "private Cluster expandCluster(final Cluster cluster,\n                                     final Point2D point,\n                                     final List<Point2D> neighbors,\n                                     final KDTree<Point2D> points,\n                                     final Map<Point2D, PointStatus> visited) {\n        cluster.addPoint(point);\n        visited.put(point, PointStatus.PART_OF_CLUSTER);\n\n        List<Point2D> seeds = new ArrayList<Point2D>(neighbors);\n        int index = 0;\n        while (index < seeds.size()) {\n            Point2D current = seeds.get(index);\n            PointStatus pStatus = visited.get(current);\n            // only check non-visited points\n            if (pStatus == null) {\n                final List<Point2D> currentNeighbors = getNeighbors(current, points);\n                if (currentNeighbors.size() >= minPoints) {\n                    seeds = merge(seeds, currentNeighbors);\n                }\n            }\n\n            if (pStatus != PointStatus.PART_OF_CLUSTER) {\n                visited.put(current, PointStatus.PART_OF_CLUSTER);\n                cluster.addPoint(current);\n            }\n\n            index++;\n        }\n        return cluster;\n    }", "language": "java", "code": "private Cluster expandCluster(final Cluster cluster,\n                                     final Point2D point,\n                                     final List<Point2D> neighbors,\n                                     final KDTree<Point2D> points,\n                                     final Map<Point2D, PointStatus> visited) {\n        cluster.addPoint(point);\n        visited.put(point, PointStatus.PART_OF_CLUSTER);\n\n        List<Point2D> seeds = new ArrayList<Point2D>(neighbors);\n        int index = 0;\n        while (index < seeds.size()) {\n            Point2D current = seeds.get(index);\n            PointStatus pStatus = visited.get(current);\n            // only check non-visited points\n            if (pStatus == null) {\n                final List<Point2D> currentNeighbors = getNeighbors(current, points);\n                if (currentNeighbors.size() >= minPoints) {\n                    seeds = merge(seeds, currentNeighbors);\n                }\n            }\n\n            if (pStatus != PointStatus.PART_OF_CLUSTER) {\n                visited.put(current, PointStatus.PART_OF_CLUSTER);\n                cluster.addPoint(current);\n            }\n\n            index++;\n        }\n        return cluster;\n    }", "code_tokens": ["private", "Cluster", "expandCluster", "(", "final", "Cluster", "cluster", ",", "final", "Point2D", "point", ",", "final", "List", "<", "Point2D", ">", "neighbors", ",", "final", "KDTree", "<", "Point2D", ">", "points", ",", "final", "Map", "<", "Point2D", ",", "PointStatus", ">", "visited", ")", "{", "cluster", ".", "addPoint", "(", "point", ")", ";", "visited", ".", "put", "(", "point", ",", "PointStatus", ".", "PART_OF_CLUSTER", ")", ";", "List", "<", "Point2D", ">", "seeds", "=", "new", "ArrayList", "<", "Point2D", ">", "(", "neighbors", ")", ";", "int", "index", "=", "0", ";", "while", "(", "index", "<", "seeds", ".", "size", "(", ")", ")", "{", "Point2D", "current", "=", "seeds", ".", "get", "(", "index", ")", ";", "PointStatus", "pStatus", "=", "visited", ".", "get", "(", "current", ")", ";", "// only check non-visited points", "if", "(", "pStatus", "==", "null", ")", "{", "final", "List", "<", "Point2D", ">", "currentNeighbors", "=", "getNeighbors", "(", "current", ",", "points", ")", ";", "if", "(", "currentNeighbors", ".", "size", "(", ")", ">=", "minPoints", ")", "{", "seeds", "=", "merge", "(", "seeds", ",", "currentNeighbors", ")", ";", "}", "}", "if", "(", "pStatus", "!=", "PointStatus", ".", "PART_OF_CLUSTER", ")", "{", "visited", ".", "put", "(", "current", ",", "PointStatus", ".", "PART_OF_CLUSTER", ")", ";", "cluster", ".", "addPoint", "(", "current", ")", ";", "}", "index", "++", ";", "}", "return", "cluster", ";", "}"], "docstring": "Expands the cluster to include density-reachable items.\n\n@param cluster Cluster to expand\n@param point Point to add to cluster\n@param neighbors List of neighbors\n@param points the data set\n@param visited the set of already visited points\n@return the expanded cluster", "docstring_tokens": ["Expands", "the", "cluster", "to", "include", "density", "-", "reachable", "items", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/cluster/DBScan.java#L114-L143", "partition": "train", "up_fun_num": 5, "levels": [0, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.etyl.geometry.Point2D;", "import com.harium.storage.kdtree.KDTree;", "import java.util.ArrayList;", "import java.util.Collection;", "import java.util.HashMap;", "import java.util.HashSet;", "import java.util.List;", "import java.util.Map;", "import java.util.Set;"], "function": ["public class DBScan\n", "    public double getEps()\n", "    public int getMinPoints()\n", "    public List<Cluster> cluster(final Collection<Point2D> points)\n", "    private List<Point2D> getNeighbors(final Point2D point, KDTree<Point2D> points)\n", "    private List<Point2D> merge(final List<Point2D> one, final List<Point2D> two)\n", "    public void setEps(double eps)\n", "    public void setMinPoints(int minPoints)\n"], "context": "package com.harium.keel.cluster;\n\nimport com.harium.etyl.geometry.Point2D;\nimport com.harium.storage.kdtree.KDTree;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Forked from: http://alvinalexander.com/java/jwarehouse/commons-math3-3.6.1/src/main/java/org/apache/commons/math3/ml/clustering/DBSCANClusterer.java.shtml\n *\n */\npublic class DBScan\n{\n\n    /** Maximum radius of the neighborhood to be considered. */\n    private double eps;\n\n    /** Minimum number of points needed for a cluster. */\n    private int minPoints;\n\n    /** Status of a point during the clustering process. */\n    private enum PointStatus\n    {\n        /** The point has is considered to be noise. */\n        NOISE,\n        /** The point is already part of a cluster. */\n        PART_OF_CLUSTER\n    }\n\n    /**\n     * Creates a new instance of a DBSCANClusterer.\n     *\n     * @param eps maximum radius of the neighborhood to be considered\n     * @param minPts minimum number of points needed for a cluster\n     * @param measure the distance measure to use\n     */\n    public DBScan(final double eps, final int minPoints)\n    {\n        super();\n\n        this.eps = eps;\n        this.minPoints = minPoints;\n    }\n\n    /**\n     * Returns the maximum radius of the neighborhood to be considered.\n     * @return maximum radius of the neighborhood\n     */\n    public double getEps()\n    {\n        return eps;\n    }\n\n    /**\n     * Returns the minimum number of points needed for a cluster.\n     * @return minimum number of points needed for a cluster\n     */\n    public int getMinPoints()\n    {\n        return minPoints;\n    }\n\n    /**\n     * Performs DBSCAN cluster analysis.\n     *\n     * @param points the points to cluster\n     * @return the list of clusters\n     * @throws NullArgumentException if the data points are null\n     */\n    public List<Cluster> cluster(final Collection<Point2D> points)\n    {\n        final List<Cluster> clusters = new ArrayList<Cluster>();\n        final Map<Point2D, PointStatus> visited = new HashMap<Point2D, DBScan.PointStatus>();\n\n        KDTree<Point2D> tree = new KDTree<Point2D>(2);\n\n        // Populate the kdTree\n        for (final Point2D point : points)\n        {\n            double[] key = {point.x, point.y};\n            tree.insert(key, point);\n        }\n\n        for (final Point2D point : points)\n        {\n            if (visited.get(point) != null)\n            {\n                continue;\n            }\n            final List<Point2D> neighbors = getNeighbors(point, tree);\n            if (neighbors.size() >= minPoints)\n            {\n                // DBSCAN does not care about center points\n                final Cluster cluster = new Cluster(clusters.size());\n                clusters.add(expandCluster(cluster, point, neighbors, tree, visited));\n            }\n            else\n            {\n                visited.put(point, PointStatus.NOISE);\n            }\n        }\n\n        for (Cluster cluster : clusters)\n        {\n            cluster.calculateCentroid();\n        }\n\n        return clusters;\n    }\n\n    /**\n     * Expands the cluster to include density-reachable items.\n     *\n     * @param cluster Cluster to expand\n     * @param point Point to add to cluster\n     * @param neighbors List of neighbors\n     * @param points the data set\n     * @param visited the set of already visited points\n     * @return the expanded cluster\n     */\n\n    /**\n     * Returns a list of density-reachable neighbors of a {@code point}.\n     *\n     * @param point the point to look for\n     * @param points possible neighbors\n     * @return the List of neighbors\n     */\n    private List<Point2D> getNeighbors(final Point2D point, KDTree<Point2D> points)\n    {\n        double[] key = {point.x, point.y};\n        final List<Point2D> neighbors = new ArrayList<Point2D>();\n\n        neighbors.addAll(points.nearestEuclidean(key, eps));\n\n        return neighbors;\n    }\n\n    /**\n        * Merges two lists together.\n        *\n        * @param one first list\n        * @param two second list\n        * @return merged lists\n        */\n    private List<Point2D> merge(final List<Point2D> one, final List<Point2D> two)\n    {\n        final Set<Point2D> oneSet = new HashSet<Point2D>(one);\n        for (Point2D item : two)\n        {\n            if (!oneSet.contains(item))\n            {\n                one.add(item);\n            }\n        }\n        return one;\n    }\n\n    public void setEps(double eps)\n    {\n        this.eps = eps;\n    }\n\n    public void setMinPoints(int minPoints)\n    {\n        this.minPoints = minPoints;\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/cluster/DBScan.java", "func_name": "DBScan.merge", "original_string": "private List<Point2D> merge(final List<Point2D> one, final List<Point2D> two) {\n        final Set<Point2D> oneSet = new HashSet<Point2D>(one);\n        for (Point2D item : two) {\n            if (!oneSet.contains(item)) {\n                one.add(item);\n            }\n        }\n        return one;\n    }", "language": "java", "code": "private List<Point2D> merge(final List<Point2D> one, final List<Point2D> two) {\n        final Set<Point2D> oneSet = new HashSet<Point2D>(one);\n        for (Point2D item : two) {\n            if (!oneSet.contains(item)) {\n                one.add(item);\n            }\n        }\n        return one;\n    }", "code_tokens": ["private", "List", "<", "Point2D", ">", "merge", "(", "final", "List", "<", "Point2D", ">", "one", ",", "final", "List", "<", "Point2D", ">", "two", ")", "{", "final", "Set", "<", "Point2D", ">", "oneSet", "=", "new", "HashSet", "<", "Point2D", ">", "(", "one", ")", ";", "for", "(", "Point2D", "item", ":", "two", ")", "{", "if", "(", "!", "oneSet", ".", "contains", "(", "item", ")", ")", "{", "one", ".", "add", "(", "item", ")", ";", "}", "}", "return", "one", ";", "}"], "docstring": "Merges two lists together.\n\n@param one first list\n@param two second list\n@return merged lists", "docstring_tokens": ["Merges", "two", "lists", "together", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/cluster/DBScan.java#L168-L176", "partition": "train", "up_fun_num": 7, "levels": [0, 1, 1, 1, 1, 1, 1, 1], "package": ["import com.harium.etyl.geometry.Point2D;", "import com.harium.storage.kdtree.KDTree;", "import java.util.ArrayList;", "import java.util.Collection;", "import java.util.HashMap;", "import java.util.HashSet;", "import java.util.List;", "import java.util.Map;", "import java.util.Set;"], "function": ["public class DBScan\n", "    public double getEps()\n", "    public int getMinPoints()\n", "    public List<Cluster> cluster(final Collection<Point2D> points)\n", "    private Cluster expandCluster(final Cluster cluster,\n", "    private List<Point2D> getNeighbors(final Point2D point, KDTree<Point2D> points)\n", "    public void setEps(double eps)\n", "    public void setMinPoints(int minPoints)\n"], "context": "package com.harium.keel.cluster;\n\nimport com.harium.etyl.geometry.Point2D;\nimport com.harium.storage.kdtree.KDTree;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Forked from: http://alvinalexander.com/java/jwarehouse/commons-math3-3.6.1/src/main/java/org/apache/commons/math3/ml/clustering/DBSCANClusterer.java.shtml\n *\n */\npublic class DBScan\n{\n\n    /** Maximum radius of the neighborhood to be considered. */\n    private double eps;\n\n    /** Minimum number of points needed for a cluster. */\n    private int minPoints;\n\n    /** Status of a point during the clustering process. */\n    private enum PointStatus\n    {\n        /** The point has is considered to be noise. */\n        NOISE,\n        /** The point is already part of a cluster. */\n        PART_OF_CLUSTER\n    }\n\n    /**\n     * Creates a new instance of a DBSCANClusterer.\n     *\n     * @param eps maximum radius of the neighborhood to be considered\n     * @param minPts minimum number of points needed for a cluster\n     * @param measure the distance measure to use\n     */\n    public DBScan(final double eps, final int minPoints)\n    {\n        super();\n\n        this.eps = eps;\n        this.minPoints = minPoints;\n    }\n\n    /**\n     * Returns the maximum radius of the neighborhood to be considered.\n     * @return maximum radius of the neighborhood\n     */\n    public double getEps()\n    {\n        return eps;\n    }\n\n    /**\n     * Returns the minimum number of points needed for a cluster.\n     * @return minimum number of points needed for a cluster\n     */\n    public int getMinPoints()\n    {\n        return minPoints;\n    }\n\n    /**\n     * Performs DBSCAN cluster analysis.\n     *\n     * @param points the points to cluster\n     * @return the list of clusters\n     * @throws NullArgumentException if the data points are null\n     */\n    public List<Cluster> cluster(final Collection<Point2D> points)\n    {\n        final List<Cluster> clusters = new ArrayList<Cluster>();\n        final Map<Point2D, PointStatus> visited = new HashMap<Point2D, DBScan.PointStatus>();\n\n        KDTree<Point2D> tree = new KDTree<Point2D>(2);\n\n        // Populate the kdTree\n        for (final Point2D point : points)\n        {\n            double[] key = {point.x, point.y};\n            tree.insert(key, point);\n        }\n\n        for (final Point2D point : points)\n        {\n            if (visited.get(point) != null)\n            {\n                continue;\n            }\n            final List<Point2D> neighbors = getNeighbors(point, tree);\n            if (neighbors.size() >= minPoints)\n            {\n                // DBSCAN does not care about center points\n                final Cluster cluster = new Cluster(clusters.size());\n                clusters.add(expandCluster(cluster, point, neighbors, tree, visited));\n            }\n            else\n            {\n                visited.put(point, PointStatus.NOISE);\n            }\n        }\n\n        for (Cluster cluster : clusters)\n        {\n            cluster.calculateCentroid();\n        }\n\n        return clusters;\n    }\n\n    /**\n     * Expands the cluster to include density-reachable items.\n     *\n     * @param cluster Cluster to expand\n     * @param point Point to add to cluster\n     * @param neighbors List of neighbors\n     * @param points the data set\n     * @param visited the set of already visited points\n     * @return the expanded cluster\n     */\n    private Cluster expandCluster(final Cluster cluster,\n                                  final Point2D point,\n                                  final List<Point2D> neighbors,\n                                  final KDTree<Point2D> points,\n                                  final Map<Point2D, PointStatus> visited)\n    {\n        cluster.addPoint(point);\n        visited.put(point, PointStatus.PART_OF_CLUSTER);\n\n        List<Point2D> seeds = new ArrayList<Point2D>(neighbors);\n        int index = 0;\n        while (index < seeds.size())\n        {\n            Point2D current = seeds.get(index);\n            PointStatus pStatus = visited.get(current);\n            // only check non-visited points\n            if (pStatus == null)\n            {\n                final List<Point2D> currentNeighbors = getNeighbors(current, points);\n                if (currentNeighbors.size() >= minPoints)\n                {\n                    seeds = merge(seeds, currentNeighbors);\n                }\n            }\n\n            if (pStatus != PointStatus.PART_OF_CLUSTER)\n            {\n                visited.put(current, PointStatus.PART_OF_CLUSTER);\n                cluster.addPoint(current);\n            }\n\n            index++;\n        }\n        return cluster;\n    }\n\n    /**\n     * Returns a list of density-reachable neighbors of a {@code point}.\n     *\n     * @param point the point to look for\n     * @param points possible neighbors\n     * @return the List of neighbors\n     */\n    private List<Point2D> getNeighbors(final Point2D point, KDTree<Point2D> points)\n    {\n        double[] key = {point.x, point.y};\n        final List<Point2D> neighbors = new ArrayList<Point2D>();\n\n        neighbors.addAll(points.nearestEuclidean(key, eps));\n\n        return neighbors;\n    }\n\n    /**\n        * Merges two lists together.\n        *\n        * @param one first list\n        * @param two second list\n        * @return merged lists\n        */\n\n    public void setEps(double eps)\n    {\n        this.eps = eps;\n    }\n\n    public void setMinPoints(int minPoints)\n    {\n        this.minPoints = minPoints;\n    }\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/effect/neuroph/LetterSeparation.java", "func_name": "LetterSeparation.apply", "original_string": "public ImageSource apply(ImageSource input) {\n        ImageSource originalImage = input;\n\n        int width = originalImage.getWidth();\n        int height = originalImage.getHeight();\n\n        boolean[][] matrix = new boolean[width][height]; // black n white boolean matrix; true = blck, false = white\n\n        // Copy\n        ImageSource filteredImage = new MatrixSource(input);\n\n        int[] histogram = OtsuBinarize.imageHistogram(originalImage);\n\n        int totalNumberOfpixels = height * width;\n\n        int threshold = OtsuBinarize.threshold(histogram, totalNumberOfpixels);\n\n        int black = 0;\n        int white = 255;\n\n        int gray;\n        int alpha;\n        int newColor;\n\n        for (int i = 0; i < width; i++) {\n            for (int j = 0; j < height; j++) {\n                gray = originalImage.getGray(i, j);\n\n                if (gray > threshold) {\n                    matrix[i][j] = false;\n                } else {\n                    matrix[i][j] = true;\n                }\n\n            }\n        }\n\n        int blackTreshold = letterThreshold(originalImage, matrix);\n\n        for (int i = 0; i < width; i++) {\n            for (int j = 0; j < height; j++) {\n                gray = originalImage.getGray(i, j);\n                alpha = originalImage.getA(i, j);\n\n                if (gray > blackTreshold) {\n                    newColor = white;\n                } else {\n                    newColor = black;\n                }\n\n                newColor = ColorHelper.getARGB(newColor, newColor, newColor, alpha);\n                filteredImage.setRGB(i, j, newColor);\n            }\n        }\n\n        return filteredImage;\n    }", "language": "java", "code": "public ImageSource apply(ImageSource input) {\n        ImageSource originalImage = input;\n\n        int width = originalImage.getWidth();\n        int height = originalImage.getHeight();\n\n        boolean[][] matrix = new boolean[width][height]; // black n white boolean matrix; true = blck, false = white\n\n        // Copy\n        ImageSource filteredImage = new MatrixSource(input);\n\n        int[] histogram = OtsuBinarize.imageHistogram(originalImage);\n\n        int totalNumberOfpixels = height * width;\n\n        int threshold = OtsuBinarize.threshold(histogram, totalNumberOfpixels);\n\n        int black = 0;\n        int white = 255;\n\n        int gray;\n        int alpha;\n        int newColor;\n\n        for (int i = 0; i < width; i++) {\n            for (int j = 0; j < height; j++) {\n                gray = originalImage.getGray(i, j);\n\n                if (gray > threshold) {\n                    matrix[i][j] = false;\n                } else {\n                    matrix[i][j] = true;\n                }\n\n            }\n        }\n\n        int blackTreshold = letterThreshold(originalImage, matrix);\n\n        for (int i = 0; i < width; i++) {\n            for (int j = 0; j < height; j++) {\n                gray = originalImage.getGray(i, j);\n                alpha = originalImage.getA(i, j);\n\n                if (gray > blackTreshold) {\n                    newColor = white;\n                } else {\n                    newColor = black;\n                }\n\n                newColor = ColorHelper.getARGB(newColor, newColor, newColor, alpha);\n                filteredImage.setRGB(i, j, newColor);\n            }\n        }\n\n        return filteredImage;\n    }", "code_tokens": ["public", "ImageSource", "apply", "(", "ImageSource", "input", ")", "{", "ImageSource", "originalImage", "=", "input", ";", "int", "width", "=", "originalImage", ".", "getWidth", "(", ")", ";", "int", "height", "=", "originalImage", ".", "getHeight", "(", ")", ";", "boolean", "[", "]", "[", "]", "matrix", "=", "new", "boolean", "[", "width", "]", "[", "height", "]", ";", "// black n white boolean matrix; true = blck, false = white", "// Copy", "ImageSource", "filteredImage", "=", "new", "MatrixSource", "(", "input", ")", ";", "int", "[", "]", "histogram", "=", "OtsuBinarize", ".", "imageHistogram", "(", "originalImage", ")", ";", "int", "totalNumberOfpixels", "=", "height", "*", "width", ";", "int", "threshold", "=", "OtsuBinarize", ".", "threshold", "(", "histogram", ",", "totalNumberOfpixels", ")", ";", "int", "black", "=", "0", ";", "int", "white", "=", "255", ";", "int", "gray", ";", "int", "alpha", ";", "int", "newColor", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "width", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "0", ";", "j", "<", "height", ";", "j", "++", ")", "{", "gray", "=", "originalImage", ".", "getGray", "(", "i", ",", "j", ")", ";", "if", "(", "gray", ">", "threshold", ")", "{", "matrix", "[", "i", "]", "[", "j", "]", "=", "false", ";", "}", "else", "{", "matrix", "[", "i", "]", "[", "j", "]", "=", "true", ";", "}", "}", "}", "int", "blackTreshold", "=", "letterThreshold", "(", "originalImage", ",", "matrix", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "width", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "0", ";", "j", "<", "height", ";", "j", "++", ")", "{", "gray", "=", "originalImage", ".", "getGray", "(", "i", ",", "j", ")", ";", "alpha", "=", "originalImage", ".", "getA", "(", "i", ",", "j", ")", ";", "if", "(", "gray", ">", "blackTreshold", ")", "{", "newColor", "=", "white", ";", "}", "else", "{", "newColor", "=", "black", ";", "}", "newColor", "=", "ColorHelper", ".", "getARGB", "(", "newColor", ",", "newColor", ",", "newColor", ",", "alpha", ")", ";", "filteredImage", ".", "setRGB", "(", "i", ",", "j", ",", "newColor", ")", ";", "}", "}", "return", "filteredImage", ";", "}"], "docstring": "radi otsu da dobije spojena crna slova i ra\n\n@param input\n@return the processed image", "docstring_tokens": ["radi", "otsu", "da", "dobije", "spojena", "crna", "slova", "i", "ra"], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/effect/neuroph/LetterSeparation.java#L25-L81", "partition": "train", "up_fun_num": 2, "levels": [0, 1], "package": ["import com.harium.keel.core.Effect;", "import com.harium.keel.core.helper.ColorHelper;", "import com.harium.keel.core.source.ImageSource;", "import com.harium.keel.core.source.MatrixSource;", "import com.harium.keel.effect.binary.OtsuBinarize;"], "function": ["public class LetterSeparation implements Effect\n", "    public int letterThreshold(ImageSource original, boolean[][] matrix)\n"], "context": "package com.harium.keel.effect.neuroph;\n\nimport com.harium.keel.core.Effect;\nimport com.harium.keel.core.helper.ColorHelper;\nimport com.harium.keel.core.source.ImageSource;\nimport com.harium.keel.core.source.MatrixSource;\nimport com.harium.keel.effect.binary.OtsuBinarize;\n\n/**\n * Prvo izrcunav threshold na osnovu otsu i binrzije\n * zatim na osnu bw i originalne slike podesaava(spusta) threshold tako da slova ne budu spojena\n *\n * @author Mihailo Stupar\n * <p>\n * Code from: https://github.com/neuroph/neuroph/blob/master/neuroph-2.9/ImageRec/src/main/java/org/neuroph/imgrec/filter/impl/LetterSeparationFilter.java\n */\npublic class LetterSeparation implements Effect\n{\n\n    /**\n     * radi otsu da dobije spojena crna slova i ra\n     *\n     * @param input\n     * @return the processed image\n     */\n\n    public int letterThreshold(ImageSource original, boolean[][] matrix)\n    {\n        double sum = 0;\n        int count = 0;\n\n        for (int i = 0; i < original.getWidth(); i++)\n        {\n            for (int j = 0; j < original.getHeight(); j++)\n            {\n                if (matrix[i][j])\n                {\n                    int gray = original.getGray(i, j);\n                    sum += gray;\n                    count++;\n                }\n            }\n        }\n\n        if (count == 0)\n        {\n            return 0;\n        }\n\n        return (int) Math.round((sum * 3) / (count * 2)); // 3 i 2 su plinkove konstnte\n    }\n\n    // Threshold by otsu method\n    /*private int threshold(int[] histogram, int total) {\n        float sum = 0;\n        for (int i = 0; i < 256; i++) {\n            sum += i * histogram[i];\n        }\n\n        float sumB = 0;\n        int wB = 0;\n        int wF = 0;\n\n        float varMax = 0;\n        int threshold = 0;\n\n        for (int i = 0; i < 256; i++) {\n            wB += histogram[i];\n            if (wB == 0) {\n                continue;\n            }\n            wF = total - wB;\n\n            if (wF == 0) {\n                break;\n            }\n\n            sumB += (float) (i * histogram[i]);\n            float mB = sumB / wB;\n            float mF = (sum - sumB) / wF;\n\n            float varBetween = (float) wB * (float) wF * (mB - mF) * (mB - mF);\n\n            if (varBetween > varMax) {\n                varMax = varBetween;\n                threshold = i;\n            }\n        }\n        return threshold;\n    }*/\n\n}"}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/core/ArraysUtil.java", "func_name": "ArraysUtil.Argsort", "original_string": "public static int[] Argsort(final float[] array, final boolean ascending) {\n        Integer[] indexes = new Integer[array.length];\n        for (int i = 0; i < indexes.length; i++) {\n            indexes[i] = i;\n        }\n        Arrays.sort(indexes, new Comparator<Integer>() {\n            @Override\n            public int compare(final Integer i1, final Integer i2) {\n                return (ascending ? 1 : -1) * Float.compare(array[i1], array[i2]);\n            }\n        });\n        return asArray(indexes);\n    }", "language": "java", "code": "public static int[] Argsort(final float[] array, final boolean ascending) {\n        Integer[] indexes = new Integer[array.length];\n        for (int i = 0; i < indexes.length; i++) {\n            indexes[i] = i;\n        }\n        Arrays.sort(indexes, new Comparator<Integer>() {\n            @Override\n            public int compare(final Integer i1, final Integer i2) {\n                return (ascending ? 1 : -1) * Float.compare(array[i1], array[i2]);\n            }\n        });\n        return asArray(indexes);\n    }", "code_tokens": ["public", "static", "int", "[", "]", "Argsort", "(", "final", "float", "[", "]", "array", ",", "final", "boolean", "ascending", ")", "{", "Integer", "[", "]", "indexes", "=", "new", "Integer", "[", "array", ".", "length", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "indexes", ".", "length", ";", "i", "++", ")", "{", "indexes", "[", "i", "]", "=", "i", ";", "}", "Arrays", ".", "sort", "(", "indexes", ",", "new", "Comparator", "<", "Integer", ">", "(", ")", "{", "@", "Override", "public", "int", "compare", "(", "final", "Integer", "i1", ",", "final", "Integer", "i2", ")", "{", "return", "(", "ascending", "?", "1", ":", "-", "1", ")", "*", "Float", ".", "compare", "(", "array", "[", "i1", "]", ",", "array", "[", "i2", "]", ")", ";", "}", "}", ")", ";", "return", "asArray", "(", "indexes", ")", ";", "}"], "docstring": "Returns the indices that would sort an array.\n\n@param array     Array.\n@param ascending Ascending order.\n@return Array of indices.", "docstring_tokens": ["Returns", "the", "indices", "that", "would", "sort", "an", "array", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/core/ArraysUtil.java#L105-L117", "partition": "train", "up_fun_num": 4, "levels": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "package": ["import java.util.Arrays;", "import java.util.Comparator;", "import java.util.List;", "import java.util.Random;"], "function": ["public class ArraysUtil\n", "    public static int[] Argsort(final double[] array, final boolean ascending)\n", "    public static int[] Argsort(final int[] array, final boolean ascending)\n", "    public static int[] Concatenate(int[] array, int[] array2)\n", "    public static double[] Concatenate(double[] array, double[] array2)\n", "    public static float[] Concatenate(float[] array, float[] array2)\n", "    public static int[] ConcatenateInt(List<int[]> arrays)\n", "    public static double[] ConcatenateDouble(List<double[]> arrays)\n", "    public static float[] ConcatenateFloat(List<float[]> arrays)\n", "    public static <T extends Number> int[] asArray(final T... array)\n", "    public static void Shuffle(double[] array)\n", "    public static void Shuffle(double[] array, long seed)\n", "    public static void Shuffle(int[] array)\n", "    public static void Shuffle(int[] array, long seed)\n", "    public static void Shuflle(float[] array)\n", "    public static void Shuffle(float[] array, long seed)\n", "    public static <T> void Shuffle(T[] array)\n", "    public static <T> void Shuffle(T[] array, long seed)\n", "    public static float[] toFloat(int[] array)\n", "    public static float[][] toFloat(int[][] array)\n", "    public static float[] toFloat(double[] array)\n", "    public static float[][] toFloat(double[][] array)\n", "    public static int[] toInt(double[] array)\n", "    public static int[][] toInt(double[][] array)\n", "    public static int[] toInt(float[] array)\n", "    public static int[][] toInt(float[][] array)\n", "    public static double[] toDouble(int[] array)\n", "    public static double[][] toDouble(int[][] array)\n", "    public static double[] toDouble(float[] array)\n", "    public static double[][] toDouble(float[][] array)\n"], "context": "// Catalano Core Library\n// The Catalano Framework\n//\n// Copyright ? Diego Catalano, 2012-2016\n// diego.catalano at live.com\n//\n//\n// Contains some methods for arrays, distributed\n// under the BSD license. The original license terms are given below:\n//\n//   Copyright ? Albert Strasheim, 2008\n//\n//   Redistribution and use in source and binary forms, with or without\n//   modification, are permitted provided that the following conditions are\n//   met:\n//\n//       * Redistributions of source code must retain the above copyright\n//         notice, this list of conditions and the following disclaimer.\n//       * Redistributions in binary form must reproduce the above copyright\n//         notice, this list of conditions and the following disclaimer in\n//         the documentation and/or other materials provided with the distribution\n//\n//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n//   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n//   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n//   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n//   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n//   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n//   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n//   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n//   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n//   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n//   POSSIBILITY OF SUCH DAMAGE.\n//\n\npackage com.harium.keel.catalano.core;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Random;\n\n/**\n * Array Utilities.\n *\n * @author Diego Catalano\n */\npublic class ArraysUtil\n{\n\n    /**\n     * Don`t let anyone to instantiate this class.\n     */\n    private ArraysUtil()\n    {\n    }\n\n    /**\n     * Returns the indices that would sort an array.\n     *\n     * @param array     Array.\n     * @param ascending Ascending order.\n     * @return Array of indices.\n     */\n    public static int[] Argsort(final double[] array, final boolean ascending)\n    {\n        Integer[] indexes = new Integer[array.length];\n        for (int i = 0; i < indexes.length; i++)\n        {\n            indexes[i] = i;\n        }\n        Arrays.sort(indexes, new Comparator<Integer>()\n        {\n            @Override\n            public int compare(final Integer i1, final Integer i2)\n            {\n                return (ascending ? 1 : -1) * Double.compare(array[i1], array[i2]);\n            }\n        });\n        return asArray(indexes);\n    }\n\n    /**\n     * Returns the indices that would sort an array.\n     *\n     * @param array     Array.\n     * @param ascending Ascending order.\n     * @return Array of indices.\n     */\n    public static int[] Argsort(final int[] array, final boolean ascending)\n    {\n        Integer[] indexes = new Integer[array.length];\n        for (int i = 0; i < indexes.length; i++)\n        {\n            indexes[i] = i;\n        }\n        Arrays.sort(indexes, new Comparator<Integer>()\n        {\n            @Override\n            public int compare(final Integer i1, final Integer i2)\n            {\n                return (ascending ? 1 : -1) * Integer.compare(array[i1], array[i2]);\n            }\n        });\n        return asArray(indexes);\n    }\n\n    /**\n     * Returns the indices that would sort an array.\n     *\n     * @param array     Array.\n     * @param ascending Ascending order.\n     * @return Array of indices.\n     */\n\n    /**\n     * Concatenate the arrays.\n     *\n     * @param array  First array.\n     * @param array2 Second array.\n     * @return Concatenate between first and second array.\n     */\n    public static int[] Concatenate(int[] array, int[] array2)\n    {\n        int[] all = new int[array.length + array2.length];\n        int idx = 0;\n\n        //First array\n        for (int i = 0; i < array.length; i++)\n            all[idx++] = array[i];\n\n        //Second array\n        for (int i = 0; i < array2.length; i++)\n            all[idx++] = array2[i];\n\n        return all;\n    }\n\n    /**\n     * Concatenate the arrays.\n     *\n     * @param array  First array.\n     * @param array2 Second array.\n     * @return Concatenate between first and second array.\n     */\n    public static double[] Concatenate(double[] array, double[] array2)\n    {\n        double[] all = new double[array.length + array2.length];\n        int idx = 0;\n\n        //First array\n        for (int i = 0; i < array.length; i++)\n            all[idx++] = array[i];\n\n        //Second array\n        for (int i = 0; i < array2.length; i++)\n            all[idx++] = array2[i];\n\n        return all;\n    }\n\n    /**\n     * Concatenate the arrays.\n     *\n     * @param array  First array.\n     * @param array2 Second array.\n     * @return Concatenate between first and second array.\n     */\n    public static float[] Concatenate(float[] array, float[] array2)\n    {\n        float[] all = new float[array.length + array2.length];\n        int idx = 0;\n\n        //First array\n        for (int i = 0; i < array.length; i++)\n            all[idx++] = array[i];\n\n        //Second array\n        for (int i = 0; i < array2.length; i++)\n            all[idx++] = array2[i];\n\n        return all;\n    }\n\n    /**\n     * Concatenate all the arrays in the list into a vector.\n     *\n     * @param arrays List of arrays.\n     * @return Vector.\n     */\n    public static int[] ConcatenateInt(List<int[]> arrays)\n    {\n\n        int size = 0;\n        for (int i = 0; i < arrays.size(); i++)\n        {\n            size += arrays.get(i).length;\n        }\n\n        int[] all = new int[size];\n        int idx = 0;\n\n        for (int i = 0; i < arrays.size(); i++)\n        {\n            int[] v = arrays.get(i);\n            for (int j = 0; j < v.length; j++)\n            {\n                all[idx++] = v[i];\n            }\n        }\n\n        return all;\n    }\n\n    /**\n     * Concatenate all the arrays in the list into a vector.\n     *\n     * @param arrays List of arrays.\n     * @return Vector.\n     */\n    public static double[] ConcatenateDouble(List<double[]> arrays)\n    {\n\n        int size = 0;\n        for (int i = 0; i < arrays.size(); i++)\n        {\n            size += arrays.get(i).length;\n        }\n\n        double[] all = new double[size];\n        int idx = 0;\n\n        for (int i = 0; i < arrays.size(); i++)\n        {\n            double[] v = arrays.get(i);\n            for (int j = 0; j < v.length; j++)\n            {\n                all[idx++] = v[i];\n            }\n        }\n\n        return all;\n    }\n\n    /**\n     * Concatenate all the arrays in the list into a vector.\n     *\n     * @param arrays List of arrays.\n     * @return Vector.\n     */\n    public static float[] ConcatenateFloat(List<float[]> arrays)\n    {\n\n        int size = 0;\n        for (int i = 0; i < arrays.size(); i++)\n        {\n            size += arrays.get(i).length;\n        }\n\n        float[] all = new float[size];\n        int idx = 0;\n\n        for (int i = 0; i < arrays.size(); i++)\n        {\n            float[] v = arrays.get(i);\n            for (int j = 0; j < v.length; j++)\n            {\n                all[idx++] = v[i];\n            }\n        }\n\n        return all;\n    }\n\n    /**\n     * Convert any number class to array of integer.\n     *\n     * @param <T>   Type.\n     * @param array Array.\n     * @return Integer array.\n     */\n    public static <T extends Number> int[] asArray(final T... array)\n    {\n        int[] b = new int[array.length];\n        for (int i = 0; i < b.length; i++)\n        {\n            b[i] = array[i].intValue();\n        }\n        return b;\n    }\n\n    /**\n     * Shuffle an array.\n     *\n     * @param array Array.\n     */\n    public static void Shuffle(double[] array)\n    {\n        Shuffle(array, 0);\n    }\n\n    /**\n     * Shuffle an array.\n     *\n     * @param array Array.\n     * @param seed  Random seed.\n     */\n    public static void Shuffle(double[] array, long seed)\n    {\n        Random random = new Random();\n        if (seed != 0) random.setSeed(seed);\n\n        for (int i = array.length - 1; i > 0; i--)\n        {\n            int index = random.nextInt(i + 1);\n            double temp = array[index];\n            array[index] = array[i];\n            array[i] = temp;\n        }\n    }\n\n    /**\n     * Shuffle an array.\n     *\n     * @param array Array.\n     */\n    public static void Shuffle(int[] array)\n    {\n        Shuffle(array, 0);\n    }\n\n    /**\n     * Shuffle an array.\n     *\n     * @param array Array.\n     * @param seed  Seed of the random.\n     */\n    public static void Shuffle(int[] array, long seed)\n    {\n\n        Random random = new Random();\n        if (seed != 0) random.setSeed(seed);\n\n        for (int i = array.length - 1; i > 0; i--)\n        {\n            int index = random.nextInt(i + 1);\n            int temp = array[index];\n            array[index] = array[i];\n            array[i] = temp;\n        }\n    }\n\n    /**\n     * Shuffle an array.\n     *\n     * @param array Array.\n     */\n    public static void Shuflle(float[] array)\n    {\n        Shuffle(array, 0);\n    }\n\n    /**\n     * Shuffle an array.\n     *\n     * @param array Array.\n     * @param seed  Random seed.\n     */\n    public static void Shuffle(float[] array, long seed)\n    {\n        Random random = new Random();\n        if (seed != 0) random.setSeed(seed);\n\n        for (int i = array.length - 1; i > 0; i--)\n        {\n            int index = random.nextInt(i + 1);\n            float temp = array[index];\n            array[index] = array[i];\n            array[i] = temp;\n        }\n    }\n\n    /**\n     * Shuffle an array.\n     *\n     * @param array Array.\n     */\n    public static <T> void Shuffle(T[] array)\n    {\n        Shuffle(array, 0);\n    }\n\n    /**\n     * Shuffle an array.\n     *\n     * @param array Array.\n     * @param seed  Random seed.\n     */\n    public static <T> void Shuffle(T[] array, long seed)\n    {\n        Random random = new Random();\n        if (seed != 0) random.setSeed(seed);\n\n        for (int i = array.length - 1; i > 0; i--)\n        {\n            int index = random.nextInt(i + 1);\n            T temp = array[index];\n            array[index] = array[i];\n            array[i] = temp;\n        }\n    }\n\n    /**\n     * 1-D Integer array to float array.\n     *\n     * @param array Integer array.\n     * @return Float array.\n     */\n    public static float[] toFloat(int[] array)\n    {\n        float[] n = new float[array.length];\n        for (int i = 0; i < array.length; i++)\n        {\n            n[i] = (float) array[i];\n        }\n        return n;\n    }\n\n    /**\n     * 2-D Integer array to float array.\n     *\n     * @param array Integer array.\n     * @return Float array.\n     */\n    public static float[][] toFloat(int[][] array)\n    {\n        float[][] n = new float[array.length][array[0].length];\n        for (int i = 0; i < array.length; i++)\n        {\n            for (int j = 0; j < array[0].length; j++)\n            {\n                n[i][j] = (float) array[i][j];\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 1-D Double array to float array.\n     *\n     * @param array Double array.\n     * @return Float array.\n     */\n    public static float[] toFloat(double[] array)\n    {\n        float[] n = new float[array.length];\n        for (int i = 0; i < array.length; i++)\n        {\n            n[i] = (float) array[i];\n        }\n        return n;\n    }\n\n    /**\n     * 2-D Double array to float array.\n     *\n     * @param array Double array.\n     * @return Float array.\n     */\n    public static float[][] toFloat(double[][] array)\n    {\n        float[][] n = new float[array.length][array[0].length];\n        for (int i = 0; i < array.length; i++)\n        {\n            for (int j = 0; j < array[0].length; j++)\n            {\n                n[i][j] = (float) array[i][j];\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 1-D Double array to integer array.\n     *\n     * @param array Double array.\n     * @return Integer array.\n     */\n    public static int[] toInt(double[] array)\n    {\n        int[] n = new int[array.length];\n        for (int i = 0; i < array.length; i++)\n        {\n            n[i] = (int) array[i];\n        }\n        return n;\n    }\n\n    /**\n     * 2-D Double array to integer array.\n     *\n     * @param array Double array.\n     * @return Integer array.\n     */\n    public static int[][] toInt(double[][] array)\n    {\n        int[][] n = new int[array.length][array[0].length];\n        for (int i = 0; i < array.length; i++)\n        {\n            for (int j = 0; j < array[0].length; j++)\n            {\n                n[i][j] = (int) array[i][j];\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 1-D Float array to integer array.\n     *\n     * @param array Float array.\n     * @return Integer array.\n     */\n    public static int[] toInt(float[] array)\n    {\n        int[] n = new int[array.length];\n        for (int i = 0; i < array.length; i++)\n        {\n            n[i] = (int) array[i];\n        }\n        return n;\n    }\n\n    /**\n     * 2-D Float array to integer array.\n     *\n     * @param array Float array.\n     * @return Integer array.\n     */\n    public static int[][] toInt(float[][] array)\n    {\n        int[][] n = new int[array.length][array[0].length];\n        for (int i = 0; i < array.length; i++)\n        {\n            for (int j = 0; j < array[0].length; j++)\n            {\n                n[i][j] = (int) array[i][j];\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 1-D Integer array to double array.\n     *\n     * @param array Integer array.\n     * @return Double array.\n     */\n    public static double[] toDouble(int[] array)\n    {\n        double[] n = new double[array.length];\n        for (int i = 0; i < array.length; i++)\n        {\n            n[i] = (double) array[i];\n        }\n        return n;\n    }\n\n    /**\n     * 2-D Integer array to double array.\n     *\n     * @param array Integer array.\n     * @return Double array.\n     */\n    public static double[][] toDouble(int[][] array)\n    {\n        double[][] n = new double[array.length][array[0].length];\n        for (int i = 0; i < array.length; i++)\n        {\n            for (int j = 0; j < array[0].length; j++)\n            {\n                n[i][j] = (double) array[i][j];\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 1-D Float array to double array.\n     *\n     * @param array Float array.\n     * @return Double array.\n     */\n    public static double[] toDouble(float[] array)\n    {\n        double[] n = new double[array.length];\n        for (int i = 0; i < array.length; i++)\n        {\n            n[i] = (double) array[i];\n        }\n        return n;\n    }\n\n    /**\n     * 2-D Float array to double array.\n     *\n     * @param array Float array.\n     * @return Double array.\n     */\n    public static double[][] toDouble(float[][] array)\n    {\n        double[][] n = new double[array.length][array[0].length];\n        for (int i = 0; i < array.length; i++)\n        {\n            for (int j = 0; j < array[0].length; j++)\n            {\n                n[i][j] = (double) array[i][j];\n            }\n        }\n        return n;\n    }\n}"}
